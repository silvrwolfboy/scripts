#!/usr/bin/env perl

# This chunk of stuff was generated by App::FatPacker. To find the original
# file's code, look for the end of this BEGIN block or the string 'FATPACK'
BEGIN {
my %fatpacked;

$fatpacked{"Carp.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CARP';
  package Carp;
  
  { use 5.006; }
  use strict;
  use warnings;
  BEGIN {
      # Very old versions of warnings.pm load Carp.  This can go wrong due
      # to the circular dependency.  If warnings is invoked before Carp,
      # then warnings starts by loading Carp, then Carp (above) tries to
      # invoke warnings, and gets nothing because warnings is in the process
      # of loading and hasn't defined its import method yet.  If we were
      # only turning on warnings ("use warnings" above) this wouldn't be too
      # bad, because Carp would just gets the state of the -w switch and so
      # might not get some warnings that it wanted.  The real problem is
      # that we then want to turn off Unicode warnings, but "no warnings
      # 'utf8'" won't be effective if we're in this circular-dependency
      # situation.  So, if warnings.pm is an affected version, we turn
      # off all warnings ourselves by directly setting ${^WARNING_BITS}.
      # On unaffected versions, we turn off just Unicode warnings, via
      # the proper API.
      if(!defined($warnings::VERSION) || eval($warnings::VERSION) < 1.06) {
  	${^WARNING_BITS} = "";
      } else {
  	"warnings"->unimport("utf8");
      }
  }
  
  sub _fetch_sub { # fetch sub without autovivifying
      my($pack, $sub) = @_;
      $pack .= '::';
      # only works with top-level packages
      return unless exists($::{$pack});
      for ($::{$pack}) {
  	return unless ref \$_ eq 'GLOB' && *$_{HASH} && exists $$_{$sub};
  	for ($$_{$sub}) {
  	    return ref \$_ eq 'GLOB' ? *$_{CODE} : undef
  	}
      }
  }
  
  # UTF8_REGEXP_PROBLEM is a compile-time constant indicating whether Carp
  # must avoid applying a regular expression to an upgraded (is_utf8)
  # string.  There are multiple problems, on different Perl versions,
  # that require this to be avoided.  All versions prior to 5.13.8 will
  # load utf8_heavy.pl for the swash system, even if the regexp doesn't
  # use character classes.  Perl 5.6 and Perls [5.11.2, 5.13.11) exhibit
  # specific problems when Carp is being invoked in the aftermath of a
  # syntax error.
  BEGIN {
      if("$]" < 5.013011) {
  	*UTF8_REGEXP_PROBLEM = sub () { 1 };
      } else {
  	*UTF8_REGEXP_PROBLEM = sub () { 0 };
      }
  }
  
  # is_utf8() is essentially the utf8::is_utf8() function, which indicates
  # whether a string is represented in the upgraded form (using UTF-8
  # internally).  As utf8::is_utf8() is only available from Perl 5.8
  # onwards, extra effort is required here to make it work on Perl 5.6.
  BEGIN {
      if(defined(my $sub = _fetch_sub utf8 => 'is_utf8')) {
  	*is_utf8 = $sub;
      } else {
  	# black magic for perl 5.6
  	*is_utf8 = sub { unpack("C", "\xaa".$_[0]) != 170 };
      }
  }
  
  # The downgrade() function defined here is to be used for attempts to
  # downgrade where it is acceptable to fail.  It must be called with a
  # second argument that is a true value.
  BEGIN {
      if(defined(my $sub = _fetch_sub utf8 => 'downgrade')) {
  	*downgrade = \&{"utf8::downgrade"};
      } else {
  	*downgrade = sub {
  	    my $r = "";
  	    my $l = length($_[0]);
  	    for(my $i = 0; $i != $l; $i++) {
  		my $o = ord(substr($_[0], $i, 1));
  		return if $o > 255;
  		$r .= chr($o);
  	    }
  	    $_[0] = $r;
  	};
      }
  }
  
  our $VERSION = '1.38';
  $VERSION =~ tr/_//d;
  
  our $MaxEvalLen = 0;
  our $Verbose    = 0;
  our $CarpLevel  = 0;
  our $MaxArgLen  = 64;    # How much of each argument to print. 0 = all.
  our $MaxArgNums = 8;     # How many arguments to print. 0 = all.
  our $RefArgFormatter = undef; # allow caller to format reference arguments
  
  require Exporter;
  our @ISA       = ('Exporter');
  our @EXPORT    = qw(confess croak carp);
  our @EXPORT_OK = qw(cluck verbose longmess shortmess);
  our @EXPORT_FAIL = qw(verbose);    # hook to enable verbose mode
  
  # The members of %Internal are packages that are internal to perl.
  # Carp will not report errors from within these packages if it
  # can.  The members of %CarpInternal are internal to Perl's warning
  # system.  Carp will not report errors from within these packages
  # either, and will not report calls *to* these packages for carp and
  # croak.  They replace $CarpLevel, which is deprecated.    The
  # $Max(EvalLen|(Arg(Len|Nums)) variables are used to specify how the eval
  # text and function arguments should be formatted when printed.
  
  our %CarpInternal;
  our %Internal;
  
  # disable these by default, so they can live w/o require Carp
  $CarpInternal{Carp}++;
  $CarpInternal{warnings}++;
  $Internal{Exporter}++;
  $Internal{'Exporter::Heavy'}++;
  
  # if the caller specifies verbose usage ("perl -MCarp=verbose script.pl")
  # then the following method will be called by the Exporter which knows
  # to do this thanks to @EXPORT_FAIL, above.  $_[1] will contain the word
  # 'verbose'.
  
  sub export_fail { shift; $Verbose = shift if $_[0] eq 'verbose'; @_ }
  
  sub _cgc {
      no strict 'refs';
      return \&{"CORE::GLOBAL::caller"} if defined &{"CORE::GLOBAL::caller"};
      return;
  }
  
  sub longmess {
      local($!, $^E);
      # Icky backwards compatibility wrapper. :-(
      #
      # The story is that the original implementation hard-coded the
      # number of call levels to go back, so calls to longmess were off
      # by one.  Other code began calling longmess and expecting this
      # behaviour, so the replacement has to emulate that behaviour.
      my $cgc = _cgc();
      my $call_pack = $cgc ? $cgc->() : caller();
      if ( $Internal{$call_pack} or $CarpInternal{$call_pack} ) {
          return longmess_heavy(@_);
      }
      else {
          local $CarpLevel = $CarpLevel + 1;
          return longmess_heavy(@_);
      }
  }
  
  our @CARP_NOT;
  
  sub shortmess {
      local($!, $^E);
      my $cgc = _cgc();
  
      # Icky backwards compatibility wrapper. :-(
      local @CARP_NOT = $cgc ? $cgc->() : caller();
      shortmess_heavy(@_);
  }
  
  sub croak   { die shortmess @_ }
  sub confess { die longmess @_ }
  sub carp    { warn shortmess @_ }
  sub cluck   { warn longmess @_ }
  
  BEGIN {
      if("$]" >= 5.015002 || ("$]" >= 5.014002 && "$]" < 5.015) ||
  	    ("$]" >= 5.012005 && "$]" < 5.013)) {
  	*CALLER_OVERRIDE_CHECK_OK = sub () { 1 };
      } else {
  	*CALLER_OVERRIDE_CHECK_OK = sub () { 0 };
      }
  }
  
  sub caller_info {
      my $i = shift(@_) + 1;
      my %call_info;
      my $cgc = _cgc();
      {
  	# Some things override caller() but forget to implement the
  	# @DB::args part of it, which we need.  We check for this by
  	# pre-populating @DB::args with a sentinel which no-one else
  	# has the address of, so that we can detect whether @DB::args
  	# has been properly populated.  However, on earlier versions
  	# of perl this check tickles a bug in CORE::caller() which
  	# leaks memory.  So we only check on fixed perls.
          @DB::args = \$i if CALLER_OVERRIDE_CHECK_OK;
          package DB;
          @call_info{
              qw(pack file line sub has_args wantarray evaltext is_require) }
              = $cgc ? $cgc->($i) : caller($i);
      }
  
      unless ( defined $call_info{file} ) {
          return ();
      }
  
      my $sub_name = Carp::get_subname( \%call_info );
      if ( $call_info{has_args} ) {
          my @args;
          if (CALLER_OVERRIDE_CHECK_OK && @DB::args == 1
              && ref $DB::args[0] eq ref \$i
              && $DB::args[0] == \$i ) {
              @DB::args = ();    # Don't let anyone see the address of $i
              local $@;
              my $where = eval {
                  my $func    = $cgc or return '';
                  my $gv      =
                      (_fetch_sub B => 'svref_2object' or return '')
                          ->($func)->GV;
                  my $package = $gv->STASH->NAME;
                  my $subname = $gv->NAME;
                  return unless defined $package && defined $subname;
  
                  # returning CORE::GLOBAL::caller isn't useful for tracing the cause:
                  return if $package eq 'CORE::GLOBAL' && $subname eq 'caller';
                  " in &${package}::$subname";
              } || '';
              @args
                  = "** Incomplete caller override detected$where; \@DB::args were not set **";
          }
          else {
              @args = @DB::args;
              my $overflow;
              if ( $MaxArgNums and @args > $MaxArgNums )
              {    # More than we want to show?
                  $#args = $MaxArgNums - 1;
                  $overflow = 1;
              }
  
              @args = map { Carp::format_arg($_) } @args;
  
              if ($overflow) {
                  push @args, '...';
              }
          }
  
          # Push the args onto the subroutine
          $sub_name .= '(' . join( ', ', @args ) . ')';
      }
      $call_info{sub_name} = $sub_name;
      return wantarray() ? %call_info : \%call_info;
  }
  
  # Transform an argument to a function into a string.
  our $in_recurse;
  sub format_arg {
      my $arg = shift;
  
      if ( ref($arg) ) {
           # legitimate, let's not leak it.
          if (!$in_recurse &&
  	    do {
                  local $@;
  	        local $in_recurse = 1;
  		local $SIG{__DIE__} = sub{};
                  eval {$arg->can('CARP_TRACE') }
              })
          {
              return $arg->CARP_TRACE();
          }
          elsif (!$in_recurse &&
  	       defined($RefArgFormatter) &&
  	       do {
                  local $@;
  	        local $in_recurse = 1;
  		local $SIG{__DIE__} = sub{};
                  eval {$arg = $RefArgFormatter->($arg); 1}
                  })
          {
              return $arg;
          }
          else
          {
  	    my $sub = _fetch_sub(overload => 'StrVal');
  	    return $sub ? &$sub($arg) : "$arg";
          }
      }
      return "undef" if !defined($arg);
      downgrade($arg, 1);
      return $arg if !(UTF8_REGEXP_PROBLEM && is_utf8($arg)) &&
  	    $arg =~ /\A-?[0-9]+(?:\.[0-9]*)?(?:[eE][-+]?[0-9]+)?\z/;
      my $suffix = "";
      if ( 2 < $MaxArgLen and $MaxArgLen < length($arg) ) {
          substr ( $arg, $MaxArgLen - 3 ) = "";
  	$suffix = "...";
      }
      if(UTF8_REGEXP_PROBLEM && is_utf8($arg)) {
  	for(my $i = length($arg); $i--; ) {
  	    my $c = substr($arg, $i, 1);
  	    my $x = substr($arg, 0, 0);   # work around bug on Perl 5.8.{1,2}
  	    if($c eq "\"" || $c eq "\\" || $c eq "\$" || $c eq "\@") {
  		substr $arg, $i, 0, "\\";
  		next;
  	    }
  	    my $o = ord($c);
  
              # This code is repeated in Regexp::CARP_TRACE()
              if ($] ge 5.007_003) {
                  substr $arg, $i, 1, sprintf("\\x{%x}", $o)
  		  if utf8::native_to_unicode($o) < utf8::native_to_unicode(0x20)
                    || utf8::native_to_unicode($o) > utf8::native_to_unicode(0x7e);
              } elsif (ord("A") == 65) {
                  substr $arg, $i, 1, sprintf("\\x{%x}", $o)
                      if $o < 0x20 || $o > 0x7e;
              } else { # Early EBCDIC
  
                  # 3 EBCDIC code pages supported then;  all controls but one
                  # are the code points below SPACE.  The other one is 0x5F on
                  # POSIX-BC; FF on the other two.
                  substr $arg, $i, 1, sprintf("\\x{%x}", $o)
                      if $o < ord(" ") || ((ord ("^") == 106)
                                            ? $o == 0x5f
                                            : $o == 0xff);
              }
  	}
      } else {
  	$arg =~ s/([\"\\\$\@])/\\$1/g;
          # This is all the ASCII printables spelled-out.  It is portable to all
          # Perl versions and platforms (such as EBCDIC).  There are other more
          # compact ways to do this, but may not work everywhere every version.
          $arg =~ s/([^ !"\$\%#'()*+,\-.\/0123456789:;<=>?\@ABCDEFGHIJKLMNOPQRSTUVWXYZ\[\\\]^_`abcdefghijklmnopqrstuvwxyz\{|}~])/sprintf("\\x{%x}",ord($1))/eg;
      }
      downgrade($arg, 1);
      return "\"".$arg."\"".$suffix;
  }
  
  sub Regexp::CARP_TRACE {
      my $arg = "$_[0]";
      downgrade($arg, 1);
      if(UTF8_REGEXP_PROBLEM && is_utf8($arg)) {
  	for(my $i = length($arg); $i--; ) {
  	    my $o = ord(substr($arg, $i, 1));
  	    my $x = substr($arg, 0, 0);   # work around bug on Perl 5.8.{1,2}
  
              # This code is repeated in format_arg()
              if ($] ge 5.007_003) {
                  substr $arg, $i, 1, sprintf("\\x{%x}", $o)
  		  if utf8::native_to_unicode($o) < utf8::native_to_unicode(0x20)
                    || utf8::native_to_unicode($o) > utf8::native_to_unicode(0x7e);
              } elsif (ord("A") == 65) {
                  substr $arg, $i, 1, sprintf("\\x{%x}", $o)
                      if $o < 0x20 || $o > 0x7e;
              } else { # Early EBCDIC
                  substr $arg, $i, 1, sprintf("\\x{%x}", $o)
                      if $o < ord(" ") || ((ord ("^") == 106)
                                            ? $o == 0x5f
                                            : $o == 0xff);
              }
  	}
      } else {
          # See comment in format_arg() about this same regex.
          $arg =~ s/([^ !"\$\%#'()*+,\-.\/0123456789:;<=>?\@ABCDEFGHIJKLMNOPQRSTUVWXYZ\[\\\]^_`abcdefghijklmnopqrstuvwxyz\{|}~])/sprintf("\\x{%x}",ord($1))/eg;
      }
      downgrade($arg, 1);
      my $suffix = "";
      if($arg =~ /\A\(\?\^?([a-z]*)(?:-[a-z]*)?:(.*)\)\z/s) {
  	($suffix, $arg) = ($1, $2);
      }
      if ( 2 < $MaxArgLen and $MaxArgLen < length($arg) ) {
          substr ( $arg, $MaxArgLen - 3 ) = "";
  	$suffix = "...".$suffix;
      }
      return "qr($arg)$suffix";
  }
  
  # Takes an inheritance cache and a package and returns
  # an anon hash of known inheritances and anon array of
  # inheritances which consequences have not been figured
  # for.
  sub get_status {
      my $cache = shift;
      my $pkg   = shift;
      $cache->{$pkg} ||= [ { $pkg => $pkg }, [ trusts_directly($pkg) ] ];
      return @{ $cache->{$pkg} };
  }
  
  # Takes the info from caller() and figures out the name of
  # the sub/require/eval
  sub get_subname {
      my $info = shift;
      if ( defined( $info->{evaltext} ) ) {
          my $eval = $info->{evaltext};
          if ( $info->{is_require} ) {
              return "require $eval";
          }
          else {
              $eval =~ s/([\\\'])/\\$1/g;
              return "eval '" . str_len_trim( $eval, $MaxEvalLen ) . "'";
          }
      }
  
      # this can happen on older perls when the sub (or the stash containing it)
      # has been deleted
      if ( !defined( $info->{sub} ) ) {
          return '__ANON__::__ANON__';
      }
  
      return ( $info->{sub} eq '(eval)' ) ? 'eval {...}' : $info->{sub};
  }
  
  # Figures out what call (from the point of view of the caller)
  # the long error backtrace should start at.
  sub long_error_loc {
      my $i;
      my $lvl = $CarpLevel;
      {
          ++$i;
          my $cgc = _cgc();
          my @caller = $cgc ? $cgc->($i) : caller($i);
          my $pkg = $caller[0];
          unless ( defined($pkg) ) {
  
              # This *shouldn't* happen.
              if (%Internal) {
                  local %Internal;
                  $i = long_error_loc();
                  last;
              }
              elsif (defined $caller[2]) {
                  # this can happen when the stash has been deleted
                  # in that case, just assume that it's a reasonable place to
                  # stop (the file and line data will still be intact in any
                  # case) - the only issue is that we can't detect if the
                  # deleted package was internal (so don't do that then)
                  # -doy
                  redo unless 0 > --$lvl;
                  last;
              }
              else {
                  return 2;
              }
          }
          redo if $CarpInternal{$pkg};
          redo unless 0 > --$lvl;
          redo if $Internal{$pkg};
      }
      return $i - 1;
  }
  
  sub longmess_heavy {
      return @_ if ref( $_[0] );    # don't break references as exceptions
      my $i = long_error_loc();
      return ret_backtrace( $i, @_ );
  }
  
  # Returns a full stack backtrace starting from where it is
  # told.
  sub ret_backtrace {
      my ( $i, @error ) = @_;
      my $mess;
      my $err = join '', @error;
      $i++;
  
      my $tid_msg = '';
      if ( defined &threads::tid ) {
          my $tid = threads->tid;
          $tid_msg = " thread $tid" if $tid;
      }
  
      my %i = caller_info($i);
      $mess = "$err at $i{file} line $i{line}$tid_msg";
      if( defined $. ) {
          local $@ = '';
          local $SIG{__DIE__};
          eval {
              CORE::die;
          };
          if($@ =~ /^Died at .*(, <.*?> line \d+).$/ ) {
              $mess .= $1;
          }
      }
      $mess .= "\.\n";
  
      while ( my %i = caller_info( ++$i ) ) {
          $mess .= "\t$i{sub_name} called at $i{file} line $i{line}$tid_msg\n";
      }
  
      return $mess;
  }
  
  sub ret_summary {
      my ( $i, @error ) = @_;
      my $err = join '', @error;
      $i++;
  
      my $tid_msg = '';
      if ( defined &threads::tid ) {
          my $tid = threads->tid;
          $tid_msg = " thread $tid" if $tid;
      }
  
      my %i = caller_info($i);
      return "$err at $i{file} line $i{line}$tid_msg\.\n";
  }
  
  sub short_error_loc {
      # You have to create your (hash)ref out here, rather than defaulting it
      # inside trusts *on a lexical*, as you want it to persist across calls.
      # (You can default it on $_[2], but that gets messy)
      my $cache = {};
      my $i     = 1;
      my $lvl   = $CarpLevel;
      {
          my $cgc = _cgc();
          my $called = $cgc ? $cgc->($i) : caller($i);
          $i++;
          my $caller = $cgc ? $cgc->($i) : caller($i);
  
          if (!defined($caller)) {
              my @caller = $cgc ? $cgc->($i) : caller($i);
              if (@caller) {
                  # if there's no package but there is other caller info, then
                  # the package has been deleted - treat this as a valid package
                  # in this case
                  redo if defined($called) && $CarpInternal{$called};
                  redo unless 0 > --$lvl;
                  last;
              }
              else {
                  return 0;
              }
          }
          redo if $Internal{$caller};
          redo if $CarpInternal{$caller};
          redo if $CarpInternal{$called};
          redo if trusts( $called, $caller, $cache );
          redo if trusts( $caller, $called, $cache );
          redo unless 0 > --$lvl;
      }
      return $i - 1;
  }
  
  sub shortmess_heavy {
      return longmess_heavy(@_) if $Verbose;
      return @_ if ref( $_[0] );    # don't break references as exceptions
      my $i = short_error_loc();
      if ($i) {
          ret_summary( $i, @_ );
      }
      else {
          longmess_heavy(@_);
      }
  }
  
  # If a string is too long, trims it with ...
  sub str_len_trim {
      my $str = shift;
      my $max = shift || 0;
      if ( 2 < $max and $max < length($str) ) {
          substr( $str, $max - 3 ) = '...';
      }
      return $str;
  }
  
  # Takes two packages and an optional cache.  Says whether the
  # first inherits from the second.
  #
  # Recursive versions of this have to work to avoid certain
  # possible endless loops, and when following long chains of
  # inheritance are less efficient.
  sub trusts {
      my $child  = shift;
      my $parent = shift;
      my $cache  = shift;
      my ( $known, $partial ) = get_status( $cache, $child );
  
      # Figure out consequences until we have an answer
      while ( @$partial and not exists $known->{$parent} ) {
          my $anc = shift @$partial;
          next if exists $known->{$anc};
          $known->{$anc}++;
          my ( $anc_knows, $anc_partial ) = get_status( $cache, $anc );
          my @found = keys %$anc_knows;
          @$known{@found} = ();
          push @$partial, @$anc_partial;
      }
      return exists $known->{$parent};
  }
  
  # Takes a package and gives a list of those trusted directly
  sub trusts_directly {
      my $class = shift;
      no strict 'refs';
      my $stash = \%{"$class\::"};
      for my $var (qw/ CARP_NOT ISA /) {
          # Don't try using the variable until we know it exists,
          # to avoid polluting the caller's namespace.
          if ( $stash->{$var} && *{$stash->{$var}}{ARRAY} && @{$stash->{$var}} ) {
             return @{$stash->{$var}}
          }
      }
      return;
  }
  
  if(!defined($warnings::VERSION) ||
  	do { no warnings "numeric"; $warnings::VERSION < 1.03 }) {
      # Very old versions of warnings.pm import from Carp.  This can go
      # wrong due to the circular dependency.  If Carp is invoked before
      # warnings, then Carp starts by loading warnings, then warnings
      # tries to import from Carp, and gets nothing because Carp is in
      # the process of loading and hasn't defined its import method yet.
      # So we work around that by manually exporting to warnings here.
      no strict "refs";
      *{"warnings::$_"} = \&$_ foreach @EXPORT;
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Carp - alternative warn and die for modules
  
  =head1 SYNOPSIS
  
      use Carp;
  
      # warn user (from perspective of caller)
      carp "string trimmed to 80 chars";
  
      # die of errors (from perspective of caller)
      croak "We're outta here!";
  
      # die of errors with stack backtrace
      confess "not implemented";
  
      # cluck, longmess and shortmess not exported by default
      use Carp qw(cluck longmess shortmess);
      cluck "This is how we got here!";
      $long_message   = longmess( "message from cluck() or confess()" );
      $short_message  = shortmess( "message from carp() or croak()" );
  
  =head1 DESCRIPTION
  
  The Carp routines are useful in your own modules because
  they act like C<die()> or C<warn()>, but with a message which is more
  likely to be useful to a user of your module.  In the case of
  C<cluck()> and C<confess()>, that context is a summary of every
  call in the call-stack; C<longmess()> returns the contents of the error
  message.
  
  For a shorter message you can use C<carp()> or C<croak()> which report the
  error as being from where your module was called.  C<shortmess()> returns the
  contents of this error message.  There is no guarantee that that is where the
  error was, but it is a good educated guess.
  
  C<Carp> takes care not to clobber the status variables C<$!> and C<$^E>
  in the course of assembling its error messages.  This means that a
  C<$SIG{__DIE__}> or C<$SIG{__WARN__}> handler can capture the error
  information held in those variables, if it is required to augment the
  error message, and if the code calling C<Carp> left useful values there.
  Of course, C<Carp> can't guarantee the latter.
  
  You can also alter the way the output and logic of C<Carp> works, by
  changing some global variables in the C<Carp> namespace. See the
  section on C<GLOBAL VARIABLES> below.
  
  Here is a more complete description of how C<carp> and C<croak> work.
  What they do is search the call-stack for a function call stack where
  they have not been told that there shouldn't be an error.  If every
  call is marked safe, they give up and give a full stack backtrace
  instead.  In other words they presume that the first likely looking
  potential suspect is guilty.  Their rules for telling whether
  a call shouldn't generate errors work as follows:
  
  =over 4
  
  =item 1.
  
  Any call from a package to itself is safe.
  
  =item 2.
  
  Packages claim that there won't be errors on calls to or from
  packages explicitly marked as safe by inclusion in C<@CARP_NOT>, or
  (if that array is empty) C<@ISA>.  The ability to override what
  @ISA says is new in 5.8.
  
  =item 3.
  
  The trust in item 2 is transitive.  If A trusts B, and B
  trusts C, then A trusts C.  So if you do not override C<@ISA>
  with C<@CARP_NOT>, then this trust relationship is identical to,
  "inherits from".
  
  =item 4.
  
  Any call from an internal Perl module is safe.  (Nothing keeps
  user modules from marking themselves as internal to Perl, but
  this practice is discouraged.)
  
  =item 5.
  
  Any call to Perl's warning system (eg Carp itself) is safe.
  (This rule is what keeps it from reporting the error at the
  point where you call C<carp> or C<croak>.)
  
  =item 6.
  
  C<$Carp::CarpLevel> can be set to skip a fixed number of additional
  call levels.  Using this is not recommended because it is very
  difficult to get it to behave correctly.
  
  =back
  
  =head2 Forcing a Stack Trace
  
  As a debugging aid, you can force Carp to treat a croak as a confess
  and a carp as a cluck across I<all> modules. In other words, force a
  detailed stack trace to be given.  This can be very helpful when trying
  to understand why, or from where, a warning or error is being generated.
  
  This feature is enabled by 'importing' the non-existent symbol
  'verbose'. You would typically enable it by saying
  
      perl -MCarp=verbose script.pl
  
  or by including the string C<-MCarp=verbose> in the PERL5OPT
  environment variable.
  
  Alternately, you can set the global variable C<$Carp::Verbose> to true.
  See the C<GLOBAL VARIABLES> section below.
  
  =head2 Stack Trace formatting
  
  At each stack level, the subroutine's name is displayed along with
  its parameters.  For simple scalars, this is sufficient.  For complex
  data types, such as objects and other references, this can simply
  display C<'HASH(0x1ab36d8)'>.
  
  Carp gives two ways to control this.
  
  =over 4
  
  =item 1.
  
  For objects, a method, C<CARP_TRACE>, will be called, if it exists.  If
  this method doesn't exist, or it recurses into C<Carp>, or it otherwise
  throws an exception, this is skipped, and Carp moves on to the next option,
  otherwise checking stops and the string returned is used.  It is recommended
  that the object's type is part of the string to make debugging easier.
  
  =item 2.
  
  For any type of reference, C<$Carp::RefArgFormatter> is checked (see below).
  This variable is expected to be a code reference, and the current parameter
  is passed in.  If this function doesn't exist (the variable is undef), or
  it recurses into C<Carp>, or it otherwise throws an exception, this is
  skipped, and Carp moves on to the next option, otherwise checking stops
  and the string returned is used.
  
  =item 3.
  
  Otherwise, if neither C<CARP_TRACE> nor C<$Carp::RefArgFormatter> is
  available, stringify the value ignoring any overloading.
  
  =back
  
  =head1 GLOBAL VARIABLES
  
  =head2 $Carp::MaxEvalLen
  
  This variable determines how many characters of a string-eval are to
  be shown in the output. Use a value of C<0> to show all text.
  
  Defaults to C<0>.
  
  =head2 $Carp::MaxArgLen
  
  This variable determines how many characters of each argument to a
  function to print. Use a value of C<0> to show the full length of the
  argument.
  
  Defaults to C<64>.
  
  =head2 $Carp::MaxArgNums
  
  This variable determines how many arguments to each function to show.
  Use a false value to show all arguments to a function call.  To suppress all
  arguments, use C<-1> or C<'0 but true'>.
  
  Defaults to C<8>.
  
  =head2 $Carp::Verbose
  
  This variable makes C<carp()> and C<croak()> generate stack backtraces
  just like C<cluck()> and C<confess()>.  This is how C<use Carp 'verbose'>
  is implemented internally.
  
  Defaults to C<0>.
  
  =head2 $Carp::RefArgFormatter
  
  This variable sets a general argument formatter to display references.
  Plain scalars and objects that implement C<CARP_TRACE> will not go through
  this formatter.  Calling C<Carp> from within this function is not supported.
  
  local $Carp::RefArgFormatter = sub {
      require Data::Dumper;
      Data::Dumper::Dump($_[0]); # not necessarily safe
  };
  
  =head2 @CARP_NOT
  
  This variable, I<in your package>, says which packages are I<not> to be
  considered as the location of an error. The C<carp()> and C<cluck()>
  functions will skip over callers when reporting where an error occurred.
  
  NB: This variable must be in the package's symbol table, thus:
  
      # These work
      our @CARP_NOT; # file scope
      use vars qw(@CARP_NOT); # package scope
      @My::Package::CARP_NOT = ... ; # explicit package variable
  
      # These don't work
      sub xyz { ... @CARP_NOT = ... } # w/o declarations above
      my @CARP_NOT; # even at top-level
  
  Example of use:
  
      package My::Carping::Package;
      use Carp;
      our @CARP_NOT;
      sub bar     { .... or _error('Wrong input') }
      sub _error  {
          # temporary control of where'ness, __PACKAGE__ is implicit
          local @CARP_NOT = qw(My::Friendly::Caller);
          carp(@_)
      }
  
  This would make C<Carp> report the error as coming from a caller not
  in C<My::Carping::Package>, nor from C<My::Friendly::Caller>.
  
  Also read the L</DESCRIPTION> section above, about how C<Carp> decides
  where the error is reported from.
  
  Use C<@CARP_NOT>, instead of C<$Carp::CarpLevel>.
  
  Overrides C<Carp>'s use of C<@ISA>.
  
  =head2 %Carp::Internal
  
  This says what packages are internal to Perl.  C<Carp> will never
  report an error as being from a line in a package that is internal to
  Perl.  For example:
  
      $Carp::Internal{ (__PACKAGE__) }++;
      # time passes...
      sub foo { ... or confess("whatever") };
  
  would give a full stack backtrace starting from the first caller
  outside of __PACKAGE__.  (Unless that package was also internal to
  Perl.)
  
  =head2 %Carp::CarpInternal
  
  This says which packages are internal to Perl's warning system.  For
  generating a full stack backtrace this is the same as being internal
  to Perl, the stack backtrace will not start inside packages that are
  listed in C<%Carp::CarpInternal>.  But it is slightly different for
  the summary message generated by C<carp> or C<croak>.  There errors
  will not be reported on any lines that are calling packages in
  C<%Carp::CarpInternal>.
  
  For example C<Carp> itself is listed in C<%Carp::CarpInternal>.
  Therefore the full stack backtrace from C<confess> will not start
  inside of C<Carp>, and the short message from calling C<croak> is
  not placed on the line where C<croak> was called.
  
  =head2 $Carp::CarpLevel
  
  This variable determines how many additional call frames are to be
  skipped that would not otherwise be when reporting where an error
  occurred on a call to one of C<Carp>'s functions.  It is fairly easy
  to count these call frames on calls that generate a full stack
  backtrace.  However it is much harder to do this accounting for calls
  that generate a short message.  Usually people skip too many call
  frames.  If they are lucky they skip enough that C<Carp> goes all of
  the way through the call stack, realizes that something is wrong, and
  then generates a full stack backtrace.  If they are unlucky then the
  error is reported from somewhere misleading very high in the call
  stack.
  
  Therefore it is best to avoid C<$Carp::CarpLevel>.  Instead use
  C<@CARP_NOT>, C<%Carp::Internal> and C<%Carp::CarpInternal>.
  
  Defaults to C<0>.
  
  =head1 BUGS
  
  The Carp routines don't handle exception objects currently.
  If called with a first argument that is a reference, they simply
  call die() or warn(), as appropriate.
  
  =head1 SEE ALSO
  
  L<Carp::Always>,
  L<Carp::Clan>
  
  =head1 AUTHOR
  
  The Carp module first appeared in Larry Wall's perl 5.000 distribution.
  Since then it has been modified by several of the perl 5 porters.
  Andrew Main (Zefram) <zefram@fysh.org> divested Carp into an independent
  distribution.
  
  =head1 COPYRIGHT
  
  Copyright (C) 1994-2013 Larry Wall
  
  Copyright (C) 2011, 2012, 2013 Andrew Main (Zefram) <zefram@fysh.org>
  
  =head1 LICENSE
  
  This module is free software; you can redistribute it and/or modify it
  under the same terms as Perl itself.
CARP

$fatpacked{"Carp/Heavy.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CARP_HEAVY';
  package Carp::Heavy;
  
  use Carp ();
  
  our $VERSION = '1.38';
  $VERSION =~ tr/_//d;
  
  # Carp::Heavy was merged into Carp in version 1.12.  Any mismatched versions
  # after this point are not significant and can be ignored.
  if(($Carp::VERSION || 0) < 1.12) {
  	my $cv = defined($Carp::VERSION) ? $Carp::VERSION : "undef";
  	die "Version mismatch between Carp $cv ($INC{q(Carp.pm)}) and Carp::Heavy $VERSION ($INC{q(Carp/Heavy.pm)}).  Did you alter \@INC after Carp was loaded?\n";
  }
  
  1;
  
  # Most of the machinery of Carp used to be here.
  # It has been moved in Carp.pm now, but this placeholder remains for
  # the benefit of modules that like to preload Carp::Heavy directly.
  # This must load Carp, because some modules rely on the historical
  # behaviour of Carp::Heavy loading Carp.
CARP_HEAVY

$fatpacked{"Getopt/Long.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'GETOPT_LONG';
  #! perl
  
  # Getopt::Long.pm -- Universal options parsing
  # Author          : Johan Vromans
  # Created On      : Tue Sep 11 15:00:12 1990
  # Last Modified By: Johan Vromans
  # Last Modified On: Thu Jun  9 14:50:37 2016
  # Update Count    : 1699
  # Status          : Released
  
  ################ Module Preamble ################
  
  package Getopt::Long;
  
  use 5.004;
  
  use strict;
  
  use vars qw($VERSION);
  $VERSION        =  2.49;
  # For testing versions only.
  use vars qw($VERSION_STRING);
  $VERSION_STRING = "2.49";
  
  use Exporter;
  use vars qw(@ISA @EXPORT @EXPORT_OK);
  @ISA = qw(Exporter);
  
  # Exported subroutines.
  sub GetOptions(@);		# always
  sub GetOptionsFromArray(@);	# on demand
  sub GetOptionsFromString(@);	# on demand
  sub Configure(@);		# on demand
  sub HelpMessage(@);		# on demand
  sub VersionMessage(@);		# in demand
  
  BEGIN {
      # Init immediately so their contents can be used in the 'use vars' below.
      @EXPORT    = qw(&GetOptions $REQUIRE_ORDER $PERMUTE $RETURN_IN_ORDER);
      @EXPORT_OK = qw(&HelpMessage &VersionMessage &Configure
  		    &GetOptionsFromArray &GetOptionsFromString);
  }
  
  # User visible variables.
  use vars @EXPORT, @EXPORT_OK;
  use vars qw($error $debug $major_version $minor_version);
  # Deprecated visible variables.
  use vars qw($autoabbrev $getopt_compat $ignorecase $bundling $order
  	    $passthrough);
  # Official invisible variables.
  use vars qw($genprefix $caller $gnu_compat $auto_help $auto_version $longprefix);
  
  # Really invisible variables.
  my $bundling_values;
  
  # Public subroutines.
  sub config(@);			# deprecated name
  
  # Private subroutines.
  sub ConfigDefaults();
  sub ParseOptionSpec($$);
  sub OptCtl($);
  sub FindOption($$$$$);
  sub ValidValue ($$$$$);
  
  ################ Local Variables ################
  
  # $requested_version holds the version that was mentioned in the 'use'
  # or 'require', if any. It can be used to enable or disable specific
  # features.
  my $requested_version = 0;
  
  ################ Resident subroutines ################
  
  sub ConfigDefaults() {
      # Handle POSIX compliancy.
      if ( defined $ENV{"POSIXLY_CORRECT"} ) {
  	$genprefix = "(--|-)";
  	$autoabbrev = 0;		# no automatic abbrev of options
  	$bundling = 0;			# no bundling of single letter switches
  	$getopt_compat = 0;		# disallow '+' to start options
  	$order = $REQUIRE_ORDER;
      }
      else {
  	$genprefix = "(--|-|\\+)";
  	$autoabbrev = 1;		# automatic abbrev of options
  	$bundling = 0;			# bundling off by default
  	$getopt_compat = 1;		# allow '+' to start options
  	$order = $PERMUTE;
      }
      # Other configurable settings.
      $debug = 0;			# for debugging
      $error = 0;			# error tally
      $ignorecase = 1;		# ignore case when matching options
      $passthrough = 0;		# leave unrecognized options alone
      $gnu_compat = 0;		# require --opt=val if value is optional
      $longprefix = "(--)";       # what does a long prefix look like
      $bundling_values = 0;	# no bundling of values
  }
  
  # Override import.
  sub import {
      my $pkg = shift;		# package
      my @syms = ();		# symbols to import
      my @config = ();		# configuration
      my $dest = \@syms;		# symbols first
      for ( @_ ) {
  	if ( $_ eq ':config' ) {
  	    $dest = \@config;	# config next
  	    next;
  	}
  	push(@$dest, $_);	# push
      }
      # Hide one level and call super.
      local $Exporter::ExportLevel = 1;
      push(@syms, qw(&GetOptions)) if @syms; # always export GetOptions
      $requested_version = 0;
      $pkg->SUPER::import(@syms);
      # And configure.
      Configure(@config) if @config;
  }
  
  ################ Initialization ################
  
  # Values for $order. See GNU getopt.c for details.
  ($REQUIRE_ORDER, $PERMUTE, $RETURN_IN_ORDER) = (0..2);
  # Version major/minor numbers.
  ($major_version, $minor_version) = $VERSION =~ /^(\d+)\.(\d+)/;
  
  ConfigDefaults();
  
  ################ OO Interface ################
  
  package Getopt::Long::Parser;
  
  # Store a copy of the default configuration. Since ConfigDefaults has
  # just been called, what we get from Configure is the default.
  my $default_config = do {
      Getopt::Long::Configure ()
  };
  
  sub new {
      my $that = shift;
      my $class = ref($that) || $that;
      my %atts = @_;
  
      # Register the callers package.
      my $self = { caller_pkg => (caller)[0] };
  
      bless ($self, $class);
  
      # Process config attributes.
      if ( defined $atts{config} ) {
  	my $save = Getopt::Long::Configure ($default_config, @{$atts{config}});
  	$self->{settings} = Getopt::Long::Configure ($save);
  	delete ($atts{config});
      }
      # Else use default config.
      else {
  	$self->{settings} = $default_config;
      }
  
      if ( %atts ) {		# Oops
  	die(__PACKAGE__.": unhandled attributes: ".
  	    join(" ", sort(keys(%atts)))."\n");
      }
  
      $self;
  }
  
  sub configure {
      my ($self) = shift;
  
      # Restore settings, merge new settings in.
      my $save = Getopt::Long::Configure ($self->{settings}, @_);
  
      # Restore orig config and save the new config.
      $self->{settings} = Getopt::Long::Configure ($save);
  }
  
  sub getoptions {
      my ($self) = shift;
  
      return $self->getoptionsfromarray(\@ARGV, @_);
  }
  
  sub getoptionsfromarray {
      my ($self) = shift;
  
      # Restore config settings.
      my $save = Getopt::Long::Configure ($self->{settings});
  
      # Call main routine.
      my $ret = 0;
      $Getopt::Long::caller = $self->{caller_pkg};
  
      eval {
  	# Locally set exception handler to default, otherwise it will
  	# be called implicitly here, and again explicitly when we try
  	# to deliver the messages.
  	local ($SIG{__DIE__}) = 'DEFAULT';
  	$ret = Getopt::Long::GetOptionsFromArray (@_);
      };
  
      # Restore saved settings.
      Getopt::Long::Configure ($save);
  
      # Handle errors and return value.
      die ($@) if $@;
      return $ret;
  }
  
  package Getopt::Long;
  
  ################ Back to Normal ################
  
  # Indices in option control info.
  # Note that ParseOptions uses the fields directly. Search for 'hard-wired'.
  use constant CTL_TYPE    => 0;
  #use constant   CTL_TYPE_FLAG   => '';
  #use constant   CTL_TYPE_NEG    => '!';
  #use constant   CTL_TYPE_INCR   => '+';
  #use constant   CTL_TYPE_INT    => 'i';
  #use constant   CTL_TYPE_INTINC => 'I';
  #use constant   CTL_TYPE_XINT   => 'o';
  #use constant   CTL_TYPE_FLOAT  => 'f';
  #use constant   CTL_TYPE_STRING => 's';
  
  use constant CTL_CNAME   => 1;
  
  use constant CTL_DEFAULT => 2;
  
  use constant CTL_DEST    => 3;
   use constant   CTL_DEST_SCALAR => 0;
   use constant   CTL_DEST_ARRAY  => 1;
   use constant   CTL_DEST_HASH   => 2;
   use constant   CTL_DEST_CODE   => 3;
  
  use constant CTL_AMIN    => 4;
  use constant CTL_AMAX    => 5;
  
  # FFU.
  #use constant CTL_RANGE   => ;
  #use constant CTL_REPEAT  => ;
  
  # Rather liberal patterns to match numbers.
  use constant PAT_INT   => "[-+]?_*[0-9][0-9_]*";
  use constant PAT_XINT  =>
    "(?:".
  	  "[-+]?_*[1-9][0-9_]*".
    "|".
  	  "0x_*[0-9a-f][0-9a-f_]*".
    "|".
  	  "0b_*[01][01_]*".
    "|".
  	  "0[0-7_]*".
    ")";
  use constant PAT_FLOAT =>
    "[-+]?".			# optional sign
    "(?=[0-9.])".			# must start with digit or dec.point
    "[0-9_]*".			# digits before the dec.point
    "(\.[0-9_]+)?".		# optional fraction
    "([eE][-+]?[0-9_]+)?";	# optional exponent
  
  sub GetOptions(@) {
      # Shift in default array.
      unshift(@_, \@ARGV);
      # Try to keep caller() and Carp consistent.
      goto &GetOptionsFromArray;
  }
  
  sub GetOptionsFromString(@) {
      my ($string) = shift;
      require Text::ParseWords;
      my $args = [ Text::ParseWords::shellwords($string) ];
      $caller ||= (caller)[0];	# current context
      my $ret = GetOptionsFromArray($args, @_);
      return ( $ret, $args ) if wantarray;
      if ( @$args ) {
  	$ret = 0;
  	warn("GetOptionsFromString: Excess data \"@$args\" in string \"$string\"\n");
      }
      $ret;
  }
  
  sub GetOptionsFromArray(@) {
  
      my ($argv, @optionlist) = @_;	# local copy of the option descriptions
      my $argend = '--';		# option list terminator
      my %opctl = ();		# table of option specs
      my $pkg = $caller || (caller)[0];	# current context
  				# Needed if linkage is omitted.
      my @ret = ();		# accum for non-options
      my %linkage;		# linkage
      my $userlinkage;		# user supplied HASH
      my $opt;			# current option
      my $prefix = $genprefix;	# current prefix
  
      $error = '';
  
      if ( $debug ) {
  	# Avoid some warnings if debugging.
  	local ($^W) = 0;
  	print STDERR
  	  ("Getopt::Long $Getopt::Long::VERSION ",
  	   "called from package \"$pkg\".",
  	   "\n  ",
  	   "argv: ",
  	   defined($argv)
  	   ? UNIVERSAL::isa( $argv, 'ARRAY' ) ? "(@$argv)" : $argv
  	   : "<undef>",
  	   "\n  ",
  	   "autoabbrev=$autoabbrev,".
  	   "bundling=$bundling,",
  	   "bundling_values=$bundling_values,",
  	   "getopt_compat=$getopt_compat,",
  	   "gnu_compat=$gnu_compat,",
  	   "order=$order,",
  	   "\n  ",
  	   "ignorecase=$ignorecase,",
  	   "requested_version=$requested_version,",
  	   "passthrough=$passthrough,",
  	   "genprefix=\"$genprefix\",",
  	   "longprefix=\"$longprefix\".",
  	   "\n");
      }
  
      # Check for ref HASH as first argument.
      # First argument may be an object. It's OK to use this as long
      # as it is really a hash underneath.
      $userlinkage = undef;
      if ( @optionlist && ref($optionlist[0]) and
  	 UNIVERSAL::isa($optionlist[0],'HASH') ) {
  	$userlinkage = shift (@optionlist);
  	print STDERR ("=> user linkage: $userlinkage\n") if $debug;
      }
  
      # See if the first element of the optionlist contains option
      # starter characters.
      # Be careful not to interpret '<>' as option starters.
      if ( @optionlist && $optionlist[0] =~ /^\W+$/
  	 && !($optionlist[0] eq '<>'
  	      && @optionlist > 0
  	      && ref($optionlist[1])) ) {
  	$prefix = shift (@optionlist);
  	# Turn into regexp. Needs to be parenthesized!
  	$prefix =~ s/(\W)/\\$1/g;
  	$prefix = "([" . $prefix . "])";
  	print STDERR ("=> prefix=\"$prefix\"\n") if $debug;
      }
  
      # Verify correctness of optionlist.
      %opctl = ();
      while ( @optionlist ) {
  	my $opt = shift (@optionlist);
  
  	unless ( defined($opt) ) {
  	    $error .= "Undefined argument in option spec\n";
  	    next;
  	}
  
  	# Strip leading prefix so people can specify "--foo=i" if they like.
  	$opt = $+ if $opt =~ /^$prefix+(.*)$/s;
  
  	if ( $opt eq '<>' ) {
  	    if ( (defined $userlinkage)
  		&& !(@optionlist > 0 && ref($optionlist[0]))
  		&& (exists $userlinkage->{$opt})
  		&& ref($userlinkage->{$opt}) ) {
  		unshift (@optionlist, $userlinkage->{$opt});
  	    }
  	    unless ( @optionlist > 0
  		    && ref($optionlist[0]) && ref($optionlist[0]) eq 'CODE' ) {
  		$error .= "Option spec <> requires a reference to a subroutine\n";
  		# Kill the linkage (to avoid another error).
  		shift (@optionlist)
  		  if @optionlist && ref($optionlist[0]);
  		next;
  	    }
  	    $linkage{'<>'} = shift (@optionlist);
  	    next;
  	}
  
  	# Parse option spec.
  	my ($name, $orig) = ParseOptionSpec ($opt, \%opctl);
  	unless ( defined $name ) {
  	    # Failed. $orig contains the error message. Sorry for the abuse.
  	    $error .= $orig;
  	    # Kill the linkage (to avoid another error).
  	    shift (@optionlist)
  	      if @optionlist && ref($optionlist[0]);
  	    next;
  	}
  
  	# If no linkage is supplied in the @optionlist, copy it from
  	# the userlinkage if available.
  	if ( defined $userlinkage ) {
  	    unless ( @optionlist > 0 && ref($optionlist[0]) ) {
  		if ( exists $userlinkage->{$orig} &&
  		     ref($userlinkage->{$orig}) ) {
  		    print STDERR ("=> found userlinkage for \"$orig\": ",
  				  "$userlinkage->{$orig}\n")
  			if $debug;
  		    unshift (@optionlist, $userlinkage->{$orig});
  		}
  		else {
  		    # Do nothing. Being undefined will be handled later.
  		    next;
  		}
  	    }
  	}
  
  	# Copy the linkage. If omitted, link to global variable.
  	if ( @optionlist > 0 && ref($optionlist[0]) ) {
  	    print STDERR ("=> link \"$orig\" to $optionlist[0]\n")
  		if $debug;
  	    my $rl = ref($linkage{$orig} = shift (@optionlist));
  
  	    if ( $rl eq "ARRAY" ) {
  		$opctl{$name}[CTL_DEST] = CTL_DEST_ARRAY;
  	    }
  	    elsif ( $rl eq "HASH" ) {
  		$opctl{$name}[CTL_DEST] = CTL_DEST_HASH;
  	    }
  	    elsif ( $rl eq "SCALAR" || $rl eq "REF" ) {
  #		if ( $opctl{$name}[CTL_DEST] == CTL_DEST_ARRAY ) {
  #		    my $t = $linkage{$orig};
  #		    $$t = $linkage{$orig} = [];
  #		}
  #		elsif ( $opctl{$name}[CTL_DEST] == CTL_DEST_HASH ) {
  #		}
  #		else {
  		    # Ok.
  #		}
  	    }
  	    elsif ( $rl eq "CODE" ) {
  		# Ok.
  	    }
  	    else {
  		$error .= "Invalid option linkage for \"$opt\"\n";
  	    }
  	}
  	else {
  	    # Link to global $opt_XXX variable.
  	    # Make sure a valid perl identifier results.
  	    my $ov = $orig;
  	    $ov =~ s/\W/_/g;
  	    if ( $opctl{$name}[CTL_DEST] == CTL_DEST_ARRAY ) {
  		print STDERR ("=> link \"$orig\" to \@$pkg","::opt_$ov\n")
  		    if $debug;
  		eval ("\$linkage{\$orig} = \\\@".$pkg."::opt_$ov;");
  	    }
  	    elsif ( $opctl{$name}[CTL_DEST] == CTL_DEST_HASH ) {
  		print STDERR ("=> link \"$orig\" to \%$pkg","::opt_$ov\n")
  		    if $debug;
  		eval ("\$linkage{\$orig} = \\\%".$pkg."::opt_$ov;");
  	    }
  	    else {
  		print STDERR ("=> link \"$orig\" to \$$pkg","::opt_$ov\n")
  		    if $debug;
  		eval ("\$linkage{\$orig} = \\\$".$pkg."::opt_$ov;");
  	    }
  	}
  
  	if ( $opctl{$name}[CTL_TYPE] eq 'I'
  	     && ( $opctl{$name}[CTL_DEST] == CTL_DEST_ARRAY
  		  || $opctl{$name}[CTL_DEST] == CTL_DEST_HASH )
  	   ) {
  	    $error .= "Invalid option linkage for \"$opt\"\n";
  	}
  
      }
  
      $error .= "GetOptionsFromArray: 1st parameter is not an array reference\n"
        unless $argv && UNIVERSAL::isa( $argv, 'ARRAY' );
  
      # Bail out if errors found.
      die ($error) if $error;
      $error = 0;
  
      # Supply --version and --help support, if needed and allowed.
      if ( defined($auto_version) ? $auto_version : ($requested_version >= 2.3203) ) {
  	if ( !defined($opctl{version}) ) {
  	    $opctl{version} = ['','version',0,CTL_DEST_CODE,undef];
  	    $linkage{version} = \&VersionMessage;
  	}
  	$auto_version = 1;
      }
      if ( defined($auto_help) ? $auto_help : ($requested_version >= 2.3203) ) {
  	if ( !defined($opctl{help}) && !defined($opctl{'?'}) ) {
  	    $opctl{help} = $opctl{'?'} = ['','help',0,CTL_DEST_CODE,undef];
  	    $linkage{help} = \&HelpMessage;
  	}
  	$auto_help = 1;
      }
  
      # Show the options tables if debugging.
      if ( $debug ) {
  	my ($arrow, $k, $v);
  	$arrow = "=> ";
  	while ( ($k,$v) = each(%opctl) ) {
  	    print STDERR ($arrow, "\$opctl{$k} = $v ", OptCtl($v), "\n");
  	    $arrow = "   ";
  	}
      }
  
      # Process argument list
      my $goon = 1;
      while ( $goon && @$argv > 0 ) {
  
  	# Get next argument.
  	$opt = shift (@$argv);
  	print STDERR ("=> arg \"", $opt, "\"\n") if $debug;
  
  	# Double dash is option list terminator.
  	if ( defined($opt) && $opt eq $argend ) {
  	  push (@ret, $argend) if $passthrough;
  	  last;
  	}
  
  	# Look it up.
  	my $tryopt = $opt;
  	my $found;		# success status
  	my $key;		# key (if hash type)
  	my $arg;		# option argument
  	my $ctl;		# the opctl entry
  
  	($found, $opt, $ctl, $arg, $key) =
  	  FindOption ($argv, $prefix, $argend, $opt, \%opctl);
  
  	if ( $found ) {
  
  	    # FindOption undefines $opt in case of errors.
  	    next unless defined $opt;
  
  	    my $argcnt = 0;
  	    while ( defined $arg ) {
  
  		# Get the canonical name.
  		print STDERR ("=> cname for \"$opt\" is ") if $debug;
  		$opt = $ctl->[CTL_CNAME];
  		print STDERR ("\"$ctl->[CTL_CNAME]\"\n") if $debug;
  
  		if ( defined $linkage{$opt} ) {
  		    print STDERR ("=> ref(\$L{$opt}) -> ",
  				  ref($linkage{$opt}), "\n") if $debug;
  
  		    if ( ref($linkage{$opt}) eq 'SCALAR'
  			 || ref($linkage{$opt}) eq 'REF' ) {
  			if ( $ctl->[CTL_TYPE] eq '+' ) {
  			    print STDERR ("=> \$\$L{$opt} += \"$arg\"\n")
  			      if $debug;
  			    if ( defined ${$linkage{$opt}} ) {
  			        ${$linkage{$opt}} += $arg;
  			    }
  		            else {
  			        ${$linkage{$opt}} = $arg;
  			    }
  			}
  			elsif ( $ctl->[CTL_DEST] == CTL_DEST_ARRAY ) {
  			    print STDERR ("=> ref(\$L{$opt}) auto-vivified",
  					  " to ARRAY\n")
  			      if $debug;
  			    my $t = $linkage{$opt};
  			    $$t = $linkage{$opt} = [];
  			    print STDERR ("=> push(\@{\$L{$opt}, \"$arg\")\n")
  			      if $debug;
  			    push (@{$linkage{$opt}}, $arg);
  			}
  			elsif ( $ctl->[CTL_DEST] == CTL_DEST_HASH ) {
  			    print STDERR ("=> ref(\$L{$opt}) auto-vivified",
  					  " to HASH\n")
  			      if $debug;
  			    my $t = $linkage{$opt};
  			    $$t = $linkage{$opt} = {};
  			    print STDERR ("=> \$\$L{$opt}->{$key} = \"$arg\"\n")
  			      if $debug;
  			    $linkage{$opt}->{$key} = $arg;
  			}
  			else {
  			    print STDERR ("=> \$\$L{$opt} = \"$arg\"\n")
  			      if $debug;
  			    ${$linkage{$opt}} = $arg;
  		        }
  		    }
  		    elsif ( ref($linkage{$opt}) eq 'ARRAY' ) {
  			print STDERR ("=> push(\@{\$L{$opt}, \"$arg\")\n")
  			    if $debug;
  			push (@{$linkage{$opt}}, $arg);
  		    }
  		    elsif ( ref($linkage{$opt}) eq 'HASH' ) {
  			print STDERR ("=> \$\$L{$opt}->{$key} = \"$arg\"\n")
  			    if $debug;
  			$linkage{$opt}->{$key} = $arg;
  		    }
  		    elsif ( ref($linkage{$opt}) eq 'CODE' ) {
  			print STDERR ("=> &L{$opt}(\"$opt\"",
  				      $ctl->[CTL_DEST] == CTL_DEST_HASH ? ", \"$key\"" : "",
  				      ", \"$arg\")\n")
  			    if $debug;
  			my $eval_error = do {
  			    local $@;
  			    local $SIG{__DIE__}  = 'DEFAULT';
  			    eval {
  				&{$linkage{$opt}}
  				  (Getopt::Long::CallBack->new
  				   (name    => $opt,
  				    ctl     => $ctl,
  				    opctl   => \%opctl,
  				    linkage => \%linkage,
  				    prefix  => $prefix,
  				   ),
  				   $ctl->[CTL_DEST] == CTL_DEST_HASH ? ($key) : (),
  				   $arg);
  			    };
  			    $@;
  			};
  			print STDERR ("=> die($eval_error)\n")
  			  if $debug && $eval_error ne '';
  			if ( $eval_error =~ /^!/ ) {
  			    if ( $eval_error =~ /^!FINISH\b/ ) {
  				$goon = 0;
  			    }
  			}
  			elsif ( $eval_error ne '' ) {
  			    warn ($eval_error);
  			    $error++;
  			}
  		    }
  		    else {
  			print STDERR ("Invalid REF type \"", ref($linkage{$opt}),
  				      "\" in linkage\n");
  			die("Getopt::Long -- internal error!\n");
  		    }
  		}
  		# No entry in linkage means entry in userlinkage.
  		elsif ( $ctl->[CTL_DEST] == CTL_DEST_ARRAY ) {
  		    if ( defined $userlinkage->{$opt} ) {
  			print STDERR ("=> push(\@{\$L{$opt}}, \"$arg\")\n")
  			    if $debug;
  			push (@{$userlinkage->{$opt}}, $arg);
  		    }
  		    else {
  			print STDERR ("=>\$L{$opt} = [\"$arg\"]\n")
  			    if $debug;
  			$userlinkage->{$opt} = [$arg];
  		    }
  		}
  		elsif ( $ctl->[CTL_DEST] == CTL_DEST_HASH ) {
  		    if ( defined $userlinkage->{$opt} ) {
  			print STDERR ("=> \$L{$opt}->{$key} = \"$arg\"\n")
  			    if $debug;
  			$userlinkage->{$opt}->{$key} = $arg;
  		    }
  		    else {
  			print STDERR ("=>\$L{$opt} = {$key => \"$arg\"}\n")
  			    if $debug;
  			$userlinkage->{$opt} = {$key => $arg};
  		    }
  		}
  		else {
  		    if ( $ctl->[CTL_TYPE] eq '+' ) {
  			print STDERR ("=> \$L{$opt} += \"$arg\"\n")
  			  if $debug;
  			if ( defined $userlinkage->{$opt} ) {
  			    $userlinkage->{$opt} += $arg;
  			}
  			else {
  			    $userlinkage->{$opt} = $arg;
  			}
  		    }
  		    else {
  			print STDERR ("=>\$L{$opt} = \"$arg\"\n") if $debug;
  			$userlinkage->{$opt} = $arg;
  		    }
  		}
  
  		$argcnt++;
  		last if $argcnt >= $ctl->[CTL_AMAX] && $ctl->[CTL_AMAX] != -1;
  		undef($arg);
  
  		# Need more args?
  		if ( $argcnt < $ctl->[CTL_AMIN] ) {
  		    if ( @$argv ) {
  			if ( ValidValue($ctl, $argv->[0], 1, $argend, $prefix) ) {
  			    $arg = shift(@$argv);
  			    if ( $ctl->[CTL_TYPE] =~ /^[iIo]$/ ) {
  				$arg =~ tr/_//d;
  				$arg = $ctl->[CTL_TYPE] eq 'o' && $arg =~ /^0/
  				  ? oct($arg)
  				  : 0+$arg
  			    }
  			    ($key,$arg) = $arg =~ /^([^=]+)=(.*)/
  			      if $ctl->[CTL_DEST] == CTL_DEST_HASH;
  			    next;
  			}
  			warn("Value \"$$argv[0]\" invalid for option $opt\n");
  			$error++;
  		    }
  		    else {
  			warn("Insufficient arguments for option $opt\n");
  			$error++;
  		    }
  		}
  
  		# Any more args?
  		if ( @$argv && ValidValue($ctl, $argv->[0], 0, $argend, $prefix) ) {
  		    $arg = shift(@$argv);
  		    if ( $ctl->[CTL_TYPE] =~ /^[iIo]$/ ) {
  			$arg =~ tr/_//d;
  			$arg = $ctl->[CTL_TYPE] eq 'o' && $arg =~ /^0/
  			  ? oct($arg)
  			  : 0+$arg
  		    }
  		    ($key,$arg) = $arg =~ /^([^=]+)=(.*)/
  		      if $ctl->[CTL_DEST] == CTL_DEST_HASH;
  		    next;
  		}
  	    }
  	}
  
  	# Not an option. Save it if we $PERMUTE and don't have a <>.
  	elsif ( $order == $PERMUTE ) {
  	    # Try non-options call-back.
  	    my $cb;
  	    if ( defined ($cb = $linkage{'<>'}) ) {
  		print STDERR ("=> &L{$tryopt}(\"$tryopt\")\n")
  		  if $debug;
  		my $eval_error = do {
  		    local $@;
  		    local $SIG{__DIE__}  = 'DEFAULT';
  		    eval {
  			# The arg to <> cannot be the CallBack object
  			# since it may be passed to other modules that
  			# get confused (e.g., Archive::Tar). Well,
  			# it's not relevant for this callback anyway.
  			&$cb($tryopt);
  		    };
  		    $@;
  		};
  		print STDERR ("=> die($eval_error)\n")
  		  if $debug && $eval_error ne '';
  		if ( $eval_error =~ /^!/ ) {
  		    if ( $eval_error =~ /^!FINISH\b/ ) {
  			$goon = 0;
  		    }
  		}
  		elsif ( $eval_error ne '' ) {
  		    warn ($eval_error);
  		    $error++;
  		}
  	    }
  	    else {
  		print STDERR ("=> saving \"$tryopt\" ",
  			      "(not an option, may permute)\n") if $debug;
  		push (@ret, $tryopt);
  	    }
  	    next;
  	}
  
  	# ...otherwise, terminate.
  	else {
  	    # Push this one back and exit.
  	    unshift (@$argv, $tryopt);
  	    return ($error == 0);
  	}
  
      }
  
      # Finish.
      if ( @ret && $order == $PERMUTE ) {
  	#  Push back accumulated arguments
  	print STDERR ("=> restoring \"", join('" "', @ret), "\"\n")
  	    if $debug;
  	unshift (@$argv, @ret);
      }
  
      return ($error == 0);
  }
  
  # A readable representation of what's in an optbl.
  sub OptCtl ($) {
      my ($v) = @_;
      my @v = map { defined($_) ? ($_) : ("<undef>") } @$v;
      "[".
        join(",",
  	   "\"$v[CTL_TYPE]\"",
  	   "\"$v[CTL_CNAME]\"",
  	   "\"$v[CTL_DEFAULT]\"",
  	   ("\$","\@","\%","\&")[$v[CTL_DEST] || 0],
  	   $v[CTL_AMIN] || '',
  	   $v[CTL_AMAX] || '',
  #	   $v[CTL_RANGE] || '',
  #	   $v[CTL_REPEAT] || '',
  	  ). "]";
  }
  
  # Parse an option specification and fill the tables.
  sub ParseOptionSpec ($$) {
      my ($opt, $opctl) = @_;
  
      # Match option spec.
      if ( $opt !~ m;^
  		   (
  		     # Option name
  		     (?: \w+[-\w]* )
  		     # Alias names, or "?"
  		     (?: \| (?: \? | \w[-\w]* ) )*
  		     # Aliases
  		     (?: \| (?: [^-|!+=:][^|!+=:]* )? )*
  		   )?
  		   (
  		     # Either modifiers ...
  		     [!+]
  		     |
  		     # ... or a value/dest/repeat specification
  		     [=:] [ionfs] [@%]? (?: \{\d*,?\d*\} )?
  		     |
  		     # ... or an optional-with-default spec
  		     : (?: -?\d+ | \+ ) [@%]?
  		   )?
  		   $;x ) {
  	return (undef, "Error in option spec: \"$opt\"\n");
      }
  
      my ($names, $spec) = ($1, $2);
      $spec = '' unless defined $spec;
  
      # $orig keeps track of the primary name the user specified.
      # This name will be used for the internal or external linkage.
      # In other words, if the user specifies "FoO|BaR", it will
      # match any case combinations of 'foo' and 'bar', but if a global
      # variable needs to be set, it will be $opt_FoO in the exact case
      # as specified.
      my $orig;
  
      my @names;
      if ( defined $names ) {
  	@names =  split (/\|/, $names);
  	$orig = $names[0];
      }
      else {
  	@names = ('');
  	$orig = '';
      }
  
      # Construct the opctl entries.
      my $entry;
      if ( $spec eq '' || $spec eq '+' || $spec eq '!' ) {
  	# Fields are hard-wired here.
  	$entry = [$spec,$orig,undef,CTL_DEST_SCALAR,0,0];
      }
      elsif ( $spec =~ /^:(-?\d+|\+)([@%])?$/ ) {
  	my $def = $1;
  	my $dest = $2;
  	my $type = $def eq '+' ? 'I' : 'i';
  	$dest ||= '$';
  	$dest = $dest eq '@' ? CTL_DEST_ARRAY
  	  : $dest eq '%' ? CTL_DEST_HASH : CTL_DEST_SCALAR;
  	# Fields are hard-wired here.
  	$entry = [$type,$orig,$def eq '+' ? undef : $def,
  		  $dest,0,1];
      }
      else {
  	my ($mand, $type, $dest) =
  	  $spec =~ /^([=:])([ionfs])([@%])?(\{(\d+)?(,)?(\d+)?\})?$/;
  	return (undef, "Cannot repeat while bundling: \"$opt\"\n")
  	  if $bundling && defined($4);
  	my ($mi, $cm, $ma) = ($5, $6, $7);
  	return (undef, "{0} is useless in option spec: \"$opt\"\n")
  	  if defined($mi) && !$mi && !defined($ma) && !defined($cm);
  
  	$type = 'i' if $type eq 'n';
  	$dest ||= '$';
  	$dest = $dest eq '@' ? CTL_DEST_ARRAY
  	  : $dest eq '%' ? CTL_DEST_HASH : CTL_DEST_SCALAR;
  	# Default minargs to 1/0 depending on mand status.
  	$mi = $mand eq '=' ? 1 : 0 unless defined $mi;
  	# Adjust mand status according to minargs.
  	$mand = $mi ? '=' : ':';
  	# Adjust maxargs.
  	$ma = $mi ? $mi : 1 unless defined $ma || defined $cm;
  	return (undef, "Max must be greater than zero in option spec: \"$opt\"\n")
  	  if defined($ma) && !$ma;
  	return (undef, "Max less than min in option spec: \"$opt\"\n")
  	  if defined($ma) && $ma < $mi;
  
  	# Fields are hard-wired here.
  	$entry = [$type,$orig,undef,$dest,$mi,$ma||-1];
      }
  
      # Process all names. First is canonical, the rest are aliases.
      my $dups = '';
      foreach ( @names ) {
  
  	$_ = lc ($_)
  	  if $ignorecase > (($bundling && length($_) == 1) ? 1 : 0);
  
  	if ( exists $opctl->{$_} ) {
  	    $dups .= "Duplicate specification \"$opt\" for option \"$_\"\n";
  	}
  
  	if ( $spec eq '!' ) {
  	    $opctl->{"no$_"} = $entry;
  	    $opctl->{"no-$_"} = $entry;
  	    $opctl->{$_} = [@$entry];
  	    $opctl->{$_}->[CTL_TYPE] = '';
  	}
  	else {
  	    $opctl->{$_} = $entry;
  	}
      }
  
      if ( $dups && $^W ) {
  	foreach ( split(/\n+/, $dups) ) {
  	    warn($_."\n");
  	}
      }
      ($names[0], $orig);
  }
  
  # Option lookup.
  sub FindOption ($$$$$) {
  
      # returns (1, $opt, $ctl, $arg, $key) if okay,
      # returns (1, undef) if option in error,
      # returns (0) otherwise.
  
      my ($argv, $prefix, $argend, $opt, $opctl) = @_;
  
      print STDERR ("=> find \"$opt\"\n") if $debug;
  
      return (0) unless defined($opt);
      return (0) unless $opt =~ /^($prefix)(.*)$/s;
      return (0) if $opt eq "-" && !defined $opctl->{''};
  
      $opt = substr( $opt, length($1) ); # retain taintedness
      my $starter = $1;
  
      print STDERR ("=> split \"$starter\"+\"$opt\"\n") if $debug;
  
      my $optarg;			# value supplied with --opt=value
      my $rest;			# remainder from unbundling
  
      # If it is a long option, it may include the value.
      # With getopt_compat, only if not bundling.
      if ( ($starter=~/^$longprefix$/
  	  || ($getopt_compat && ($bundling == 0 || $bundling == 2)))
  	 && (my $oppos = index($opt, '=', 1)) > 0) {
  	my $optorg = $opt;
  	$opt = substr($optorg, 0, $oppos);
  	$optarg = substr($optorg, $oppos + 1); # retain tainedness
  	print STDERR ("=> option \"", $opt,
  		      "\", optarg = \"$optarg\"\n") if $debug;
      }
  
      #### Look it up ###
  
      my $tryopt = $opt;		# option to try
  
      if ( ( $bundling || $bundling_values ) && $starter eq '-' ) {
  
  	# To try overrides, obey case ignore.
  	$tryopt = $ignorecase ? lc($opt) : $opt;
  
  	# If bundling == 2, long options can override bundles.
  	if ( $bundling == 2 && length($tryopt) > 1
  	     && defined ($opctl->{$tryopt}) ) {
  	    print STDERR ("=> $starter$tryopt overrides unbundling\n")
  	      if $debug;
  	}
  
  	# If bundling_values, option may be followed by the value.
  	elsif ( $bundling_values ) {
  	    $tryopt = $opt;
  	    # Unbundle single letter option.
  	    $rest = length ($tryopt) > 0 ? substr ($tryopt, 1) : '';
  	    $tryopt = substr ($tryopt, 0, 1);
  	    $tryopt = lc ($tryopt) if $ignorecase > 1;
  	    print STDERR ("=> $starter$tryopt unbundled from ",
  			  "$starter$tryopt$rest\n") if $debug;
  	    # Whatever remains may not be considered an option.
  	    $optarg = $rest eq '' ? undef : $rest;
  	    $rest = undef;
  	}
  
  	# Split off a single letter and leave the rest for
  	# further processing.
  	else {
  	    $tryopt = $opt;
  	    # Unbundle single letter option.
  	    $rest = length ($tryopt) > 0 ? substr ($tryopt, 1) : '';
  	    $tryopt = substr ($tryopt, 0, 1);
  	    $tryopt = lc ($tryopt) if $ignorecase > 1;
  	    print STDERR ("=> $starter$tryopt unbundled from ",
  			  "$starter$tryopt$rest\n") if $debug;
  	    $rest = undef unless $rest ne '';
  	}
      }
  
      # Try auto-abbreviation.
      elsif ( $autoabbrev && $opt ne "" ) {
  	# Sort the possible long option names.
  	my @names = sort(keys (%$opctl));
  	# Downcase if allowed.
  	$opt = lc ($opt) if $ignorecase;
  	$tryopt = $opt;
  	# Turn option name into pattern.
  	my $pat = quotemeta ($opt);
  	# Look up in option names.
  	my @hits = grep (/^$pat/, @names);
  	print STDERR ("=> ", scalar(@hits), " hits (@hits) with \"$pat\" ",
  		      "out of ", scalar(@names), "\n") if $debug;
  
  	# Check for ambiguous results.
  	unless ( (@hits <= 1) || (grep ($_ eq $opt, @hits) == 1) ) {
  	    # See if all matches are for the same option.
  	    my %hit;
  	    foreach ( @hits ) {
  		my $hit = $opctl->{$_}->[CTL_CNAME]
  		  if defined $opctl->{$_}->[CTL_CNAME];
  		$hit = "no" . $hit if $opctl->{$_}->[CTL_TYPE] eq '!';
  		$hit{$hit} = 1;
  	    }
  	    # Remove auto-supplied options (version, help).
  	    if ( keys(%hit) == 2 ) {
  		if ( $auto_version && exists($hit{version}) ) {
  		    delete $hit{version};
  		}
  		elsif ( $auto_help && exists($hit{help}) ) {
  		    delete $hit{help};
  		}
  	    }
  	    # Now see if it really is ambiguous.
  	    unless ( keys(%hit) == 1 ) {
  		return (0) if $passthrough;
  		warn ("Option ", $opt, " is ambiguous (",
  		      join(", ", @hits), ")\n");
  		$error++;
  		return (1, undef);
  	    }
  	    @hits = keys(%hit);
  	}
  
  	# Complete the option name, if appropriate.
  	if ( @hits == 1 && $hits[0] ne $opt ) {
  	    $tryopt = $hits[0];
  	    $tryopt = lc ($tryopt) if $ignorecase;
  	    print STDERR ("=> option \"$opt\" -> \"$tryopt\"\n")
  		if $debug;
  	}
      }
  
      # Map to all lowercase if ignoring case.
      elsif ( $ignorecase ) {
  	$tryopt = lc ($opt);
      }
  
      # Check validity by fetching the info.
      my $ctl = $opctl->{$tryopt};
      unless  ( defined $ctl ) {
  	return (0) if $passthrough;
  	# Pretend one char when bundling.
  	if ( $bundling == 1 && length($starter) == 1 ) {
  	    $opt = substr($opt,0,1);
              unshift (@$argv, $starter.$rest) if defined $rest;
  	}
  	if ( $opt eq "" ) {
  	    warn ("Missing option after ", $starter, "\n");
  	}
  	else {
  	    warn ("Unknown option: ", $opt, "\n");
  	}
  	$error++;
  	return (1, undef);
      }
      # Apparently valid.
      $opt = $tryopt;
      print STDERR ("=> found ", OptCtl($ctl),
  		  " for \"", $opt, "\"\n") if $debug;
  
      #### Determine argument status ####
  
      # If it is an option w/o argument, we're almost finished with it.
      my $type = $ctl->[CTL_TYPE];
      my $arg;
  
      if ( $type eq '' || $type eq '!' || $type eq '+' ) {
  	if ( defined $optarg ) {
  	    return (0) if $passthrough;
  	    warn ("Option ", $opt, " does not take an argument\n");
  	    $error++;
  	    undef $opt;
  	    undef $optarg if $bundling_values;
  	}
  	elsif ( $type eq '' || $type eq '+' ) {
  	    # Supply explicit value.
  	    $arg = 1;
  	}
  	else {
  	    $opt =~ s/^no-?//i;	# strip NO prefix
  	    $arg = 0;		# supply explicit value
  	}
  	unshift (@$argv, $starter.$rest) if defined $rest;
  	return (1, $opt, $ctl, $arg);
      }
  
      # Get mandatory status and type info.
      my $mand = $ctl->[CTL_AMIN];
  
      # Check if there is an option argument available.
      if ( $gnu_compat ) {
  	my $optargtype = 0; # 0 = none, 1 = empty, 2 = nonempty
  	$optargtype = ( !defined($optarg) ? 0 : ( (length($optarg) == 0) ? 1 : 2 ) );
      return (1, $opt, $ctl, defined($ctl->[CTL_DEFAULT]) ? $ctl->[CTL_DEFAULT] : undef)
  	  if (($optargtype == 0) && !$mand);
  	return (1, $opt, $ctl, $type eq 's' ? '' : 0)
  	  if $optargtype == 1;  # --foo=  -> return nothing
      }
  
      # Check if there is an option argument available.
      if ( defined $optarg
  	 ? ($optarg eq '')
  	 : !(defined $rest || @$argv > 0) ) {
  	# Complain if this option needs an argument.
  #	if ( $mand && !($type eq 's' ? defined($optarg) : 0) ) {
  	if ( $mand ) {
  	    return (0) if $passthrough;
  	    warn ("Option ", $opt, " requires an argument\n");
  	    $error++;
  	    return (1, undef);
  	}
  	if ( $type eq 'I' ) {
  	    # Fake incremental type.
  	    my @c = @$ctl;
  	    $c[CTL_TYPE] = '+';
  	    return (1, $opt, \@c, 1);
  	}
  	return (1, $opt, $ctl,
  		defined($ctl->[CTL_DEFAULT]) ? $ctl->[CTL_DEFAULT] :
  		$type eq 's' ? '' : 0);
      }
  
      # Get (possibly optional) argument.
      $arg = (defined $rest ? $rest
  	    : (defined $optarg ? $optarg : shift (@$argv)));
  
      # Get key if this is a "name=value" pair for a hash option.
      my $key;
      if ($ctl->[CTL_DEST] == CTL_DEST_HASH && defined $arg) {
  	($key, $arg) = ($arg =~ /^([^=]*)=(.*)$/s) ? ($1, $2)
  	  : ($arg, defined($ctl->[CTL_DEFAULT]) ? $ctl->[CTL_DEFAULT] :
  	     ($mand ? undef : ($type eq 's' ? "" : 1)));
  	if (! defined $arg) {
  	    warn ("Option $opt, key \"$key\", requires a value\n");
  	    $error++;
  	    # Push back.
  	    unshift (@$argv, $starter.$rest) if defined $rest;
  	    return (1, undef);
  	}
      }
  
      #### Check if the argument is valid for this option ####
  
      my $key_valid = $ctl->[CTL_DEST] == CTL_DEST_HASH ? "[^=]+=" : "";
  
      if ( $type eq 's' ) {	# string
  	# A mandatory string takes anything.
  	return (1, $opt, $ctl, $arg, $key) if $mand;
  
  	# Same for optional string as a hash value
  	return (1, $opt, $ctl, $arg, $key)
  	  if $ctl->[CTL_DEST] == CTL_DEST_HASH;
  
  	# An optional string takes almost anything.
  	return (1, $opt, $ctl, $arg, $key)
  	  if defined $optarg || defined $rest;
  	return (1, $opt, $ctl, $arg, $key) if $arg eq "-"; # ??
  
  	# Check for option or option list terminator.
  	if ($arg eq $argend ||
  	    $arg =~ /^$prefix.+/) {
  	    # Push back.
  	    unshift (@$argv, $arg);
  	    # Supply empty value.
  	    $arg = '';
  	}
      }
  
      elsif ( $type eq 'i'	# numeric/integer
              || $type eq 'I'	# numeric/integer w/ incr default
  	    || $type eq 'o' ) { # dec/oct/hex/bin value
  
  	my $o_valid = $type eq 'o' ? PAT_XINT : PAT_INT;
  
  	if ( $bundling && defined $rest
  	     && $rest =~ /^($key_valid)($o_valid)(.*)$/si ) {
  	    ($key, $arg, $rest) = ($1, $2, $+);
  	    chop($key) if $key;
  	    $arg = ($type eq 'o' && $arg =~ /^0/) ? oct($arg) : 0+$arg;
  	    unshift (@$argv, $starter.$rest) if defined $rest && $rest ne '';
  	}
  	elsif ( $arg =~ /^$o_valid$/si ) {
  	    $arg =~ tr/_//d;
  	    $arg = ($type eq 'o' && $arg =~ /^0/) ? oct($arg) : 0+$arg;
  	}
  	else {
  	    if ( defined $optarg || $mand ) {
  		if ( $passthrough ) {
  		    unshift (@$argv, defined $rest ? $starter.$rest : $arg)
  		      unless defined $optarg;
  		    return (0);
  		}
  		warn ("Value \"", $arg, "\" invalid for option ",
  		      $opt, " (",
  		      $type eq 'o' ? "extended " : '',
  		      "number expected)\n");
  		$error++;
  		# Push back.
  		unshift (@$argv, $starter.$rest) if defined $rest;
  		return (1, undef);
  	    }
  	    else {
  		# Push back.
  		unshift (@$argv, defined $rest ? $starter.$rest : $arg);
  		if ( $type eq 'I' ) {
  		    # Fake incremental type.
  		    my @c = @$ctl;
  		    $c[CTL_TYPE] = '+';
  		    return (1, $opt, \@c, 1);
  		}
  		# Supply default value.
  		$arg = defined($ctl->[CTL_DEFAULT]) ? $ctl->[CTL_DEFAULT] : 0;
  	    }
  	}
      }
  
      elsif ( $type eq 'f' ) { # real number, int is also ok
  	my $o_valid = PAT_FLOAT;
  	if ( $bundling && defined $rest &&
  	     $rest =~ /^($key_valid)($o_valid)(.*)$/s ) {
  	    $arg =~ tr/_//d;
  	    ($key, $arg, $rest) = ($1, $2, $+);
  	    chop($key) if $key;
  	    unshift (@$argv, $starter.$rest) if defined $rest && $rest ne '';
  	}
  	elsif ( $arg =~ /^$o_valid$/ ) {
  	    $arg =~ tr/_//d;
  	}
  	else {
  	    if ( defined $optarg || $mand ) {
  		if ( $passthrough ) {
  		    unshift (@$argv, defined $rest ? $starter.$rest : $arg)
  		      unless defined $optarg;
  		    return (0);
  		}
  		warn ("Value \"", $arg, "\" invalid for option ",
  		      $opt, " (real number expected)\n");
  		$error++;
  		# Push back.
  		unshift (@$argv, $starter.$rest) if defined $rest;
  		return (1, undef);
  	    }
  	    else {
  		# Push back.
  		unshift (@$argv, defined $rest ? $starter.$rest : $arg);
  		# Supply default value.
  		$arg = 0.0;
  	    }
  	}
      }
      else {
  	die("Getopt::Long internal error (Can't happen)\n");
      }
      return (1, $opt, $ctl, $arg, $key);
  }
  
  sub ValidValue ($$$$$) {
      my ($ctl, $arg, $mand, $argend, $prefix) = @_;
  
      if ( $ctl->[CTL_DEST] == CTL_DEST_HASH ) {
  	return 0 unless $arg =~ /[^=]+=(.*)/;
  	$arg = $1;
      }
  
      my $type = $ctl->[CTL_TYPE];
  
      if ( $type eq 's' ) {	# string
  	# A mandatory string takes anything.
  	return (1) if $mand;
  
  	return (1) if $arg eq "-";
  
  	# Check for option or option list terminator.
  	return 0 if $arg eq $argend || $arg =~ /^$prefix.+/;
  	return 1;
      }
  
      elsif ( $type eq 'i'	# numeric/integer
              || $type eq 'I'	# numeric/integer w/ incr default
  	    || $type eq 'o' ) { # dec/oct/hex/bin value
  
  	my $o_valid = $type eq 'o' ? PAT_XINT : PAT_INT;
  	return $arg =~ /^$o_valid$/si;
      }
  
      elsif ( $type eq 'f' ) { # real number, int is also ok
  	my $o_valid = PAT_FLOAT;
  	return $arg =~ /^$o_valid$/;
      }
      die("ValidValue: Cannot happen\n");
  }
  
  # Getopt::Long Configuration.
  sub Configure (@) {
      my (@options) = @_;
  
      my $prevconfig =
        [ $error, $debug, $major_version, $minor_version, $caller,
  	$autoabbrev, $getopt_compat, $ignorecase, $bundling, $order,
  	$gnu_compat, $passthrough, $genprefix, $auto_version, $auto_help,
  	$longprefix, $bundling_values ];
  
      if ( ref($options[0]) eq 'ARRAY' ) {
  	( $error, $debug, $major_version, $minor_version, $caller,
  	  $autoabbrev, $getopt_compat, $ignorecase, $bundling, $order,
  	  $gnu_compat, $passthrough, $genprefix, $auto_version, $auto_help,
  	  $longprefix, $bundling_values ) = @{shift(@options)};
      }
  
      my $opt;
      foreach $opt ( @options ) {
  	my $try = lc ($opt);
  	my $action = 1;
  	if ( $try =~ /^no_?(.*)$/s ) {
  	    $action = 0;
  	    $try = $+;
  	}
  	if ( ($try eq 'default' or $try eq 'defaults') && $action ) {
  	    ConfigDefaults ();
  	}
  	elsif ( ($try eq 'posix_default' or $try eq 'posix_defaults') ) {
  	    local $ENV{POSIXLY_CORRECT};
  	    $ENV{POSIXLY_CORRECT} = 1 if $action;
  	    ConfigDefaults ();
  	}
  	elsif ( $try eq 'auto_abbrev' or $try eq 'autoabbrev' ) {
  	    $autoabbrev = $action;
  	}
  	elsif ( $try eq 'getopt_compat' ) {
  	    $getopt_compat = $action;
              $genprefix = $action ? "(--|-|\\+)" : "(--|-)";
  	}
  	elsif ( $try eq 'gnu_getopt' ) {
  	    if ( $action ) {
  		$gnu_compat = 1;
  		$bundling = 1;
  		$getopt_compat = 0;
                  $genprefix = "(--|-)";
  		$order = $PERMUTE;
  		$bundling_values = 0;
  	    }
  	}
  	elsif ( $try eq 'gnu_compat' ) {
  	    $gnu_compat = $action;
  	    $bundling = 0;
  	    $bundling_values = 1;
  	}
  	elsif ( $try =~ /^(auto_?)?version$/ ) {
  	    $auto_version = $action;
  	}
  	elsif ( $try =~ /^(auto_?)?help$/ ) {
  	    $auto_help = $action;
  	}
  	elsif ( $try eq 'ignorecase' or $try eq 'ignore_case' ) {
  	    $ignorecase = $action;
  	}
  	elsif ( $try eq 'ignorecase_always' or $try eq 'ignore_case_always' ) {
  	    $ignorecase = $action ? 2 : 0;
  	}
  	elsif ( $try eq 'bundling' ) {
  	    $bundling = $action;
  	    $bundling_values = 0 if $action;
  	}
  	elsif ( $try eq 'bundling_override' ) {
  	    $bundling = $action ? 2 : 0;
  	    $bundling_values = 0 if $action;
  	}
  	elsif ( $try eq 'bundling_values' ) {
  	    $bundling_values = $action;
  	    $bundling = 0 if $action;
  	}
  	elsif ( $try eq 'require_order' ) {
  	    $order = $action ? $REQUIRE_ORDER : $PERMUTE;
  	}
  	elsif ( $try eq 'permute' ) {
  	    $order = $action ? $PERMUTE : $REQUIRE_ORDER;
  	}
  	elsif ( $try eq 'pass_through' or $try eq 'passthrough' ) {
  	    $passthrough = $action;
  	}
  	elsif ( $try =~ /^prefix=(.+)$/ && $action ) {
  	    $genprefix = $1;
  	    # Turn into regexp. Needs to be parenthesized!
  	    $genprefix = "(" . quotemeta($genprefix) . ")";
  	    eval { '' =~ /$genprefix/; };
  	    die("Getopt::Long: invalid pattern \"$genprefix\"\n") if $@;
  	}
  	elsif ( $try =~ /^prefix_pattern=(.+)$/ && $action ) {
  	    $genprefix = $1;
  	    # Parenthesize if needed.
  	    $genprefix = "(" . $genprefix . ")"
  	      unless $genprefix =~ /^\(.*\)$/;
  	    eval { '' =~ m"$genprefix"; };
  	    die("Getopt::Long: invalid pattern \"$genprefix\"\n") if $@;
  	}
  	elsif ( $try =~ /^long_prefix_pattern=(.+)$/ && $action ) {
  	    $longprefix = $1;
  	    # Parenthesize if needed.
  	    $longprefix = "(" . $longprefix . ")"
  	      unless $longprefix =~ /^\(.*\)$/;
  	    eval { '' =~ m"$longprefix"; };
  	    die("Getopt::Long: invalid long prefix pattern \"$longprefix\"\n") if $@;
  	}
  	elsif ( $try eq 'debug' ) {
  	    $debug = $action;
  	}
  	else {
  	    die("Getopt::Long: unknown or erroneous config parameter \"$opt\"\n")
  	}
      }
      $prevconfig;
  }
  
  # Deprecated name.
  sub config (@) {
      Configure (@_);
  }
  
  # Issue a standard message for --version.
  #
  # The arguments are mostly the same as for Pod::Usage::pod2usage:
  #
  #  - a number (exit value)
  #  - a string (lead in message)
  #  - a hash with options. See Pod::Usage for details.
  #
  sub VersionMessage(@) {
      # Massage args.
      my $pa = setup_pa_args("version", @_);
  
      my $v = $main::VERSION;
      my $fh = $pa->{-output} ||
        ( ($pa->{-exitval} eq "NOEXIT" || $pa->{-exitval} < 2) ? \*STDOUT : \*STDERR );
  
      print $fh (defined($pa->{-message}) ? $pa->{-message} : (),
  	       $0, defined $v ? " version $v" : (),
  	       "\n",
  	       "(", __PACKAGE__, "::", "GetOptions",
  	       " version ",
  	       defined($Getopt::Long::VERSION_STRING)
  	         ? $Getopt::Long::VERSION_STRING : $VERSION, ";",
  	       " Perl version ",
  	       $] >= 5.006 ? sprintf("%vd", $^V) : $],
  	       ")\n");
      exit($pa->{-exitval}) unless $pa->{-exitval} eq "NOEXIT";
  }
  
  # Issue a standard message for --help.
  #
  # The arguments are the same as for Pod::Usage::pod2usage:
  #
  #  - a number (exit value)
  #  - a string (lead in message)
  #  - a hash with options. See Pod::Usage for details.
  #
  sub HelpMessage(@) {
      eval {
  	require Pod::Usage;
  	import Pod::Usage;
  	1;
      } || die("Cannot provide help: cannot load Pod::Usage\n");
  
      # Note that pod2usage will issue a warning if -exitval => NOEXIT.
      pod2usage(setup_pa_args("help", @_));
  
  }
  
  # Helper routine to set up a normalized hash ref to be used as
  # argument to pod2usage.
  sub setup_pa_args($@) {
      my $tag = shift;		# who's calling
  
      # If called by direct binding to an option, it will get the option
      # name and value as arguments. Remove these, if so.
      @_ = () if @_ == 2 && $_[0] eq $tag;
  
      my $pa;
      if ( @_ > 1 ) {
  	$pa = { @_ };
      }
      else {
  	$pa = shift || {};
      }
  
      # At this point, $pa can be a number (exit value), string
      # (message) or hash with options.
  
      if ( UNIVERSAL::isa($pa, 'HASH') ) {
  	# Get rid of -msg vs. -message ambiguity.
  	$pa->{-message} = $pa->{-msg};
  	delete($pa->{-msg});
      }
      elsif ( $pa =~ /^-?\d+$/ ) {
  	$pa = { -exitval => $pa };
      }
      else {
  	$pa = { -message => $pa };
      }
  
      # These are _our_ defaults.
      $pa->{-verbose} = 0 unless exists($pa->{-verbose});
      $pa->{-exitval} = 0 unless exists($pa->{-exitval});
      $pa;
  }
  
  # Sneak way to know what version the user requested.
  sub VERSION {
      $requested_version = $_[1];
      shift->SUPER::VERSION(@_);
  }
  
  package Getopt::Long::CallBack;
  
  sub new {
      my ($pkg, %atts) = @_;
      bless { %atts }, $pkg;
  }
  
  sub name {
      my $self = shift;
      ''.$self->{name};
  }
  
  use overload
    # Treat this object as an ordinary string for legacy API.
    '""'	   => \&name,
    fallback => 1;
  
  1;
  
  ################ Documentation ################
  
  =head1 NAME
  
  Getopt::Long - Extended processing of command line options
  
  =head1 SYNOPSIS
  
    use Getopt::Long;
    my $data   = "file.dat";
    my $length = 24;
    my $verbose;
    GetOptions ("length=i" => \$length,    # numeric
                "file=s"   => \$data,      # string
                "verbose"  => \$verbose)   # flag
    or die("Error in command line arguments\n");
  
  =head1 DESCRIPTION
  
  The Getopt::Long module implements an extended getopt function called
  GetOptions(). It parses the command line from C<@ARGV>, recognizing
  and removing specified options and their possible values.
  
  This function adheres to the POSIX syntax for command
  line options, with GNU extensions. In general, this means that options
  have long names instead of single letters, and are introduced with a
  double dash "--". Support for bundling of command line options, as was
  the case with the more traditional single-letter approach, is provided
  but not enabled by default.
  
  =head1 Command Line Options, an Introduction
  
  Command line operated programs traditionally take their arguments from
  the command line, for example filenames or other information that the
  program needs to know. Besides arguments, these programs often take
  command line I<options> as well. Options are not necessary for the
  program to work, hence the name 'option', but are used to modify its
  default behaviour. For example, a program could do its job quietly,
  but with a suitable option it could provide verbose information about
  what it did.
  
  Command line options come in several flavours. Historically, they are
  preceded by a single dash C<->, and consist of a single letter.
  
      -l -a -c
  
  Usually, these single-character options can be bundled:
  
      -lac
  
  Options can have values, the value is placed after the option
  character. Sometimes with whitespace in between, sometimes not:
  
      -s 24 -s24
  
  Due to the very cryptic nature of these options, another style was
  developed that used long names. So instead of a cryptic C<-l> one
  could use the more descriptive C<--long>. To distinguish between a
  bundle of single-character options and a long one, two dashes are used
  to precede the option name. Early implementations of long options used
  a plus C<+> instead. Also, option values could be specified either
  like
  
      --size=24
  
  or
  
      --size 24
  
  The C<+> form is now obsolete and strongly deprecated.
  
  =head1 Getting Started with Getopt::Long
  
  Getopt::Long is the Perl5 successor of C<newgetopt.pl>. This was the
  first Perl module that provided support for handling the new style of
  command line options, in particular long option names, hence the Perl5
  name Getopt::Long. This module also supports single-character options
  and bundling.
  
  To use Getopt::Long from a Perl program, you must include the
  following line in your Perl program:
  
      use Getopt::Long;
  
  This will load the core of the Getopt::Long module and prepare your
  program for using it. Most of the actual Getopt::Long code is not
  loaded until you really call one of its functions.
  
  In the default configuration, options names may be abbreviated to
  uniqueness, case does not matter, and a single dash is sufficient,
  even for long option names. Also, options may be placed between
  non-option arguments. See L<Configuring Getopt::Long> for more
  details on how to configure Getopt::Long.
  
  =head2 Simple options
  
  The most simple options are the ones that take no values. Their mere
  presence on the command line enables the option. Popular examples are:
  
      --all --verbose --quiet --debug
  
  Handling simple options is straightforward:
  
      my $verbose = '';	# option variable with default value (false)
      my $all = '';	# option variable with default value (false)
      GetOptions ('verbose' => \$verbose, 'all' => \$all);
  
  The call to GetOptions() parses the command line arguments that are
  present in C<@ARGV> and sets the option variable to the value C<1> if
  the option did occur on the command line. Otherwise, the option
  variable is not touched. Setting the option value to true is often
  called I<enabling> the option.
  
  The option name as specified to the GetOptions() function is called
  the option I<specification>. Later we'll see that this specification
  can contain more than just the option name. The reference to the
  variable is called the option I<destination>.
  
  GetOptions() will return a true value if the command line could be
  processed successfully. Otherwise, it will write error messages using
  die() and warn(), and return a false result.
  
  =head2 A little bit less simple options
  
  Getopt::Long supports two useful variants of simple options:
  I<negatable> options and I<incremental> options.
  
  A negatable option is specified with an exclamation mark C<!> after the
  option name:
  
      my $verbose = '';	# option variable with default value (false)
      GetOptions ('verbose!' => \$verbose);
  
  Now, using C<--verbose> on the command line will enable C<$verbose>,
  as expected. But it is also allowed to use C<--noverbose>, which will
  disable C<$verbose> by setting its value to C<0>. Using a suitable
  default value, the program can find out whether C<$verbose> is false
  by default, or disabled by using C<--noverbose>.
  
  An incremental option is specified with a plus C<+> after the
  option name:
  
      my $verbose = '';	# option variable with default value (false)
      GetOptions ('verbose+' => \$verbose);
  
  Using C<--verbose> on the command line will increment the value of
  C<$verbose>. This way the program can keep track of how many times the
  option occurred on the command line. For example, each occurrence of
  C<--verbose> could increase the verbosity level of the program.
  
  =head2 Mixing command line option with other arguments
  
  Usually programs take command line options as well as other arguments,
  for example, file names. It is good practice to always specify the
  options first, and the other arguments last. Getopt::Long will,
  however, allow the options and arguments to be mixed and 'filter out'
  all the options before passing the rest of the arguments to the
  program. To stop Getopt::Long from processing further arguments,
  insert a double dash C<--> on the command line:
  
      --size 24 -- --all
  
  In this example, C<--all> will I<not> be treated as an option, but
  passed to the program unharmed, in C<@ARGV>.
  
  =head2 Options with values
  
  For options that take values it must be specified whether the option
  value is required or not, and what kind of value the option expects.
  
  Three kinds of values are supported: integer numbers, floating point
  numbers, and strings.
  
  If the option value is required, Getopt::Long will take the
  command line argument that follows the option and assign this to the
  option variable. If, however, the option value is specified as
  optional, this will only be done if that value does not look like a
  valid command line option itself.
  
      my $tag = '';	# option variable with default value
      GetOptions ('tag=s' => \$tag);
  
  In the option specification, the option name is followed by an equals
  sign C<=> and the letter C<s>. The equals sign indicates that this
  option requires a value. The letter C<s> indicates that this value is
  an arbitrary string. Other possible value types are C<i> for integer
  values, and C<f> for floating point values. Using a colon C<:> instead
  of the equals sign indicates that the option value is optional. In
  this case, if no suitable value is supplied, string valued options get
  an empty string C<''> assigned, while numeric options are set to C<0>.
  
  =head2 Options with multiple values
  
  Options sometimes take several values. For example, a program could
  use multiple directories to search for library files:
  
      --library lib/stdlib --library lib/extlib
  
  To accomplish this behaviour, simply specify an array reference as the
  destination for the option:
  
      GetOptions ("library=s" => \@libfiles);
  
  Alternatively, you can specify that the option can have multiple
  values by adding a "@", and pass a scalar reference as the
  destination:
  
      GetOptions ("library=s@" => \$libfiles);
  
  Used with the example above, C<@libfiles> (or C<@$libfiles>) would
  contain two strings upon completion: C<"lib/stdlib"> and
  C<"lib/extlib">, in that order. It is also possible to specify that
  only integer or floating point numbers are acceptable values.
  
  Often it is useful to allow comma-separated lists of values as well as
  multiple occurrences of the options. This is easy using Perl's split()
  and join() operators:
  
      GetOptions ("library=s" => \@libfiles);
      @libfiles = split(/,/,join(',',@libfiles));
  
  Of course, it is important to choose the right separator string for
  each purpose.
  
  Warning: What follows is an experimental feature.
  
  Options can take multiple values at once, for example
  
      --coordinates 52.2 16.4 --rgbcolor 255 255 149
  
  This can be accomplished by adding a repeat specifier to the option
  specification. Repeat specifiers are very similar to the C<{...}>
  repeat specifiers that can be used with regular expression patterns.
  For example, the above command line would be handled as follows:
  
      GetOptions('coordinates=f{2}' => \@coor, 'rgbcolor=i{3}' => \@color);
  
  The destination for the option must be an array or array reference.
  
  It is also possible to specify the minimal and maximal number of
  arguments an option takes. C<foo=s{2,4}> indicates an option that
  takes at least two and at most 4 arguments. C<foo=s{1,}> indicates one
  or more values; C<foo:s{,}> indicates zero or more option values.
  
  =head2 Options with hash values
  
  If the option destination is a reference to a hash, the option will
  take, as value, strings of the form I<key>C<=>I<value>. The value will
  be stored with the specified key in the hash.
  
      GetOptions ("define=s" => \%defines);
  
  Alternatively you can use:
  
      GetOptions ("define=s%" => \$defines);
  
  When used with command line options:
  
      --define os=linux --define vendor=redhat
  
  the hash C<%defines> (or C<%$defines>) will contain two keys, C<"os">
  with value C<"linux"> and C<"vendor"> with value C<"redhat">. It is
  also possible to specify that only integer or floating point numbers
  are acceptable values. The keys are always taken to be strings.
  
  =head2 User-defined subroutines to handle options
  
  Ultimate control over what should be done when (actually: each time)
  an option is encountered on the command line can be achieved by
  designating a reference to a subroutine (or an anonymous subroutine)
  as the option destination. When GetOptions() encounters the option, it
  will call the subroutine with two or three arguments. The first
  argument is the name of the option. (Actually, it is an object that
  stringifies to the name of the option.) For a scalar or array destination,
  the second argument is the value to be stored. For a hash destination,
  the second argument is the key to the hash, and the third argument
  the value to be stored. It is up to the subroutine to store the value,
  or do whatever it thinks is appropriate.
  
  A trivial application of this mechanism is to implement options that
  are related to each other. For example:
  
      my $verbose = '';	# option variable with default value (false)
      GetOptions ('verbose' => \$verbose,
  	        'quiet'   => sub { $verbose = 0 });
  
  Here C<--verbose> and C<--quiet> control the same variable
  C<$verbose>, but with opposite values.
  
  If the subroutine needs to signal an error, it should call die() with
  the desired error message as its argument. GetOptions() will catch the
  die(), issue the error message, and record that an error result must
  be returned upon completion.
  
  If the text of the error message starts with an exclamation mark C<!>
  it is interpreted specially by GetOptions(). There is currently one
  special command implemented: C<die("!FINISH")> will cause GetOptions()
  to stop processing options, as if it encountered a double dash C<-->.
  
  In version 2.37 the first argument to the callback function was
  changed from string to object. This was done to make room for
  extensions and more detailed control. The object stringifies to the
  option name so this change should not introduce compatibility
  problems.
  
  Here is an example of how to access the option name and value from within
  a subroutine:
  
      GetOptions ('opt=i' => \&handler);
      sub handler {
          my ($opt_name, $opt_value) = @_;
          print("Option name is $opt_name and value is $opt_value\n");
      }
  
  =head2 Options with multiple names
  
  Often it is user friendly to supply alternate mnemonic names for
  options. For example C<--height> could be an alternate name for
  C<--length>. Alternate names can be included in the option
  specification, separated by vertical bar C<|> characters. To implement
  the above example:
  
      GetOptions ('length|height=f' => \$length);
  
  The first name is called the I<primary> name, the other names are
  called I<aliases>. When using a hash to store options, the key will
  always be the primary name.
  
  Multiple alternate names are possible.
  
  =head2 Case and abbreviations
  
  Without additional configuration, GetOptions() will ignore the case of
  option names, and allow the options to be abbreviated to uniqueness.
  
      GetOptions ('length|height=f' => \$length, "head" => \$head);
  
  This call will allow C<--l> and C<--L> for the length option, but
  requires a least C<--hea> and C<--hei> for the head and height options.
  
  =head2 Summary of Option Specifications
  
  Each option specifier consists of two parts: the name specification
  and the argument specification.
  
  The name specification contains the name of the option, optionally
  followed by a list of alternative names separated by vertical bar
  characters.
  
      length	      option name is "length"
      length|size|l     name is "length", aliases are "size" and "l"
  
  The argument specification is optional. If omitted, the option is
  considered boolean, a value of 1 will be assigned when the option is
  used on the command line.
  
  The argument specification can be
  
  =over 4
  
  =item !
  
  The option does not take an argument and may be negated by prefixing
  it with "no" or "no-". E.g. C<"foo!"> will allow C<--foo> (a value of
  1 will be assigned) as well as C<--nofoo> and C<--no-foo> (a value of
  0 will be assigned). If the option has aliases, this applies to the
  aliases as well.
  
  Using negation on a single letter option when bundling is in effect is
  pointless and will result in a warning.
  
  =item +
  
  The option does not take an argument and will be incremented by 1
  every time it appears on the command line. E.g. C<"more+">, when used
  with C<--more --more --more>, will increment the value three times,
  resulting in a value of 3 (provided it was 0 or undefined at first).
  
  The C<+> specifier is ignored if the option destination is not a scalar.
  
  =item = I<type> [ I<desttype> ] [ I<repeat> ]
  
  The option requires an argument of the given type. Supported types
  are:
  
  =over 4
  
  =item s
  
  String. An arbitrary sequence of characters. It is valid for the
  argument to start with C<-> or C<-->.
  
  =item i
  
  Integer. An optional leading plus or minus sign, followed by a
  sequence of digits.
  
  =item o
  
  Extended integer, Perl style. This can be either an optional leading
  plus or minus sign, followed by a sequence of digits, or an octal
  string (a zero, optionally followed by '0', '1', .. '7'), or a
  hexadecimal string (C<0x> followed by '0' .. '9', 'a' .. 'f', case
  insensitive), or a binary string (C<0b> followed by a series of '0'
  and '1').
  
  =item f
  
  Real number. For example C<3.14>, C<-6.23E24> and so on.
  
  =back
  
  The I<desttype> can be C<@> or C<%> to specify that the option is
  list or a hash valued. This is only needed when the destination for
  the option value is not otherwise specified. It should be omitted when
  not needed.
  
  The I<repeat> specifies the number of values this option takes per
  occurrence on the command line. It has the format C<{> [ I<min> ] [ C<,> [ I<max> ] ] C<}>.
  
  I<min> denotes the minimal number of arguments. It defaults to 1 for
  options with C<=> and to 0 for options with C<:>, see below. Note that
  I<min> overrules the C<=> / C<:> semantics.
  
  I<max> denotes the maximum number of arguments. It must be at least
  I<min>. If I<max> is omitted, I<but the comma is not>, there is no
  upper bound to the number of argument values taken.
  
  =item : I<type> [ I<desttype> ]
  
  Like C<=>, but designates the argument as optional.
  If omitted, an empty string will be assigned to string values options,
  and the value zero to numeric options.
  
  Note that if a string argument starts with C<-> or C<-->, it will be
  considered an option on itself.
  
  =item : I<number> [ I<desttype> ]
  
  Like C<:i>, but if the value is omitted, the I<number> will be assigned.
  
  =item : + [ I<desttype> ]
  
  Like C<:i>, but if the value is omitted, the current value for the
  option will be incremented.
  
  =back
  
  =head1 Advanced Possibilities
  
  =head2 Object oriented interface
  
  Getopt::Long can be used in an object oriented way as well:
  
      use Getopt::Long;
      $p = Getopt::Long::Parser->new;
      $p->configure(...configuration options...);
      if ($p->getoptions(...options descriptions...)) ...
      if ($p->getoptionsfromarray( \@array, ...options descriptions...)) ...
  
  Configuration options can be passed to the constructor:
  
      $p = new Getopt::Long::Parser
               config => [...configuration options...];
  
  =head2 Thread Safety
  
  Getopt::Long is thread safe when using ithreads as of Perl 5.8.  It is
  I<not> thread safe when using the older (experimental and now
  obsolete) threads implementation that was added to Perl 5.005.
  
  =head2 Documentation and help texts
  
  Getopt::Long encourages the use of Pod::Usage to produce help
  messages. For example:
  
      use Getopt::Long;
      use Pod::Usage;
  
      my $man = 0;
      my $help = 0;
  
      GetOptions('help|?' => \$help, man => \$man) or pod2usage(2);
      pod2usage(1) if $help;
      pod2usage(-exitval => 0, -verbose => 2) if $man;
  
      __END__
  
      =head1 NAME
  
      sample - Using Getopt::Long and Pod::Usage
  
      =head1 SYNOPSIS
  
      sample [options] [file ...]
  
       Options:
         -help            brief help message
         -man             full documentation
  
      =head1 OPTIONS
  
      =over 8
  
      =item B<-help>
  
      Print a brief help message and exits.
  
      =item B<-man>
  
      Prints the manual page and exits.
  
      =back
  
      =head1 DESCRIPTION
  
      B<This program> will read the given input file(s) and do something
      useful with the contents thereof.
  
      =cut
  
  See L<Pod::Usage> for details.
  
  =head2 Parsing options from an arbitrary array
  
  By default, GetOptions parses the options that are present in the
  global array C<@ARGV>. A special entry C<GetOptionsFromArray> can be
  used to parse options from an arbitrary array.
  
      use Getopt::Long qw(GetOptionsFromArray);
      $ret = GetOptionsFromArray(\@myopts, ...);
  
  When used like this, options and their possible values are removed
  from C<@myopts>, the global C<@ARGV> is not touched at all.
  
  The following two calls behave identically:
  
      $ret = GetOptions( ... );
      $ret = GetOptionsFromArray(\@ARGV, ... );
  
  This also means that a first argument hash reference now becomes the
  second argument:
  
      $ret = GetOptions(\%opts, ... );
      $ret = GetOptionsFromArray(\@ARGV, \%opts, ... );
  
  =head2 Parsing options from an arbitrary string
  
  A special entry C<GetOptionsFromString> can be used to parse options
  from an arbitrary string.
  
      use Getopt::Long qw(GetOptionsFromString);
      $ret = GetOptionsFromString($string, ...);
  
  The contents of the string are split into arguments using a call to
  C<Text::ParseWords::shellwords>. As with C<GetOptionsFromArray>, the
  global C<@ARGV> is not touched.
  
  It is possible that, upon completion, not all arguments in the string
  have been processed. C<GetOptionsFromString> will, when called in list
  context, return both the return status and an array reference to any
  remaining arguments:
  
      ($ret, $args) = GetOptionsFromString($string, ... );
  
  If any arguments remain, and C<GetOptionsFromString> was not called in
  list context, a message will be given and C<GetOptionsFromString> will
  return failure.
  
  As with GetOptionsFromArray, a first argument hash reference now
  becomes the second argument.
  
  =head2 Storing options values in a hash
  
  Sometimes, for example when there are a lot of options, having a
  separate variable for each of them can be cumbersome. GetOptions()
  supports, as an alternative mechanism, storing options values in a
  hash.
  
  To obtain this, a reference to a hash must be passed I<as the first
  argument> to GetOptions(). For each option that is specified on the
  command line, the option value will be stored in the hash with the
  option name as key. Options that are not actually used on the command
  line will not be put in the hash, on other words,
  C<exists($h{option})> (or defined()) can be used to test if an option
  was used. The drawback is that warnings will be issued if the program
  runs under C<use strict> and uses C<$h{option}> without testing with
  exists() or defined() first.
  
      my %h = ();
      GetOptions (\%h, 'length=i');	# will store in $h{length}
  
  For options that take list or hash values, it is necessary to indicate
  this by appending an C<@> or C<%> sign after the type:
  
      GetOptions (\%h, 'colours=s@');	# will push to @{$h{colours}}
  
  To make things more complicated, the hash may contain references to
  the actual destinations, for example:
  
      my $len = 0;
      my %h = ('length' => \$len);
      GetOptions (\%h, 'length=i');	# will store in $len
  
  This example is fully equivalent with:
  
      my $len = 0;
      GetOptions ('length=i' => \$len);	# will store in $len
  
  Any mixture is possible. For example, the most frequently used options
  could be stored in variables while all other options get stored in the
  hash:
  
      my $verbose = 0;			# frequently referred
      my $debug = 0;			# frequently referred
      my %h = ('verbose' => \$verbose, 'debug' => \$debug);
      GetOptions (\%h, 'verbose', 'debug', 'filter', 'size=i');
      if ( $verbose ) { ... }
      if ( exists $h{filter} ) { ... option 'filter' was specified ... }
  
  =head2 Bundling
  
  With bundling it is possible to set several single-character options
  at once. For example if C<a>, C<v> and C<x> are all valid options,
  
      -vax
  
  will set all three.
  
  Getopt::Long supports three styles of bundling. To enable bundling, a
  call to Getopt::Long::Configure is required.
  
  The simplest style of bundling can be enabled with:
  
      Getopt::Long::Configure ("bundling");
  
  Configured this way, single-character options can be bundled but long
  options B<must> always start with a double dash C<--> to avoid
  ambiguity. For example, when C<vax>, C<a>, C<v> and C<x> are all valid
  options,
  
      -vax
  
  will set C<a>, C<v> and C<x>, but
  
      --vax
  
  will set C<vax>.
  
  The second style of bundling lifts this restriction. It can be enabled
  with:
  
      Getopt::Long::Configure ("bundling_override");
  
  Now, C<-vax> will set the option C<vax>.
  
  In all of the above cases, option values may be inserted in the
  bundle. For example:
  
      -h24w80
  
  is equivalent to
  
      -h 24 -w 80
  
  A third style of bundling allows only values to be bundled with
  options. It can be enabled with:
  
      Getopt::Long::Configure ("bundling_values");
  
  Now, C<-h24> will set the option C<h> to C<24>, but option bundles
  like C<-vxa> and C<-h24w80> are flagged as errors.
  
  Enabling C<bundling_values> will disable the other two styles of
  bundling.
  
  When configured for bundling, single-character options are matched
  case sensitive while long options are matched case insensitive. To
  have the single-character options matched case insensitive as well,
  use:
  
      Getopt::Long::Configure ("bundling", "ignorecase_always");
  
  It goes without saying that bundling can be quite confusing.
  
  =head2 The lonesome dash
  
  Normally, a lone dash C<-> on the command line will not be considered
  an option. Option processing will terminate (unless "permute" is
  configured) and the dash will be left in C<@ARGV>.
  
  It is possible to get special treatment for a lone dash. This can be
  achieved by adding an option specification with an empty name, for
  example:
  
      GetOptions ('' => \$stdio);
  
  A lone dash on the command line will now be a legal option, and using
  it will set variable C<$stdio>.
  
  =head2 Argument callback
  
  A special option 'name' C<< <> >> can be used to designate a subroutine
  to handle non-option arguments. When GetOptions() encounters an
  argument that does not look like an option, it will immediately call this
  subroutine and passes it one parameter: the argument name. Well, actually
  it is an object that stringifies to the argument name.
  
  For example:
  
      my $width = 80;
      sub process { ... }
      GetOptions ('width=i' => \$width, '<>' => \&process);
  
  When applied to the following command line:
  
      arg1 --width=72 arg2 --width=60 arg3
  
  This will call
  C<process("arg1")> while C<$width> is C<80>,
  C<process("arg2")> while C<$width> is C<72>, and
  C<process("arg3")> while C<$width> is C<60>.
  
  This feature requires configuration option B<permute>, see section
  L<Configuring Getopt::Long>.
  
  =head1 Configuring Getopt::Long
  
  Getopt::Long can be configured by calling subroutine
  Getopt::Long::Configure(). This subroutine takes a list of quoted
  strings, each specifying a configuration option to be enabled, e.g.
  C<ignore_case>, or disabled, e.g. C<no_ignore_case>. Case does not
  matter. Multiple calls to Configure() are possible.
  
  Alternatively, as of version 2.24, the configuration options may be
  passed together with the C<use> statement:
  
      use Getopt::Long qw(:config no_ignore_case bundling);
  
  The following options are available:
  
  =over 12
  
  =item default
  
  This option causes all configuration options to be reset to their
  default values.
  
  =item posix_default
  
  This option causes all configuration options to be reset to their
  default values as if the environment variable POSIXLY_CORRECT had
  been set.
  
  =item auto_abbrev
  
  Allow option names to be abbreviated to uniqueness.
  Default is enabled unless environment variable
  POSIXLY_CORRECT has been set, in which case C<auto_abbrev> is disabled.
  
  =item getopt_compat
  
  Allow C<+> to start options.
  Default is enabled unless environment variable
  POSIXLY_CORRECT has been set, in which case C<getopt_compat> is disabled.
  
  =item gnu_compat
  
  C<gnu_compat> controls whether C<--opt=> is allowed, and what it should
  do. Without C<gnu_compat>, C<--opt=> gives an error. With C<gnu_compat>,
  C<--opt=> will give option C<opt> and empty value.
  This is the way GNU getopt_long() does it.
  
  =item gnu_getopt
  
  This is a short way of setting C<gnu_compat> C<bundling> C<permute>
  C<no_getopt_compat>. With C<gnu_getopt>, command line handling should be
  fully compatible with GNU getopt_long().
  
  =item require_order
  
  Whether command line arguments are allowed to be mixed with options.
  Default is disabled unless environment variable
  POSIXLY_CORRECT has been set, in which case C<require_order> is enabled.
  
  See also C<permute>, which is the opposite of C<require_order>.
  
  =item permute
  
  Whether command line arguments are allowed to be mixed with options.
  Default is enabled unless environment variable
  POSIXLY_CORRECT has been set, in which case C<permute> is disabled.
  Note that C<permute> is the opposite of C<require_order>.
  
  If C<permute> is enabled, this means that
  
      --foo arg1 --bar arg2 arg3
  
  is equivalent to
  
      --foo --bar arg1 arg2 arg3
  
  If an argument callback routine is specified, C<@ARGV> will always be
  empty upon successful return of GetOptions() since all options have been
  processed. The only exception is when C<--> is used:
  
      --foo arg1 --bar arg2 -- arg3
  
  This will call the callback routine for arg1 and arg2, and then
  terminate GetOptions() leaving C<"arg3"> in C<@ARGV>.
  
  If C<require_order> is enabled, options processing
  terminates when the first non-option is encountered.
  
      --foo arg1 --bar arg2 arg3
  
  is equivalent to
  
      --foo -- arg1 --bar arg2 arg3
  
  If C<pass_through> is also enabled, options processing will terminate
  at the first unrecognized option, or non-option, whichever comes
  first.
  
  =item bundling (default: disabled)
  
  Enabling this option will allow single-character options to be
  bundled. To distinguish bundles from long option names, long options
  I<must> be introduced with C<--> and bundles with C<->.
  
  Note that, if you have options C<a>, C<l> and C<all>, and
  auto_abbrev enabled, possible arguments and option settings are:
  
      using argument               sets option(s)
      ------------------------------------------
      -a, --a                      a
      -l, --l                      l
      -al, -la, -ala, -all,...     a, l
      --al, --all                  all
  
  The surprising part is that C<--a> sets option C<a> (due to auto
  completion), not C<all>.
  
  Note: disabling C<bundling> also disables C<bundling_override>.
  
  =item bundling_override (default: disabled)
  
  If C<bundling_override> is enabled, bundling is enabled as with
  C<bundling> but now long option names override option bundles.
  
  Note: disabling C<bundling_override> also disables C<bundling>.
  
  B<Note:> Using option bundling can easily lead to unexpected results,
  especially when mixing long options and bundles. Caveat emptor.
  
  =item ignore_case  (default: enabled)
  
  If enabled, case is ignored when matching option names. If, however,
  bundling is enabled as well, single character options will be treated
  case-sensitive.
  
  With C<ignore_case>, option specifications for options that only
  differ in case, e.g., C<"foo"> and C<"Foo">, will be flagged as
  duplicates.
  
  Note: disabling C<ignore_case> also disables C<ignore_case_always>.
  
  =item ignore_case_always (default: disabled)
  
  When bundling is in effect, case is ignored on single-character
  options also.
  
  Note: disabling C<ignore_case_always> also disables C<ignore_case>.
  
  =item auto_version (default:disabled)
  
  Automatically provide support for the B<--version> option if
  the application did not specify a handler for this option itself.
  
  Getopt::Long will provide a standard version message that includes the
  program name, its version (if $main::VERSION is defined), and the
  versions of Getopt::Long and Perl. The message will be written to
  standard output and processing will terminate.
  
  C<auto_version> will be enabled if the calling program explicitly
  specified a version number higher than 2.32 in the C<use> or
  C<require> statement.
  
  =item auto_help (default:disabled)
  
  Automatically provide support for the B<--help> and B<-?> options if
  the application did not specify a handler for this option itself.
  
  Getopt::Long will provide a help message using module L<Pod::Usage>. The
  message, derived from the SYNOPSIS POD section, will be written to
  standard output and processing will terminate.
  
  C<auto_help> will be enabled if the calling program explicitly
  specified a version number higher than 2.32 in the C<use> or
  C<require> statement.
  
  =item pass_through (default: disabled)
  
  With C<pass_through> anything that is unknown, ambiguous or supplied with
  an invalid option will not be flagged as an error. Instead the unknown
  option(s) will be passed to the catchall C<< <> >> if present, otherwise
  through to C<@ARGV>. This makes it possible to write wrapper scripts that
  process only part of the user supplied command line arguments, and pass the
  remaining options to some other program.
  
  If C<require_order> is enabled, options processing will terminate at the
  first unrecognized option, or non-option, whichever comes first and all
  remaining arguments are passed to C<@ARGV> instead of the catchall
  C<< <> >> if present.  However, if C<permute> is enabled instead, results
  can become confusing.
  
  Note that the options terminator (default C<-->), if present, will
  also be passed through in C<@ARGV>.
  
  =item prefix
  
  The string that starts options. If a constant string is not
  sufficient, see C<prefix_pattern>.
  
  =item prefix_pattern
  
  A Perl pattern that identifies the strings that introduce options.
  Default is C<--|-|\+> unless environment variable
  POSIXLY_CORRECT has been set, in which case it is C<--|->.
  
  =item long_prefix_pattern
  
  A Perl pattern that allows the disambiguation of long and short
  prefixes. Default is C<-->.
  
  Typically you only need to set this if you are using nonstandard
  prefixes and want some or all of them to have the same semantics as
  '--' does under normal circumstances.
  
  For example, setting prefix_pattern to C<--|-|\+|\/> and
  long_prefix_pattern to C<--|\/> would add Win32 style argument
  handling.
  
  =item debug (default: disabled)
  
  Enable debugging output.
  
  =back
  
  =head1 Exportable Methods
  
  =over
  
  =item VersionMessage
  
  This subroutine provides a standard version message. Its argument can be:
  
  =over 4
  
  =item *
  
  A string containing the text of a message to print I<before> printing
  the standard message.
  
  =item *
  
  A numeric value corresponding to the desired exit status.
  
  =item *
  
  A reference to a hash.
  
  =back
  
  If more than one argument is given then the entire argument list is
  assumed to be a hash.  If a hash is supplied (either as a reference or
  as a list) it should contain one or more elements with the following
  keys:
  
  =over 4
  
  =item C<-message>
  
  =item C<-msg>
  
  The text of a message to print immediately prior to printing the
  program's usage message.
  
  =item C<-exitval>
  
  The desired exit status to pass to the B<exit()> function.
  This should be an integer, or else the string "NOEXIT" to
  indicate that control should simply be returned without
  terminating the invoking process.
  
  =item C<-output>
  
  A reference to a filehandle, or the pathname of a file to which the
  usage message should be written. The default is C<\*STDERR> unless the
  exit value is less than 2 (in which case the default is C<\*STDOUT>).
  
  =back
  
  You cannot tie this routine directly to an option, e.g.:
  
      GetOptions("version" => \&VersionMessage);
  
  Use this instead:
  
      GetOptions("version" => sub { VersionMessage() });
  
  =item HelpMessage
  
  This subroutine produces a standard help message, derived from the
  program's POD section SYNOPSIS using L<Pod::Usage>. It takes the same
  arguments as VersionMessage(). In particular, you cannot tie it
  directly to an option, e.g.:
  
      GetOptions("help" => \&HelpMessage);
  
  Use this instead:
  
      GetOptions("help" => sub { HelpMessage() });
  
  =back
  
  =head1 Return values and Errors
  
  Configuration errors and errors in the option definitions are
  signalled using die() and will terminate the calling program unless
  the call to Getopt::Long::GetOptions() was embedded in C<eval { ...
  }>, or die() was trapped using C<$SIG{__DIE__}>.
  
  GetOptions returns true to indicate success.
  It returns false when the function detected one or more errors during
  option parsing. These errors are signalled using warn() and can be
  trapped with C<$SIG{__WARN__}>.
  
  =head1 Legacy
  
  The earliest development of C<newgetopt.pl> started in 1990, with Perl
  version 4. As a result, its development, and the development of
  Getopt::Long, has gone through several stages. Since backward
  compatibility has always been extremely important, the current version
  of Getopt::Long still supports a lot of constructs that nowadays are
  no longer necessary or otherwise unwanted. This section describes
  briefly some of these 'features'.
  
  =head2 Default destinations
  
  When no destination is specified for an option, GetOptions will store
  the resultant value in a global variable named C<opt_>I<XXX>, where
  I<XXX> is the primary name of this option. When a program executes
  under C<use strict> (recommended), these variables must be
  pre-declared with our() or C<use vars>.
  
      our $opt_length = 0;
      GetOptions ('length=i');	# will store in $opt_length
  
  To yield a usable Perl variable, characters that are not part of the
  syntax for variables are translated to underscores. For example,
  C<--fpp-struct-return> will set the variable
  C<$opt_fpp_struct_return>. Note that this variable resides in the
  namespace of the calling program, not necessarily C<main>. For
  example:
  
      GetOptions ("size=i", "sizes=i@");
  
  with command line "-size 10 -sizes 24 -sizes 48" will perform the
  equivalent of the assignments
  
      $opt_size = 10;
      @opt_sizes = (24, 48);
  
  =head2 Alternative option starters
  
  A string of alternative option starter characters may be passed as the
  first argument (or the first argument after a leading hash reference
  argument).
  
      my $len = 0;
      GetOptions ('/', 'length=i' => $len);
  
  Now the command line may look like:
  
      /length 24 -- arg
  
  Note that to terminate options processing still requires a double dash
  C<-->.
  
  GetOptions() will not interpret a leading C<< "<>" >> as option starters
  if the next argument is a reference. To force C<< "<" >> and C<< ">" >> as
  option starters, use C<< "><" >>. Confusing? Well, B<using a starter
  argument is strongly deprecated> anyway.
  
  =head2 Configuration variables
  
  Previous versions of Getopt::Long used variables for the purpose of
  configuring. Although manipulating these variables still work, it is
  strongly encouraged to use the C<Configure> routine that was introduced
  in version 2.17. Besides, it is much easier.
  
  =head1 Tips and Techniques
  
  =head2 Pushing multiple values in a hash option
  
  Sometimes you want to combine the best of hashes and arrays. For
  example, the command line:
  
    --list add=first --list add=second --list add=third
  
  where each successive 'list add' option will push the value of add
  into array ref $list->{'add'}. The result would be like
  
    $list->{add} = [qw(first second third)];
  
  This can be accomplished with a destination routine:
  
    GetOptions('list=s%' =>
                 sub { push(@{$list{$_[1]}}, $_[2]) });
  
  =head1 Troubleshooting
  
  =head2 GetOptions does not return a false result when an option is not supplied
  
  That's why they're called 'options'.
  
  =head2 GetOptions does not split the command line correctly
  
  The command line is not split by GetOptions, but by the command line
  interpreter (CLI). On Unix, this is the shell. On Windows, it is
  COMMAND.COM or CMD.EXE. Other operating systems have other CLIs.
  
  It is important to know that these CLIs may behave different when the
  command line contains special characters, in particular quotes or
  backslashes. For example, with Unix shells you can use single quotes
  (C<'>) and double quotes (C<">) to group words together. The following
  alternatives are equivalent on Unix:
  
      "two words"
      'two words'
      two\ words
  
  In case of doubt, insert the following statement in front of your Perl
  program:
  
      print STDERR (join("|",@ARGV),"\n");
  
  to verify how your CLI passes the arguments to the program.
  
  =head2 Undefined subroutine &main::GetOptions called
  
  Are you running Windows, and did you write
  
      use GetOpt::Long;
  
  (note the capital 'O')?
  
  =head2 How do I put a "-?" option into a Getopt::Long?
  
  You can only obtain this using an alias, and Getopt::Long of at least
  version 2.13.
  
      use Getopt::Long;
      GetOptions ("help|?");    # -help and -? will both set $opt_help
  
  Other characters that can't appear in Perl identifiers are also supported
  as aliases with Getopt::Long of at least version 2.39.
  
  As of version 2.32 Getopt::Long provides auto-help, a quick and easy way
  to add the options --help and -? to your program, and handle them.
  
  See C<auto_help> in section L<Configuring Getopt::Long>.
  
  =head1 AUTHOR
  
  Johan Vromans <jvromans@squirrel.nl>
  
  =head1 COPYRIGHT AND DISCLAIMER
  
  This program is Copyright 1990,2015 by Johan Vromans.
  This program is free software; you can redistribute it and/or
  modify it under the terms of the Perl Artistic License or the
  GNU General Public License as published by the Free Software
  Foundation; either version 2 of the License, or (at your option) any
  later version.
  
  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.
  
  If you do not have a copy of the GNU General Public License write to
  the Free Software Foundation, Inc., 675 Mass Ave, Cambridge,
  MA 02139, USA.
  
  =cut
  
GETOPT_LONG

$fatpacked{"LWP.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LWP';
  package LWP;
  
  our $VERSION = '6.23';
  
  require 5.008;
  require LWP::UserAgent;  # this should load everything you need
  
  sub Version { $VERSION; }
  
  1;
  
  __END__
  
  =pod
  
  =encoding utf-8
  
  =head1 NAME
  
  LWP - The World-Wide Web library for Perl
  
  =head1 SYNOPSIS
  
    use LWP;
    print "This is libwww-perl-$LWP::VERSION\n";
  
  
  =head1 DESCRIPTION
  
  The libwww-perl collection is a set of Perl modules which provides a
  simple and consistent application programming interface (API) to the
  World-Wide Web.  The main focus of the library is to provide classes
  and functions that allow you to write WWW clients. The library also
  contain modules that are of more general use and even classes that
  help you implement simple HTTP servers.
  
  Most modules in this library provide an object oriented API.  The user
  agent, requests sent and responses received from the WWW server are
  all represented by objects.  This makes a simple and powerful
  interface to these services.  The interface is easy to extend
  and customize for your own needs.
  
  The main features of the library are:
  
  =over 3
  
  =item *
  
  Contains various reusable components (modules) that can be
  used separately or together.
  
  =item *
  
  Provides an object oriented model of HTTP-style communication.  Within
  this framework we currently support access to C<http>, C<https>, C<gopher>,
  C<ftp>, C<news>, C<file>, and C<mailto> resources.
  
  =item *
  
  Provides a full object oriented interface or
  a very simple procedural interface.
  
  =item *
  
  Supports the basic and digest authorization schemes.
  
  =item *
  
  Supports transparent redirect handling.
  
  =item *
  
  Supports access through proxy servers.
  
  =item *
  
  Provides parser for F<robots.txt> files and a framework for constructing robots.
  
  =item *
  
  Supports parsing of HTML forms.
  
  =item *
  
  Implements HTTP content negotiation algorithm that can
  be used both in protocol modules and in server scripts (like CGI
  scripts).
  
  =item *
  
  Supports HTTP cookies.
  
  =item *
  
  Some simple command line clients, for instance C<lwp-request> and C<lwp-download>.
  
  =back
  
  
  =head1 HTTP STYLE COMMUNICATION
  
  
  The libwww-perl library is based on HTTP style communication. This
  section tries to describe what that means.
  
  Let us start with this quote from the HTTP specification document
  <URL:http://www.w3.org/Protocols/>:
  
  =over 3
  
  =item *
  
  The HTTP protocol is based on a request/response paradigm. A client
  establishes a connection with a server and sends a request to the
  server in the form of a request method, URI, and protocol version,
  followed by a MIME-like message containing request modifiers, client
  information, and possible body content. The server responds with a
  status line, including the message's protocol version and a success or
  error code, followed by a MIME-like message containing server
  information, entity meta-information, and possible body content.
  
  =back
  
  What this means to libwww-perl is that communication always take place
  through these steps: First a I<request> object is created and
  configured. This object is then passed to a server and we get a
  I<response> object in return that we can examine. A request is always
  independent of any previous requests, i.e. the service is stateless.
  The same simple model is used for any kind of service we want to
  access.
  
  For example, if we want to fetch a document from a remote file server,
  then we send it a request that contains a name for that document and
  the response will contain the document itself.  If we access a search
  engine, then the content of the request will contain the query
  parameters and the response will contain the query result.  If we want
  to send a mail message to somebody then we send a request object which
  contains our message to the mail server and the response object will
  contain an acknowledgment that tells us that the message has been
  accepted and will be forwarded to the recipient(s).
  
  It is as simple as that!
  
  
  =head2 The Request Object
  
  The libwww-perl request object has the class name L<HTTP::Request>.
  The fact that the class name uses C<HTTP::> as a
  prefix only implies that we use the HTTP model of communication.  It
  does not limit the kind of services we can try to pass this I<request>
  to.  For instance, we will send L<HTTP::Request>s both to ftp and
  gopher servers, as well as to the local file system.
  
  The main attributes of the request objects are:
  
  =over 3
  
  =item *
  
  B<method> is a short string that tells what kind of
  request this is.  The most common methods are B<GET>, B<PUT>,
  B<POST> and B<HEAD>.
  
  =item *
  
  B<uri> is a string denoting the protocol, server and
  the name of the "document" we want to access.  The B<uri> might
  also encode various other parameters.
  
  =item *
  
  B<headers> contains additional information about the
  request and can also used to describe the content.  The headers
  are a set of keyword/value pairs.
  
  =item *
  
  B<content> is an arbitrary amount of data.
  
  =back
  
  =head2 The Response Object
  
  The libwww-perl response object has the class name L<HTTP::Response>.
  The main attributes of objects of this class are:
  
  =over 3
  
  =item *
  
  B<code> is a numerical value that indicates the overall
  outcome of the request.
  
  =item *
  
  B<message> is a short, human readable string that
  corresponds to the I<code>.
  
  =item *
  
  B<headers> contains additional information about the
  response and describe the content.
  
  =item *
  
  B<content> is an arbitrary amount of data.
  
  =back
  
  Since we don't want to handle all possible I<code> values directly in
  our programs, a libwww-perl response object has methods that can be
  used to query what kind of response this is.  The most commonly used
  response classification methods are:
  
  =over 3
  
  =item is_success()
  
  The request was successfully received, understood or accepted.
  
  =item is_error()
  
  The request failed.  The server or the resource might not be
  available, access to the resource might be denied or other things might
  have failed for some reason.
  
  =back
  
  =head2 The User Agent
  
  Let us assume that we have created a I<request> object. What do we
  actually do with it in order to receive a I<response>?
  
  The answer is that you pass it to a I<user agent> object and this
  object takes care of all the things that need to be done
  (like low-level communication and error handling) and returns
  a I<response> object. The user agent represents your
  application on the network and provides you with an interface that
  can accept I<requests> and return I<responses>.
  
  The user agent is an interface layer between
  your application code and the network.  Through this interface you are
  able to access the various servers on the network.
  
  The class name for the user agent is L<LWP::UserAgent>.  Every
  libwww-perl application that wants to communicate should create at
  least one object of this class. The main method provided by this
  object is request(). This method takes an L<HTTP::Request> object as
  argument and (eventually) returns a L<HTTP::Response> object.
  
  The user agent has many other attributes that let you
  configure how it will interact with the network and with your
  application.
  
  =over 3
  
  =item *
  
  B<timeout> specifies how much time we give remote servers to
  respond before the library disconnects and creates an
  internal I<timeout> response.
  
  =item *
  
  B<agent> specifies the name that your application uses when it
  presents itself on the network.
  
  =item *
  
  B<from> can be set to the e-mail address of the person
  responsible for running the application.  If this is set, then the
  address will be sent to the servers with every request.
  
  =item *
  
  B<parse_head> specifies whether we should initialize response
  headers from the E<lt>head> section of HTML documents.
  
  =item *
  
  B<proxy> and B<no_proxy> specify if and when to go through
  a proxy server. <URL:http://www.w3.org/History/1994/WWW/Proxies/>
  
  =item *
  
  B<credentials> provides a way to set up user names and
  passwords needed to access certain services.
  
  =back
  
  Many applications want even more control over how they interact
  with the network and they get this by sub-classing
  L<LWP::UserAgent>.  The library includes a
  sub-class, L<LWP::RobotUA>, for robot applications.
  
  =head2 An Example
  
  This example shows how the user agent, a request and a response are
  represented in actual perl code:
  
    # Create a user agent object
    use LWP::UserAgent;
    my $ua = LWP::UserAgent->new;
    $ua->agent("MyApp/0.1 ");
  
    # Create a request
    my $req = HTTP::Request->new(POST => 'http://search.cpan.org/search');
    $req->content_type('application/x-www-form-urlencoded');
    $req->content('query=libwww-perl&mode=dist');
  
    # Pass request to the user agent and get a response back
    my $res = $ua->request($req);
  
    # Check the outcome of the response
    if ($res->is_success) {
        print $res->content;
    }
    else {
        print $res->status_line, "\n";
    }
  
  The $ua is created once when the application starts up.  New request
  objects should normally created for each request sent.
  
  
  =head1 NETWORK SUPPORT
  
  This section discusses the various protocol schemes and
  the HTTP style methods that headers may be used for each.
  
  For all requests, a "User-Agent" header is added and initialized from
  the $ua->agent attribute before the request is handed to the network
  layer.  In the same way, a "From" header is initialized from the
  $ua->from attribute.
  
  For all responses, the library adds a header called "Client-Date".
  This header holds the time when the response was received by
  your application.  The format and semantics of the header are the
  same as the server created "Date" header.  You may also encounter other
  "Client-XXX" headers.  They are all generated by the library
  internally and are not received from the servers.
  
  =head2 HTTP Requests
  
  HTTP requests are just handed off to an HTTP server and it
  decides what happens.  Few servers implement methods beside the usual
  "GET", "HEAD", "POST" and "PUT", but CGI-scripts may implement
  any method they like.
  
  If the server is not available then the library will generate an
  internal error response.
  
  The library automatically adds a "Host" and a "Content-Length" header
  to the HTTP request before it is sent over the network.
  
  For a GET request you might want to add a "If-Modified-Since" or
  "If-None-Match" header to make the request conditional.
  
  For a POST request you should add the "Content-Type" header.  When you
  try to emulate HTML E<lt>FORM> handling you should usually let the value
  of the "Content-Type" header be "application/x-www-form-urlencoded".
  See L<lwpcook> for examples of this.
  
  The libwww-perl HTTP implementation currently support the HTTP/1.1
  and HTTP/1.0 protocol.
  
  The library allows you to access proxy server through HTTP.  This
  means that you can set up the library to forward all types of request
  through the HTTP protocol module.  See L<LWP::UserAgent> for
  documentation of this.
  
  
  =head2 HTTPS Requests
  
  HTTPS requests are HTTP requests over an encrypted network connection
  using the SSL protocol developed by Netscape.  Everything about HTTP
  requests above also apply to HTTPS requests.  In addition the library
  will add the headers "Client-SSL-Cipher", "Client-SSL-Cert-Subject" and
  "Client-SSL-Cert-Issuer" to the response.  These headers denote the
  encryption method used and the name of the server owner.
  
  The request can contain the header "If-SSL-Cert-Subject" in order to
  make the request conditional on the content of the server certificate.
  If the certificate subject does not match, no request is sent to the
  server and an internally generated error response is returned.  The
  value of the "If-SSL-Cert-Subject" header is interpreted as a Perl
  regular expression.
  
  
  =head2 FTP Requests
  
  The library currently supports GET, HEAD and PUT requests.  GET
  retrieves a file or a directory listing from an FTP server.  PUT
  stores a file on a ftp server.
  
  You can specify a ftp account for servers that want this in addition
  to user name and password.  This is specified by including an "Account"
  header in the request.
  
  User name/password can be specified using basic authorization or be
  encoded in the URL.  Failed logins return an UNAUTHORIZED response with
  "WWW-Authenticate: Basic" and can be treated like basic authorization
  for HTTP.
  
  The library supports ftp ASCII transfer mode by specifying the "type=a"
  parameter in the URL. It also supports transfer of ranges for FTP transfers
  using the "Range" header.
  
  Directory listings are by default returned unprocessed (as returned
  from the ftp server) with the content media type reported to be
  "text/ftp-dir-listing". The L<File::Listing> module provides methods
  for parsing of these directory listing.
  
  The ftp module is also able to convert directory listings to HTML and
  this can be requested via the standard HTTP content negotiation
  mechanisms (add an "Accept: text/html" header in the request if you
  want this).
  
  For normal file retrievals, the "Content-Type" is guessed based on the
  file name suffix. See L<LWP::MediaTypes>.
  
  The "If-Modified-Since" request header works for servers that implement
  the C<MDTM> command.  It will probably not work for directory listings though.
  
  Example:
  
    $req = HTTP::Request->new(GET => 'ftp://me:passwd@ftp.some.where.com/');
    $req->header(Accept => "text/html, */*;q=0.1");
  
  =head2 News Requests
  
  Access to the USENET News system is implemented through the NNTP
  protocol.  The name of the news server is obtained from the
  NNTP_SERVER environment variable and defaults to "news".  It is not
  possible to specify the hostname of the NNTP server in news: URLs.
  
  The library supports GET and HEAD to retrieve news articles through the
  NNTP protocol.  You can also post articles to newsgroups by using
  (surprise!) the POST method.
  
  GET on newsgroups is not implemented yet.
  
  Examples:
  
    $req = HTTP::Request->new(GET => 'news:abc1234@a.sn.no');
  
    $req = HTTP::Request->new(POST => 'news:comp.lang.perl.test');
    $req->header(Subject => 'This is a test',
                 From    => 'me@some.where.org');
    $req->content(<<EOT);
    This is the content of the message that we are sending to
    the world.
    EOT
  
  
  =head2 Gopher Request
  
  The library supports the GET and HEAD methods for gopher requests.  All
  request header values are ignored.  HEAD cheats and returns a
  response without even talking to server.
  
  Gopher menus are always converted to HTML.
  
  The response "Content-Type" is generated from the document type
  encoded (as the first letter) in the request URL path itself.
  
  Example:
  
    $req = HTTP::Request->new(GET => 'gopher://gopher.sn.no/');
  
  
  
  =head2 File Request
  
  The library supports GET and HEAD methods for file requests.  The
  "If-Modified-Since" header is supported.  All other headers are
  ignored.  The I<host> component of the file URL must be empty or set
  to "localhost".  Any other I<host> value will be treated as an error.
  
  Directories are always converted to an HTML document.  For normal
  files, the "Content-Type" and "Content-Encoding" in the response are
  guessed based on the file suffix.
  
  Example:
  
    $req = HTTP::Request->new(GET => 'file:/etc/passwd');
  
  
  =head2 Mailto Request
  
  You can send (aka "POST") mail messages using the library.  All
  headers specified for the request are passed on to the mail system.
  The "To" header is initialized from the mail address in the URL.
  
  Example:
  
    $req = HTTP::Request->new(POST => 'mailto:libwww@perl.org');
    $req->header(Subject => "subscribe");
    $req->content("Please subscribe me to the libwww-perl mailing list!\n");
  
  =head2 CPAN Requests
  
  URLs with scheme C<cpan:> are redirected to a suitable CPAN
  mirror.  If you have your own local mirror of CPAN you might tell LWP
  to use it for C<cpan:> URLs by an assignment like this:
  
    $LWP::Protocol::cpan::CPAN = "file:/local/CPAN/";
  
  Suitable CPAN mirrors are also picked up from the configuration for
  the CPAN.pm, so if you have used that module a suitable mirror should
  be picked automatically.  If neither of these apply, then a redirect
  to the generic CPAN http location is issued.
  
  Example request to download the newest perl:
  
    $req = HTTP::Request->new(GET => "cpan:src/latest.tar.gz");
  
  
  =head1 OVERVIEW OF CLASSES AND PACKAGES
  
  This table should give you a quick overview of the classes provided by the
  library. Indentation shows class inheritance.
  
   LWP::MemberMixin   -- Access to member variables of Perl5 classes
     LWP::UserAgent   -- WWW user agent class
       LWP::RobotUA   -- When developing a robot applications
     LWP::Protocol          -- Interface to various protocol schemes
       LWP::Protocol::http  -- http:// access
       LWP::Protocol::file  -- file:// access
       LWP::Protocol::ftp   -- ftp:// access
       ...
  
   LWP::Authen::Basic -- Handle 401 and 407 responses
   LWP::Authen::Digest
  
   HTTP::Headers      -- MIME/RFC822 style header (used by HTTP::Message)
   HTTP::Message      -- HTTP style message
     HTTP::Request    -- HTTP request
     HTTP::Response   -- HTTP response
   HTTP::Daemon       -- A HTTP server class
  
   WWW::RobotRules    -- Parse robots.txt files
     WWW::RobotRules::AnyDBM_File -- Persistent RobotRules
  
   Net::HTTP          -- Low level HTTP client
  
  The following modules provide various functions and definitions.
  
   LWP                -- This file.  Library version number and documentation.
   LWP::MediaTypes    -- MIME types configuration (text/html etc.)
   LWP::Simple        -- Simplified procedural interface for common functions
   HTTP::Status       -- HTTP status code (200 OK etc)
   HTTP::Date         -- Date parsing module for HTTP date formats
   HTTP::Negotiate    -- HTTP content negotiation calculation
   File::Listing      -- Parse directory listings
   HTML::Form         -- Processing for <form>s in HTML documents
  
  
  =head1 MORE DOCUMENTATION
  
  All modules contain detailed information on the interfaces they
  provide.  The L<lwpcook> manpage is the libwww-perl cookbook that contain
  examples of typical usage of the library.  You might want to take a
  look at how the scripts L<lwp-request>, L<lwp-download>, L<lwp-dump>
  and L<lwp-mirror> are implemented.
  
  =head1 ENVIRONMENT
  
  The following environment variables are used by LWP:
  
  =over
  
  =item HOME
  
  The L<LWP::MediaTypes> functions will look for the F<.media.types> and
  F<.mime.types> files relative to you home directory.
  
  =item http_proxy
  
  =item ftp_proxy
  
  =item xxx_proxy
  
  =item no_proxy
  
  These environment variables can be set to enable communication through
  a proxy server.  See the description of the C<env_proxy> method in
  L<LWP::UserAgent>.
  
  =item PERL_LWP_ENV_PROXY
  
  If set to a TRUE value, then the L<LWP::UserAgent> will by default call
  C<env_proxy> during initialization.  This makes LWP honor the proxy variables
  described above.
  
  =item PERL_LWP_SSL_VERIFY_HOSTNAME
  
  The default C<verify_hostname> setting for L<LWP::UserAgent>.  If
  not set the default will be 1.  Set it as 0 to disable hostname
  verification (the default prior to libwww-perl 5.840.
  
  =item PERL_LWP_SSL_CA_FILE
  
  =item PERL_LWP_SSL_CA_PATH
  
  The file and/or directory
  where the trusted Certificate Authority certificates
  is located.  See L<LWP::UserAgent> for details.
  
  =item PERL_HTTP_URI_CLASS
  
  Used to decide what URI objects to instantiate.  The default is L<URI>.
  You might want to set it to L<URI::URL> for compatibility with old times.
  
  =back
  
  =head1 AUTHORS
  
  LWP was made possible by contributions from Adam Newby, Albert
  Dvornik, Alexandre Duret-Lutz, Andreas Gustafsson, Andreas Knig,
  Andrew Pimlott, Andy Lester, Ben Coleman, Benjamin Low, Ben Low, Ben
  Tilly, Blair Zajac, Bob Dalgleish, BooK, Brad Hughes, Brian
  J. Murrell, Brian McCauley, Charles C. Fu, Charles Lane, Chris Nandor,
  Christian Gilmore, Chris W. Unger, Craig Macdonald, Dale Couch, Dan
  Kubb, Dave Dunkin, Dave W. Smith, David Coppit, David Dick, David
  D. Kilzer, Doug MacEachern, Edward Avis, erik, Gary Shea, Gisle Aas,
  Graham Barr, Gurusamy Sarathy, Hans de Graaff, Harald Joerg, Harry
  Bochner, Hugo, Ilya Zakharevich, INOUE Yoshinari, Ivan Panchenko, Jack
  Shirazi, James Tillman, Jan Dubois, Jared Rhine, Jim Stern, Joao
  Lopes, John Klar, Johnny Lee, Josh Kronengold, Josh Rai, Joshua
  Chamas, Joshua Hoblitt, Kartik Subbarao, Keiichiro Nagano, Ken
  Williams, KONISHI Katsuhiro, Lee T Lindley, Liam Quinn, Marc Hedlund,
  Marc Langheinrich, Mark D. Anderson, Marko Asplund, Mark Stosberg,
  Markus B Krger, Markus Laker, Martijn Koster, Martin Thurn, Matthew
  Eldridge, Matthew.van.Eerde, Matt Sergeant, Michael A. Chase, Michael
  Quaranta, Michael Thompson, Mike Schilli, Moshe Kaminsky, Nathan
  Torkington, Nicolai Langfeldt, Norton Allen, Olly Betts, Paul
  J. Schinder, peterm, Philip Guenther, Daniel Buenzli, Pon Hwa Lin,
  Radoslaw Zielinski, Radu Greab, Randal L. Schwartz, Richard Chen,
  Robin Barker, Roy Fielding, Sander van Zoest, Sean M. Burke,
  shildreth, Slaven Rezic, Steve A Fink, Steve Hay, Steven Butler,
  Steve_Kilbane, Takanori Ugai, Thomas Lotterer, Tim Bunce, Tom Hughes,
  Tony Finch, Ville Skytt, Ward Vandewege, William York, Yale Huang,
  and Yitzchak Scott-Thoennes.
  
  LWP owes a lot in motivation, design, and code, to the libwww-perl
  library for Perl4 by Roy Fielding, which included work from Alberto
  Accomazzi, James Casey, Brooks Cutter, Martijn Koster, Oscar
  Nierstrasz, Mel Melchner, Gertjan van Oosten, Jared Rhine, Jack
  Shirazi, Gene Spafford, Marc VanHeyningen, Steven E. Brenner, Marion
  Hakanson, Waldemar Kebsch, Tony Sanders, and Larry Wall; see the
  libwww-perl-0.40 library for details.
  
  =head1 COPYRIGHT
  
    Copyright 1995-2009, Gisle Aas
    Copyright 1995, Martijn Koster
  
  This library is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  =head1 AVAILABILITY
  
  The latest version of this library is likely to be available from CPAN
  as well as:
  
    http://github.com/libwww-perl/libwww-perl
  
  The best place to discuss this code is on the <libwww@perl.org>
  mailing list.
  
  =cut
LWP

$fatpacked{"LWP/Authen/Basic.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LWP_AUTHEN_BASIC';
  package LWP::Authen::Basic;
  $LWP::Authen::Basic::VERSION = '6.23';
  use strict;
  
  require MIME::Base64;
  
  sub auth_header {
      my($class, $user, $pass) = @_;
      return "Basic " . MIME::Base64::encode("$user:$pass", "");
  }
  
  sub authenticate
  {
      my($class, $ua, $proxy, $auth_param, $response,
         $request, $arg, $size) = @_;
  
      my $realm = $auth_param->{realm} || "";
      my $url = $proxy ? $request->{proxy} : $request->uri_canonical;
      return $response unless $url;
      my $host_port = $url->host_port;
      my $auth_header = $proxy ? "Proxy-Authorization" : "Authorization";
  
      my @m = $proxy ? (m_proxy => $url) : (m_host_port => $host_port);
      push(@m, realm => $realm);
  
      my $h = $ua->get_my_handler("request_prepare", @m, sub {
          $_[0]{callback} = sub {
              my($req, $ua, $h) = @_;
              my($user, $pass) = $ua->credentials($host_port, $h->{realm});
  	    if (defined $user) {
  		my $auth_value = $class->auth_header($user, $pass, $req, $ua, $h);
  		$req->header($auth_header => $auth_value);
  	    }
          };
      });
      $h->{auth_param} = $auth_param;
  
      if (!$proxy && !$request->header($auth_header) && $ua->credentials($host_port, $realm)) {
  	# we can make sure this handler applies and retry
          add_path($h, $url->path);
          return $ua->request($request->clone, $arg, $size, $response);
      }
  
      my($user, $pass) = $ua->get_basic_credentials($realm, $url, $proxy);
      unless (defined $user and defined $pass) {
  	$ua->set_my_handler("request_prepare", undef, @m);  # delete handler
  	return $response;
      }
  
      # check that the password has changed
      my ($olduser, $oldpass) = $ua->credentials($host_port, $realm);
      return $response if (defined $olduser and defined $oldpass and
                           $user eq $olduser and $pass eq $oldpass);
  
      $ua->credentials($host_port, $realm, $user, $pass);
      add_path($h, $url->path) unless $proxy;
      return $ua->request($request->clone, $arg, $size, $response);
  }
  
  sub add_path {
      my($h, $path) = @_;
      $path =~ s,[^/]+\z,,;
      push(@{$h->{m_path_prefix}}, $path);
  }
  
  1;
LWP_AUTHEN_BASIC

$fatpacked{"LWP/Authen/Digest.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LWP_AUTHEN_DIGEST';
  package LWP::Authen::Digest;
  $LWP::Authen::Digest::VERSION = '6.23';
  use strict;
  use base 'LWP::Authen::Basic';
  
  require Digest::MD5;
  
  sub auth_header {
      my($class, $user, $pass, $request, $ua, $h) = @_;
  
      my $auth_param = $h->{auth_param};
  
      my $nc = sprintf "%08X", ++$ua->{authen_md5_nonce_count}{$auth_param->{nonce}};
      my $cnonce = sprintf "%8x", time;
  
      my $uri = $request->uri->path_query;
      $uri = "/" unless length $uri;
  
      my $md5 = Digest::MD5->new;
  
      my(@digest);
      $md5->add(join(":", $user, $auth_param->{realm}, $pass));
      push(@digest, $md5->hexdigest);
      $md5->reset;
  
      push(@digest, $auth_param->{nonce});
  
      if ($auth_param->{qop}) {
  	push(@digest, $nc, $cnonce, ($auth_param->{qop} =~ m|^auth[,;]auth-int$|) ? 'auth' : $auth_param->{qop});
      }
  
      $md5->add(join(":", $request->method, $uri));
      push(@digest, $md5->hexdigest);
      $md5->reset;
  
      $md5->add(join(":", @digest));
      my($digest) = $md5->hexdigest;
      $md5->reset;
  
      my %resp = map { $_ => $auth_param->{$_} } qw(realm nonce opaque);
      @resp{qw(username uri response algorithm)} = ($user, $uri, $digest, "MD5");
  
      if (($auth_param->{qop} || "") =~ m|^auth([,;]auth-int)?$|) {
  	@resp{qw(qop cnonce nc)} = ("auth", $cnonce, $nc);
      }
  
      my(@order) = qw(username realm qop algorithm uri nonce nc cnonce response);
      if($request->method =~ /^(?:POST|PUT)$/) {
  	$md5->add($request->content);
  	my $content = $md5->hexdigest;
  	$md5->reset;
  	$md5->add(join(":", @digest[0..1], $content));
  	$md5->reset;
  	$resp{"message-digest"} = $md5->hexdigest;
  	push(@order, "message-digest");
      }
      push(@order, "opaque");
      my @pairs;
      for (@order) {
  	next unless defined $resp{$_};
  
  	# RFC2617 says that qop-value and nc-value should be unquoted.
  	if ( $_ eq 'qop' || $_ eq 'nc' ) {
  		push(@pairs, "$_=" . $resp{$_});
  	}
  	else {
  		push(@pairs, "$_=" . qq("$resp{$_}"));
  	}
      }
  
      my $auth_value  = "Digest " . join(", ", @pairs);
      return $auth_value;
  }
  
  1;
LWP_AUTHEN_DIGEST

$fatpacked{"LWP/Authen/Ntlm.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LWP_AUTHEN_NTLM';
  package LWP::Authen::Ntlm;
  
  use strict;
  
  our $VERSION = '6.23';
  
  use Authen::NTLM "1.02";
  use MIME::Base64 "2.12";
  
  sub authenticate {
      my($class, $ua, $proxy, $auth_param, $response,
         $request, $arg, $size) = @_;
  
      my($user, $pass) = $ua->get_basic_credentials($auth_param->{realm},
                                                    $request->uri, $proxy);
  
      unless(defined $user and defined $pass) {
  		return $response;
  	}
  
  	if (!$ua->conn_cache()) {
  		warn "The keep_alive option must be enabled for NTLM authentication to work.  NTLM authentication aborted.\n";
  		return $response;
  	}
  
  	my($domain, $username) = split(/\\/, $user);
  
  	ntlm_domain($domain);
  	ntlm_user($username);
  	ntlm_password($pass);
  
      my $auth_header = $proxy ? "Proxy-Authorization" : "Authorization";
  
  	# my ($challenge) = $response->header('WWW-Authenticate');
  	my $challenge;
  	foreach ($response->header('WWW-Authenticate')) {
  		last if /^NTLM/ && ($challenge=$_);
  	}
  
  	if ($challenge eq 'NTLM') {
  		# First phase, send handshake
  	    my $auth_value = "NTLM " . ntlm();
  		ntlm_reset();
  
  	    # Need to check this isn't a repeated fail!
  	    my $r = $response;
  		my $retry_count = 0;
  	    while ($r) {
  			my $auth = $r->request->header($auth_header);
  			++$retry_count if ($auth && $auth eq $auth_value);
  			if ($retry_count > 2) {
  				    # here we know this failed before
  				    $response->header("Client-Warning" =>
  						      "Credentials for '$user' failed before");
  				    return $response;
  			}
  			$r = $r->previous;
  	    }
  
  	    my $referral = $request->clone;
  	    $referral->header($auth_header => $auth_value);
  	    return $ua->request($referral, $arg, $size, $response);
  	}
  
  	else {
  		# Second phase, use the response challenge (unless non-401 code
  		#  was returned, in which case, we just send back the response
  		#  object, as is
  		my $auth_value;
  		if ($response->code ne '401') {
  			return $response;
  		}
  		else {
  			my $challenge;
  			foreach ($response->header('WWW-Authenticate')) {
  				last if /^NTLM/ && ($challenge=$_);
  			}
  			$challenge =~ s/^NTLM //;
  			ntlm();
  			$auth_value = "NTLM " . ntlm($challenge);
  			ntlm_reset();
  		}
  
  	    my $referral = $request->clone;
  	    $referral->header($auth_header => $auth_value);
  	    my $response2 = $ua->request($referral, $arg, $size, $response);
  		return $response2;
  	}
  }
  
  1;
  __END__
  
  =pod
  
  =head1 NAME
  
  LWP::Authen::Ntlm - Library for enabling NTLM authentication (Microsoft) in LWP
  
  =head1 SYNOPSIS
  
   use LWP::UserAgent;
   use HTTP::Request::Common;
   my $url = 'http://www.company.com/protected_page.html';
  
   # Set up the ntlm client and then the base64 encoded ntlm handshake message
   my $ua = LWP::UserAgent->new(keep_alive=>1);
   $ua->credentials('www.company.com:80', '', "MyDomain\\MyUserCode", 'MyPassword');
  
   $request = GET $url;
   print "--Performing request now...-----------\n";
   $response = $ua->request($request);
   print "--Done with request-------------------\n";
  
   if ($response->is_success) {print "It worked!->" . $response->code . "\n"}
   else {print "It didn't work!->" . $response->code . "\n"}
  
  =head1 DESCRIPTION
  
  L<LWP::Authen::Ntlm> allows LWP to authenticate against servers that are using the
  NTLM authentication scheme popularized by Microsoft.  This type of authentication is
  common on intranets of Microsoft-centric organizations.
  
  The module takes advantage of the Authen::NTLM module by Mark Bush.  Since there
  is also another Authen::NTLM module available from CPAN by Yee Man Chan with an
  entirely different interface, it is necessary to ensure that you have the correct
  NTLM module.
  
  In addition, there have been problems with incompatibilities between different
  versions of Mime::Base64, which Bush's Authen::NTLM makes use of.  Therefore, it is
  necessary to ensure that your Mime::Base64 module supports exporting of the
  encode_base64 and decode_base64 functions.
  
  =head1 USAGE
  
  The module is used indirectly through LWP, rather than including it directly in your
  code.  The LWP system will invoke the NTLM authentication when it encounters the
  authentication scheme while attempting to retrieve a URL from a server.  In order
  for the NTLM authentication to work, you must have a few things set up in your
  code prior to attempting to retrieve the URL:
  
  =over 4
  
  =item *
  
  Enable persistent HTTP connections
  
  To do this, pass the "keep_alive=>1" option to the LWP::UserAgent when creating it, like this:
  
      my $ua = LWP::UserAgent->new(keep_alive=>1);
  
  =item *
  
  Set the credentials on the UserAgent object
  
  The credentials must be set like this:
  
     $ua->credentials('www.company.com:80', '', "MyDomain\\MyUserCode", 'MyPassword');
  
  Note that you cannot use the HTTP::Request object's authorization_basic() method to set
  the credentials.  Note, too, that the 'www.company.com:80' portion only sets credentials
  on the specified port AND it is case-sensitive (this is due to the way LWP is coded, and
  has nothing to do with LWP::Authen::Ntlm)
  
  =back
  
  =head1 AVAILABILITY
  
  General queries regarding LWP should be made to the LWP Mailing List.
  
  Questions specific to LWP::Authen::Ntlm can be forwarded to jtillman@bigfoot.com
  
  =head1 COPYRIGHT
  
  Copyright (c) 2002 James Tillman. All rights reserved. This
  program is free software; you can redistribute it and/or modify it
  under the same terms as Perl itself.
  
  =head1 SEE ALSO
  
  L<LWP>, L<LWP::UserAgent>, L<lwpcook>.
  
  =cut
LWP_AUTHEN_NTLM

$fatpacked{"LWP/ConnCache.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LWP_CONNCACHE';
  package LWP::ConnCache;
  
  use strict;
  
  our $VERSION = '6.23';
  our $DEBUG;
  
  sub new {
      my($class, %cnf) = @_;
  
      my $total_capacity = 1;
      if (exists $cnf{total_capacity}) {
          $total_capacity = delete $cnf{total_capacity};
      }
      if (%cnf && $^W) {
  	require Carp;
  	Carp::carp("Unrecognised options: @{[sort keys %cnf]}")
      }
      my $self = bless { cc_conns => [] }, $class;
      $self->total_capacity($total_capacity);
      $self;
  }
  
  
  sub deposit {
      my($self, $type, $key, $conn) = @_;
      push(@{$self->{cc_conns}}, [$conn, $type, $key, time]);
      $self->enforce_limits($type);
      return;
  }
  
  
  sub withdraw {
      my($self, $type, $key) = @_;
      my $conns = $self->{cc_conns};
      for my $i (0 .. @$conns - 1) {
  	my $c = $conns->[$i];
  	next unless $c->[1] eq $type && $c->[2] eq $key;
  	splice(@$conns, $i, 1);  # remove it
  	return $c->[0];
      }
      return undef;
  }
  
  
  sub total_capacity {
      my $self = shift;
      my $old = $self->{cc_limit_total};
      if (@_) {
  	$self->{cc_limit_total} = shift;
  	$self->enforce_limits;
      }
      $old;
  }
  
  
  sub capacity {
      my $self = shift;
      my $type = shift;
      my $old = $self->{cc_limit}{$type};
      if (@_) {
  	$self->{cc_limit}{$type} = shift;
  	$self->enforce_limits($type);
      }
      $old;
  }
  
  
  sub enforce_limits {
      my($self, $type) = @_;
      my $conns = $self->{cc_conns};
  
      my @types = $type ? ($type) : ($self->get_types);
      for $type (@types) {
  	next unless $self->{cc_limit};
  	my $limit = $self->{cc_limit}{$type};
  	next unless defined $limit;
  	for my $i (reverse 0 .. @$conns - 1) {
  	    next unless $conns->[$i][1] eq $type;
  	    if (--$limit < 0) {
  		$self->dropping(splice(@$conns, $i, 1), "$type capacity exceeded");
  	    }
  	}
      }
  
      if (defined(my $total = $self->{cc_limit_total})) {
  	while (@$conns > $total) {
  	    $self->dropping(shift(@$conns), "Total capacity exceeded");
  	}
      }
  }
  
  
  sub dropping {
      my($self, $c, $reason) = @_;
      print "DROPPING @$c [$reason]\n" if $DEBUG;
  }
  
  
  sub drop {
      my($self, $checker, $reason) = @_;
      if (ref($checker) ne "CODE") {
  	# make it so
  	if (!defined $checker) {
  	    $checker = sub { 1 };  # drop all of them
  	}
  	elsif (_looks_like_number($checker)) {
  	    my $age_limit = $checker;
  	    my $time_limit = time - $age_limit;
  	    $reason ||= "older than $age_limit";
  	    $checker = sub { $_[3] < $time_limit };
  	}
  	else {
  	    my $type = $checker;
  	    $reason ||= "drop $type";
  	    $checker = sub { $_[1] eq $type };  # match on type
  	}
      }
      $reason ||= "drop";
  
      local $SIG{__DIE__};  # don't interfere with eval below
      local $@;
      my @c;
      for (@{$self->{cc_conns}}) {
  	my $drop;
  	eval {
  	    if (&$checker(@$_)) {
  		$self->dropping($_, $reason);
  		$drop++;
  	    }
  	};
  	push(@c, $_) unless $drop;
      }
      @{$self->{cc_conns}} = @c;
  }
  
  
  sub prune {
      my $self = shift;
      $self->drop(sub { !shift->ping }, "ping");
  }
  
  
  sub get_types {
      my $self = shift;
      my %t;
      $t{$_->[1]}++ for @{$self->{cc_conns}};
      return keys %t;
  }
  
  
  sub get_connections {
      my($self, $type) = @_;
      my @c;
      for (@{$self->{cc_conns}}) {
  	push(@c, $_->[0]) if !$type || ($type && $type eq $_->[1]);
      }
      @c;
  }
  
  
  sub _looks_like_number {
      $_[0] =~ /^([+-]?)(?=\d|\.\d)\d*(\.\d*)?([Ee]([+-]?\d+))?$/;
  }
  
  1;
  
  
  __END__
  
  =pod
  
  =head1 NAME
  
  LWP::ConnCache - Connection cache manager
  
  =head1 NOTE
  
  This module is experimental.  Details of its interface is likely to
  change in the future.
  
  =head1 SYNOPSIS
  
   use LWP::ConnCache;
   my $cache = LWP::ConnCache->new;
   $cache->deposit($type, $key, $sock);
   $sock = $cache->withdraw($type, $key);
  
  =head1 DESCRIPTION
  
  The C<LWP::ConnCache> class is the standard connection cache manager
  for L<LWP::UserAgent>.
  
  =head1 METHODS
  
  The following basic methods are provided:
  
  =head2 new
  
      my $cache = LWP::ConnCache->new( %options )
  
  This method constructs a new L<LWP::ConnCache> object.  The only
  option currently accepted is C<total_capacity>.  If specified it
  initialize the L<LWP::ConnCache/total_capacity> option. It defaults to C<1>.
  
  =head2 total_capacity
  
      my $cap = $cache->total_capacity;
      $cache->total_capacity(0); # drop all immediately
      $cache->total_capacity(undef); # no limit
      $cache->total_capacity($number);
  
  Get/sets the number of connection that will be cached.  Connections
  will start to be dropped when this limit is reached.  If set to C<0>,
  then all connections are immediately dropped.  If set to C<undef>,
  then there is no limit.
  
  =head2 capacity
  
      my $http_capacity = $cache->capacity('http');
      $cache->capacity('http', 2 );
  
  Get/set a limit for the number of connections of the specified type
  that can be cached.  The first parameter is a short string like
  "http" or "ftp".
  
  =head2 drop
  
      $cache->drop(); # Drop ALL connections
      # which is just a synonym for:
      $cache->drop(sub{1}); # Drop ALL connections
      # drop all connections older than 22 seconds and add a reason for it!
      $cache->drop(22, "Older than 22 secs dropped");
      # which is just a synonym for:
      $cache->drop(sub {
          my ($conn, $type, $key, $deposit_time) = @_;
          if ($deposit_time < 22) {
              # true values drop the connection
              return 1;
          }
          # false values don't drop the connection
          return 0;
      }, "Older than 22 secs dropped" );
  
  Drop connections by some criteria.  The $checker argument is a
  subroutine that is called for each connection.  If the routine returns
  a TRUE value then the connection is dropped.  The routine is called
  with ($conn, $type, $key, $deposit_time) as arguments.
  
  Shortcuts: If the $checker argument is absent (or C<undef>) all cached
  connections are dropped.  If the $checker is a number then all
  connections untouched that the given number of seconds or more are
  dropped.  If $checker is a string then all connections of the given
  type are dropped.
  
  The C<reason> is passed on to the L<LWP::ConnCache/dropped> method.
  
  =head2 prune
  
      $cache->prune();
  
  Calling this method will drop all connections that are dead.  This is
  tested by calling the L<LWP::ConnCache/ping> method on the connections. If
  the L<LWP::ConnCache/ping> method exists and returns a false value, then the
  connection is dropped.
  
  =head2 get_types
  
      my @types = $cache->get_types();
  
  This returns all the C<type> fields used for the currently cached
  connections.
  
  =head2 get_connections
  
      my @conns = $cache->get_connections(); # all connections
      my @conns = $cache->get_connections('http'); # connections for http
  
  This returns all connection objects of the specified type.  If no type
  is specified then all connections are returned.  In scalar context the
  number of cached connections of the specified type is returned.
  
  =head1 PROTOCOL METHODS
  
  The following methods are called by low-level protocol modules to
  try to save away connections and to get them back.
  
  =head2 deposit
  
      $cache->deposit($type, $key, $conn);
  
  This method adds a new connection to the cache.  As a result, other
  already cached connections might be dropped.  Multiple connections with
  the same type/key might be added.
  
  =head2 withdraw
  
      my $conn = $cache->withdraw($type, $key);
  
  This method tries to fetch back a connection that was previously
  deposited.  If no cached connection with the specified $type/$key is
  found, then C<undef> is returned.  There is not guarantee that a
  deposited connection can be withdrawn, as the cache manger is free to
  drop connections at any time.
  
  =head1 INTERNAL METHODS
  
  The following methods are called internally.  Subclasses might want to
  override them.
  
  =head2 enforce_limits
  
      $conn->enforce_limits([$type])
  
  This method is called with after a new connection is added (deposited)
  in the cache or capacity limits are adjusted.  The default
  implementation drops connections until the specified capacity limits
  are not exceeded.
  
  =head2 dropping
  
      $conn->dropping($conn_record, $reason)
  
  This method is called when a connection is dropped.  The record
  belonging to the dropped connection is passed as the first argument
  and a string describing the reason for the drop is passed as the
  second argument.  The default implementation makes some noise if the
  C<$LWP::ConnCache::DEBUG> variable is set and nothing more.
  
  =head1 SUBCLASSING
  
  For specialized cache policy it makes sense to subclass
  C<LWP::ConnCache> and perhaps override the L<LWP::ConnCache/deposit>,
  L<LWP::ConnCache/enforce_limits>, and L<LWP::ConnCache/dropping> methods.
  
  The object itself is a hash.  Keys prefixed with C<cc_> are reserved
  for the base class.
  
  =head1 SEE ALSO
  
  L<LWP::UserAgent>
  
  =head1 COPYRIGHT
  
  Copyright 2001 Gisle Aas.
  
  This library is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  =cut
LWP_CONNCACHE

$fatpacked{"LWP/Debug.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LWP_DEBUG';
  package LWP::Debug;    # legacy
  $LWP::Debug::VERSION = '6.23';
  require Exporter;
  our @ISA       = qw(Exporter);
  our @EXPORT_OK = qw(level trace debug conns);
  
  use Carp ();
  
  my @levels = qw(trace debug conns);
  our %current_level = ();
  
  sub import {
      my $pack    = shift;
      my $callpkg = caller(0);
      my @symbols = ();
      my @levels  = ();
      for (@_) {
          if (/^[-+]/) {
              push(@levels, $_);
          }
          else {
              push(@symbols, $_);
          }
      }
      Exporter::export($pack, $callpkg, @symbols);
      level(@levels);
  }
  
  sub level {
      for (@_) {
          if ($_ eq '+') {    # all on
                              # switch on all levels
              %current_level = map { $_ => 1 } @levels;
          }
          elsif ($_ eq '-') {    # all off
              %current_level = ();
          }
          elsif (/^([-+])(\w+)$/) {
              $current_level{$2} = $1 eq '+';
          }
          else {
              Carp::croak("Illegal level format $_");
          }
      }
  }
  
  sub trace { _log(@_) if $current_level{'trace'}; }
  sub debug { _log(@_) if $current_level{'debug'}; }
  sub conns { _log(@_) if $current_level{'conns'}; }
  
  sub _log {
      my $msg = shift;
      $msg .= "\n" unless $msg =~ /\n$/;    # ensure trailing "\n"
  
      my ($package, $filename, $line, $sub) = caller(2);
      print STDERR "$sub: $msg";
  }
  
  1;
  
  __END__
  
  =pod
  
  =head1 NAME
  
  LWP::Debug - deprecated
  
  =head1 DESCRIPTION
  
  LWP::Debug is used to provide tracing facilities, but these are not used
  by LWP any more.  The code in this module is kept around
  (undocumented) so that 3rd party code that happens to use the old
  interfaces continue to run.
  
  One useful feature that LWP::Debug provided (in an imprecise and
  troublesome way) was network traffic monitoring.  The following
  section provides some hints about recommended replacements.
  
  =head2 Network traffic monitoring
  
  The best way to monitor the network traffic that LWP generates is to
  use an external TCP monitoring program.  The
  L<WireShark|http://www.wireshark.org/> program is highly recommended for this.
  
  Another approach it to use a debugging HTTP proxy server and make
  LWP direct all its traffic via this one.  Call C<< $ua->proxy >> to
  set it up and then just use LWP as before.
  
  For less precise monitoring needs just setting up a few simple
  handlers might do.  The following example sets up handlers to dump the
  request and response objects that pass through LWP:
  
    use LWP::UserAgent;
    $ua = LWP::UserAgent->new;
    $ua->default_header('Accept-Encoding' => scalar HTTP::Message::decodable());
  
    $ua->add_handler("request_send",  sub { shift->dump; return });
    $ua->add_handler("response_done", sub { shift->dump; return });
  
    $ua->get("http://www.example.com");
  
  =head1 SEE ALSO
  
  L<LWP::UserAgent>
  
  =cut
LWP_DEBUG

$fatpacked{"LWP/Debug/TraceHTTP.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LWP_DEBUG_TRACEHTTP';
  package LWP::Debug::TraceHTTP;
  $LWP::Debug::TraceHTTP::VERSION = '6.23';
  # Just call:
  #
  #   require LWP::Debug::TraceHTTP;
  #   LWP::Protocol::implementor('http', 'LWP::Debug::TraceHTTP');
  #
  # to use this module to trace all calls to the HTTP socket object in
  # programs that use LWP.
  
  use strict;
  use base 'LWP::Protocol::http';
  
  package LWP::Debug::TraceHTTP::Socket;
  $LWP::Debug::TraceHTTP::Socket::VERSION = '6.23';
  use Data::Dump 1.13;
  use Data::Dump::Trace qw(autowrap mcall);
  
  autowrap("LWP::Protocol::http::Socket" => "sock");
  
  sub new {
      my $class = shift;
      return mcall("LWP::Protocol::http::Socket" => "new", undef, @_);
  }
  
  1;
LWP_DEBUG_TRACEHTTP

$fatpacked{"LWP/DebugFile.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LWP_DEBUGFILE';
  package LWP::DebugFile;
  $LWP::DebugFile::VERSION = '6.23';
  # legacy stub
  
  1;
LWP_DEBUGFILE

$fatpacked{"LWP/MemberMixin.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LWP_MEMBERMIXIN';
  package LWP::MemberMixin;
  $LWP::MemberMixin::VERSION = '6.23';
  sub _elem {
      my $self = shift;
      my $elem = shift;
      my $old  = $self->{$elem};
      $self->{$elem} = shift if @_;
      return $old;
  }
  
  1;
  
  __END__
  
  =pod
  
  =head1 NAME
  
  LWP::MemberMixin - Member access mixin class
  
  =head1 SYNOPSIS
  
   package Foo;
   use base qw(LWP::MemberMixin);
  
  =head1 DESCRIPTION
  
  A mixin class to get methods that provide easy access to member
  variables in the C<%$self>.
  Ideally there should be better Perl language support for this.
  
  =head1 METHODS
  
  There is only one method provided:
  
  =head2 _elem
  
      _elem($elem [, $val])
  
  Internal method to get/set the value of member variable
  C<$elem>. If C<$val> is present it is used as the new value
  for the member variable.  If it is not present the current
  value is not touched. In both cases the previous value of
  the member variable is returned.
  
  =cut
LWP_MEMBERMIXIN

$fatpacked{"LWP/Protocol.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LWP_PROTOCOL';
  package LWP::Protocol;
  
  use base 'LWP::MemberMixin';
  
  our $VERSION = '6.23';
  
  use strict;
  use Carp ();
  use HTTP::Status ();
  use HTTP::Response ();
  use Try::Tiny qw(try catch);
  
  my %ImplementedBy = (); # scheme => classname
  
  sub new
  {
      my($class, $scheme, $ua) = @_;
  
      my $self = bless {
  	scheme => $scheme,
  	ua => $ua,
  
  	# historical/redundant
          max_size => $ua->{max_size},
      }, $class;
  
      $self;
  }
  
  
  sub create
  {
      my($scheme, $ua) = @_;
      my $impclass = LWP::Protocol::implementor($scheme) or
  	Carp::croak("Protocol scheme '$scheme' is not supported");
  
      # hand-off to scheme specific implementation sub-class
      my $protocol = $impclass->new($scheme, $ua);
  
      return $protocol;
  }
  
  
  sub implementor
  {
      my($scheme, $impclass) = @_;
  
      if ($impclass) {
  	$ImplementedBy{$scheme} = $impclass;
      }
      my $ic = $ImplementedBy{$scheme};
      return $ic if $ic;
  
      return '' unless $scheme =~ /^([.+\-\w]+)$/;  # check valid URL schemes
      $scheme = $1; # untaint
      $scheme =~ s/[.+\-]/_/g;  # make it a legal module name
  
      # scheme not yet known, look for a 'use'd implementation
      $ic = "LWP::Protocol::$scheme";  # default location
      $ic = "LWP::Protocol::nntp" if $scheme eq 'news'; #XXX ugly hack
      no strict 'refs';
      # check we actually have one for the scheme:
      unless (@{"${ic}::ISA"}) {
          # try to autoload it
          try {
              (my $class = $ic) =~ s{::}{/}g;
              $class .= '.pm' unless $class =~ /\.pm$/;
              require $class;
          }
          catch {
              my $error = $_;
              if ($error =~ /Can't locate/) {
                  $ic = '';
              }
              else {
                  die "$error\n";
              }
          };
      }
      $ImplementedBy{$scheme} = $ic if $ic;
      $ic;
  }
  
  
  sub request
  {
      my($self, $request, $proxy, $arg, $size, $timeout) = @_;
      Carp::croak('LWP::Protocol::request() needs to be overridden in subclasses');
  }
  
  
  # legacy
  sub timeout    { shift->_elem('timeout',    @_); }
  sub max_size   { shift->_elem('max_size',   @_); }
  
  
  sub collect
  {
      my ($self, $arg, $response, $collector) = @_;
      my $content;
      my($ua, $max_size) = @{$self}{qw(ua max_size)};
  
      try {
          local $\; # protect the print below from surprises
          if (!defined($arg) || !$response->is_success) {
              $response->{default_add_content} = 1;
          }
          elsif (!ref($arg) && length($arg)) {
              open(my $fh, ">", $arg) or die "Can't write to '$arg': $!";
  	    binmode($fh);
              push(@{$response->{handlers}{response_data}}, {
                  callback => sub {
                      print $fh $_[3] or die "Can't write to '$arg': $!";
                      1;
                  },
              });
              push(@{$response->{handlers}{response_done}}, {
                  callback => sub {
  		    close($fh) or die "Can't write to '$arg': $!";
  		    undef($fh);
  		},
  	    });
          }
          elsif (ref($arg) eq 'CODE') {
              push(@{$response->{handlers}{response_data}}, {
                  callback => sub {
  		    &$arg($_[3], $_[0], $self);
  		    1;
                  },
              });
          }
          else {
              die "Unexpected collect argument '$arg'";
          }
  
          $ua->run_handlers("response_header", $response);
  
          if (delete $response->{default_add_content}) {
              push(@{$response->{handlers}{response_data}}, {
  		callback => sub {
  		    $_[0]->add_content($_[3]);
  		    1;
  		},
  	    });
          }
  
  
          my $content_size = 0;
          my $length = $response->content_length;
          my %skip_h;
  
          while ($content = &$collector, length $$content) {
              for my $h ($ua->handlers("response_data", $response)) {
                  next if $skip_h{$h};
                  unless ($h->{callback}->($response, $ua, $h, $$content)) {
                      # XXX remove from $response->{handlers}{response_data} if present
                      $skip_h{$h}++;
                  }
              }
              $content_size += length($$content);
              $ua->progress(($length ? ($content_size / $length) : "tick"), $response);
              if (defined($max_size) && $content_size > $max_size) {
                  $response->push_header("Client-Aborted", "max_size");
                  last;
              }
          }
      }
      catch {
          my $error = $_;
          chomp($error);
          $response->push_header('X-Died' => $error);
          $response->push_header("Client-Aborted", "die");
      };
      delete $response->{handlers}{response_data};
      delete $response->{handlers} unless %{$response->{handlers}};
      return $response;
  }
  
  
  sub collect_once
  {
      my($self, $arg, $response) = @_;
      my $content = \ $_[3];
      my $first = 1;
      $self->collect($arg, $response, sub {
  	return $content if $first--;
  	return \ "";
      });
  }
  
  1;
  
  
  __END__
  
  =pod
  
  =head1 NAME
  
  LWP::Protocol - Base class for LWP protocols
  
  =head1 SYNOPSIS
  
   package LWP::Protocol::foo;
   use base qw(LWP::Protocol);
  
  =head1 DESCRIPTION
  
  This class is used as the base class for all protocol implementations
  supported by the LWP library.
  
  When creating an instance of this class using
  C<LWP::Protocol::create($url)>, and you get an initialized subclass
  appropriate for that access method. In other words, the
  L<LWP::Protocol/create> function calls the constructor for one of its
  subclasses.
  
  All derived C<LWP::Protocol> classes need to override the request()
  method which is used to service a request. The overridden method can
  make use of the collect() function to collect together chunks of data
  as it is received.
  
  =head1 METHODS
  
  The following methods and functions are provided:
  
  =head2 new
  
      my $prot = LWP::Protocol->new();
  
  The LWP::Protocol constructor is inherited by subclasses. As this is a
  virtual base class this method should B<not> be called directly.
  
  =head2 create
  
      my $prot = LWP::Protocol::create($scheme)
  
  Create an object of the class implementing the protocol to handle the
  given scheme. This is a function, not a method. It is more an object
  factory than a constructor. This is the function user agents should
  use to access protocols.
  
  =head2 implementor
  
      my $class = LWP::Protocol::implementor($scheme, [$class])
  
  Get and/or set implementor class for a scheme.  Returns C<''> if the
  specified scheme is not supported.
  
  =head2 request
  
      $response = $protocol->request($request, $proxy, undef);
      $response = $protocol->request($request, $proxy, '/tmp/sss');
      $response = $protocol->request($request, $proxy, \&callback, 1024);
  
  Dispatches a request over the protocol, and returns a response
  object. This method needs to be overridden in subclasses.  Refer to
  L<LWP::UserAgent> for description of the arguments.
  
  =head2 collect
  
      my $res = $prot->collect(undef, $response, $collector); # stored in $response
      my $res = $prot->collect($filename, $response, $collector);
      my $res = $prot->collect(sub { ... }, $response, $collector);
  
  Collect the content of a request, and process it appropriately into a scalar,
  file, or by calling a callback. If the first parameter is undefined, then the
  content is stored within the C<$response>. If it's a simple scalar, then it's
  interpreted as a file name and the content is written to this file.  If it's a
  code reference, then content is passed to this routine.
  
  The collector is a routine that will be called and which is
  responsible for returning pieces (as ref to scalar) of the content to
  process.  The C<$collector> signals C<EOF> by returning a reference to an
  empty string.
  
  The return value is the L<HTTP::Response> object reference.
  
  B<Note:> We will only use the callback or file argument if
  C<< $response->is_success() >>.  This avoids sending content data for
  redirects and authentication responses to the callback which would be
  confusing.
  
  =head2 collect_once
  
      $prot->collect_once($arg, $response, $content)
  
  Can be called when the whole response content is available as content. This
  will invoke L<LWP::Protocol/collect> with a collector callback that
  returns a reference to C<$content> the first time and an empty string the
  next.
  
  =head1 SEE ALSO
  
  Inspect the F<LWP/Protocol/file.pm> and F<LWP/Protocol/http.pm> files
  for examples of usage.
  
  =head1 COPYRIGHT
  
  Copyright 1995-2001 Gisle Aas.
  
  This library is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  =cut
LWP_PROTOCOL

$fatpacked{"LWP/Protocol/cpan.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LWP_PROTOCOL_CPAN';
  package LWP::Protocol::cpan;
  $LWP::Protocol::cpan::VERSION = '6.23';
  use strict;
  
  use base qw(LWP::Protocol);
  
  require URI;
  require HTTP::Status;
  require HTTP::Response;
  
  our $CPAN;
  
  unless ($CPAN) {
      # Try to find local CPAN mirror via $CPAN::Config
      eval {
  	require CPAN::Config;
  	if($CPAN::Config) {
  	    my $urls = $CPAN::Config->{urllist};
  	    if (ref($urls) eq "ARRAY") {
  		my $file;
  		for (@$urls) {
  		    if (/^file:/) {
  			$file = $_;
  			last;
  		    }
  		}
  
  		if ($file) {
  		    $CPAN = $file;
  		}
  		else {
  		    $CPAN = $urls->[0];
  		}
  	    }
  	}
      };
  
      $CPAN ||= "http://cpan.org/";  # last resort
  }
  
  # ensure that we don't chop of last part
  $CPAN .= "/" unless $CPAN =~ m,/$,;
  
  
  sub request {
      my($self, $request, $proxy, $arg, $size) = @_;
      # check proxy
      if (defined $proxy)
      {
  	return HTTP::Response->new(HTTP::Status::RC_BAD_REQUEST,
  				   'You can not proxy with cpan');
      }
  
      # check method
      my $method = $request->method;
      unless ($method eq 'GET' || $method eq 'HEAD') {
  	return HTTP::Response->new(HTTP::Status::RC_BAD_REQUEST,
  				   'Library does not allow method ' .
  				   "$method for 'cpan:' URLs");
      }
  
      my $path = $request->uri->path;
      $path =~ s,^/,,;
  
      my $response = HTTP::Response->new(HTTP::Status::RC_FOUND);
      $response->header("Location" => URI->new_abs($path, $CPAN));
      $response;
  }
  
  1;
LWP_PROTOCOL_CPAN

$fatpacked{"LWP/Protocol/data.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LWP_PROTOCOL_DATA';
  package LWP::Protocol::data;
  $LWP::Protocol::data::VERSION = '6.23';
  # Implements access to data:-URLs as specified in RFC 2397
  
  use strict;
  
  require HTTP::Response;
  require HTTP::Status;
  
  use base qw(LWP::Protocol);
  
  use HTTP::Date qw(time2str);
  require LWP;  # needs version number
  
  sub request
  {
      my($self, $request, $proxy, $arg, $size) = @_;
  
      # check proxy
      if (defined $proxy)
      {
  	return HTTP::Response->new( HTTP::Status::RC_BAD_REQUEST,
  				  'You can not proxy with data');
      }
  
      # check method
      my $method = $request->method;
      unless ($method eq 'GET' || $method eq 'HEAD') {
  	return HTTP::Response->new( HTTP::Status::RC_BAD_REQUEST,
  				  'Library does not allow method ' .
  				  "$method for 'data:' URLs");
      }
  
      my $url = $request->uri;
      my $response = HTTP::Response->new( HTTP::Status::RC_OK, "Document follows");
  
      my $media_type = $url->media_type;
  
      my $data = $url->data;
      $response->header('Content-Type'   => $media_type,
  		      'Content-Length' => length($data),
  		      'Date'           => time2str(time),
  		      'Server'         => "libwww-perl-internal/$LWP::VERSION"
  		     );
  
      $data = "" if $method eq "HEAD";
      return $self->collect_once($arg, $response, $data);
  }
  
  1;
LWP_PROTOCOL_DATA

$fatpacked{"LWP/Protocol/file.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LWP_PROTOCOL_FILE';
  package LWP::Protocol::file;
  $LWP::Protocol::file::VERSION = '6.23';
  use base qw(LWP::Protocol);
  
  use strict;
  
  require LWP::MediaTypes;
  require HTTP::Request;
  require HTTP::Response;
  require HTTP::Status;
  require HTTP::Date;
  
  
  sub request
  {
      my($self, $request, $proxy, $arg, $size) = @_;
  
      $size = 4096 unless defined $size and $size > 0;
  
      # check proxy
      if (defined $proxy)
      {
  	return HTTP::Response->new( HTTP::Status::RC_BAD_REQUEST,
  				  'You can not proxy through the filesystem');
      }
  
      # check method
      my $method = $request->method;
      unless ($method eq 'GET' || $method eq 'HEAD') {
  	return HTTP::Response->new( HTTP::Status::RC_BAD_REQUEST,
  				  'Library does not allow method ' .
  				  "$method for 'file:' URLs");
      }
  
      # check url
      my $url = $request->uri;
  
      my $scheme = $url->scheme;
      if ($scheme ne 'file') {
  	return HTTP::Response->new( HTTP::Status::RC_INTERNAL_SERVER_ERROR,
  			   "LWP::Protocol::file::request called for '$scheme'");
      }
  
      # URL OK, look at file
      my $path  = $url->file;
  
      # test file exists and is readable
      unless (-e $path) {
  	return HTTP::Response->new( HTTP::Status::RC_NOT_FOUND,
  				  "File `$path' does not exist");
      }
      unless (-r _) {
  	return HTTP::Response->new( HTTP::Status::RC_FORBIDDEN,
  				  'User does not have read permission');
      }
  
      # looks like file exists
      my($dev,$ino,$mode,$nlink,$uid,$gid,$rdev,$filesize,
         $atime,$mtime,$ctime,$blksize,$blocks)
  	    = stat(_);
  
      # XXX should check Accept headers?
  
      # check if-modified-since
      my $ims = $request->header('If-Modified-Since');
      if (defined $ims) {
  	my $time = HTTP::Date::str2time($ims);
  	if (defined $time and $time >= $mtime) {
  	    return HTTP::Response->new( HTTP::Status::RC_NOT_MODIFIED,
  				      "$method $path");
  	}
      }
  
      # Ok, should be an OK response by now...
      my $response = HTTP::Response->new( HTTP::Status::RC_OK );
  
      # fill in response headers
      $response->header('Last-Modified', HTTP::Date::time2str($mtime));
  
      if (-d _) {         # If the path is a directory, process it
  	# generate the HTML for directory
  	opendir(D, $path) or
  	   return HTTP::Response->new( HTTP::Status::RC_INTERNAL_SERVER_ERROR,
  				     "Cannot read directory '$path': $!");
  	my(@files) = sort readdir(D);
  	closedir(D);
  
  	# Make directory listing
  	require URI::Escape;
  	require HTML::Entities;
          my $pathe = $path . ( $^O eq 'MacOS' ? ':' : '/');
  	for (@files) {
  	    my $furl = URI::Escape::uri_escape($_);
              if ( -d "$pathe$_" ) {
                  $furl .= '/';
                  $_ .= '/';
              }
  	    my $desc = HTML::Entities::encode($_);
  	    $_ = qq{<LI><A HREF="$furl">$desc</A>};
  	}
  	# Ensure that the base URL is "/" terminated
  	my $base = $url->clone;
  	unless ($base->path =~ m|/$|) {
  	    $base->path($base->path . "/");
  	}
  	my $html = join("\n",
  			"<HTML>\n<HEAD>",
  			"<TITLE>Directory $path</TITLE>",
  			"<BASE HREF=\"$base\">",
  			"</HEAD>\n<BODY>",
  			"<H1>Directory listing of $path</H1>",
  			"<UL>", @files, "</UL>",
  			"</BODY>\n</HTML>\n");
  
  	$response->header('Content-Type',   'text/html');
  	$response->header('Content-Length', length $html);
  	$html = "" if $method eq "HEAD";
  
  	return $self->collect_once($arg, $response, $html);
  
      }
  
      # path is a regular file
      $response->header('Content-Length', $filesize);
      LWP::MediaTypes::guess_media_type($path, $response);
  
      # read the file
      if ($method ne "HEAD") {
  	open(F, $path) or return new
  	    HTTP::Response(HTTP::Status::RC_INTERNAL_SERVER_ERROR,
  			   "Cannot read file '$path': $!");
  	binmode(F);
  	$response =  $self->collect($arg, $response, sub {
  	    my $content = "";
  	    my $bytes = sysread(F, $content, $size);
  	    return \$content if $bytes > 0;
  	    return \ "";
  	});
  	close(F);
      }
  
      $response;
  }
  
  1;
LWP_PROTOCOL_FILE

$fatpacked{"LWP/Protocol/ftp.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LWP_PROTOCOL_FTP';
  package LWP::Protocol::ftp;
  $LWP::Protocol::ftp::VERSION = '6.23';
  # Implementation of the ftp protocol (RFC 959). We let the Net::FTP
  # package do all the dirty work.
  
  use Carp ();
  
  use HTTP::Status ();
  use HTTP::Negotiate ();
  use HTTP::Response ();
  use LWP::MediaTypes ();
  use File::Listing ();
  
  use base qw(LWP::Protocol);
  
  use strict;
  eval {
      package LWP::Protocol::MyFTP;
  $LWP::Protocol::MyFTP::VERSION = '6.23';
  require Net::FTP;
      Net::FTP->require_version(2.00);
  
      use base qw(Net::FTP);
  
      sub new {
  	my $class = shift;
  
  	my $self = $class->SUPER::new(@_) || return undef;
  
  	my $mess = $self->message;  # welcome message
  	$mess =~ s|\n.*||s; # only first line left
  	$mess =~ s|\s*ready\.?$||;
  	# Make the version number more HTTP like
  	$mess =~ s|\s*\(Version\s*|/| and $mess =~ s|\)$||;
  	${*$self}{myftp_server} = $mess;
  	#$response->header("Server", $mess);
  
  	$self;
      }
  
      sub http_server {
  	my $self = shift;
  	${*$self}{myftp_server};
      }
  
      sub home {
  	my $self = shift;
  	my $old = ${*$self}{myftp_home};
  	if (@_) {
  	    ${*$self}{myftp_home} = shift;
  	}
  	$old;
      }
  
      sub go_home {
  	my $self = shift;
  	$self->cwd(${*$self}{myftp_home});
      }
  
      sub request_count {
  	my $self = shift;
  	++${*$self}{myftp_reqcount};
      }
  
      sub ping {
  	my $self = shift;
  	return $self->go_home;
      }
  
  };
  my $init_failed = $@;
  
  
  sub _connect {
      my($self, $host, $port, $user, $account, $password, $timeout) = @_;
  
      my $key;
      my $conn_cache = $self->{ua}{conn_cache};
      if ($conn_cache) {
  	$key = "$host:$port:$user";
  	$key .= ":$account" if defined($account);
  	if (my $ftp = $conn_cache->withdraw("ftp", $key)) {
  	    if ($ftp->ping) {
  		# save it again
  		$conn_cache->deposit("ftp", $key, $ftp);
  		return $ftp;
  	    }
  	}
      }
  
      # try to make a connection
      my $ftp = LWP::Protocol::MyFTP->new($host,
  					Port => $port,
  					Timeout => $timeout,
  					LocalAddr => $self->{ua}{local_address},
  				       );
      # XXX Should be some what to pass on 'Passive' (header??)
      unless ($ftp) {
  	$@ =~ s/^Net::FTP: //;
  	return HTTP::Response->new(HTTP::Status::RC_INTERNAL_SERVER_ERROR, $@);
      }
  
      unless ($ftp->login($user, $password, $account)) {
  	# Unauthorized.  Let's fake a RC_UNAUTHORIZED response
  	my $mess = scalar($ftp->message);
  	$mess =~ s/\n$//;
  	my $res =  HTTP::Response->new(HTTP::Status::RC_UNAUTHORIZED, $mess);
  	$res->header("Server", $ftp->http_server);
  	$res->header("WWW-Authenticate", qq(Basic Realm="FTP login"));
  	return $res;
      }
  
      my $home = $ftp->pwd;
      $ftp->home($home);
  
      $conn_cache->deposit("ftp", $key, $ftp) if $conn_cache;
  
      return $ftp;
  }
  
  
  sub request
  {
      my($self, $request, $proxy, $arg, $size, $timeout) = @_;
  
      $size = 4096 unless $size;
  
      # check proxy
      if (defined $proxy)
      {
  	return HTTP::Response->new(HTTP::Status::RC_BAD_REQUEST,
  				   'You can not proxy through the ftp');
      }
  
      my $url = $request->uri;
      if ($url->scheme ne 'ftp') {
  	my $scheme = $url->scheme;
  	return HTTP::Response->new(HTTP::Status::RC_INTERNAL_SERVER_ERROR,
  		       "LWP::Protocol::ftp::request called for '$scheme'");
      }
  
      # check method
      my $method = $request->method;
  
      unless ($method eq 'GET' || $method eq 'HEAD' || $method eq 'PUT') {
  	return HTTP::Response->new(HTTP::Status::RC_BAD_REQUEST,
  				   'Library does not allow method ' .
  				   "$method for 'ftp:' URLs");
      }
  
      if ($init_failed) {
  	return HTTP::Response->new(HTTP::Status::RC_INTERNAL_SERVER_ERROR,
  				   $init_failed);
      }
  
      my $host     = $url->host;
      my $port     = $url->port;
      my $user     = $url->user;
      my $password = $url->password;
  
      # If a basic authorization header is present than we prefer these over
      # the username/password specified in the URL.
      {
  	my($u,$p) = $request->authorization_basic;
  	if (defined $u) {
  	    $user = $u;
  	    $password = $p;
  	}
      }
  
      # We allow the account to be specified in the "Account" header
      my $account = $request->header('Account');
  
      my $ftp = $self->_connect($host, $port, $user, $account, $password, $timeout);
      return $ftp if ref($ftp) eq "HTTP::Response"; # ugh!
  
      # Create an initial response object
      my $response = HTTP::Response->new(HTTP::Status::RC_OK, "OK");
      $response->header(Server => $ftp->http_server);
      $response->header('Client-Request-Num' => $ftp->request_count);
      $response->request($request);
  
      # Get & fix the path
      my @path =  grep { length } $url->path_segments;
      my $remote_file = pop(@path);
      $remote_file = '' unless defined $remote_file;
  
      my $type;
      if (ref $remote_file) {
  	my @params;
  	($remote_file, @params) = @$remote_file;
  	for (@params) {
  	    $type = $_ if s/^type=//;
  	}
      }
  
      if ($type && $type eq 'a') {
  	$ftp->ascii;
      }
      else {
  	$ftp->binary;
      }
  
      for (@path) {
  	unless ($ftp->cwd($_)) {
  	    return HTTP::Response->new(HTTP::Status::RC_NOT_FOUND,
  				       "Can't chdir to $_");
  	}
      }
  
      if ($method eq 'GET' || $method eq 'HEAD') {
  	if (my $mod_time = $ftp->mdtm($remote_file)) {
  	    $response->last_modified($mod_time);
  	    if (my $ims = $request->if_modified_since) {
  		if ($mod_time <= $ims) {
  		    $response->code(HTTP::Status::RC_NOT_MODIFIED);
  		    $response->message("Not modified");
  		    return $response;
  		}
  	    }
  	}
  
  	# We'll use this later to abort the transfer if necessary.
  	# if $max_size is defined, we need to abort early. Otherwise, it's
        # a normal transfer
  	my $max_size = undef;
  
  	# Set resume location, if the client requested it
  	if ($request->header('Range') && $ftp->supported('REST'))
  	{
  		my $range_info = $request->header('Range');
  
  		# Change bytes=2772992-6781209 to just 2772992
  		my ($start_byte,$end_byte) = $range_info =~ /.*=\s*(\d+)-(\d+)?/;
  		if ( defined $start_byte && !defined $end_byte ) {
  
  		  # open range -- only the start is specified
  
  		  $ftp->restart( $start_byte );
  		  # don't define $max_size, we don't want to abort early
  		}
  		elsif ( defined $start_byte && defined $end_byte &&
  			$start_byte >= 0 && $end_byte >= $start_byte ) {
  
  		  $ftp->restart( $start_byte );
  		  $max_size = $end_byte - $start_byte;
  		}
  		else {
  
  		  return HTTP::Response->new(HTTP::Status::RC_BAD_REQUEST,
  		     'Incorrect syntax for Range request');
  		}
  	}
  	elsif ($request->header('Range') && !$ftp->supported('REST'))
  	{
  		return HTTP::Response->new(HTTP::Status::RC_NOT_IMPLEMENTED,
  	         "Server does not support resume.");
  	}
  
  	my $data;  # the data handle
  	if (length($remote_file) and $data = $ftp->retr($remote_file)) {
  	    my($type, @enc) = LWP::MediaTypes::guess_media_type($remote_file);
  	    $response->header('Content-Type',   $type) if $type;
  	    for (@enc) {
  		$response->push_header('Content-Encoding', $_);
  	    }
  	    my $mess = $ftp->message;
  	    if ($mess =~ /\((\d+)\s+bytes\)/) {
  		$response->header('Content-Length', "$1");
  	    }
  
  	    if ($method ne 'HEAD') {
  		# Read data from server
  		$response = $self->collect($arg, $response, sub {
  		    my $content = '';
  		    my $result = $data->read($content, $size);
  
                      # Stop early if we need to.
                      if (defined $max_size)
                      {
                        # We need an interface to Net::FTP::dataconn for getting
                        # the number of bytes already read
                        my $bytes_received = $data->bytes_read();
  
                        # We were already over the limit. (Should only happen
                        # once at the end.)
                        if ($bytes_received - length($content) > $max_size)
                        {
                          $content = '';
                        }
                        # We just went over the limit
                        elsif ($bytes_received  > $max_size)
                        {
                          # Trim content
                          $content = substr($content, 0,
                            $max_size - ($bytes_received - length($content)) );
                        }
                        # We're under the limit
                        else
                        {
                        }
                      }
  
  		    return \$content;
  		} );
  	    }
  	    # abort is needed for HEAD, it's == close if the transfer has
  	    # already completed.
  	    unless ($data->abort) {
  		# Something did not work too well.  Note that we treat
  		# responses to abort() with code 0 in case of HEAD as ok
  		# (at least wu-ftpd 2.6.1(1) does that).
  		if ($method ne 'HEAD' || $ftp->code != 0) {
  		    $response->code(HTTP::Status::RC_INTERNAL_SERVER_ERROR);
  		    $response->message("FTP close response: " . $ftp->code .
  				       " " . $ftp->message);
  		}
  	    }
  	}
  	elsif (!length($remote_file) || ( $ftp->code >= 400 && $ftp->code < 600 )) {
  	    # not a plain file, try to list instead
  	    if (length($remote_file) && !$ftp->cwd($remote_file)) {
  		return HTTP::Response->new(HTTP::Status::RC_NOT_FOUND,
  					   "File '$remote_file' not found");
  	    }
  
  	    # It should now be safe to try to list the directory
  	    my @lsl = $ftp->dir;
  
  	    # Try to figure out if the user want us to convert the
  	    # directory listing to HTML.
  	    my @variants =
  	      (
  	       ['html',  0.60, 'text/html'            ],
  	       ['dir',   1.00, 'text/ftp-dir-listing' ]
  	      );
  	    #$HTTP::Negotiate::DEBUG=1;
  	    my $prefer = HTTP::Negotiate::choose(\@variants, $request);
  
  	    my $content = '';
  
  	    if (!defined($prefer)) {
  		return HTTP::Response->new(HTTP::Status::RC_NOT_ACCEPTABLE,
  			       "Neither HTML nor directory listing wanted");
  	    }
  	    elsif ($prefer eq 'html') {
  		$response->header('Content-Type' => 'text/html');
  		$content = "<HEAD><TITLE>File Listing</TITLE>\n";
  		my $base = $request->uri->clone;
  		my $path = $base->path;
  		$base->path("$path/") unless $path =~ m|/$|;
  		$content .= qq(<BASE HREF="$base">\n</HEAD>\n);
  		$content .= "<BODY>\n<UL>\n";
  		for (File::Listing::parse_dir(\@lsl, 'GMT')) {
  		    my($name, $type, $size, $mtime, $mode) = @$_;
  		    $content .= qq(  <LI> <a href="$name">$name</a>);
  		    $content .= " $size bytes" if $type eq 'f';
  		    $content .= "\n";
  		}
  		$content .= "</UL></body>\n";
  	    }
  	    else {
  		$response->header('Content-Type', 'text/ftp-dir-listing');
  		$content = join("\n", @lsl, '');
  	    }
  
  	    $response->header('Content-Length', length($content));
  
  	    if ($method ne 'HEAD') {
  		$response = $self->collect_once($arg, $response, $content);
  	    }
  	}
  	else {
  	    my $res = HTTP::Response->new(HTTP::Status::RC_BAD_REQUEST,
  			  "FTP return code " . $ftp->code);
  	    $res->content_type("text/plain");
  	    $res->content($ftp->message);
  	    return $res;
  	}
      }
      elsif ($method eq 'PUT') {
  	# method must be PUT
  	unless (length($remote_file)) {
  	    return HTTP::Response->new(HTTP::Status::RC_BAD_REQUEST,
  				       "Must have a file name to PUT to");
  	}
  	my $data;
  	if ($data = $ftp->stor($remote_file)) {
  	    my $content = $request->content;
  	    my $bytes = 0;
  	    if (defined $content) {
  		if (ref($content) eq 'SCALAR') {
  		    $bytes = $data->write($$content, length($$content));
  		}
  		elsif (ref($content) eq 'CODE') {
  		    my($buf, $n);
  		    while (length($buf = &$content)) {
  			$n = $data->write($buf, length($buf));
  			last unless $n;
  			$bytes += $n;
  		    }
  		}
  		elsif (!ref($content)) {
  		    if (defined $content && length($content)) {
  			$bytes = $data->write($content, length($content));
  		    }
  		}
  		else {
  		    die "Bad content";
  		}
  	    }
  	    $data->close;
  
  	    $response->code(HTTP::Status::RC_CREATED);
  	    $response->header('Content-Type', 'text/plain');
  	    $response->content("$bytes bytes stored as $remote_file on $host\n")
  
  	}
  	else {
  	    my $res = HTTP::Response->new(HTTP::Status::RC_BAD_REQUEST,
  					  "FTP return code " . $ftp->code);
  	    $res->content_type("text/plain");
  	    $res->content($ftp->message);
  	    return $res;
  	}
      }
      else {
  	return HTTP::Response->new(HTTP::Status::RC_BAD_REQUEST,
  				   "Illegal method $method");
      }
  
      $response;
  }
  
  1;
  
  __END__
  
  # This is what RFC 1738 has to say about FTP access:
  # --------------------------------------------------
  #
  # 3.2. FTP
  #
  #    The FTP URL scheme is used to designate files and directories on
  #    Internet hosts accessible using the FTP protocol (RFC959).
  #
  #    A FTP URL follow the syntax described in Section 3.1.  If :<port> is
  #    omitted, the port defaults to 21.
  #
  # 3.2.1. FTP Name and Password
  #
  #    A user name and password may be supplied; they are used in the ftp
  #    "USER" and "PASS" commands after first making the connection to the
  #    FTP server.  If no user name or password is supplied and one is
  #    requested by the FTP server, the conventions for "anonymous" FTP are
  #    to be used, as follows:
  #
  #         The user name "anonymous" is supplied.
  #
  #         The password is supplied as the Internet e-mail address
  #         of the end user accessing the resource.
  #
  #    If the URL supplies a user name but no password, and the remote
  #    server requests a password, the program interpreting the FTP URL
  #    should request one from the user.
  #
  # 3.2.2. FTP url-path
  #
  #    The url-path of a FTP URL has the following syntax:
  #
  #         <cwd1>/<cwd2>/.../<cwdN>/<name>;type=<typecode>
  #
  #    Where <cwd1> through <cwdN> and <name> are (possibly encoded) strings
  #    and <typecode> is one of the characters "a", "i", or "d".  The part
  #    ";type=<typecode>" may be omitted. The <cwdx> and <name> parts may be
  #    empty. The whole url-path may be omitted, including the "/"
  #    delimiting it from the prefix containing user, password, host, and
  #    port.
  #
  #    The url-path is interpreted as a series of FTP commands as follows:
  #
  #       Each of the <cwd> elements is to be supplied, sequentially, as the
  #       argument to a CWD (change working directory) command.
  #
  #       If the typecode is "d", perform a NLST (name list) command with
  #       <name> as the argument, and interpret the results as a file
  #       directory listing.
  #
  #       Otherwise, perform a TYPE command with <typecode> as the argument,
  #       and then access the file whose name is <name> (for example, using
  #       the RETR command.)
  #
  #    Within a name or CWD component, the characters "/" and ";" are
  #    reserved and must be encoded. The components are decoded prior to
  #    their use in the FTP protocol.  In particular, if the appropriate FTP
  #    sequence to access a particular file requires supplying a string
  #    containing a "/" as an argument to a CWD or RETR command, it is
  #    necessary to encode each "/".
  #
  #    For example, the URL <URL:ftp://myname@host.dom/%2Fetc/motd> is
  #    interpreted by FTP-ing to "host.dom", logging in as "myname"
  #    (prompting for a password if it is asked for), and then executing
  #    "CWD /etc" and then "RETR motd". This has a different meaning from
  #    <URL:ftp://myname@host.dom/etc/motd> which would "CWD etc" and then
  #    "RETR motd"; the initial "CWD" might be executed relative to the
  #    default directory for "myname". On the other hand,
  #    <URL:ftp://myname@host.dom//etc/motd>, would "CWD " with a null
  #    argument, then "CWD etc", and then "RETR motd".
  #
  #    FTP URLs may also be used for other operations; for example, it is
  #    possible to update a file on a remote file server, or infer
  #    information about it from the directory listings. The mechanism for
  #    doing so is not spelled out here.
  #
  # 3.2.3. FTP Typecode is Optional
  #
  #    The entire ;type=<typecode> part of a FTP URL is optional. If it is
  #    omitted, the client program interpreting the URL must guess the
  #    appropriate mode to use. In general, the data content type of a file
  #    can only be guessed from the name, e.g., from the suffix of the name;
  #    the appropriate type code to be used for transfer of the file can
  #    then be deduced from the data content of the file.
  #
  # 3.2.4 Hierarchy
  #
  #    For some file systems, the "/" used to denote the hierarchical
  #    structure of the URL corresponds to the delimiter used to construct a
  #    file name hierarchy, and thus, the filename will look similar to the
  #    URL path. This does NOT mean that the URL is a Unix filename.
  #
  # 3.2.5. Optimization
  #
  #    Clients accessing resources via FTP may employ additional heuristics
  #    to optimize the interaction. For some FTP servers, for example, it
  #    may be reasonable to keep the control connection open while accessing
  #    multiple URLs from the same server. However, there is no common
  #    hierarchical model to the FTP protocol, so if a directory change
  #    command has been given, it is impossible in general to deduce what
  #    sequence should be given to navigate to another directory for a
  #    second retrieval, if the paths are different.  The only reliable
  #    algorithm is to disconnect and reestablish the control connection.
LWP_PROTOCOL_FTP

$fatpacked{"LWP/Protocol/gopher.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LWP_PROTOCOL_GOPHER';
  package LWP::Protocol::gopher;
  $LWP::Protocol::gopher::VERSION = '6.23';
  # Implementation of the gopher protocol (RFC 1436)
  #
  # This code is based on 'wwwgopher.pl,v 0.10 1994/10/17 18:12:34 shelden'
  # which in turn is a vastly modified version of Oscar's http'get()
  # dated 28/3/94 in <ftp://cui.unige.ch/PUBLIC/oscar/scripts/http.pl>
  # including contributions from Marc van Heyningen and Martijn Koster.
  
  use strict;
  
  require HTTP::Response;
  require HTTP::Status;
  require IO::Socket;
  require IO::Select;
  
  use base qw(LWP::Protocol);
  
  
  my %gopher2mimetype = (
      '0' => 'text/plain',                # 0 file
      '1' => 'text/html',                 # 1 menu
  					# 2 CSO phone-book server
  					# 3 Error
      '4' => 'application/mac-binhex40',  # 4 BinHexed Macintosh file
      '5' => 'application/zip',           # 5 DOS binary archive of some sort
      '6' => 'application/octet-stream',  # 6 UNIX uuencoded file.
      '7' => 'text/html',                 # 7 Index-Search server
  					# 8 telnet session
      '9' => 'application/octet-stream',  # 9 binary file
      'h' => 'text/html',                 # html
      'g' => 'image/gif',                 # gif
      'I' => 'image/*',                   # some kind of image
  );
  
  my %gopher2encoding = (
      '6' => 'x_uuencode',                # 6 UNIX uuencoded file.
  );
  
  sub request
  {
      my($self, $request, $proxy, $arg, $size, $timeout) = @_;
  
      $size = 4096 unless $size;
  
      # check proxy
      if (defined $proxy) {
  	return HTTP::Response->new(HTTP::Status::RC_BAD_REQUEST,
  				   'You can not proxy through the gopher');
      }
  
      my $url = $request->uri;
      die "bad scheme" if $url->scheme ne 'gopher';
  
  
      my $method = $request->method;
      unless ($method eq 'GET' || $method eq 'HEAD') {
  	return HTTP::Response->new(HTTP::Status::RC_BAD_REQUEST,
  				   'Library does not allow method ' .
  				   "$method for 'gopher:' URLs");
      }
  
      my $gophertype = $url->gopher_type;
      unless (exists $gopher2mimetype{$gophertype}) {
  	return HTTP::Response->new(HTTP::Status::RC_NOT_IMPLEMENTED,
  				   'Library does not support gophertype ' .
  				   $gophertype);
      }
  
      my $response = HTTP::Response->new(HTTP::Status::RC_OK, "OK");
      $response->header('Content-type' => $gopher2mimetype{$gophertype}
  					|| 'text/plain');
      $response->header('Content-Encoding' => $gopher2encoding{$gophertype})
  	if exists $gopher2encoding{$gophertype};
  
      if ($method eq 'HEAD') {
  	# XXX: don't even try it so we set this header
  	$response->header('Client-Warning' => 'Client answer only');
  	return $response;
      }
  
      if ($gophertype eq '7' && ! $url->search) {
        # the url is the prompt for a gopher search; supply boiler-plate
        return $self->collect_once($arg, $response, <<"EOT");
  <HEAD>
  <TITLE>Gopher Index</TITLE>
  <ISINDEX>
  </HEAD>
  <BODY>
  <H1>$url<BR>Gopher Search</H1>
  This is a searchable Gopher index.
  Use the search function of your browser to enter search terms.
  </BODY>
  EOT
      }
  
      my $host = $url->host;
      my $port = $url->port;
  
      my $requestLine = "";
  
      my $selector = $url->selector;
      if (defined $selector) {
  	$requestLine .= $selector;
  	my $search = $url->search;
  	if (defined $search) {
  	    $requestLine .= "\t$search";
  	    my $string = $url->string;
  	    if (defined $string) {
  		$requestLine .= "\t$string";
  	    }
  	}
      }
      $requestLine .= "\015\012";
  
      # potential request headers are just ignored
  
      # Ok, lets make the request
      my $socket = IO::Socket::INET->new(PeerAddr => $host,
  				       PeerPort => $port,
  				       LocalAddr => $self->{ua}{local_address},
  				       Proto    => 'tcp',
  				       Timeout  => $timeout);
      die "Can't connect to $host:$port" unless $socket;
      my $sel = IO::Select->new($socket);
  
      {
  	die "write timeout" if $timeout && !$sel->can_write($timeout);
  	my $n = syswrite($socket, $requestLine, length($requestLine));
  	die $! unless defined($n);
  	die "short write" if $n != length($requestLine);
      }
  
      my $user_arg = $arg;
  
      # must handle menus in a special way since they are to be
      # converted to HTML.  Undefing $arg ensures that the user does
      # not see the data before we get a change to convert it.
      $arg = undef if $gophertype eq '1' || $gophertype eq '7';
  
      # collect response
      my $buf = '';
      $response = $self->collect($arg, $response, sub {
  	die "read timeout" if $timeout && !$sel->can_read($timeout);
          my $n = sysread($socket, $buf, $size);
  	die $! unless defined($n);
  	return \$buf;
        } );
  
      # Convert menu to HTML and return data to user.
      if ($gophertype eq '1' || $gophertype eq '7') {
  	my $content = menu2html($response->content);
  	if (defined $user_arg) {
  	    $response = $self->collect_once($user_arg, $response, $content);
  	}
  	else {
  	    $response->content($content);
  	}
      }
  
      $response;
  }
  
  
  sub gopher2url
  {
      my($gophertype, $path, $host, $port) = @_;
  
      my $url;
  
      if ($gophertype eq '8' || $gophertype eq 'T') {
  	# telnet session
  	$url = $HTTP::URI_CLASS->new($gophertype eq '8' ? 'telnet:':'tn3270:');
  	$url->user($path) if defined $path;
      }
      else {
  	$path = URI::Escape::uri_escape($path);
  	$url = $HTTP::URI_CLASS->new("gopher:/$gophertype$path");
      }
      $url->host($host);
      $url->port($port);
      $url;
  }
  
  sub menu2html {
      my($menu) = @_;
  
      $menu =~ s/\015//g;  # remove carriage return
      my $tmp = <<"EOT";
  <HTML>
  <HEAD>
     <TITLE>Gopher menu</TITLE>
  </HEAD>
  <BODY>
  <H1>Gopher menu</H1>
  EOT
      for (split("\n", $menu)) {
  	last if /^\./;
  	my($pretty, $path, $host, $port) = split("\t");
  
  	$pretty =~ s/^(.)//;
  	my $type = $1;
  
  	my $url = gopher2url($type, $path, $host, $port)->as_string;
  	$tmp .= qq{<A HREF="$url">$pretty</A><BR>\n};
      }
      $tmp .= "</BODY>\n</HTML>\n";
      $tmp;
  }
  
  1;
LWP_PROTOCOL_GOPHER

$fatpacked{"LWP/Protocol/http.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LWP_PROTOCOL_HTTP';
  package LWP::Protocol::http;
  $LWP::Protocol::http::VERSION = '6.23';
  use strict;
  
  require HTTP::Response;
  require HTTP::Status;
  require Net::HTTP;
  
  use base qw(LWP::Protocol);
  
  our @EXTRA_SOCK_OPTS;
  my $CRLF = "\015\012";
  
  sub _new_socket
  {
      my($self, $host, $port, $timeout) = @_;
  
      # IPv6 literal IP address should be [bracketed] to remove
      # ambiguity between ip address and port number.
      if ( ($host =~ /:/) && ($host !~ /^\[/) ) {
        $host = "[$host]";
      }
  
      local($^W) = 0;  # IO::Socket::INET can be noisy
      my $sock = $self->socket_class->new(PeerAddr => $host,
  					PeerPort => $port,
  					LocalAddr => $self->{ua}{local_address},
  					Proto    => 'tcp',
  					Timeout  => $timeout,
  					KeepAlive => !!$self->{ua}{conn_cache},
  					SendTE    => 1,
  					$self->_extra_sock_opts($host, $port),
  				       );
  
      unless ($sock) {
  	# IO::Socket::INET leaves additional error messages in $@
  	my $status = "Can't connect to $host:$port";
  	if ($@ =~ /\bconnect: (.*)/ ||
  	    $@ =~ /\b(Bad hostname)\b/ ||
  	    $@ =~ /\b(nodename nor servname provided, or not known)\b/ ||
  	    $@ =~ /\b(certificate verify failed)\b/ ||
  	    $@ =~ /\b(Crypt-SSLeay can't verify hostnames)\b/
  	) {
  	    $status .= " ($1)";
  	}
  	die "$status\n\n$@";
      }
  
      # perl 5.005's IO::Socket does not have the blocking method.
      eval { $sock->blocking(0); };
  
      $sock;
  }
  
  sub socket_type
  {
      return "http";
  }
  
  sub socket_class
  {
      my $self = shift;
      (ref($self) || $self) . "::Socket";
  }
  
  sub _extra_sock_opts  # to be overridden by subclass
  {
      return @EXTRA_SOCK_OPTS;
  }
  
  sub _check_sock
  {
      #my($self, $req, $sock) = @_;
  }
  
  sub _get_sock_info
  {
      my($self, $res, $sock) = @_;
      if (defined(my $peerhost = $sock->peerhost)) {
          $res->header("Client-Peer" => "$peerhost:" . $sock->peerport);
      }
  }
  
  sub _fixup_header
  {
      my($self, $h, $url, $proxy) = @_;
  
      # Extract 'Host' header
      my $hhost = $url->authority;
      if ($hhost =~ s/^([^\@]*)\@//) {  # get rid of potential "user:pass@"
  	# add authorization header if we need them.  HTTP URLs do
  	# not really support specification of user and password, but
  	# we allow it.
  	if (defined($1) && not $h->header('Authorization')) {
  	    require URI::Escape;
  	    $h->authorization_basic(map URI::Escape::uri_unescape($_),
  				    split(":", $1, 2));
  	}
      }
      $h->init_header('Host' => $hhost);
  
      if ($proxy && $url->scheme ne 'https') {
  	# Check the proxy URI's userinfo() for proxy credentials
  	# export http_proxy="http://proxyuser:proxypass@proxyhost:port".
  	# For https only the initial CONNECT requests needs authorization.
  	my $p_auth = $proxy->userinfo();
  	if(defined $p_auth) {
  	    require URI::Escape;
  	    $h->proxy_authorization_basic(map URI::Escape::uri_unescape($_),
  					  split(":", $p_auth, 2))
  	}
      }
  }
  
  sub hlist_remove {
      my($hlist, $k) = @_;
      $k = lc $k;
      for (my $i = @$hlist - 2; $i >= 0; $i -= 2) {
  	next unless lc($hlist->[$i]) eq $k;
  	splice(@$hlist, $i, 2);
      }
  }
  
  sub request
  {
      my($self, $request, $proxy, $arg, $size, $timeout) = @_;
  
      $size ||= 4096;
  
      # check method
      my $method = $request->method;
      unless ($method =~ /^[A-Za-z0-9_!\#\$%&\'*+\-.^\`|~]+$/) {  # HTTP token
  	return HTTP::Response->new( HTTP::Status::RC_BAD_REQUEST,
  				  'Library does not allow method ' .
  				  "$method for 'http:' URLs");
      }
  
      my $url = $request->uri;
  
      # Proxying SSL with a http proxy needs issues a CONNECT request to build a
      # tunnel and then upgrades the tunnel to SSL. But when doing keep-alive the
      # https request does not need to be the first request in the connection, so
      # we need to distinguish between
      # - not yet connected (create socket and ssl upgrade)
      # - connected but not inside ssl tunnel (ssl upgrade)
      # - inside ssl tunnel to the target - once we are in the tunnel to the
      #   target we cannot only reuse the tunnel for more https requests with the
      #   same target
  
      my $ssl_tunnel = $proxy && $url->scheme eq 'https'
  	&& $url->host.":".$url->port;
  
      my ($host,$port) = $proxy
  	? ($proxy->host,$proxy->port)
  	: ($url->host,$url->port);
      my $fullpath =
  	$method eq 'CONNECT' ? $url->host . ":" . $url->port :
  	$proxy && ! $ssl_tunnel ? $url->as_string :
  	do {
  	    my $path = $url->path_query;
  	    $path = "/$path" if $path !~m{^/};
  	    $path
  	};
  
      my $socket;
      my $conn_cache = $self->{ua}{conn_cache};
      my $cache_key;
      if ( $conn_cache ) {
  	$cache_key = "$host:$port";
  	# For https we reuse the socket immediately only if it has an established
  	# tunnel to the target. Otherwise a CONNECT request followed by an SSL
  	# upgrade need to be done first. The request itself might reuse an
  	# existing non-ssl connection to the proxy
  	$cache_key .= "!".$ssl_tunnel if $ssl_tunnel;
  	if ( $socket = $conn_cache->withdraw($self->socket_type,$cache_key)) {
  	    if ($socket->can_read(0)) {
  		# if the socket is readable, then either the peer has closed the
  		# connection or there are some garbage bytes on it.  In either
  		# case we abandon it.
  		$socket->close;
  		$socket = undef;
  	    } # else use $socket
  	    else {
  		$socket->timeout($timeout);
  	    }
  	}
      }
  
      if ( ! $socket && $ssl_tunnel ) {
  	my $proto_https = LWP::Protocol::create('https',$self->{ua})
  	    or die "no support for scheme https found";
  
  	# only if ssl socket class is IO::Socket::SSL we can upgrade
  	# a plain socket to SSL. In case of Net::SSL we fall back to
  	# the old version
  	if ( my $upgrade_sub = $proto_https->can('_upgrade_sock')) {
  	    my $response = $self->request(
  		HTTP::Request->new('CONNECT',"http://$ssl_tunnel"),
  		$proxy,
  		undef,$size,$timeout
  	    );
  	    $response->is_success or die
  		"establishing SSL tunnel failed: ".$response->status_line;
  	    $socket = $upgrade_sub->($proto_https,
  		$response->{client_socket},$url)
  		or die "SSL upgrade failed: $@";
  	} else {
  	    $socket = $proto_https->_new_socket($url->host,$url->port,$timeout);
  	}
      }
  
      if ( ! $socket ) {
  	# connect to remote site w/o reusing established socket
  	$socket = $self->_new_socket($host, $port, $timeout );
      }
  
      my $http_version = "";
      if (my $proto = $request->protocol) {
  	if ($proto =~ /^(?:HTTP\/)?(1.\d+)$/) {
  	    $http_version = $1;
  	    $socket->http_version($http_version);
  	    $socket->send_te(0) if $http_version eq "1.0";
  	}
      }
  
      $self->_check_sock($request, $socket);
  
      my @h;
      my $request_headers = $request->headers->clone;
      $self->_fixup_header($request_headers, $url, $proxy);
  
      $request_headers->scan(sub {
  			       my($k, $v) = @_;
  			       $k =~ s/^://;
  			       $v =~ s/\n/ /g;
  			       push(@h, $k, $v);
  			   });
  
      my $content_ref = $request->content_ref;
      $content_ref = $$content_ref if ref($$content_ref);
      my $chunked;
      my $has_content;
  
      if (ref($content_ref) eq 'CODE') {
  	my $clen = $request_headers->header('Content-Length');
  	$has_content++ if $clen;
  	unless (defined $clen) {
  	    push(@h, "Transfer-Encoding" => "chunked");
  	    $has_content++;
  	    $chunked++;
  	}
      }
      else {
  	# Set (or override) Content-Length header
  	my $clen = $request_headers->header('Content-Length');
  	if (defined($$content_ref) && length($$content_ref)) {
  	    $has_content = length($$content_ref);
  	    if (!defined($clen) || $clen ne $has_content) {
  		if (defined $clen) {
  		    warn "Content-Length header value was wrong, fixed";
  		    hlist_remove(\@h, 'Content-Length');
  		}
  		push(@h, 'Content-Length' => $has_content);
  	    }
  	}
  	elsif ($clen) {
  	    warn "Content-Length set when there is no content, fixed";
  	    hlist_remove(\@h, 'Content-Length');
  	}
      }
  
      my $write_wait = 0;
      $write_wait = 2
  	if ($request_headers->header("Expect") || "") =~ /100-continue/;
  
      my $req_buf = $socket->format_request($method, $fullpath, @h);
      #print "------\n$req_buf\n------\n";
  
      if (!$has_content || $write_wait || $has_content > 8*1024) {
        WRITE:
          {
              # Since this just writes out the header block it should almost
              # always succeed to send the whole buffer in a single write call.
              my $n = $socket->syswrite($req_buf, length($req_buf));
              unless (defined $n) {
                  redo WRITE if $!{EINTR};
                  if ($!{EWOULDBLOCK} || $!{EAGAIN}) {
                      select(undef, undef, undef, 0.1);
                      redo WRITE;
                  }
                  die "write failed: $!";
              }
              if ($n) {
                  substr($req_buf, 0, $n, "");
              }
              else {
                  select(undef, undef, undef, 0.5);
              }
              redo WRITE if length $req_buf;
          }
      }
  
      my($code, $mess, @junk);
      my $drop_connection;
  
      if ($has_content) {
  	my $eof;
  	my $wbuf;
  	my $woffset = 0;
        INITIAL_READ:
  	if ($write_wait) {
  	    # skip filling $wbuf when waiting for 100-continue
  	    # because if the response is a redirect or auth required
  	    # the request will be cloned and there is no way
  	    # to reset the input stream
  	    # return here via the label after the 100-continue is read
  	}
  	elsif (ref($content_ref) eq 'CODE') {
  	    my $buf = &$content_ref();
  	    $buf = "" unless defined($buf);
  	    $buf = sprintf "%x%s%s%s", length($buf), $CRLF, $buf, $CRLF
  		if $chunked;
  	    substr($buf, 0, 0) = $req_buf if $req_buf;
  	    $wbuf = \$buf;
  	}
  	else {
  	    if ($req_buf) {
  		my $buf = $req_buf . $$content_ref;
  		$wbuf = \$buf;
  	    }
  	    else {
  		$wbuf = $content_ref;
  	    }
  	    $eof = 1;
  	}
  
  	my $fbits = '';
  	vec($fbits, fileno($socket), 1) = 1;
  
        WRITE:
  	while ($write_wait || $woffset < length($$wbuf)) {
  
  	    my $sel_timeout = $timeout;
  	    if ($write_wait) {
  		$sel_timeout = $write_wait if $write_wait < $sel_timeout;
  	    }
  	    my $time_before;
              $time_before = time if $sel_timeout;
  
  	    my $rbits = $fbits;
  	    my $wbits = $write_wait ? undef : $fbits;
              my $sel_timeout_before = $sel_timeout;
            SELECT:
              {
                  my $nfound = select($rbits, $wbits, undef, $sel_timeout);
                  if ($nfound < 0) {
                      if ($!{EINTR} || $!{EWOULDBLOCK} || $!{EAGAIN}) {
                          if ($time_before) {
                              $sel_timeout = $sel_timeout_before - (time - $time_before);
                              $sel_timeout = 0 if $sel_timeout < 0;
                          }
                          redo SELECT;
                      }
                      die "select failed: $!";
                  }
  	    }
  
  	    if ($write_wait) {
  		$write_wait -= time - $time_before;
  		$write_wait = 0 if $write_wait < 0;
  	    }
  
  	    if (defined($rbits) && $rbits =~ /[^\0]/) {
  		# readable
  		my $buf = $socket->_rbuf;
  		my $n = $socket->sysread($buf, 1024, length($buf));
                  unless (defined $n) {
                      die "read failed: $!" unless  $!{EINTR} || $!{EWOULDBLOCK} || $!{EAGAIN};
                      # if we get here the rest of the block will do nothing
                      # and we will retry the read on the next round
                  }
  		elsif ($n == 0) {
                      # the server closed the connection before we finished
                      # writing all the request content.  No need to write any more.
                      $drop_connection++;
                      last WRITE;
  		}
  		$socket->_rbuf($buf);
  		if (!$code && $buf =~ /\015?\012\015?\012/) {
  		    # a whole response header is present, so we can read it without blocking
  		    ($code, $mess, @h) = $socket->read_response_headers(laxed => 1,
  									junk_out => \@junk,
  								       );
  		    if ($code eq "100") {
  			$write_wait = 0;
  			undef($code);
  			goto INITIAL_READ;
  		    }
  		    else {
  			$drop_connection++;
  			last WRITE;
  			# XXX should perhaps try to abort write in a nice way too
  		    }
  		}
  	    }
  	    if (defined($wbits) && $wbits =~ /[^\0]/) {
  		my $n = $socket->syswrite($$wbuf, length($$wbuf), $woffset);
                  unless (defined $n) {
                      die "write failed: $!" unless $!{EINTR} || $!{EWOULDBLOCK} || $!{EAGAIN};
                      $n = 0;  # will retry write on the next round
                  }
                  elsif ($n == 0) {
  		    die "write failed: no bytes written";
  		}
  		$woffset += $n;
  
  		if (!$eof && $woffset >= length($$wbuf)) {
  		    # need to refill buffer from $content_ref code
  		    my $buf = &$content_ref();
  		    $buf = "" unless defined($buf);
  		    $eof++ unless length($buf);
  		    $buf = sprintf "%x%s%s%s", length($buf), $CRLF, $buf, $CRLF
  			if $chunked;
  		    $wbuf = \$buf;
  		    $woffset = 0;
  		}
  	    }
  	} # WRITE
      }
  
      ($code, $mess, @h) = $socket->read_response_headers(laxed => 1, junk_out => \@junk)
  	unless $code;
      ($code, $mess, @h) = $socket->read_response_headers(laxed => 1, junk_out => \@junk)
  	if $code eq "100";
  
      my $response = HTTP::Response->new($code, $mess);
      my $peer_http_version = $socket->peer_http_version;
      $response->protocol("HTTP/$peer_http_version");
      {
  	local $HTTP::Headers::TRANSLATE_UNDERSCORE;
  	$response->push_header(@h);
      }
      $response->push_header("Client-Junk" => \@junk) if @junk;
  
      $response->request($request);
      $self->_get_sock_info($response, $socket);
  
      if ($method eq "CONNECT") {
  	$response->{client_socket} = $socket;  # so it can be picked up
  	return $response;
      }
  
      if (my @te = $response->remove_header('Transfer-Encoding')) {
  	$response->push_header('Client-Transfer-Encoding', \@te);
      }
      $response->push_header('Client-Response-Num', scalar $socket->increment_response_count);
  
      my $complete;
      $response = $self->collect($arg, $response, sub {
  	my $buf = ""; #prevent use of uninitialized value in SSLeay.xs
  	my $n;
        READ:
  	{
  	    $n = $socket->read_entity_body($buf, $size);
              unless (defined $n) {
                  redo READ if $!{EINTR} || $!{EWOULDBLOCK} || $!{EAGAIN} || $!{ENOTTY};
                  die "read failed: $!";
              }
  	    redo READ if $n == -1;
  	}
  	$complete++ if !$n;
          return \$buf;
      } );
      $drop_connection++ unless $complete;
  
      @h = $socket->get_trailers;
      if (@h) {
  	local $HTTP::Headers::TRANSLATE_UNDERSCORE;
  	$response->push_header(@h);
      }
  
      # keep-alive support
      unless ($drop_connection) {
  	if ($cache_key) {
  	    my %connection = map { (lc($_) => 1) }
  		             split(/\s*,\s*/, ($response->header("Connection") || ""));
  	    if (($peer_http_version eq "1.1" && !$connection{close}) ||
  		$connection{"keep-alive"})
  	    {
  		$conn_cache->deposit($self->socket_type, $cache_key, $socket);
  	    }
  	}
      }
  
      $response;
  }
  
  
  #-----------------------------------------------------------
  package LWP::Protocol::http::SocketMethods;
  $LWP::Protocol::http::SocketMethods::VERSION = '6.23';
  sub ping {
      my $self = shift;
      !$self->can_read(0);
  }
  
  sub increment_response_count {
      my $self = shift;
      return ++${*$self}{'myhttp_response_count'};
  }
  
  #-----------------------------------------------------------
  package LWP::Protocol::http::Socket;
  $LWP::Protocol::http::Socket::VERSION = '6.23';
  use base qw(LWP::Protocol::http::SocketMethods Net::HTTP);
  
  1;
LWP_PROTOCOL_HTTP

$fatpacked{"LWP/Protocol/loopback.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LWP_PROTOCOL_LOOPBACK';
  package LWP::Protocol::loopback;
  $LWP::Protocol::loopback::VERSION = '6.23';
  use strict;
  require HTTP::Response;
  
  use base qw(LWP::Protocol);
  
  sub request {
      my($self, $request, $proxy, $arg, $size, $timeout) = @_;
  
      my $response = HTTP::Response->new(200, "OK");
      $response->content_type("message/http; msgtype=request");
  
      $response->header("Via", "loopback/1.0 $proxy")
  	if $proxy;
  
      $response->header("X-Arg", $arg);
      $response->header("X-Read-Size", $size);
      $response->header("X-Timeout", $timeout);
  
      return $self->collect_once($arg, $response, $request->as_string);
  }
  
  1;
LWP_PROTOCOL_LOOPBACK

$fatpacked{"LWP/Protocol/mailto.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LWP_PROTOCOL_MAILTO';
  package LWP::Protocol::mailto;
  $LWP::Protocol::mailto::VERSION = '6.23';
  # This module implements the mailto protocol.  It is just a simple
  # frontend to the Unix sendmail program except on MacOS, where it uses
  # Mail::Internet.
  
  require HTTP::Request;
  require HTTP::Response;
  require HTTP::Status;
  
  use Carp;
  use strict;
  
  use base qw(LWP::Protocol);
  our $SENDMAIL;
  
  unless ($SENDMAIL = $ENV{SENDMAIL}) {
      for my $sm (qw(/usr/sbin/sendmail
  		   /usr/lib/sendmail
  		   /usr/ucblib/sendmail
  		  ))
      {
  	if (-x $sm) {
  	    $SENDMAIL = $sm;
  	    last;
  	}
      }
      die "Can't find the 'sendmail' program" unless $SENDMAIL;
  }
  
  sub request
  {
      my($self, $request, $proxy, $arg, $size) = @_;
  
      my ($mail, $addr) if $^O eq "MacOS";
      my @text = () if $^O eq "MacOS";
  
      # check proxy
      if (defined $proxy)
      {
  	return HTTP::Response->new(HTTP::Status::RC_BAD_REQUEST,
  				  'You can not proxy with mail');
      }
  
      # check method
      my $method = $request->method;
  
      if ($method ne 'POST') {
  	return HTTP::Response->new( HTTP::Status::RC_BAD_REQUEST,
  				  'Library does not allow method ' .
  				  "$method for 'mailto:' URLs");
      }
  
      # check url
      my $url = $request->uri;
  
      my $scheme = $url->scheme;
      if ($scheme ne 'mailto') {
  	return HTTP::Response->new( HTTP::Status::RC_INTERNAL_SERVER_ERROR,
  			 "LWP::Protocol::mailto::request called for '$scheme'");
      }
      if ($^O eq "MacOS") {
  	eval {
  	    require Mail::Internet;
  	};
  	if($@) {
  	    return HTTP::Response->new( HTTP::Status::RC_INTERNAL_SERVER_ERROR,
  	               "You don't have MailTools installed");
  	}
  	unless ($ENV{SMTPHOSTS}) {
  	    return HTTP::Response->new( HTTP::Status::RC_INTERNAL_SERVER_ERROR,
  	               "You don't have SMTPHOSTS defined");
  	}
      }
      else {
  	unless (-x $SENDMAIL) {
  	    return HTTP::Response->new( HTTP::Status::RC_INTERNAL_SERVER_ERROR,
  	               "You don't have $SENDMAIL");
      }
      }
      if ($^O eq "MacOS") {
  	    $mail = Mail::Internet->new or
  	    return HTTP::Response->new( HTTP::Status::RC_INTERNAL_SERVER_ERROR,
  	    "Can't get a Mail::Internet object");
      }
      else {
  	open(SENDMAIL, "| $SENDMAIL -oi -t") or
  	    return HTTP::Response->new( HTTP::Status::RC_INTERNAL_SERVER_ERROR,
  	               "Can't run $SENDMAIL: $!");
      }
      if ($^O eq "MacOS") {
  	$addr = $url->encoded822addr;
      }
      else {
  	$request = $request->clone;  # we modify a copy
  	my @h = $url->headers;  # URL headers override those in the request
  	while (@h) {
  	    my $k = shift @h;
  	    my $v = shift @h;
  	    next unless defined $v;
  	    if (lc($k) eq "body") {
  		$request->content($v);
  	    }
  	    else {
  		$request->push_header($k => $v);
  	    }
  	}
      }
      if ($^O eq "MacOS") {
  	$mail->add(To => $addr);
  	$mail->add(split(/[:\n]/,$request->headers_as_string));
      }
      else {
  	print SENDMAIL $request->headers_as_string;
  	print SENDMAIL "\n";
      }
      my $content = $request->content;
      if (defined $content) {
  	my $contRef = ref($content) ? $content : \$content;
  	if (ref($contRef) eq 'SCALAR') {
  	    if ($^O eq "MacOS") {
  		@text = split("\n",$$contRef);
  		foreach (@text) {
  		    $_ .= "\n";
  		}
  	    }
  	    else {
  	    print SENDMAIL $$contRef;
  	    }
  
  	}
  	elsif (ref($contRef) eq 'CODE') {
  	    # Callback provides data
  	    my $d;
  	    if ($^O eq "MacOS") {
  		my $stuff = "";
  		while (length($d = &$contRef)) {
  		    $stuff .= $d;
  		}
  		@text = split("\n",$stuff);
  		foreach (@text) {
  		    $_ .= "\n";
  		}
  	    }
  	    else {
  		print SENDMAIL $d;
  	    }
  	}
      }
      if ($^O eq "MacOS") {
  	$mail->body(\@text);
  	unless ($mail->smtpsend) {
  	    return HTTP::Response->new(HTTP::Status::RC_INTERNAL_SERVER_ERROR,
  				       "Mail::Internet->smtpsend unable to send message to <$addr>");
  	}
      }
      else {
  	unless (close(SENDMAIL)) {
  	    my $err = $! ? "$!" : "Exit status $?";
  	    return HTTP::Response->new(HTTP::Status::RC_INTERNAL_SERVER_ERROR,
  				       "$SENDMAIL: $err");
  	}
      }
  
  
      my $response = HTTP::Response->new(HTTP::Status::RC_ACCEPTED,
  				       "Mail accepted");
      $response->header('Content-Type', 'text/plain');
      if ($^O eq "MacOS") {
  	$response->header('Server' => "Mail::Internet $Mail::Internet::VERSION");
  	$response->content("Message sent to <$addr>\n");
      }
      else {
  	$response->header('Server' => $SENDMAIL);
  	my $to = $request->header("To");
  	$response->content("Message sent to <$to>\n");
      }
  
      return $response;
  }
  
  1;
LWP_PROTOCOL_MAILTO

$fatpacked{"LWP/Protocol/nntp.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LWP_PROTOCOL_NNTP';
  package LWP::Protocol::nntp;
  $LWP::Protocol::nntp::VERSION = '6.23';
  # Implementation of the Network News Transfer Protocol (RFC 977)
  
  use base qw(LWP::Protocol);
  
  require HTTP::Response;
  require HTTP::Status;
  require Net::NNTP;
  
  use strict;
  
  
  sub request {
      my ($self, $request, $proxy, $arg, $size, $timeout) = @_;
  
      $size = 4096 unless $size;
  
      # Check for proxy
      if (defined $proxy) {
          return HTTP::Response->new(HTTP::Status::RC_BAD_REQUEST,
              'You can not proxy through NNTP');
      }
  
      # Check that the scheme is as expected
      my $url    = $request->uri;
      my $scheme = $url->scheme;
      unless ($scheme eq 'news' || $scheme eq 'nntp') {
          return HTTP::Response->new(HTTP::Status::RC_INTERNAL_SERVER_ERROR,
              "LWP::Protocol::nntp::request called for '$scheme'");
      }
  
      # check for a valid method
      my $method = $request->method;
      unless ($method eq 'GET' || $method eq 'HEAD' || $method eq 'POST') {
          return HTTP::Response->new(HTTP::Status::RC_BAD_REQUEST,
              'Library does not allow method ' . "$method for '$scheme:' URLs");
      }
  
      # extract the identifier and check against posting to an article
      my $groupart = $url->_group;
      my $is_art   = $groupart =~ /@/;
  
      if ($is_art && $method eq 'POST') {
          return HTTP::Response->new(HTTP::Status::RC_BAD_REQUEST,
              "Can't post to an article <$groupart>");
      }
  
      my $nntp = Net::NNTP->new(
          $url->host,
  
          #Port    => 18574,
          Timeout => $timeout,
  
          #Debug   => 1,
      );
      die "Can't connect to nntp server" unless $nntp;
  
      # Check the initial welcome message from the NNTP server
      if ($nntp->status != 2) {
          return HTTP::Response->new(HTTP::Status::RC_SERVICE_UNAVAILABLE,
              $nntp->message);
      }
      my $response = HTTP::Response->new(HTTP::Status::RC_OK, "OK");
  
      my $mess = $nntp->message;
  
      # Try to extract server name from greeting message.
      # Don't know if this works well for a large class of servers, but
      # this works for our server.
      $mess =~ s/\s+ready\b.*//;
      $mess =~ s/^\S+\s+//;
      $response->header(Server => $mess);
  
      # First we handle posting of articles
      if ($method eq 'POST') {
          $nntp->quit;
          $nntp = undef;
          $response->code(HTTP::Status::RC_NOT_IMPLEMENTED);
          $response->message("POST not implemented yet");
          return $response;
      }
  
      # The method must be "GET" or "HEAD" by now
      if (!$is_art) {
          if (!$nntp->group($groupart)) {
              $response->code(HTTP::Status::RC_NOT_FOUND);
              $response->message($nntp->message);
          }
          $nntp->quit;
          $nntp = undef;
  
          # HEAD: just check if the group exists
          if ($method eq 'GET' && $response->is_success) {
              $response->code(HTTP::Status::RC_NOT_IMPLEMENTED);
              $response->message("GET newsgroup not implemented yet");
          }
          return $response;
      }
  
      # Send command to server to retrieve an article (or just the headers)
      my $get = $method eq 'HEAD' ? "head" : "article";
      my $art = $nntp->$get("<$groupart>");
      unless ($art) {
          $nntp->quit;
          $response->code(HTTP::Status::RC_NOT_FOUND);
          $response->message($nntp->message);
          $nntp = undef;
          return $response;
      }
  
      # Parse headers
      my ($key, $val);
      local $_;
      while ($_ = shift @$art) {
          if (/^\s+$/) {
              last;    # end of headers
          }
          elsif (/^(\S+):\s*(.*)/) {
              $response->push_header($key, $val) if $key;
              ($key, $val) = ($1, $2);
          }
          elsif (/^\s+(.*)/) {
              next unless $key;
              $val .= $1;
          }
          else {
              unshift(@$art, $_);
              last;
          }
      }
      $response->push_header($key, $val) if $key;
  
      # Ensure that there is a Content-Type header
      $response->header("Content-Type", "text/plain")
          unless $response->header("Content-Type");
  
      # Collect the body
      $response = $self->collect_once($arg, $response, join("", @$art)) if @$art;
  
      # Say goodbye to the server
      $nntp->quit;
      $nntp = undef;
  
      $response;
  }
  
  1;
LWP_PROTOCOL_NNTP

$fatpacked{"LWP/Protocol/nogo.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LWP_PROTOCOL_NOGO';
  package LWP::Protocol::nogo;
  # If you want to disable access to a particular scheme, use this
  # class and then call
  #   LWP::Protocol::implementor(that_scheme, 'LWP::Protocol::nogo');
  # For then on, attempts to access URLs with that scheme will generate
  # a 500 error.
  $LWP::Protocol::nogo::VERSION = '6.23';
  use strict;
  
  require HTTP::Response;
  require HTTP::Status;
  use base qw(LWP::Protocol);
  
  sub request {
      my($self, $request) = @_;
      my $scheme = $request->uri->scheme;
  
      return HTTP::Response->new(
        HTTP::Status::RC_INTERNAL_SERVER_ERROR,
        "Access to \'$scheme\' URIs has been disabled"
      );
  }
  1;
LWP_PROTOCOL_NOGO

$fatpacked{"LWP/RobotUA.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LWP_ROBOTUA';
  package LWP::RobotUA;
  
  use base qw(LWP::UserAgent);
  
  our $VERSION = '6.23';
  
  require WWW::RobotRules;
  require HTTP::Request;
  require HTTP::Response;
  
  use Carp ();
  use HTTP::Status ();
  use HTTP::Date qw(time2str);
  use strict;
  
  
  #
  # Additional attributes in addition to those found in LWP::UserAgent:
  #
  # $self->{'delay'}    Required delay between request to the same
  #                     server in minutes.
  #
  # $self->{'rules'}     A WWW::RobotRules object
  #
  
  sub new
  {
      my $class = shift;
      my %cnf;
      if (@_ < 4) {
  	# legacy args
  	@cnf{qw(agent from rules)} = @_;
      }
      else {
  	%cnf = @_;
      }
  
      Carp::croak('LWP::RobotUA agent required') unless $cnf{agent};
      Carp::croak('LWP::RobotUA from address required')
  	unless $cnf{from} && $cnf{from} =~ m/\@/;
  
      my $delay = delete $cnf{delay} || 1;
      my $use_sleep = delete $cnf{use_sleep};
      $use_sleep = 1 unless defined($use_sleep);
      my $rules = delete $cnf{rules};
  
      my $self = LWP::UserAgent->new(%cnf);
      $self = bless $self, $class;
  
      $self->{'delay'} = $delay;   # minutes
      $self->{'use_sleep'} = $use_sleep;
  
      if ($rules) {
  	$rules->agent($cnf{agent});
  	$self->{'rules'} = $rules;
      }
      else {
  	$self->{'rules'} = WWW::RobotRules->new($cnf{agent});
      }
  
      $self;
  }
  
  
  sub delay     { shift->_elem('delay',     @_); }
  sub use_sleep { shift->_elem('use_sleep', @_); }
  
  
  sub agent
  {
      my $self = shift;
      my $old = $self->SUPER::agent(@_);
      if (@_) {
  	# Changing our name means to start fresh
  	$self->{'rules'}->agent($self->{'agent'});
      }
      $old;
  }
  
  
  sub rules {
      my $self = shift;
      my $old = $self->_elem('rules', @_);
      $self->{'rules'}->agent($self->{'agent'}) if @_;
      $old;
  }
  
  
  sub no_visits
  {
      my($self, $netloc) = @_;
      $self->{'rules'}->no_visits($netloc) || 0;
  }
  
  *host_count = \&no_visits;  # backwards compatibility with LWP-5.02
  
  
  sub host_wait
  {
      my($self, $netloc) = @_;
      return undef unless defined $netloc;
      my $last = $self->{'rules'}->last_visit($netloc);
      if ($last) {
  	my $wait = int($self->{'delay'} * 60 - (time - $last));
  	$wait = 0 if $wait < 0;
  	return $wait;
      }
      return 0;
  }
  
  
  sub simple_request
  {
      my($self, $request, $arg, $size) = @_;
  
      # Do we try to access a new server?
      my $allowed = $self->{'rules'}->allowed($request->uri);
  
      if ($allowed < 0) {
  	# Host is not visited before, or robots.txt expired; fetch "robots.txt"
  	my $robot_url = $request->uri->clone;
  	$robot_url->path("robots.txt");
  	$robot_url->query(undef);
  
  	# make access to robot.txt legal since this will be a recursive call
  	$self->{'rules'}->parse($robot_url, "");
  
  	my $robot_req = HTTP::Request->new('GET', $robot_url);
  	my $parse_head = $self->parse_head(0);
  	my $robot_res = $self->request($robot_req);
  	$self->parse_head($parse_head);
  	my $fresh_until = $robot_res->fresh_until;
  	my $content = "";
  	if ($robot_res->is_success && $robot_res->content_is_text) {
  	    $content = $robot_res->decoded_content;
  	    $content = "" unless $content && $content =~ /^\s*Disallow\s*:/mi;
  	}
  	$self->{'rules'}->parse($robot_url, $content, $fresh_until);
  
  	# recalculate allowed...
  	$allowed = $self->{'rules'}->allowed($request->uri);
      }
  
      # Check rules
      unless ($allowed) {
  	my $res = HTTP::Response->new(
  	  HTTP::Status::RC_FORBIDDEN, 'Forbidden by robots.txt');
  	$res->request( $request ); # bind it to that request
  	return $res;
      }
  
      my $netloc = eval { local $SIG{__DIE__}; $request->uri->host_port; };
      my $wait = $self->host_wait($netloc);
  
      if ($wait) {
  	if ($self->{'use_sleep'}) {
  	    sleep($wait)
  	}
  	else {
  	    my $res = HTTP::Response->new(
  	      HTTP::Status::RC_SERVICE_UNAVAILABLE, 'Please, slow down');
  	    $res->header('Retry-After', time2str(time + $wait));
  	    $res->request( $request ); # bind it to that request
  	    return $res;
  	}
      }
  
      # Perform the request
      my $res = $self->SUPER::simple_request($request, $arg, $size);
  
      $self->{'rules'}->visit($netloc);
  
      $res;
  }
  
  
  sub as_string
  {
      my $self = shift;
      my @s;
      push(@s, "Robot: $self->{'agent'} operated by $self->{'from'}  [$self]");
      push(@s, "    Minimum delay: " . int($self->{'delay'}*60) . "s");
      push(@s, "    Will sleep if too early") if $self->{'use_sleep'};
      push(@s, "    Rules = $self->{'rules'}");
      join("\n", @s, '');
  }
  
  1;
  
  
  __END__
  
  =pod
  
  =head1 NAME
  
  LWP::RobotUA - a class for well-behaved Web robots
  
  =head1 SYNOPSIS
  
    use LWP::RobotUA;
    my $ua = LWP::RobotUA->new('my-robot/0.1', 'me@foo.com');
    $ua->delay(10);  # be very nice -- max one hit every ten minutes!
    ...
  
    # Then just use it just like a normal LWP::UserAgent:
    my $response = $ua->get('http://whatever.int/...');
    ...
  
  =head1 DESCRIPTION
  
  This class implements a user agent that is suitable for robot
  applications.  Robots should be nice to the servers they visit.  They
  should consult the F</robots.txt> file to ensure that they are welcomed
  and they should not make requests too frequently.
  
  But before you consider writing a robot, take a look at
  L<URL:http://www.robotstxt.org/>.
  
  When you use an I<LWP::RobotUA> object as your user agent, then you do not
  really have to think about these things yourself; C<robots.txt> files
  are automatically consulted and obeyed, the server isn't queried
  too rapidly, and so on.  Just send requests
  as you do when you are using a normal I<LWP::UserAgent>
  object (using C<< $ua->get(...) >>, C<< $ua->head(...) >>,
  C<< $ua->request(...) >>, etc.), and this
  special agent will make sure you are nice.
  
  =head1 METHODS
  
  The LWP::RobotUA is a sub-class of L<LWP::UserAgent> and implements the
  same methods. In addition the following methods are provided:
  
  =head2 new
  
      my $ua = LWP::RobotUA->new( %options )
      my $ua = LWP::RobotUA->new( $agent, $from )
      my $ua = LWP::RobotUA->new( $agent, $from, $rules )
  
  The LWP::UserAgent options C<agent> and C<from> are mandatory.  The
  options C<delay>, C<use_sleep> and C<rules> initialize attributes
  private to the RobotUA.  If C<rules> are not provided, then
  C<WWW::RobotRules> is instantiated providing an internal database of
  F<robots.txt>.
  
  It is also possible to just pass the value of C<agent>, C<from> and
  optionally C<rules> as plain positional arguments.
  
  =head2 delay
  
      my $delay = $ua->delay;
      $ua->delay( $minutes );
  
  Get/set the minimum delay between requests to the same server, in
  I<minutes>.  The default is C<1> minute.  Note that this number doesn't
  have to be an integer; for example, this sets the delay to C<10> seconds:
  
      $ua->delay(10/60);
  
  =head2 use_sleep
  
      my $bool = $ua->use_sleep;
      $ua->use_sleep( $boolean );
  
  Get/set a value indicating whether the UA should L<LWP::RobotUA/sleep> if
  requests arrive too fast, defined as C<< $ua->delay >> minutes not passed since
  last request to the given server.  The default is true.  If this value is
  false then an internal C<SERVICE_UNAVAILABLE> response will be generated.
  It will have a C<Retry-After> header that indicates when it is OK to
  send another request to this server.
  
  =head2 rules
  
      my $rules = $ua->rules;
      $ua->rules( $rules );
  
  Set/get which I<WWW::RobotRules> object to use.
  
  =head2 no_visits
  
      my $num = $ua->no_visits( $netloc )
  
  Returns the number of documents fetched from this server host. Yeah I
  know, this method should probably have been named C<num_visits> or
  something like that. :-(
  
  =head2 host_wait
  
      my $num = $ua->host_wait( $netloc )
  
  Returns the number of I<seconds> (from now) you must wait before you can
  make a new request to this host.
  
  =head2 as_string
  
      my $string = $ua->as_string;
  
  Returns a string that describes the state of the UA.
  Mainly useful for debugging.
  
  =head1 SEE ALSO
  
  L<LWP::UserAgent>, L<WWW::RobotRules>
  
  =head1 COPYRIGHT
  
  Copyright 1996-2004 Gisle Aas.
  
  This library is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  =cut
LWP_ROBOTUA

$fatpacked{"LWP/Simple.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LWP_SIMPLE';
  package LWP::Simple;
  
  use strict;
  
  our $VERSION = '6.23';
  
  require Exporter;
  
  our @EXPORT = qw(get head getprint getstore mirror);
  our @EXPORT_OK = qw($ua);
  
  # I really hate this.  It was a bad idea to do it in the first place.
  # Wonder how to get rid of it???  (It even makes LWP::Simple 7% slower
  # for trivial tests)
  use HTTP::Status;
  push(@EXPORT, @HTTP::Status::EXPORT);
  
  sub import
  {
      my $pkg = shift;
      my $callpkg = caller;
      Exporter::export($pkg, $callpkg, @_);
  }
  
  use LWP::UserAgent ();
  use HTTP::Date ();
  
  our $ua = LWP::UserAgent->new;  # we create a global UserAgent object
  $ua->agent("LWP::Simple/$VERSION ");
  $ua->env_proxy;
  
  sub get ($)
  {
      my $response = $ua->get(shift);
      return $response->decoded_content if $response->is_success;
      return undef;
  }
  
  
  sub head ($)
  {
      my($url) = @_;
      my $request = HTTP::Request->new(HEAD => $url);
      my $response = $ua->request($request);
  
      if ($response->is_success) {
  	return $response unless wantarray;
  	return (scalar $response->header('Content-Type'),
  		scalar $response->header('Content-Length'),
  		HTTP::Date::str2time($response->header('Last-Modified')),
  		HTTP::Date::str2time($response->header('Expires')),
  		scalar $response->header('Server'),
  	       );
      }
      return;
  }
  
  
  sub getprint ($)
  {
      my($url) = @_;
      my $request = HTTP::Request->new(GET => $url);
      local($\) = ""; # ensure standard $OUTPUT_RECORD_SEPARATOR
      my $callback = sub { print $_[0] };
      if ($^O eq "MacOS") {
  	$callback = sub { $_[0] =~ s/\015?\012/\n/g; print $_[0] }
      }
      my $response = $ua->request($request, $callback);
      unless ($response->is_success) {
  	print STDERR $response->status_line, " <URL:$url>\n";
      }
      $response->code;
  }
  
  
  sub getstore ($$)
  {
      my($url, $file) = @_;
      my $request = HTTP::Request->new(GET => $url);
      my $response = $ua->request($request, $file);
  
      $response->code;
  }
  
  
  sub mirror ($$)
  {
      my($url, $file) = @_;
      my $response = $ua->mirror($url, $file);
      $response->code;
  }
  
  
  1;
  
  __END__
  
  =pod
  
  =head1 NAME
  
  LWP::Simple - simple procedural interface to LWP
  
  =head1 SYNOPSIS
  
   perl -MLWP::Simple -e 'getprint "http://www.sn.no"'
  
   use LWP::Simple;
   $content = get("http://www.sn.no/");
   die "Couldn't get it!" unless defined $content;
  
   if (mirror("http://www.sn.no/", "foo") == RC_NOT_MODIFIED) {
       ...
   }
  
   if (is_success(getprint("http://www.sn.no/"))) {
       ...
   }
  
  =head1 DESCRIPTION
  
  This module is meant for people who want a simplified view of the
  libwww-perl library.  It should also be suitable for one-liners.  If
  you need more control or access to the header fields in the requests
  sent and responses received, then you should use the full object-oriented
  interface provided by the L<LWP::UserAgent> module.
  
  The module will also export the L<LWP::UserAgent> object as C<$ua> if you
  ask for it explicitly.
  
  The user agent created by this module will identify itself as
  C<LWP::Simple/#.##>
  and will initialize its proxy defaults from the environment (by
  calling C<< $ua->env_proxy >>).
  
  =head1 FUNCTIONS
  
  The following functions are provided (and exported) by this module:
  
  =head2 get
  
      my $res = get($url);
  
  The get() function will fetch the document identified by the given URL
  and return it.  It returns C<undef> if it fails.  The C<$url> argument can
  be either a string or a reference to a L<URI> object.
  
  You will not be able to examine the response code or response headers
  (like C<Content-Type>) when you are accessing the web using this
  function.  If you need that information you should use the full OO
  interface (see L<LWP::UserAgent>).
  
  =head2 head
  
      my $res = head($url);
  
  Get document headers. Returns the following 5 values if successful:
  ($content_type, $document_length, $modified_time, $expires, $server)
  
  Returns an empty list if it fails.  In scalar context returns TRUE if
  successful.
  
  =head2 getprint
  
      my $code = getprint($url);
  
  Get and print a document identified by a URL. The document is printed
  to the selected default filehandle for output (normally STDOUT) as
  data is received from the network.  If the request fails, then the
  status code and message are printed on STDERR.  The return value is
  the HTTP response code.
  
  =head2 getstore
  
      my $code = getstore($url, $file)
  
  Gets a document identified by a URL and stores it in the file. The
  return value is the HTTP response code.
  
  =head2 mirror
  
      my $code = mirror($url, $file);
  
  Get and store a document identified by a URL, using
  I<If-modified-since>, and checking the I<Content-Length>.  Returns
  the HTTP response code.
  
  =head1 STATUS CONSTANTS
  
  This module also exports the L<HTTP::Status> constants and procedures.
  You can use them when you check the response code from L<LWP::Simple/getprint>,
  L<LWP::Simple/getstore> or L<LWP::Simple/mirror>.  The constants are:
  
     RC_CONTINUE
     RC_SWITCHING_PROTOCOLS
     RC_OK
     RC_CREATED
     RC_ACCEPTED
     RC_NON_AUTHORITATIVE_INFORMATION
     RC_NO_CONTENT
     RC_RESET_CONTENT
     RC_PARTIAL_CONTENT
     RC_MULTIPLE_CHOICES
     RC_MOVED_PERMANENTLY
     RC_MOVED_TEMPORARILY
     RC_SEE_OTHER
     RC_NOT_MODIFIED
     RC_USE_PROXY
     RC_BAD_REQUEST
     RC_UNAUTHORIZED
     RC_PAYMENT_REQUIRED
     RC_FORBIDDEN
     RC_NOT_FOUND
     RC_METHOD_NOT_ALLOWED
     RC_NOT_ACCEPTABLE
     RC_PROXY_AUTHENTICATION_REQUIRED
     RC_REQUEST_TIMEOUT
     RC_CONFLICT
     RC_GONE
     RC_LENGTH_REQUIRED
     RC_PRECONDITION_FAILED
     RC_REQUEST_ENTITY_TOO_LARGE
     RC_REQUEST_URI_TOO_LARGE
     RC_UNSUPPORTED_MEDIA_TYPE
     RC_INTERNAL_SERVER_ERROR
     RC_NOT_IMPLEMENTED
     RC_BAD_GATEWAY
     RC_SERVICE_UNAVAILABLE
     RC_GATEWAY_TIMEOUT
     RC_HTTP_VERSION_NOT_SUPPORTED
  
  =head1 CLASSIFICATION FUNCTIONS
  
  The L<HTTP::Status> classification functions are:
  
  =head2 is_success
  
      my $bool = is_success($rc);
  
  True if response code indicated a successful request.
  
  =head2 is_error
  
      my $bool = is_error($rc)
  
  True if response code indicated that an error occurred.
  
  =head1 CAVEAT
  
  Note that if you are using both LWP::Simple and the very popular L<CGI>
  module, you may be importing a C<head> function from each module,
  producing a warning like C<Prototype mismatch: sub main::head ($) vs none>.
  Get around this problem by just not importing LWP::Simple's
  C<head> function, like so:
  
          use LWP::Simple qw(!head);
          use CGI qw(:standard);  # then only CGI.pm defines a head()
  
  Then if you do need LWP::Simple's C<head> function, you can just call
  it as C<LWP::Simple::head($url)>.
  
  =head1 SEE ALSO
  
  L<LWP>, L<lwpcook>, L<LWP::UserAgent>, L<HTTP::Status>, L<lwp-request>,
  L<lwp-mirror>
  
  =cut
LWP_SIMPLE

$fatpacked{"LWP/UserAgent.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LWP_USERAGENT';
  package LWP::UserAgent;
  
  use strict;
  
  use base qw(LWP::MemberMixin);
  
  use Carp ();
  use HTTP::Request ();
  use HTTP::Response ();
  use HTTP::Date ();
  
  use LWP ();
  use LWP::Protocol ();
  
  use Scalar::Util qw(blessed);
  use Try::Tiny qw(try catch);
  
  our $VERSION = '6.23';
  
  sub new
  {
      # Check for common user mistake
      Carp::croak("Options to LWP::UserAgent should be key/value pairs, not hash reference")
          if ref($_[1]) eq 'HASH';
  
      my($class, %cnf) = @_;
  
      my $agent = delete $cnf{agent};
      my $from  = delete $cnf{from};
      my $def_headers = delete $cnf{default_headers};
      my $timeout = delete $cnf{timeout};
      $timeout = 3*60 unless defined $timeout;
      my $local_address = delete $cnf{local_address};
      my $ssl_opts = delete $cnf{ssl_opts} || {};
      unless (exists $ssl_opts->{verify_hostname}) {
  	# The processing of HTTPS_CA_* below is for compatibility with Crypt::SSLeay
  	if (exists $ENV{PERL_LWP_SSL_VERIFY_HOSTNAME}) {
  	    $ssl_opts->{verify_hostname} = $ENV{PERL_LWP_SSL_VERIFY_HOSTNAME};
  	}
  	elsif ($ENV{HTTPS_CA_FILE} || $ENV{HTTPS_CA_DIR}) {
  	    # Crypt-SSLeay compatibility (verify peer certificate; but not the hostname)
  	    $ssl_opts->{verify_hostname} = 0;
  	    $ssl_opts->{SSL_verify_mode} = 1;
  	}
  	else {
  	    $ssl_opts->{verify_hostname} = 1;
  	}
      }
      unless (exists $ssl_opts->{SSL_ca_file}) {
  	if (my $ca_file = $ENV{PERL_LWP_SSL_CA_FILE} || $ENV{HTTPS_CA_FILE}) {
  	    $ssl_opts->{SSL_ca_file} = $ca_file;
  	}
      }
      unless (exists $ssl_opts->{SSL_ca_path}) {
  	if (my $ca_path = $ENV{PERL_LWP_SSL_CA_PATH} || $ENV{HTTPS_CA_DIR}) {
  	    $ssl_opts->{SSL_ca_path} = $ca_path;
  	}
      }
      my $use_eval = delete $cnf{use_eval};
      $use_eval = 1 unless defined $use_eval;
      my $parse_head = delete $cnf{parse_head};
      $parse_head = 1 unless defined $parse_head;
      my $show_progress = delete $cnf{show_progress};
      my $max_size = delete $cnf{max_size};
      my $max_redirect = delete $cnf{max_redirect};
      $max_redirect = 7 unless defined $max_redirect;
      my $env_proxy = exists $cnf{env_proxy} ? delete $cnf{env_proxy} : $ENV{PERL_LWP_ENV_PROXY};
  
      my $cookie_jar = delete $cnf{cookie_jar};
      my $conn_cache = delete $cnf{conn_cache};
      my $keep_alive = delete $cnf{keep_alive};
  
      Carp::croak("Can't mix conn_cache and keep_alive")
  	  if $conn_cache && $keep_alive;
  
      my $protocols_allowed   = delete $cnf{protocols_allowed};
      my $protocols_forbidden = delete $cnf{protocols_forbidden};
  
      my $requests_redirectable = delete $cnf{requests_redirectable};
      $requests_redirectable = ['GET', 'HEAD']
        unless defined $requests_redirectable;
  
      # Actually ""s are just as good as 0's, but for concision we'll just say:
      Carp::croak("protocols_allowed has to be an arrayref or 0, not \"$protocols_allowed\"!")
        if $protocols_allowed and ref($protocols_allowed) ne 'ARRAY';
      Carp::croak("protocols_forbidden has to be an arrayref or 0, not \"$protocols_forbidden\"!")
        if $protocols_forbidden and ref($protocols_forbidden) ne 'ARRAY';
      Carp::croak("requests_redirectable has to be an arrayref or 0, not \"$requests_redirectable\"!")
        if $requests_redirectable and ref($requests_redirectable) ne 'ARRAY';
  
  
      if (%cnf && $^W) {
  	Carp::carp("Unrecognized LWP::UserAgent options: @{[sort keys %cnf]}");
      }
  
      my $self = bless {
  		      def_headers  => $def_headers,
  		      timeout      => $timeout,
  		      local_address => $local_address,
  		      ssl_opts     => $ssl_opts,
  		      use_eval     => $use_eval,
                        show_progress=> $show_progress,
  		      max_size     => $max_size,
  		      max_redirect => $max_redirect,
                        proxy        => {},
  		      no_proxy     => [],
                        protocols_allowed     => $protocols_allowed,
                        protocols_forbidden   => $protocols_forbidden,
                        requests_redirectable => $requests_redirectable,
  		     }, $class;
  
      $self->agent(defined($agent) ? $agent : $class->_agent)
  	if defined($agent) || !$def_headers || !$def_headers->header("User-Agent");
      $self->from($from) if $from;
      $self->cookie_jar($cookie_jar) if $cookie_jar;
      $self->parse_head($parse_head);
      $self->env_proxy if $env_proxy;
  
      $self->protocols_allowed(  $protocols_allowed  ) if $protocols_allowed;
      $self->protocols_forbidden($protocols_forbidden) if $protocols_forbidden;
  
      if ($keep_alive) {
  	$conn_cache ||= { total_capacity => $keep_alive };
      }
      $self->conn_cache($conn_cache) if $conn_cache;
  
      return $self;
  }
  
  
  sub send_request
  {
      my($self, $request, $arg, $size) = @_;
      my($method, $url) = ($request->method, $request->uri);
      my $scheme = $url->scheme;
  
      local($SIG{__DIE__});  # protect against user defined die handlers
  
      $self->progress("begin", $request);
  
      my $response = $self->run_handlers("request_send", $request);
  
      unless ($response) {
          my $protocol;
  
          {
              # Honor object-specific restrictions by forcing protocol objects
              #  into class LWP::Protocol::nogo.
              my $x;
              if($x = $self->protocols_allowed) {
                  if (grep lc($_) eq $scheme, @$x) {
                  }
                  else {
                      require LWP::Protocol::nogo;
                      $protocol = LWP::Protocol::nogo->new;
                  }
              }
              elsif ($x = $self->protocols_forbidden) {
                  if(grep lc($_) eq $scheme, @$x) {
                      require LWP::Protocol::nogo;
                      $protocol = LWP::Protocol::nogo->new;
                  }
              }
              # else fall thru and create the protocol object normally
          }
  
          # Locate protocol to use
          my $proxy = $request->{proxy};
          if ($proxy) {
              $scheme = $proxy->scheme;
          }
  
          unless ($protocol) {
              try {
                  $protocol = LWP::Protocol::create($scheme, $self);
              }
              catch {
                  my $error = $_;
                  $error =~ s/ at .* line \d+.*//s;  # remove file/line number
                  $response =  _new_response($request, HTTP::Status::RC_NOT_IMPLEMENTED, $error);
                  if ($scheme eq "https") {
                      $response->message($response->message . " (LWP::Protocol::https not installed)");
                      $response->content_type("text/plain");
                      $response->content(<<EOT);
  LWP will support https URLs if the LWP::Protocol::https module
  is installed.
  EOT
                  }
              };
          }
  
          if (!$response && $self->{use_eval}) {
              # we eval, and turn dies into responses below
              try {
                  $response = $protocol->request($request, $proxy, $arg, $size, $self->{timeout}) || die "No response returned by $protocol";
              }
              catch {
                  my $error = $_;
                  if (blessed($error) && $error->isa("HTTP::Response")) {
                      $response = $error;
                      $response->request($request);
                  }
                  else {
                      my $full = $error;
                      (my $status = $error) =~ s/\n.*//s;
                      $status =~ s/ at .* line \d+.*//s;  # remove file/line number
                      my $code = ($status =~ s/^(\d\d\d)\s+//) ? $1 : HTTP::Status::RC_INTERNAL_SERVER_ERROR;
                      $response = _new_response($request, $code, $status, $full);
                  }
              };
          }
          elsif (!$response) {
              $response = $protocol->request($request, $proxy,
                                             $arg, $size, $self->{timeout});
              # XXX: Should we die unless $response->is_success ???
          }
      }
  
      $response->request($request);  # record request for reference
      $response->header("Client-Date" => HTTP::Date::time2str(time));
  
      $self->run_handlers("response_done", $response);
  
      $self->progress("end", $response);
      return $response;
  }
  
  
  sub prepare_request
  {
      my($self, $request) = @_;
      die "Method missing" unless $request->method;
      my $url = $request->uri;
      die "URL missing" unless $url;
      die "URL must be absolute" unless $url->scheme;
  
      $self->run_handlers("request_preprepare", $request);
  
      if (my $def_headers = $self->{def_headers}) {
  	for my $h ($def_headers->header_field_names) {
  	    $request->init_header($h => [$def_headers->header($h)]);
  	}
      }
  
      $self->run_handlers("request_prepare", $request);
  
      return $request;
  }
  
  
  sub simple_request
  {
      my($self, $request, $arg, $size) = @_;
  
      # sanity check the request passed in
      if (defined $request) {
  	if (ref $request) {
  	    Carp::croak("You need a request object, not a " . ref($request) . " object")
  	      if ref($request) eq 'ARRAY' or ref($request) eq 'HASH' or
  		 !$request->can('method') or !$request->can('uri');
  	}
  	else {
  	    Carp::croak("You need a request object, not '$request'");
  	}
      }
      else {
          Carp::croak("No request object passed in");
      }
  
      my $error;
      try {
          $request = $self->prepare_request($request);
      }
      catch {
          $error = $_;
          $error =~ s/ at .* line \d+.*//s;  # remove file/line number
      };
  
      if ($error) {
          return _new_response($request, HTTP::Status::RC_BAD_REQUEST, $error);
      }
      return $self->send_request($request, $arg, $size);
  }
  
  
  sub request {
      my ($self, $request, $arg, $size, $previous) = @_;
  
      my $response = $self->simple_request($request, $arg, $size);
      $response->previous($previous) if $previous;
  
      if ($response->redirects >= $self->{max_redirect}) {
          $response->header("Client-Warning" =>
                  "Redirect loop detected (max_redirect = $self->{max_redirect})"
          );
          return $response;
      }
  
      if (my $req = $self->run_handlers("response_redirect", $response)) {
          return $self->request($req, $arg, $size, $response);
      }
  
      my $code = $response->code;
  
      if (   $code == HTTP::Status::RC_MOVED_PERMANENTLY
          or $code == HTTP::Status::RC_FOUND
          or $code == HTTP::Status::RC_SEE_OTHER
          or $code == HTTP::Status::RC_TEMPORARY_REDIRECT)
      {
          my $referral = $request->clone;
  
          # These headers should never be forwarded
          $referral->remove_header('Host', 'Cookie');
  
          if (   $referral->header('Referer')
              && $request->uri->scheme eq 'https'
              && $referral->uri->scheme eq 'http')
          {
              # RFC 2616, section 15.1.3.
              # https -> http redirect, suppressing Referer
              $referral->remove_header('Referer');
          }
  
          if (   $code == HTTP::Status::RC_SEE_OTHER
              || $code == HTTP::Status::RC_FOUND)
          {
              my $method = uc($referral->method);
              unless ($method eq "GET" || $method eq "HEAD") {
                  $referral->method("GET");
                  $referral->content("");
                  $referral->remove_content_headers;
              }
          }
  
          # And then we update the URL based on the Location:-header.
          my $referral_uri = $response->header('Location');
          {
              # Some servers erroneously return a relative URL for redirects,
              # so make it absolute if it not already is.
              local $URI::ABS_ALLOW_RELATIVE_SCHEME = 1;
              my $base = $response->base;
              $referral_uri = "" unless defined $referral_uri;
              $referral_uri
                  = $HTTP::URI_CLASS->new($referral_uri, $base)->abs($base);
          }
          $referral->uri($referral_uri);
  
          return $response unless $self->redirect_ok($referral, $response);
          return $self->request($referral, $arg, $size, $response);
  
      }
      elsif ($code == HTTP::Status::RC_UNAUTHORIZED
          || $code == HTTP::Status::RC_PROXY_AUTHENTICATION_REQUIRED)
      {
          my $proxy = ($code == HTTP::Status::RC_PROXY_AUTHENTICATION_REQUIRED);
          my $ch_header
              = $proxy || $request->method eq 'CONNECT'
              ? "Proxy-Authenticate"
              : "WWW-Authenticate";
          my @challenges = $response->header($ch_header);
          unless (@challenges) {
              $response->header(
                  "Client-Warning" => "Missing Authenticate header");
              return $response;
          }
  
          require HTTP::Headers::Util;
          CHALLENGE: for my $challenge (@challenges) {
              $challenge =~ tr/,/;/;    # "," is used to separate auth-params!!
              ($challenge) = HTTP::Headers::Util::split_header_words($challenge);
              my $scheme = shift(@$challenge);
              shift(@$challenge);       # no value
              $challenge = {@$challenge};    # make rest into a hash
  
              unless ($scheme =~ /^([a-z]+(?:-[a-z]+)*)$/) {
                  $response->header(
                      "Client-Warning" => "Bad authentication scheme '$scheme'");
                  return $response;
              }
              $scheme = $1;                  # untainted now
              my $class = "LWP::Authen::\u$scheme";
              $class =~ s/-/_/g;
  
              no strict 'refs';
              unless (%{"$class\::"}) {
                  # try to load it
                  my $error;
                  try {
                      (my $req = $class) =~ s{::}{/}g;
                      $req .= '.pm' unless $req =~ /\.pm$/;
                      require $req;
                  }
                  catch {
                      $error = $_;
                  };
                  if ($error) {
                      if ($error =~ /^Can\'t locate/) {
                          $response->header("Client-Warning" =>
                                  "Unsupported authentication scheme '$scheme'");
                      }
                      else {
                          $response->header("Client-Warning" => $error);
                      }
                      next CHALLENGE;
                  }
              }
              unless ($class->can("authenticate")) {
                  $response->header("Client-Warning" =>
                          "Unsupported authentication scheme '$scheme'");
                  next CHALLENGE;
              }
              return $class->authenticate($self, $proxy, $challenge, $response,
                  $request, $arg, $size);
          }
          return $response;
      }
      return $response;
  }
  
  #
  # Now the shortcuts...
  #
  sub get {
      require HTTP::Request::Common;
      my($self, @parameters) = @_;
      my @suff = $self->_process_colonic_headers(\@parameters,1);
      return $self->request( HTTP::Request::Common::GET( @parameters ), @suff );
  }
  
  sub _has_raw_content {
      my $self = shift;
      shift; # drop url
  
      # taken from HTTP::Request::Common::request_type_with_data
      my $content;
      $content = shift if @_ and ref $_[0];
      my($k, $v);
      while (($k,$v) = splice(@_, 0, 2)) {
          if (lc($k) eq 'content') {
              $content = $v;
          }
      }
  
      # We were given Content => 'string' ...
      if (defined $content && ! ref ($content)) {
          return 1;
      }
  
      return;
  }
  
  sub _maybe_copy_default_content_type {
      my ($self, $req, @parameters) = @_;
  
      # If we have a default Content-Type and someone passes in a POST/PUT
      # with Content => 'some-string-value', use that Content-Type instead
      # of x-www-form-urlencoded
      my $ct = $self->default_header('Content-Type');
      return unless defined $ct && $self->_has_raw_content(@parameters);
  
      $req->header('Content-Type' => $ct);
  }
  
  sub post {
      require HTTP::Request::Common;
      my($self, @parameters) = @_;
      my @suff = $self->_process_colonic_headers(\@parameters, (ref($parameters[1]) ? 2 : 1));
      my $req = HTTP::Request::Common::POST(@parameters);
      $self->_maybe_copy_default_content_type($req, @parameters);
      return $self->request($req, @suff);
  }
  
  
  sub head {
      require HTTP::Request::Common;
      my($self, @parameters) = @_;
      my @suff = $self->_process_colonic_headers(\@parameters,1);
      return $self->request( HTTP::Request::Common::HEAD( @parameters ), @suff );
  }
  
  
  sub put {
      require HTTP::Request::Common;
      my($self, @parameters) = @_;
      my @suff = $self->_process_colonic_headers(\@parameters, (ref($parameters[1]) ? 2 : 1));
      my $req = HTTP::Request::Common::PUT(@parameters);
      $self->_maybe_copy_default_content_type($req, @parameters);
      return $self->request($req, @suff);
  }
  
  
  sub delete {
      require HTTP::Request::Common;
      my($self, @parameters) = @_;
      my @suff = $self->_process_colonic_headers(\@parameters,1);
      return $self->request( HTTP::Request::Common::DELETE( @parameters ), @suff );
  }
  
  
  sub _process_colonic_headers {
      # Process :content_cb / :content_file / :read_size_hint headers.
      my($self, $args, $start_index) = @_;
  
      my($arg, $size);
      for(my $i = $start_index; $i < @$args; $i += 2) {
  	next unless defined $args->[$i];
  
  	#printf "Considering %s => %s\n", $args->[$i], $args->[$i + 1];
  
  	if($args->[$i] eq ':content_cb') {
  	    # Some sanity-checking...
  	    $arg = $args->[$i + 1];
  	    Carp::croak("A :content_cb value can't be undef") unless defined $arg;
  	    Carp::croak("A :content_cb value must be a coderef")
  		unless ref $arg and UNIVERSAL::isa($arg, 'CODE');
  
  	}
  	elsif ($args->[$i] eq ':content_file') {
  	    $arg = $args->[$i + 1];
  
  	    # Some sanity-checking...
  	    Carp::croak("A :content_file value can't be undef")
  		unless defined $arg;
  	    Carp::croak("A :content_file value can't be a reference")
  		if ref $arg;
  	    Carp::croak("A :content_file value can't be \"\"")
  		unless length $arg;
  
  	}
  	elsif ($args->[$i] eq ':read_size_hint') {
  	    $size = $args->[$i + 1];
  	    # Bother checking it?
  
  	}
  	else {
  	    next;
  	}
  	splice @$args, $i, 2;
  	$i -= 2;
      }
  
      # And return a suitable suffix-list for request(REQ,...)
  
      return             unless defined $arg;
      return $arg, $size if     defined $size;
      return $arg;
  }
  
  
  sub is_online {
      my $self = shift;
      return 1 if $self->get("http://www.msftncsi.com/ncsi.txt")->content eq "Microsoft NCSI";
      return 1 if $self->get("http://www.apple.com")->content =~ m,<title>Apple</title>,;
      return 0;
  }
  
  
  my @ANI = qw(- \ | /);
  
  sub progress {
      my($self, $status, $m) = @_;
      return unless $self->{show_progress};
  
      local($,, $\);
      if ($status eq "begin") {
          print STDERR "** ", $m->method, " ", $m->uri, " ==> ";
          $self->{progress_start} = time;
          $self->{progress_lastp} = "";
          $self->{progress_ani} = 0;
      }
      elsif ($status eq "end") {
          delete $self->{progress_lastp};
          delete $self->{progress_ani};
          print STDERR $m->status_line;
          my $t = time - delete $self->{progress_start};
          print STDERR " (${t}s)" if $t;
          print STDERR "\n";
      }
      elsif ($status eq "tick") {
          print STDERR "$ANI[$self->{progress_ani}++]\b";
          $self->{progress_ani} %= @ANI;
      }
      else {
          my $p = sprintf "%3.0f%%", $status * 100;
          return if $p eq $self->{progress_lastp};
          print STDERR "$p\b\b\b\b";
          $self->{progress_lastp} = $p;
      }
      STDERR->flush;
  }
  
  
  #
  # This whole allow/forbid thing is based on man 1 at's way of doing things.
  #
  sub is_protocol_supported
  {
      my($self, $scheme) = @_;
      if (ref $scheme) {
  	# assume we got a reference to an URI object
  	$scheme = $scheme->scheme;
      }
      else {
  	Carp::croak("Illegal scheme '$scheme' passed to is_protocol_supported")
  	    if $scheme =~ /\W/;
  	$scheme = lc $scheme;
      }
  
      my $x;
      if(ref($self) and $x       = $self->protocols_allowed) {
        return 0 unless grep lc($_) eq $scheme, @$x;
      }
      elsif (ref($self) and $x = $self->protocols_forbidden) {
        return 0 if grep lc($_) eq $scheme, @$x;
      }
  
      local($SIG{__DIE__});  # protect against user defined die handlers
      $x = LWP::Protocol::implementor($scheme);
      return 1 if $x and $x ne 'LWP::Protocol::nogo';
      return 0;
  }
  
  
  sub protocols_allowed      { shift->_elem('protocols_allowed'    , @_) }
  sub protocols_forbidden    { shift->_elem('protocols_forbidden'  , @_) }
  sub requests_redirectable  { shift->_elem('requests_redirectable', @_) }
  
  
  sub redirect_ok
  {
      # RFC 2616, section 10.3.2 and 10.3.3 say:
      #  If the 30[12] status code is received in response to a request other
      #  than GET or HEAD, the user agent MUST NOT automatically redirect the
      #  request unless it can be confirmed by the user, since this might
      #  change the conditions under which the request was issued.
  
      # Note that this routine used to be just:
      #  return 0 if $_[1]->method eq "POST";  return 1;
  
      my($self, $new_request, $response) = @_;
      my $method = $response->request->method;
      return 0 unless grep $_ eq $method,
        @{ $self->requests_redirectable || [] };
  
      if ($new_request->uri->scheme eq 'file') {
        $response->header("Client-Warning" =>
  			"Can't redirect to a file:// URL!");
        return 0;
      }
  
      # Otherwise it's apparently okay...
      return 1;
  }
  
  
  sub credentials
  {
      my $self = shift;
      my $netloc = lc(shift);
      my $realm = shift || "";
      my $old = $self->{basic_authentication}{$netloc}{$realm};
      if (@_) {
          $self->{basic_authentication}{$netloc}{$realm} = [@_];
      }
      return unless $old;
      return @$old if wantarray;
      return join(":", @$old);
  }
  
  
  sub get_basic_credentials
  {
      my($self, $realm, $uri, $proxy) = @_;
      return if $proxy;
      return $self->credentials($uri->host_port, $realm);
  }
  
  
  sub timeout      { shift->_elem('timeout',      @_); }
  sub local_address{ shift->_elem('local_address',@_); }
  sub max_size     { shift->_elem('max_size',     @_); }
  sub max_redirect { shift->_elem('max_redirect', @_); }
  sub show_progress{ shift->_elem('show_progress', @_); }
  
  sub ssl_opts {
      my $self = shift;
      if (@_ == 1) {
  	my $k = shift;
  	return $self->{ssl_opts}{$k};
      }
      if (@_) {
  	my $old;
  	while (@_) {
  	    my($k, $v) = splice(@_, 0, 2);
  	    $old = $self->{ssl_opts}{$k} unless @_;
  	    if (defined $v) {
  		$self->{ssl_opts}{$k} = $v;
  	    }
  	    else {
  		delete $self->{ssl_opts}{$k};
  	    }
  	}
  	%{$self->{ssl_opts}} = (%{$self->{ssl_opts}}, @_);
  	return $old;
      }
  
      return keys %{$self->{ssl_opts}};
  }
  
  sub parse_head {
      my $self = shift;
      if (@_) {
          my $flag = shift;
          my $parser;
          my $old = $self->set_my_handler("response_header", $flag ? sub {
                 my($response, $ua) = @_;
                 require HTML::HeadParser;
                 $parser = HTML::HeadParser->new;
                 $parser->xml_mode(1) if $response->content_is_xhtml;
                 $parser->utf8_mode(1) if $] >= 5.008 && $HTML::Parser::VERSION >= 3.40;
  
                 push(@{$response->{handlers}{response_data}}, {
  		   callback => sub {
  		       return unless $parser;
  		       unless ($parser->parse($_[3])) {
  			   my $h = $parser->header;
  			   my $r = $_[0];
  			   for my $f ($h->header_field_names) {
  			       $r->init_header($f, [$h->header($f)]);
  			   }
  			   undef($parser);
  		       }
  		   },
  	       });
  
              } : undef,
              m_media_type => "html",
          );
          return !!$old;
      }
      else {
          return !!$self->get_my_handler("response_header");
      }
  }
  
  sub cookie_jar {
      my $self = shift;
      my $old = $self->{cookie_jar};
      if (@_) {
  	my $jar = shift;
  	if (ref($jar) eq "HASH") {
  	    require HTTP::Cookies;
  	    $jar = HTTP::Cookies->new(%$jar);
  	}
  	$self->{cookie_jar} = $jar;
          $self->set_my_handler("request_prepare",
              $jar ? sub { $jar->add_cookie_header($_[0]); } : undef,
          );
          $self->set_my_handler("response_done",
              $jar ? sub { $jar->extract_cookies($_[0]); } : undef,
          );
      }
      $old;
  }
  
  sub default_headers {
      my $self = shift;
      my $old = $self->{def_headers} ||= HTTP::Headers->new;
      if (@_) {
  	Carp::croak("default_headers not set to HTTP::Headers compatible object")
  	    unless @_ == 1 && $_[0]->can("header_field_names");
  	$self->{def_headers} = shift;
      }
      return $old;
  }
  
  sub default_header {
      my $self = shift;
      return $self->default_headers->header(@_);
  }
  
  sub _agent { "libwww-perl/$VERSION" }
  
  sub agent {
      my $self = shift;
      if (@_) {
  	my $agent = shift;
          if ($agent) {
              $agent .= $self->_agent if $agent =~ /\s+$/;
          }
          else {
              undef($agent)
          }
          return $self->default_header("User-Agent", $agent);
      }
      return $self->default_header("User-Agent");
  }
  
  sub from {  # legacy
      my $self = shift;
      return $self->default_header("From", @_);
  }
  
  
  sub conn_cache {
      my $self = shift;
      my $old = $self->{conn_cache};
      if (@_) {
  	my $cache = shift;
  	if (ref($cache) eq "HASH") {
  	    require LWP::ConnCache;
  	    $cache = LWP::ConnCache->new(%$cache);
  	}
  	$self->{conn_cache} = $cache;
      }
      $old;
  }
  
  
  sub add_handler {
      my($self, $phase, $cb, %spec) = @_;
      $spec{line} ||= join(":", (caller)[1,2]);
      my $conf = $self->{handlers}{$phase} ||= do {
          require HTTP::Config;
          HTTP::Config->new;
      };
      $conf->add(%spec, callback => $cb);
  }
  
  sub set_my_handler {
      my($self, $phase, $cb, %spec) = @_;
      $spec{owner} = (caller(1))[3] unless exists $spec{owner};
      $self->remove_handler($phase, %spec);
      $spec{line} ||= join(":", (caller)[1,2]);
      $self->add_handler($phase, $cb, %spec) if $cb;
  }
  
  sub get_my_handler {
      my $self = shift;
      my $phase = shift;
      my $init = pop if @_ % 2;
      my %spec = @_;
      my $conf = $self->{handlers}{$phase};
      unless ($conf) {
          return unless $init;
          require HTTP::Config;
          $conf = $self->{handlers}{$phase} = HTTP::Config->new;
      }
      $spec{owner} = (caller(1))[3] unless exists $spec{owner};
      my @h = $conf->find(%spec);
      if (!@h && $init) {
          if (ref($init) eq "CODE") {
              $init->(\%spec);
          }
          elsif (ref($init) eq "HASH") {
              while (my($k, $v) = each %$init) {
                  $spec{$k} = $v;
              }
          }
          $spec{callback} ||= sub {};
          $spec{line} ||= join(":", (caller)[1,2]);
          $conf->add(\%spec);
          return \%spec;
      }
      return wantarray ? @h : $h[0];
  }
  
  sub remove_handler {
      my($self, $phase, %spec) = @_;
      if ($phase) {
          my $conf = $self->{handlers}{$phase} || return;
          my @h = $conf->remove(%spec);
          delete $self->{handlers}{$phase} if $conf->empty;
          return @h;
      }
  
      return unless $self->{handlers};
      return map $self->remove_handler($_), sort keys %{$self->{handlers}};
  }
  
  sub handlers {
      my($self, $phase, $o) = @_;
      my @h;
      if ($o->{handlers} && $o->{handlers}{$phase}) {
          push(@h, @{$o->{handlers}{$phase}});
      }
      if (my $conf = $self->{handlers}{$phase}) {
          push(@h, $conf->matching($o));
      }
      return @h;
  }
  
  sub run_handlers {
      my($self, $phase, $o) = @_;
      if (defined(wantarray)) {
          for my $h ($self->handlers($phase, $o)) {
              my $ret = $h->{callback}->($o, $self, $h);
              return $ret if $ret;
          }
          return undef;
      }
  
      for my $h ($self->handlers($phase, $o)) {
          $h->{callback}->($o, $self, $h);
      }
  }
  
  
  # deprecated
  sub use_eval   { shift->_elem('use_eval',  @_); }
  sub use_alarm
  {
      Carp::carp("LWP::UserAgent->use_alarm(BOOL) is a no-op")
  	if @_ > 1 && $^W;
      "";
  }
  
  
  sub clone
  {
      my $self = shift;
      my $copy = bless { %$self }, ref $self;  # copy most fields
  
      delete $copy->{handlers};
      delete $copy->{conn_cache};
  
      # copy any plain arrays and hashes; known not to need recursive copy
      for my $k (qw(proxy no_proxy requests_redirectable ssl_opts)) {
          next unless $copy->{$k};
          if (ref($copy->{$k}) eq "ARRAY") {
              $copy->{$k} = [ @{$copy->{$k}} ];
          }
          elsif (ref($copy->{$k}) eq "HASH") {
              $copy->{$k} = { %{$copy->{$k}} };
          }
      }
  
      if ($self->{def_headers}) {
          $copy->{def_headers} = $self->{def_headers}->clone;
      }
  
      # re-enable standard handlers
      $copy->parse_head($self->parse_head);
  
      # no easy way to clone the cookie jar; so let's just remove it for now
      $copy->cookie_jar(undef);
  
      $copy;
  }
  
  
  sub mirror
  {
      my($self, $url, $file) = @_;
  
      my $request = HTTP::Request->new('GET', $url);
  
      # If the file exists, add a cache-related header
      if ( -e $file ) {
          my ($mtime) = ( stat($file) )[9];
          if ($mtime) {
              $request->header( 'If-Modified-Since' => HTTP::Date::time2str($mtime) );
          }
      }
      my $tmpfile = "$file-$$";
  
      my $response = $self->request($request, $tmpfile);
      if ( $response->header('X-Died') ) {
  	die $response->header('X-Died');
      }
  
      # Only fetching a fresh copy of the would be considered success.
      # If the file was not modified, "304" would returned, which
      # is considered by HTTP::Status to be a "redirect", /not/ "success"
      if ( $response->is_success ) {
          my @stat        = stat($tmpfile) or die "Could not stat tmpfile '$tmpfile': $!";
          my $file_length = $stat[7];
          my ($content_length) = $response->header('Content-length');
  
          if ( defined $content_length and $file_length < $content_length ) {
              unlink($tmpfile);
              die "Transfer truncated: " . "only $file_length out of $content_length bytes received\n";
          }
          elsif ( defined $content_length and $file_length > $content_length ) {
              unlink($tmpfile);
              die "Content-length mismatch: " . "expected $content_length bytes, got $file_length\n";
          }
          # The file was the expected length.
          else {
              # Replace the stale file with a fresh copy
              if ( -e $file ) {
                  # Some DOSish systems fail to rename if the target exists
                  chmod 0777, $file;
                  unlink $file;
              }
              rename( $tmpfile, $file )
                  or die "Cannot rename '$tmpfile' to '$file': $!\n";
  
              # make sure the file has the same last modification time
              if ( my $lm = $response->last_modified ) {
                  utime $lm, $lm, $file;
              }
          }
      }
      # The local copy is fresh enough, so just delete the temp file
      else {
  	unlink($tmpfile);
      }
      return $response;
  }
  
  
  sub _need_proxy {
      my($req, $ua) = @_;
      return if exists $req->{proxy};
      my $proxy = $ua->{proxy}{$req->uri->scheme} || return;
      if ($ua->{no_proxy}) {
          if (my $host = eval { $req->uri->host }) {
              for my $domain (@{$ua->{no_proxy}}) {
                  if ($host =~ /\Q$domain\E$/) {
                      return;
                  }
              }
          }
      }
      $req->{proxy} = $HTTP::URI_CLASS->new($proxy);
  }
  
  
  sub proxy
  {
      my $self = shift;
      my $key  = shift;
      return map $self->proxy($_, @_), @$key if ref $key;
  
      Carp::croak("'$key' is not a valid URI scheme") unless $key =~ /^$URI::scheme_re\z/;
      my $old = $self->{'proxy'}{$key};
      if (@_) {
          my $url = shift;
          if (defined($url) && length($url)) {
              Carp::croak("Proxy must be specified as absolute URI; '$url' is not") unless $url =~ /^$URI::scheme_re:/;
              Carp::croak("Bad http proxy specification '$url'") if $url =~ /^https?:/ && $url !~ m,^https?://\w,;
          }
          $self->{proxy}{$key} = $url;
          $self->set_my_handler("request_preprepare", \&_need_proxy)
      }
      return $old;
  }
  
  
  sub env_proxy {
      my ($self) = @_;
      require Encode;
      require Encode::Locale;
      my($k,$v);
      while(($k, $v) = each %ENV) {
  	if ($ENV{REQUEST_METHOD}) {
  	    # Need to be careful when called in the CGI environment, as
  	    # the HTTP_PROXY variable is under control of that other guy.
  	    next if $k =~ /^HTTP_/;
  	    $k = "HTTP_PROXY" if $k eq "CGI_HTTP_PROXY";
  	}
  	$k = lc($k);
  	next unless $k =~ /^(.*)_proxy$/;
  	$k = $1;
  	if ($k eq 'no') {
  	    $self->no_proxy(split(/\s*,\s*/, $v));
  	}
  	else {
              # Ignore random _proxy variables, allow only valid schemes
              next unless $k =~ /^$URI::scheme_re\z/;
              # Ignore xxx_proxy variables if xxx isn't a supported protocol
              next unless LWP::Protocol::implementor($k);
  	    $self->proxy($k, Encode::decode(locale => $v));
  	}
      }
  }
  
  
  sub no_proxy {
      my($self, @no) = @_;
      if (@no) {
  	push(@{ $self->{'no_proxy'} }, @no);
      }
      else {
  	$self->{'no_proxy'} = [];
      }
  }
  
  
  sub _new_response {
      my($request, $code, $message, $content) = @_;
      $message ||= HTTP::Status::status_message($code);
      my $response = HTTP::Response->new($code, $message);
      $response->request($request);
      $response->header("Client-Date" => HTTP::Date::time2str(time));
      $response->header("Client-Warning" => "Internal response");
      $response->header("Content-Type" => "text/plain");
      $response->content($content || "$code $message\n");
      return $response;
  }
  
  
  1;
  
  __END__
  
  =pod
  
  =head1 NAME
  
  LWP::UserAgent - Web user agent class
  
  =head1 SYNOPSIS
  
   use strict;
   use warnings;
   use LWP::UserAgent ();
  
   my $ua = LWP::UserAgent->new;
   $ua->timeout(10);
   $ua->env_proxy;
  
   my $response = $ua->get('http://search.cpan.org/');
  
   if ($response->is_success) {
       print $response->decoded_content;  # or whatever
   }
   else {
       die $response->status_line;
   }
  
  =head1 DESCRIPTION
  
  The L<LWP::UserAgent> is a class implementing a web user agent.
  L<LWP::UserAgent> objects can be used to dispatch web requests.
  
  In normal use the application creates an L<LWP::UserAgent> object, and
  then configures it with values for timeouts, proxies, name, etc. It
  then creates an instance of L<HTTP::Request> for the request that
  needs to be performed. This request is then passed to one of the
  request method the UserAgent, which dispatches it using the relevant
  protocol, and returns a L<HTTP::Response> object.  There are
  convenience methods for sending the most common request types:
  L<LWP::UserAgent/get>, L<LWP::UserAgent/head>, L<LWP::UserAgent/post>,
  L<LWP::UserAgent/put> and L<LWP::UserAgent/delete>.  When using these
  methods, the creation of the request object is hidden as shown in the
  synopsis above.
  
  The basic approach of the library is to use HTTP-style communication
  for all protocol schemes.  This means that you will construct
  L<HTTP::Request> objects and receive L<HTTP::Response> objects even
  for non-HTTP resources like I<gopher> and I<ftp>.  In order to achieve
  even more similarity to HTTP-style communications, I<gopher> menus and
  file directories are converted to HTML documents.
  
  =head1 CONSTRUCTOR METHODS
  
  The following constructor methods are available:
  
  =head2 clone
  
      my $ua2 = $ua->clone;
  
  Returns a copy of the L<LWP::UserAgent> object.
  
  =head2 new
  
      my $ua = LWP::UserAgent->new( %options )
  
  This method constructs a new L<LWP::UserAgent> object and returns it.
  Key/value pair arguments may be provided to set up the initial state.
  The following options correspond to attribute methods described below:
  
     KEY                     DEFAULT
     -----------             --------------------
     agent                   "libwww-perl/#.###"
     from                    undef
     conn_cache              undef
     cookie_jar              undef
     default_headers         HTTP::Headers->new
     local_address           undef
     ssl_opts                { verify_hostname => 1 }
     max_size                undef
     max_redirect            7
     parse_head              1
     protocols_allowed       undef
     protocols_forbidden     undef
     requests_redirectable   ['GET', 'HEAD']
     timeout                 180
  
  The following additional options are also accepted: If the C<env_proxy> option
  is passed in with a true value, then proxy settings are read from environment
  variables (see L<LWP::UserAgent/env_proxy>). If C<env_proxy> isn't provided, the
  C<PERL_LWP_ENV_PROXY> environment variable controls if
  L<LWP::UserAgent/env_proxy> is called during initialization.  If the
  C<keep_alive> option is passed in, then a C<LWP::ConnCache> is set up (see
  L<LWP::UserAgent/conn_cache>).  The C<keep_alive> value is passed on as the
  C<total_capacity> for the connection cache.
  
  =head1 ATTRIBUTES
  
  The settings of the configuration attributes modify the behaviour of the
  L<LWP::UserAgent> when it dispatches requests.  Most of these can also
  be initialized by options passed to the constructor method.
  
  The following attribute methods are provided.  The attribute value is
  left unchanged if no argument is given.  The return value from each
  method is the old attribute value.
  
  =head2 agent
  
      my $agent = $ua->agent;
      $ua->agent('Checkbot/0.4 ');    # append the defaul to the end
      $ua->agent('Mozilla/5.0');
      $ua->agent("");                 # don't identify
  
  Get/set the product token that is used to identify the user agent on
  the network. The agent value is sent as the C<User-Agent> header in
  the requests.
  
  The default is a string of the form C<libwww-perl/#.###>, where C<#.###> is
  substituted with the version number of this library.
  
  If the provided string ends with space, the default C<libwww-perl/#.###>
  string is appended to it.
  
  The user agent string should be one or more simple product identifiers
  with an optional version number separated by the C</> character.
  
  =head2 conn_cache
  
      my $cache_obj = $ua->conn_cache;
      $ua->conn_cache( $cache_obj );
  
  Get/set the L<LWP::ConnCache> object to use.  See L<LWP::ConnCache>
  for details.
  
  =head2 cookie_jar
  
      my $jar = $ua->cookie_jar;
      $ua->cookie_jar( $cookie_jar_obj );
  
  Get/set the cookie jar object to use.  The only requirement is that
  the cookie jar object must implement the C<extract_cookies($response)> and
  C<add_cookie_header($request)> methods.  These methods will then be
  invoked by the user agent as requests are sent and responses are
  received.  Normally this will be a L<HTTP::Cookies> object or some
  subclass.
  
  The default is to have no cookie jar, i.e. never automatically add
  C<Cookie> headers to the requests.
  
  Shortcut: If a reference to a plain hash is passed in, it is replaced with an
  instance of L<HTTP::Cookies> that is initialized based on the hash. This form
  also automatically loads the L<HTTP::Cookies> module.  It means that:
  
    $ua->cookie_jar({ file => "$ENV{HOME}/.cookies.txt" });
  
  is really just a shortcut for:
  
    require HTTP::Cookies;
    $ua->cookie_jar(HTTP::Cookies->new(file => "$ENV{HOME}/.cookies.txt"));
  
  =head2 credentials
  
      my $creds = $ua->credentials();
      $ua->credentials( $netloc, $realm );
      $ua->credentials( $netloc, $realm, $uname, $pass );
      $ua->credentials("www.example.com:80", "Some Realm", "foo", "secret");
  
  Get/set the user name and password to be used for a realm.
  
  The C<$netloc> is a string of the form C<< <host>:<port> >>.  The username and
  password will only be passed to this server.
  
  =head2 default_header
  
      $ua->default_header( $field );
      $ua->default_header( $field => $value );
      $ua->default_header('Accept-Encoding' => scalar HTTP::Message::decodable());
      $ua->default_header('Accept-Language' => "no, en");
  
  This is just a shortcut for
  C<< $ua->default_headers->header( $field => $value ) >>.
  
  =head2 default_headers
  
      my $headers = $ua->default_headers;
      $ua->default_headers( $headers_obj );
  
  Get/set the headers object that will provide default header values for
  any requests sent.  By default this will be an empty L<HTTP::Headers>
  object.
  
  =head2 from
  
      my $from = $ua->from;
      $ua->from('foo@bar.com');
  
  Get/set the email address for the human user who controls
  the requesting user agent.  The address should be machine-usable, as
  defined in L<RFC2822|https://tools.ietf.org/html/rfc2822>. The C<from> value
  is sent as the C<From> header in the requests.
  
  The default is to not send a C<From> header.  See
  L<LWP::UserAgent/default_headers> for the more general interface that allow
  any header to be defaulted.
  
  
  =head2 local_address
  
      my $address = $ua->local_address;
      $ua->local_address( $address );
  
  Get/set the local interface to bind to for network connections.  The interface
  can be specified as a hostname or an IP address.  This value is passed as the
  C<LocalAddr> argument to L<IO::Socket::INET>.
  
  =head2 max_redirect
  
      my $max = $ua->max_redirect;
      $ua->max_redirect( $n );
  
  This reads or sets the object's limit of how many times it will obey
  redirection responses in a given request cycle.
  
  By default, the value is C<7>. This means that if you call L<LWP::UserAgent/request>
  and the response is a redirect elsewhere which is in turn a
  redirect, and so on seven times, then LWP gives up after that seventh
  request.
  
  =head2 max_size
  
      my $size = $ua->max_size;
      $ua->max_size( $bytes );
  
  Get/set the size limit for response content.  The default is C<undef>,
  which means that there is no limit.  If the returned response content
  is only partial, because the size limit was exceeded, then a
  C<Client-Aborted> header will be added to the response.  The content
  might end up longer than C<max_size> as we abort once appending a
  chunk of data makes the length exceed the limit.  The C<Content-Length>
  header, if present, will indicate the length of the full content and
  will normally not be the same as C<< length($res->content) >>.
  
  =head2 parse_head
  
      my $bool = $ua->parse_head;
      $ua->parse_head( $boolean );
  
  Get/set a value indicating whether we should initialize response
  headers from the E<lt>head> section of HTML documents. The default is
  true. I<Do not turn this off> unless you know what you are doing.
  
  =head2 protocols_allowed
  
      my $aref = $ua->protocols_allowed;      # get allowed protocols
      $ua->protocols_allowed( \@protocols );  # allow ONLY these
      $ua->protocols_allowed(undef);          # delete the list
      $ua->protocols_allowed(['http',]);      # ONLY allow http
  
  By default, an object has neither a C<protocols_allowed> list, nor a
  L<LWP::UserAgent/protocols_forbidden> list.
  
  This reads (or sets) this user agent's list of protocols that the
  request methods will exclusively allow.  The protocol names are case
  insensitive.
  
  For example: C<< $ua->protocols_allowed( [ 'http', 'https'] ); >>
  means that this user agent will I<allow only> those protocols,
  and attempts to use this user agent to access URLs with any other
  schemes (like C<ftp://...>) will result in a 500 error.
  
  Note that having a C<protocols_allowed> list causes any
  L<LWP::UserAgent/protocols_forbidden> list to be ignored.
  
  =head2 protocols_forbidden
  
      my $aref = $ua->protocols_forbidden;    # get the forbidden list
      $ua->protocols_forbidden(\@protocols);  # do not allow these
      $ua->protocols_forbidden(['http',]);    # All http reqs get a 500
      $ua->protocols_forbidden(undef);        # delete the list
  
  This reads (or sets) this user agent's list of protocols that the
  request method will I<not> allow. The protocol names are case
  insensitive.
  
  For example: C<< $ua->protocols_forbidden( [ 'file', 'mailto'] ); >>
  means that this user agent will I<not> allow those protocols, and
  attempts to use this user agent to access URLs with those schemes
  will result in a 500 error.
  
  =head2 requests_redirectable
  
      my $aref = $ua->requests_redirectable;
      $ua->requests_redirectable( \@requests );
      $ua->requests_redirectable(['GET', 'HEAD',]); # the default
  
  This reads or sets the object's list of request names that
  L<LWP::UserAgent/redirect_ok> will allow redirection for. By default, this
  is C<['GET', 'HEAD']>, as per L<RFC 2616|https://tools.ietf.org/html/rfc2616>.
  To change to include C<POST>, consider:
  
     push @{ $ua->requests_redirectable }, 'POST';
  
  =head2 show_progress
  
      my $bool = $ua->show_progress;
      $ua->show_progress( $boolean );
  
  Get/set a value indicating whether a progress bar should be displayed
  on the terminal as requests are processed. The default is false.
  
  =head2 ssl_opts
  
      my @keys = $ua->ssl_opts;
      my $val = $ua->ssl_opts( $key );
      $ua->ssl_opts( $key => $value );
  
  Get/set the options for SSL connections.  Without argument return the list
  of options keys currently set.  With a single argument return the current
  value for the given option.  With 2 arguments set the option value and return
  the old.  Setting an option to the value C<undef> removes this option.
  
  The options that LWP relates to are:
  
  =over
  
  =item C<verify_hostname> => $bool
  
  When TRUE LWP will for secure protocol schemes ensure it connects to servers
  that have a valid certificate matching the expected hostname.  If FALSE no
  checks are made and you can't be sure that you communicate with the expected peer.
  The no checks behaviour was the default for libwww-perl-5.837 and earlier releases.
  
  This option is initialized from the L<PERL_LWP_SSL_VERIFY_HOSTNAME> environment
  variable.  If this environment variable isn't set; then C<verify_hostname>
  defaults to 1.
  
  =item C<SSL_ca_file> => $path
  
  The path to a file containing Certificate Authority certificates.
  A default setting for this option is provided by checking the environment
  variables C<PERL_LWP_SSL_CA_FILE> and C<HTTPS_CA_FILE> in order.
  
  =item C<SSL_ca_path> => $path
  
  The path to a directory containing files containing Certificate Authority
  certificates.
  A default setting for this option is provided by checking the environment
  variables C<PERL_LWP_SSL_CA_PATH> and C<HTTPS_CA_DIR> in order.
  
  =back
  
  Other options can be set and are processed directly by the SSL Socket implementation
  in use.  See L<IO::Socket::SSL> or L<Net::SSL> for details.
  
  The libwww-perl core no longer bundles protocol plugins for SSL.  You will need
  to install L<LWP::Protocol::https> separately to enable support for processing
  https-URLs.
  
  =head2 timeout
  
      my $secs = $ua->timeout;
      $ua->timeout( $secs );
  
  Get/set the timeout value in seconds. The default value is
  180 seconds, i.e. 3 minutes.
  
  The requests is aborted if no activity on the connection to the server
  is observed for C<timeout> seconds.  This means that the time it takes
  for the complete transaction and the L<LWP::UserAgent/request> method to
  actually return might be longer.
  
  =head1 PROXY ATTRIBUTES
  
  The following methods set up when requests should be passed via a
  proxy server.
  
  =head2 env_proxy
  
      $ua->env_proxy;
  
  Load proxy settings from C<*_proxy> environment variables.  You might
  specify proxies like this (sh-syntax):
  
    gopher_proxy=http://proxy.my.place/
    wais_proxy=http://proxy.my.place/
    no_proxy="localhost,example.com"
    export gopher_proxy wais_proxy no_proxy
  
  csh or tcsh users should use the C<setenv> command to define these
  environment variables.
  
  On systems with case insensitive environment variables there exists a
  name clash between the CGI environment variables and the C<HTTP_PROXY>
  environment variable normally picked up by C<env_proxy>.  Because of
  this C<HTTP_PROXY> is not honored for CGI scripts.  The
  C<CGI_HTTP_PROXY> environment variable can be used instead.
  
  =head2 no_proxy
  
      $ua->no_proxy( @domains );
      $ua->no_proxy('localhost', 'example.com');
      $ua->no_proxy(); # clear the list
  
  Do not proxy requests to the given domains.  Calling C<no_proxy> without
  any domains clears the list of domains.
  
  =head2 proxy
  
      $ua->proxy(\@schemes, $proxy_url)
      $ua->proxy(['http', 'ftp'], 'http://proxy.sn.no:8001/');
      # or, for a single scheme
      $ua->proxy($scheme, $proxy_url)
      $ua->proxy('gopher', 'http://proxy.sn.no:8001/');
  
  Set/retrieve proxy URL for a scheme.
  
  The first form specifies that the URL is to be used as a proxy for
  access methods listed in the list in the first method argument,
  i.e. C<http> and C<ftp>.
  
  The second form shows a shorthand form for specifying
  proxy URL for a single access scheme.
  
  =head1 HANDLERS
  
  Handlers are code that injected at various phases during the
  processing of requests.  The following methods are provided to manage
  the active handlers:
  
  =head2 add_handler
  
      $ua->add_handler( $phase => \&cb, %matchspec )
  
  Add handler to be invoked in the given processing phase.  For how to
  specify C<%matchspec> see L<HTTP::Config/"Matching">.
  
  The possible values C<$phase> and the corresponding callback signatures are:
  
  =over
  
  =item response_data => sub { my($response, $ua, $h, $data) = @_; ... }
  
  This handler is called for each chunk of data received for the
  response.  The handler might croak to abort the request.
  
  This handler needs to return a TRUE value to be called again for
  subsequent chunks for the same request.
  
  =item response_done => sub { my($response, $ua, $h) = @_; ... }
  
  The handler is called after the response has been fully received, but
  before any redirect handling is attempted.  The handler can be used to
  extract information or modify the response.
  
  =item response_header => sub { my($response, $ua, $h) = @_; ... }
  
  This handler is called right after the response headers have been
  received, but before any content data.  The handler might set up
  handlers for data and might croak to abort the request.
  
  The handler might set the $response->{default_add_content} value to
  control if any received data should be added to the response object
  directly.  This will initially be false if the $ua->request() method
  was called with a $content_file or $content_cb argument; otherwise true.
  
  =item request_prepare => sub { my($request, $ua, $h) = @_; ... }
  
  The handler is called before the request is sent and can modify the
  request any way it see fit.  This can for instance be used to add
  certain headers to specific requests.
  
  The method can assign a new request object to $_[0] to replace the
  request that is sent fully.
  
  The return value from the callback is ignored.  If an exception is
  raised it will abort the request and make the request method return a
  "400 Bad request" response.
  
  =item request_preprepare => sub { my($request, $ua, $h) = @_; ... }
  
  The handler is called before the C<request_prepare> and other standard
  initialization of the request.  This can be used to set up headers
  and attributes that the C<request_prepare> handler depends on.  Proxy
  initialization should take place here; but in general don't register
  handlers for this phase.
  
  =item request_send => sub { my($request, $ua, $h) = @_; ... }
  
  This handler gets a chance of handling requests before they're sent to the
  protocol handlers.  It should return an HTTP::Response object if it
  wishes to terminate the processing; otherwise it should return nothing.
  
  The C<response_header> and C<response_data> handlers will not be
  invoked for this response, but the C<response_done> will be.
  
  =item response_redirect => sub { my($response, $ua, $h) = @_; ... }
  
  The handler is called in $ua->request after C<response_done>.  If the
  handler returns an HTTP::Request object we'll start over with processing
  this request instead.
  
  =back
  
  =head2 get_my_handler
  
      $ua->get_my_handler( $phase, %matchspec );
      $ua->get_my_handler( $phase, %matchspec, $init );
  
  Will retrieve the matching handler as hash ref.
  
  If C<$init> is passed as a true value, create and add the
  handler if it's not found.  If C<$init> is a subroutine reference, then
  it's called with the created handler hash as argument.  This sub might
  populate the hash with extra fields; especially the callback.  If
  C<$init> is a hash reference, merge the hashes.
  
  =head2 handlers
  
      $ua->handlers( $phase, $request )
      $ua->handlers( $phase, $response )
  
  Returns the handlers that apply to the given request or response at
  the given processing phase.
  
  =head2 remove_handler
  
      $ua->remove_handler( undef, %matchspec );
      $ua->remove_handler( $phase, %matchspec );
      $ua->remove_handlers(); # REMOVE ALL HANDLERS IN ALL PHASES
  
  Remove handlers that match the given C<%matchspec>.  If C<$phase> is not
  provided, remove handlers from all phases.
  
  Be careful as calling this function with C<%matchspec> that is not
  specific enough can remove handlers not owned by you.  It's probably
  better to use the L<LWP::UserAgent/set_my_handler> method instead.
  
  The removed handlers are returned.
  
  =head2 set_my_handler
  
      $ua->set_my_handler( $phase, $cb, %matchspec );
      $ua->set_my_handler($phase, undef); # remove handler for phase
  
  Set handlers private to the executing subroutine.  Works by defaulting
  an C<owner> field to the C<%matchspec> that holds the name of the called
  subroutine.  You might pass an explicit C<owner> to override this.
  
  If $cb is passed as C<undef>, remove the handler.
  
  =head1 REQUEST METHODS
  
  The methods described in this section are used to dispatch requests
  via the user agent.  The following request methods are provided:
  
  =head2 delete
  
      my $res = $ua->delete( $url );
      my $res = $ua->delete( $url, $field_name => $value, ... );
  
  This method will dispatch a C<DELETE> request on the given URL.  Additional
  headers and content options are the same as for the L<LWP::UserAgent/get>
  method.
  
  This method will use the DELETE() function from L<HTTP::Request::Common>
  to build the request.  See L<HTTP::Request::Common> for a details on
  how to pass form content and other advanced features.
  
  =head2 get
  
      my $res = $ua->get( $url );
      my $res = $ua->get( $url , $field_name => $value, ... );
  
  This method will dispatch a C<GET> request on the given URL.  Further
  arguments can be given to initialize the headers of the request. These
  are given as separate name/value pairs.  The return value is a
  response object.  See L<HTTP::Response> for a description of the
  interface it provides.
  
  There will still be a response object returned when LWP can't connect to the
  server specified in the URL or when other failures in protocol handlers occur.
  These internal responses use the standard HTTP status codes, so the responses
  can't be differentiated by testing the response status code alone.  Error
  responses that LWP generates internally will have the "Client-Warning" header
  set to the value "Internal response".  If you need to differentiate these
  internal responses from responses that a remote server actually generates, you
  need to test this header value.
  
  Fields names that start with ":" are special.  These will not
  initialize headers of the request but will determine how the response
  content is treated.  The following special field names are recognized:
  
      :content_file   => $filename
      :content_cb     => \&callback
      :read_size_hint => $bytes
  
  If a $filename is provided with the C<:content_file> option, then the
  response content will be saved here instead of in the response
  object.  If a callback is provided with the C<:content_cb> option then
  this function will be called for each chunk of the response content as
  it is received from the server.  If neither of these options are
  given, then the response content will accumulate in the response
  object itself.  This might not be suitable for very large response
  bodies.  Only one of C<:content_file> or C<:content_cb> can be
  specified.  The content of unsuccessful responses will always
  accumulate in the response object itself, regardless of the
  C<:content_file> or C<:content_cb> options passed in.  Note that errors
  writing to the content file (for example due to permission denied
  or the filesystem being full) will be reported via the C<Client-Aborted>
  or C<X-Died> response headers, and not the C<is_success> method.
  
  The C<:read_size_hint> option is passed to the protocol module which
  will try to read data from the server in chunks of this size.  A
  smaller value for the C<:read_size_hint> will result in a higher
  number of callback invocations.
  
  The callback function is called with 3 arguments: a chunk of data, a
  reference to the response object, and a reference to the protocol
  object.  The callback can abort the request by invoking die().  The
  exception message will show up as the "X-Died" header field in the
  response returned by the get() function.
  
  =head2 head
  
      my $res = $ua->head( $url );
      my $res = $ua->head( $url , $field_name => $value, ... );
  
  This method will dispatch a C<HEAD> request on the given URL.
  Otherwise it works like the L<LWP::UserAgent/get> method described above.
  
  =head2 is_protocol_supported
  
      my $bool = $ua->is_protocol_supported( $scheme );
  
  You can use this method to test whether this user agent object supports the
  specified C<scheme>.  (The C<scheme> might be a string (like C<http> or
  C<ftp>) or it might be an L<URI> object reference.)
  
  Whether a scheme is supported is determined by the user agent's
  C<protocols_allowed> or C<protocols_forbidden> lists (if any), and by
  the capabilities of LWP.  I.e., this will return true only if LWP
  supports this protocol I<and> it's permitted for this particular
  object.
  
  =head2 is_online
  
      my $bool = $ua->is_online;
  
  Tries to determine if you have access to the Internet. Returns C<1> (true)
  if the built-in heuristics determine that the user agent is
  able to access the Internet (over HTTP) or C<0> (false).
  
  See also L<LWP::Online>.
  
  =head2 mirror
  
      my $res = $ua->mirror( $url, $filename );
  
  This method will get the document identified by URL and store it in
  file called C<$filename>.  If the file already exists, then the request
  will contain an C<If-Modified-Since> header matching the modification
  time of the file.  If the document on the server has not changed since
  this time, then nothing happens.  If the document has been updated, it
  will be downloaded again.  The modification time of the file will be
  forced to match that of the server.
  
  The return value is an L<HTTP::Response> object.
  
  =head2 post
  
      my $res = $ua->post( $url, \%form );
      my $res = $ua->post( $url, \@form );
      my $res = $ua->post( $url, \%form, $field_name => $value, ... );
      my $res = $ua->post( $url, $field_name => $value, Content => \%form );
      my $res = $ua->post( $url, $field_name => $value, Content => \@form );
      my $res = $ua->post( $url, $field_name => $value, Content => $content );
  
  This method will dispatch a C<POST> request on the given URL, with
  C<%form> or C<@form> providing the key/value pairs for the fill-in form
  content. Additional headers and content options are the same as for
  the L<LWP::UserAgent/get> method.
  
  This method will use the C<POST> function from L<HTTP::Request::Common>
  to build the request.  See L<HTTP::Request::Common> for a details on
  how to pass form content and other advanced features.
  
  =head2 put
  
      # Any version of HTTP::Message works with this form:
      my $res = $ua->put( $url, $field_name => $value, Content => $content );
  
      # Using hash or array references requires HTTP::Message >= 6.07
      use HTTP::Request 6.07;
      my $res = $ua->put( $url, \%form );
      my $res = $ua->put( $url, \@form );
      my $res = $ua->put( $url, \%form, $field_name => $value, ... );
      my $res = $ua->put( $url, $field_name => $value, Content => \%form );
      my $res = $ua->put( $url, $field_name => $value, Content => \@form );
  
  This method will dispatch a C<PUT> request on the given URL, with
  C<%form> or C<@form> providing the key/value pairs for the fill-in form
  content. Additional headers and content options are the same as for
  the L<LWP::UserAgent/get> method.
  
  CAVEAT:
  
  This method can only accept content that is in key-value pairs when using
  L<HTTP::Request::Common> prior to version C<6.07>. Any use of hash or array
  references will result in an error prior to version C<6.07>.
  
  This method will use the C<PUT> function from L<HTTP::Request::Common>
  to build the request.  See L<HTTP::Request::Common> for a details on
  how to pass form content and other advanced features.
  
  =head2 request
  
      my $res = $ua->request( $request );
      my $res = $ua->request( $request, $content_file );
      my $res = $ua->request( $request, $content_cb );
      my $res = $ua->request( $request, $content_cb, $read_size_hint );
  
  This method will dispatch the given C<$request> object.  Normally this
  will be an instance of the L<HTTP::Request> class, but any object with
  a similar interface will do.  The return value is an L<HTTP::Response> object.
  See L<HTTP::Request> and L<HTTP::Response> for a description of the
  interface provided by these classes.
  
  The C<request> method will process redirects and authentication
  responses transparently.  This means that it may actually send several
  simple requests via the L<LWP::Simple/simple_request> method described below.
  
  The request methods described above; L<LWP::Simple/get>, L<LWP::Simple/head>,
  L<LWP::Simple/post> and L<LWP::Simple/mirror> will all dispatch the request
  they build via this method.
  They are convenience methods that simply hide the creation of the
  request object for you.
  
  The C<$content_file>, C<$content_cb> and C<$read_size_hint> all correspond to
  options described with the L<LWP::Simple/get> method above.  Note that errors
  writing to the content file (for example due to permission denied
  or the filesystem being full) will be reported via the C<Client-Aborted>
  or C<X-Died> response headers, and not the C<is_success> method.
  
  You are allowed to use a CODE reference as C<content> in the request
  object passed in.  The C<content> function should return the content
  when called.  The content can be returned in chunks.  The content
  function will be invoked repeatedly until it return an empty string to
  signal that there is no more content.
  
  =head2 simple_request
  
      my $request = HTTP::Request->new( ... );
      my $res = $ua->simple_request( $request );
      my $res = $ua->simple_request( $request, $content_file );
      my $res = $ua->simple_request( $request, $content_cb );
      my $res = $ua->simple_request( $request, $content_cb, $read_size_hint );
  
  This method dispatches a single request and returns the response
  received.  Arguments are the same as for the L<LWP::Simple/request> described above.
  
  The difference from L<LWP::Simple/request> is that C<simple_request> will not try to
  handle redirects or authentication responses.  The L<LWP::Simple/request> method
  will, in fact, invoke this method for each simple request it sends.
  
  =head1 CALLBACK METHODS
  
  The following methods will be invoked as requests are processed. These
  methods are documented here because subclasses of L<LWP::UserAgent>
  might want to override their behaviour.
  
  =head2 get_basic_credentials
  
      # This checks wantarray and can either return an array:
      my ($user, $pass) = $ua->get_basic_credentials( $realm, $uri, $isproxy );
      # or a string that looks like "user:pass"
      my $creds = $ua->get_basic_credentials($realm, $uri, $isproxy);
  
  This is called by L<LWP::UserAgent/request> to retrieve credentials for documents
  protected by Basic or Digest Authentication.  The arguments passed in
  is the C<$realm> provided by the server, the C<$uri> requested and a
  C<boolean flag> to indicate if this is authentication against a proxy server.
  
  The method should return a username and password.  It should return an
  empty list to abort the authentication resolution attempt.  Subclasses
  can override this method to prompt the user for the information. An
  example of this can be found in C<lwp-request> program distributed
  with this library.
  
  The base implementation simply checks a set of pre-stored member
  variables, set up with the L<LWP::UserAgent/credentials> method.
  
  =head2 prepare_request
  
      $request = $ua->prepare_request( $request );
  
  This method is invoked by L<LWP::UserAgent/simple_request>. Its task is
  to modify the given C<$request> object by setting up various headers based
  on the attributes of the user agent. The return value should normally be the
  C<$request> object passed in.  If a different request object is returned
  it will be the one actually processed.
  
  The headers affected by the base implementation are; C<User-Agent>,
  C<From>, C<Range> and C<Cookie>.
  
  =head2 progress
  
      my $prog = $ua->progress( $status, $request_or_response );
  
  This is called frequently as the response is received regardless of
  how the content is processed.  The method is called with C<$status>
  "begin" at the start of processing the request and with C<$state> "end"
  before the request method returns.  In between these C<$status> will be
  the fraction of the response currently received or the string "tick"
  if the fraction can't be calculated.
  
  When C<$status> is "begin" the second argument is the L<HTTP::Request> object,
  otherwise it is the L<HTTP::Response> object.
  
  =head2 redirect_ok
  
      my $bool = $ua->redirect_ok( $prospective_request, $response );
  
  This method is called by L<LWP::UserAgent/request> before it tries to follow a
  redirection to the request in C<$response>.  This should return a true
  value if this redirection is permissible.  The C<$prospective_request>
  will be the request to be sent if this method returns true.
  
  The base implementation will return false unless the method
  is in the object's C<requests_redirectable> list,
  false if the proposed redirection is to a C<file://...>
  URL, and true otherwise.
  
  =head1 SEE ALSO
  
  See L<LWP> for a complete overview of libwww-perl5.  See L<lwpcook>
  and the scripts F<lwp-request> and F<lwp-download> for examples of
  usage.
  
  See L<HTTP::Request> and L<HTTP::Response> for a description of the
  message objects dispatched and received.  See L<HTTP::Request::Common>
  and L<HTML::Form> for other ways to build request objects.
  
  See L<WWW::Mechanize> and L<WWW::Search> for examples of more
  specialized user agents based on L<LWP::UserAgent>.
  
  =head1 COPYRIGHT AND LICENSE
  
  Copyright 1995-2009 Gisle Aas.
  
  This library is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  =cut
LWP_USERAGENT

$fatpacked{"Mojo.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJO';
  package Mojo;
  use Mojo::Base -base;
  
  # "Professor: These old Doomsday devices are dangerously unstable. I'll rest
  #             easier not knowing where they are."
  use Carp ();
  use Mojo::Home;
  use Mojo::Log;
  use Mojo::Transaction::HTTP;
  use Mojo::UserAgent;
  use Mojo::Util;
  use Scalar::Util ();
  
  has home => sub { Mojo::Home->new->detect(ref shift) };
  has log  => sub { Mojo::Log->new };
  has ua   => sub {
    my $ua = Mojo::UserAgent->new;
    Scalar::Util::weaken $ua->server->app(shift)->{app};
    return $ua;
  };
  
  sub build_tx { Mojo::Transaction::HTTP->new }
  
  sub config { Mojo::Util::_stash(config => @_) }
  
  sub handler { Carp::croak 'Method "handler" not implemented in subclass' }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojo - Web development toolkit
  
  =head1 SYNOPSIS
  
    package MyApp;
    use Mojo::Base 'Mojo';
  
    # All the complexities of CGI, PSGI, HTTP and WebSockets get reduced to a
    # single method call!
    sub handler {
      my ($self, $tx) = @_;
  
      # Request
      my $method = $tx->req->method;
      my $path   = $tx->req->url->path;
  
      # Response
      $tx->res->code(200);
      $tx->res->headers->content_type('text/plain');
      $tx->res->body("$method request for $path!");
  
      # Resume transaction
      $tx->resume;
    }
  
  =head1 DESCRIPTION
  
  A powerful web development toolkit, with all the basic tools and helpers needed
  to write simple web applications and higher level web frameworks, such as
  L<Mojolicious>. Some of the most commonly used tools are L<Mojo::UserAgent>,
  L<Mojo::DOM>, L<Mojo::JSON>, L<Mojo::Server::Daemon>, L<Mojo::Server::Prefork>,
  L<Mojo::IOLoop> and L<Mojo::Template>.
  
  See L<Mojolicious::Guides> for more!
  
  =head1 ATTRIBUTES
  
  L<Mojo> implements the following attributes.
  
  =head2 home
  
    my $home = $app->home;
    $app     = $app->home(Mojo::Home->new);
  
  The home directory of your application, defaults to a L<Mojo::Home> object
  which stringifies to the actual path.
  
    # Portably generate path relative to home directory
    my $path = $app->home->child('data', 'important.txt');
  
  =head2 log
  
    my $log = $app->log;
    $app    = $app->log(Mojo::Log->new);
  
  The logging layer of your application, defaults to a L<Mojo::Log> object.
  
    # Log debug message
    $app->log->debug('It works');
  
  =head2 ua
  
    my $ua = $app->ua;
    $app   = $app->ua(Mojo::UserAgent->new);
  
  A full featured HTTP user agent for use in your applications, defaults to a
  L<Mojo::UserAgent> object.
  
    # Perform blocking request
    say $app->ua->get('example.com')->result->body;
  
  =head1 METHODS
  
  L<Mojo> inherits all methods from L<Mojo::Base> and implements the following
  new ones.
  
  =head2 build_tx
  
    my $tx = $app->build_tx;
  
  Transaction builder, defaults to building a L<Mojo::Transaction::HTTP> object.
  
  =head2 config
  
    my $hash = $app->config;
    my $foo  = $app->config('foo');
    $app     = $app->config({foo => 'bar', baz => 23});
    $app     = $app->config(foo => 'bar', baz => 23);
  
  Application configuration.
  
    # Remove value
    my $foo = delete $app->config->{foo};
  
    # Assign multiple values at once
    $app->config(foo => 'test', bar => 23);
  
  =head2 handler
  
    $app->handler(Mojo::Transaction::HTTP->new);
  
  The handler is the main entry point to your application or framework and will
  be called for each new transaction, which will usually be a
  L<Mojo::Transaction::HTTP> or L<Mojo::Transaction::WebSocket> object. Meant to
  be overloaded in a subclass.
  
    sub handler {
      my ($self, $tx) = @_;
      ...
    }
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<http://mojolicious.org>.
  
  =cut
MOJO

$fatpacked{"Mojo/Asset.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJO_ASSET';
  package Mojo::Asset;
  use Mojo::Base 'Mojo::EventEmitter';
  
  use Carp 'croak';
  
  has 'end_range';
  has start_range => 0;
  
  sub add_chunk { croak 'Method "add_chunk" not implemented by subclass' }
  sub contains  { croak 'Method "contains" not implemented by subclass' }
  sub get_chunk { croak 'Method "get_chunk" not implemented by subclass' }
  
  sub is_file {undef}
  
  sub is_range { !!($_[0]->end_range || $_[0]->start_range) }
  
  sub move_to { croak 'Method "move_to" not implemented by subclass' }
  sub mtime   { croak 'Method "mtime" not implemented by subclass' }
  sub size    { croak 'Method "size" not implemented by subclass' }
  sub slurp   { croak 'Method "slurp" not implemented by subclass' }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojo::Asset - HTTP content storage base class
  
  =head1 SYNOPSIS
  
    package Mojo::Asset::MyAsset;
    use Mojo::Base 'Mojo::Asset';
  
    sub add_chunk {...}
    sub contains  {...}
    sub get_chunk {...}
    sub move_to   {...}
    sub mtime     {...}
    sub size      {...}
    sub slurp     {...}
  
  =head1 DESCRIPTION
  
  L<Mojo::Asset> is an abstract base class for HTTP content storage backends,
  like L<Mojo::Asset::File> and L<Mojo::Asset::Memory>.
  
  =head1 EVENTS
  
  L<Mojo::Asset> inherits all events from L<Mojo::EventEmitter>.
  
  =head1 ATTRIBUTES
  
  L<Mojo::Asset> implements the following attributes.
  
  =head2 end_range
  
    my $end = $asset->end_range;
    $asset  = $asset->end_range(8);
  
  Pretend file ends earlier.
  
  =head2 start_range
  
    my $start = $asset->start_range;
    $asset    = $asset->start_range(3);
  
  Pretend file starts later.
  
  =head1 METHODS
  
  L<Mojo::Asset> inherits all methods from L<Mojo::EventEmitter> and implements
  the following new ones.
  
  =head2 add_chunk
  
    $asset = $asset->add_chunk('foo bar baz');
  
  Add chunk of data to asset. Meant to be overloaded in a subclass.
  
  =head2 contains
  
    my $position = $asset->contains('bar');
  
  Check if asset contains a specific string. Meant to be overloaded in a
  subclass.
  
  =head2 get_chunk
  
    my $bytes = $asset->get_chunk($offset);
    my $bytes = $asset->get_chunk($offset, $max);
  
  Get chunk of data starting from a specific position, defaults to a maximum
  chunk size of C<131072> bytes (128KB). Meant to be overloaded in a subclass.
  
  =head2 is_file
  
    my $bool = $asset->is_file;
  
  False, this is not a L<Mojo::Asset::File> object.
  
  =head2 is_range
  
    my $bool = $asset->is_range;
  
  Check if asset has a L</"start_range"> or L</"end_range">.
  
  =head2 move_to
  
    $asset = $asset->move_to('/home/sri/foo.txt');
  
  Move asset data into a specific file. Meant to be overloaded in a subclass.
  
  =head2 mtime
  
    my $mtime = $asset->mtime;
  
  Modification time of asset. Meant to be overloaded in a subclass.
  
  =head2 size
  
    my $size = $asset->size;
  
  Size of asset data in bytes. Meant to be overloaded in a subclass.
  
  =head2 slurp
  
    my $bytes = $asset->slurp;
  
  Read all asset data at once. Meant to be overloaded in a subclass.
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<http://mojolicious.org>.
  
  =cut
MOJO_ASSET

$fatpacked{"Mojo/Asset/File.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJO_ASSET_FILE';
  package Mojo::Asset::File;
  use Mojo::Base 'Mojo::Asset';
  
  use Carp 'croak';
  use Fcntl 'SEEK_SET';
  use File::Spec::Functions ();
  use Mojo::File 'tempfile';
  
  has [qw(cleanup path)];
  has handle => sub {
    my $self = shift;
  
    # Open existing file
    my $path = $self->path;
    return Mojo::File->new($path)->open('<') if defined $path && -e $path;
  
    $self->cleanup(1) unless defined $self->cleanup;
  
    # Create a specific file
    return Mojo::File->new($path)->open('+>>') if defined $path;
  
    # Create a temporary file
    my $template = 'mojo.tmp.XXXXXXXXXXXXXXXX';
    my $file = tempfile DIR => $self->tmpdir, TEMPLATE => $template, UNLINK => 0;
    $self->path($file->to_string);
    return $file->open('+>>');
  };
  has tmpdir => sub { $ENV{MOJO_TMPDIR} || File::Spec::Functions::tmpdir };
  
  sub DESTROY {
    my $self = shift;
    return unless $self->cleanup && defined(my $path = $self->path);
    if (my $handle = $self->handle) { close $handle }
    unlink $path if -w $path;
  }
  
  sub add_chunk {
    my ($self, $chunk) = @_;
    ($self->handle->syswrite($chunk) // -1) == length $chunk
      or croak "Can't write to asset: $!";
    return $self;
  }
  
  sub contains {
    my ($self, $str) = @_;
  
    my $handle = $self->handle;
    $handle->sysseek($self->start_range, SEEK_SET);
  
    # Calculate window size
    my $end  = $self->end_range // $self->size;
    my $len  = length $str;
    my $size = $len > 131072 ? $len : 131072;
    $size = $end - $self->start_range if $size > $end - $self->start_range;
  
    # Sliding window search
    my $offset = 0;
    my $start = $handle->sysread(my $window, $len);
    while ($offset < $end) {
  
      # Read as much as possible
      my $diff = $end - ($start + $offset);
      my $read = $handle->sysread(my $buffer, $diff < $size ? $diff : $size);
      $window .= $buffer;
  
      # Search window
      my $pos = index $window, $str;
      return $offset + $pos if $pos >= 0;
      return -1 if $read == 0 || ($offset += $read) == $end;
  
      # Resize window
      substr $window, 0, $read, '';
    }
  
    return -1;
  }
  
  sub get_chunk {
    my ($self, $offset, $max) = @_;
    $max //= 131072;
  
    $offset += $self->start_range;
    my $handle = $self->handle;
    $handle->sysseek($offset, SEEK_SET);
  
    my $buffer;
    if (defined(my $end = $self->end_range)) {
      return '' if (my $chunk = $end + 1 - $offset) <= 0;
      $handle->sysread($buffer, $chunk > $max ? $max : $chunk);
    }
    else { $handle->sysread($buffer, $max) }
  
    return $buffer;
  }
  
  sub is_file {1}
  
  sub move_to {
    my ($self, $to) = @_;
  
    # Windows requires that the handle is closed
    close $self->handle;
    delete $self->{handle};
  
    # Move file and prevent clean up
    Mojo::File->new($self->path)->move_to($to);
    return $self->path($to)->cleanup(0);
  }
  
  sub mtime { (stat shift->handle)[9] }
  
  sub size { -s shift->handle }
  
  sub slurp {
    my $handle = shift->handle;
    $handle->sysseek(0, SEEK_SET);
    my $ret = my $content = '';
    while ($ret = $handle->sysread(my $buffer, 131072, 0)) { $content .= $buffer }
    return defined $ret ? $content : croak "Can't read from asset: $!";
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojo::Asset::File - File storage for HTTP content
  
  =head1 SYNOPSIS
  
    use Mojo::Asset::File;
  
    # Temporary file
    my $file = Mojo::Asset::File->new;
    $file->add_chunk('foo bar baz');
    say 'File contains "bar"' if $file->contains('bar') >= 0;
    say $file->slurp;
  
    # Existing file
    my $file = Mojo::Asset::File->new(path => '/home/sri/foo.txt');
    $file->move_to('/yada.txt');
    say $file->slurp;
  
  =head1 DESCRIPTION
  
  L<Mojo::Asset::File> is a file storage backend for HTTP content.
  
  =head1 EVENTS
  
  L<Mojo::Asset::File> inherits all events from L<Mojo::Asset>.
  
  =head1 ATTRIBUTES
  
  L<Mojo::Asset::File> inherits all attributes from L<Mojo::Asset> and implements
  the following new ones.
  
  =head2 cleanup
  
    my $bool = $file->cleanup;
    $file    = $file->cleanup($bool);
  
  Delete L</"path"> automatically once the file is not used anymore.
  
  =head2 handle
  
    my $handle = $file->handle;
    $file      = $file->handle(IO::File->new);
  
  Filehandle, created on demand for L</"path">, which can be generated
  automatically and safely based on L</"tmpdir">.
  
  =head2 path
  
    my $path = $file->path;
    $file    = $file->path('/home/sri/foo.txt');
  
  File path used to create L</"handle">.
  
  =head2 tmpdir
  
    my $tmpdir = $file->tmpdir;
    $file      = $file->tmpdir('/tmp');
  
  Temporary directory used to generate L</"path">, defaults to the value of the
  C<MOJO_TMPDIR> environment variable or auto-detection.
  
  =head1 METHODS
  
  L<Mojo::Asset::File> inherits all methods from L<Mojo::Asset> and implements
  the following new ones.
  
  =head2 add_chunk
  
    $file = $file->add_chunk('foo bar baz');
  
  Add chunk of data.
  
  =head2 contains
  
    my $position = $file->contains('bar');
  
  Check if asset contains a specific string.
  
  =head2 get_chunk
  
    my $bytes = $file->get_chunk($offset);
    my $bytes = $file->get_chunk($offset, $max);
  
  Get chunk of data starting from a specific position, defaults to a maximum
  chunk size of C<131072> bytes (128KB).
  
  =head2 is_file
  
    my $bool = $file->is_file;
  
  True, this is a L<Mojo::Asset::File> object.
  
  =head2 move_to
  
    $file = $file->move_to('/home/sri/bar.txt');
  
  Move asset data into a specific file and disable L</"cleanup">.
  
  =head2 mtime
  
    my $mtime = $file->mtime;
  
  Modification time of asset.
  
  =head2 size
  
    my $size = $file->size;
  
  Size of asset data in bytes.
  
  =head2 slurp
  
    my $bytes = $file->slurp;
  
  Read all asset data at once.
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<http://mojolicious.org>.
  
  =cut
MOJO_ASSET_FILE

$fatpacked{"Mojo/Asset/Memory.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJO_ASSET_MEMORY';
  package Mojo::Asset::Memory;
  use Mojo::Base 'Mojo::Asset';
  
  use Mojo::Asset::File;
  use Mojo::File 'path';
  
  has 'auto_upgrade';
  has max_memory_size => sub { $ENV{MOJO_MAX_MEMORY_SIZE} || 262144 };
  has mtime => sub {$^T};
  
  sub add_chunk {
    my ($self, $chunk) = @_;
  
    # Upgrade if necessary
    $self->{content} .= $chunk;
    return $self if !$self->auto_upgrade || $self->size <= $self->max_memory_size;
    my $file = Mojo::Asset::File->new;
    return $file->add_chunk($self->emit(upgrade => $file)->slurp);
  }
  
  sub contains {
    my ($self, $str) = @_;
  
    my $start = $self->start_range;
    my $pos = index $self->{content} // '', $str, $start;
    $pos -= $start if $start && $pos >= 0;
    my $end = $self->end_range;
  
    return $end && ($pos + length $str) >= $end ? -1 : $pos;
  }
  
  sub get_chunk {
    my ($self, $offset, $max) = @_;
    $max //= 131072;
  
    $offset += $self->start_range;
    if (my $end = $self->end_range) {
      $max = $end + 1 - $offset if ($offset + $max) > $end;
    }
  
    return substr shift->{content} // '', $offset, $max;
  }
  
  sub move_to { path($_[1])->spurt($_[0]{content} // '') and return $_[0] }
  
  sub size { length(shift->{content} // '') }
  
  sub slurp { shift->{content} // '' }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojo::Asset::Memory - In-memory storage for HTTP content
  
  =head1 SYNOPSIS
  
    use Mojo::Asset::Memory;
  
    my $mem = Mojo::Asset::Memory->new;
    $mem->add_chunk('foo bar baz');
    say $mem->slurp;
  
  =head1 DESCRIPTION
  
  L<Mojo::Asset::Memory> is an in-memory storage backend for HTTP content.
  
  =head1 EVENTS
  
  L<Mojo::Asset::Memory> inherits all events from L<Mojo::Asset> and can emit the
  following new ones.
  
  =head2 upgrade
  
    $mem->on(upgrade => sub {
      my ($mem, $file) = @_;
      ...
    });
  
  Emitted when asset gets upgraded to a L<Mojo::Asset::File> object.
  
    $mem->on(upgrade => sub {
      my ($mem, $file) = @_;
      $file->tmpdir('/tmp');
    });
  
  =head1 ATTRIBUTES
  
  L<Mojo::Asset::Memory> inherits all attributes from L<Mojo::Asset> and
  implements the following new ones.
  
  =head2 auto_upgrade
  
    my $bool = $mem->auto_upgrade;
    $mem     = $mem->auto_upgrade($bool);
  
  Try to detect if content size exceeds L</"max_memory_size"> limit and
  automatically upgrade to a L<Mojo::Asset::File> object.
  
  =head2 max_memory_size
  
    my $size = $mem->max_memory_size;
    $mem     = $mem->max_memory_size(1024);
  
  Maximum size in bytes of data to keep in memory before automatically upgrading
  to a L<Mojo::Asset::File> object, defaults to the value of the
  C<MOJO_MAX_MEMORY_SIZE> environment variable or C<262144> (256KB).
  
  =head2 mtime
  
    my $mtime = $mem->mtime;
    $mem      = $mem->mtime(1408567500);
  
  Modification time of asset, defaults to the value of C<$^T>.
  
  =head1 METHODS
  
  L<Mojo::Asset::Memory> inherits all methods from L<Mojo::Asset> and implements
  the following new ones.
  
  =head2 add_chunk
  
    $mem     = $mem->add_chunk('foo bar baz');
    my $file = $mem->add_chunk('abc' x 262144);
  
  Add chunk of data and upgrade to L<Mojo::Asset::File> object if necessary.
  
  =head2 contains
  
    my $position = $mem->contains('bar');
  
  Check if asset contains a specific string.
  
  =head2 get_chunk
  
    my $bytes = $mem->get_chunk($offset);
    my $bytes = $mem->get_chunk($offset, $max);
  
  Get chunk of data starting from a specific position, defaults to a maximum
  chunk size of C<131072> bytes (128KB).
  
  =head2 move_to
  
    $mem = $mem->move_to('/home/sri/foo.txt');
  
  Move asset data into a specific file.
  
  =head2 size
  
    my $size = $mem->size;
  
  Size of asset data in bytes.
  
  =head2 slurp
  
    my $bytes = mem->slurp;
  
  Read all asset data at once.
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<http://mojolicious.org>.
  
  =cut
MOJO_ASSET_MEMORY

$fatpacked{"Mojo/Base.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJO_BASE';
  package Mojo::Base;
  
  use strict;
  use warnings;
  use utf8;
  use feature ();
  
  # No imports because we get subclassed, a lot!
  use Carp ();
  
  # Only Perl 5.14+ requires it on demand
  use IO::Handle ();
  
  # Supported on Perl 5.22+
  my $NAME
    = eval { require Sub::Util; Sub::Util->can('set_subname') } || sub { $_[1] };
  
  # Protect subclasses using AUTOLOAD
  sub DESTROY { }
  
  # Declared here to avoid circular require problems in Mojo::Util
  sub _monkey_patch {
    my ($class, %patch) = @_;
    no strict 'refs';
    no warnings 'redefine';
    *{"${class}::$_"} = $NAME->("${class}::$_", $patch{$_}) for keys %patch;
  }
  
  sub attr {
    my ($self, $attrs, $value) = @_;
    return unless (my $class = ref $self || $self) && $attrs;
  
    Carp::croak 'Default has to be a code reference or constant value'
      if ref $value && ref $value ne 'CODE';
  
    for my $attr (@{ref $attrs eq 'ARRAY' ? $attrs : [$attrs]}) {
      Carp::croak qq{Attribute "$attr" invalid} unless $attr =~ /^[a-zA-Z_]\w*$/;
  
      # Very performance-sensitive code with lots of micro-optimizations
      if (ref $value) {
        _monkey_patch $class, $attr, sub {
          return
            exists $_[0]{$attr} ? $_[0]{$attr} : ($_[0]{$attr} = $value->($_[0]))
            if @_ == 1;
          $_[0]{$attr} = $_[1];
          $_[0];
        };
      }
      elsif (defined $value) {
        _monkey_patch $class, $attr, sub {
          return exists $_[0]{$attr} ? $_[0]{$attr} : ($_[0]{$attr} = $value)
            if @_ == 1;
          $_[0]{$attr} = $_[1];
          $_[0];
        };
      }
      else {
        _monkey_patch $class, $attr,
          sub { return $_[0]{$attr} if @_ == 1; $_[0]{$attr} = $_[1]; $_[0] };
      }
    }
  }
  
  sub import {
    my $class = shift;
    return unless my $flag = shift;
  
    # Base
    if ($flag eq '-base') { $flag = $class }
  
    # Strict
    elsif ($flag eq '-strict') { $flag = undef }
  
    # Module
    elsif ((my $file = $flag) && !$flag->can('new')) {
      $file =~ s!::|'!/!g;
      require "$file.pm";
    }
  
    # ISA
    if ($flag) {
      my $caller = caller;
      no strict 'refs';
      push @{"${caller}::ISA"}, $flag;
      _monkey_patch $caller, 'has', sub { attr($caller, @_) };
    }
  
    # Mojo modules are strict!
    $_->import for qw(strict warnings utf8);
    feature->import(':5.10');
  }
  
  sub new {
    my $class = shift;
    bless @_ ? @_ > 1 ? {@_} : {%{$_[0]}} : {}, ref $class || $class;
  }
  
  sub tap {
    my ($self, $cb) = (shift, shift);
    $_->$cb(@_) for $self;
    return $self;
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojo::Base - Minimal base class for Mojo projects
  
  =head1 SYNOPSIS
  
    package Cat;
    use Mojo::Base -base;
  
    has name => 'Nyan';
    has ['age', 'weight'] => 4;
  
    package Tiger;
    use Mojo::Base 'Cat';
  
    has friend  => sub { Cat->new };
    has stripes => 42;
  
    package main;
    use Mojo::Base -strict;
  
    my $mew = Cat->new(name => 'Longcat');
    say $mew->age;
    say $mew->age(3)->weight(5)->age;
  
    my $rawr = Tiger->new(stripes => 38, weight => 250);
    say $rawr->tap(sub { $_->friend->name('Tacgnol') })->weight;
  
  =head1 DESCRIPTION
  
  L<Mojo::Base> is a simple base class for L<Mojo> projects with fluent
  interfaces.
  
    # Automatically enables "strict", "warnings", "utf8" and Perl 5.10 features
    use Mojo::Base -strict;
    use Mojo::Base -base;
    use Mojo::Base 'SomeBaseClass';
  
  All three forms save a lot of typing.
  
    # use Mojo::Base -strict;
    use strict;
    use warnings;
    use utf8;
    use feature ':5.10';
    use IO::Handle ();
  
    # use Mojo::Base -base;
    use strict;
    use warnings;
    use utf8;
    use feature ':5.10';
    use IO::Handle ();
    use Mojo::Base;
    push @ISA, 'Mojo::Base';
    sub has { Mojo::Base::attr(__PACKAGE__, @_) }
  
    # use Mojo::Base 'SomeBaseClass';
    use strict;
    use warnings;
    use utf8;
    use feature ':5.10';
    use IO::Handle ();
    require SomeBaseClass;
    push @ISA, 'SomeBaseClass';
    use Mojo::Base;
    sub has { Mojo::Base::attr(__PACKAGE__, @_) }
  
  =head1 FUNCTIONS
  
  L<Mojo::Base> implements the following functions, which can be imported with
  the C<-base> flag or by setting a base class.
  
  =head2 has
  
    has 'name';
    has ['name1', 'name2', 'name3'];
    has name => 'foo';
    has name => sub {...};
    has ['name1', 'name2', 'name3'] => 'foo';
    has ['name1', 'name2', 'name3'] => sub {...};
  
  Create attributes for hash-based objects, just like the L</"attr"> method.
  
  =head1 METHODS
  
  L<Mojo::Base> implements the following methods.
  
  =head2 attr
  
    $object->attr('name');
    SubClass->attr('name');
    SubClass->attr(['name1', 'name2', 'name3']);
    SubClass->attr(name => 'foo');
    SubClass->attr(name => sub {...});
    SubClass->attr(['name1', 'name2', 'name3'] => 'foo');
    SubClass->attr(['name1', 'name2', 'name3'] => sub {...});
  
  Create attribute accessors for hash-based objects, an array reference can be
  used to create more than one at a time. Pass an optional second argument to set
  a default value, it should be a constant or a callback. The callback will be
  executed at accessor read time if there's no set value, and gets passed the
  current instance of the object as first argument. Accessors can be chained, that
  means they return their invocant when they are called with an argument.
  
  =head2 new
  
    my $object = SubClass->new;
    my $object = SubClass->new(name => 'value');
    my $object = SubClass->new({name => 'value'});
  
  This base class provides a basic constructor for hash-based objects. You can
  pass it either a hash or a hash reference with attribute values.
  
  =head2 tap
  
    $object = $object->tap(sub {...});
    $object = $object->tap('some_method');
    $object = $object->tap('some_method', @args);
  
  Tap into a method chain to perform operations on an object within the chain
  (also known as a K combinator or Kestrel). The object will be the first argument
  passed to the callback, and is also available as C<$_>. The callback's return
  value will be ignored; instead, the object (the callback's first argument) will
  be the return value. In this way, arbitrary code can be used within (i.e.,
  spliced or tapped into) a chained set of object method calls.
  
    # Longer version
    $object = $object->tap(sub { $_->some_method(@args) });
  
    # Inject side effects into a method chain
    $object->foo('A')->tap(sub { say $_->foo })->foo('B');
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<http://mojolicious.org>.
  
  =cut
MOJO_BASE

$fatpacked{"Mojo/ByteStream.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJO_BYTESTREAM';
  package Mojo::ByteStream;
  use Mojo::Base -strict;
  use overload bool => sub {1}, '""' => sub { ${$_[0]} }, fallback => 1;
  
  use Exporter 'import';
  use Mojo::Collection;
  use Mojo::Util;
  
  our @EXPORT_OK = ('b');
  
  # Turn most functions from Mojo::Util into methods
  my @UTILS = (
    qw(b64_decode b64_encode camelize decamelize hmac_sha1_sum html_unescape),
    qw(md5_bytes md5_sum punycode_decode punycode_encode quote sha1_bytes),
    qw(sha1_sum term_escape trim unindent unquote url_escape url_unescape),
    qw(xml_escape xor_encode)
  );
  for my $name (@UTILS) {
    my $sub = Mojo::Util->can($name);
    Mojo::Util::monkey_patch __PACKAGE__, $name, sub {
      my $self = shift;
      $$self = $sub->($$self, @_);
      return $self;
    };
  }
  
  sub b { __PACKAGE__->new(@_) }
  
  sub clone { $_[0]->new(${$_[0]}) }
  
  sub decode { shift->_delegate(\&Mojo::Util::decode, @_) }
  sub encode { shift->_delegate(\&Mojo::Util::encode, @_) }
  
  sub new {
    my $class = shift;
    return bless \(my $dummy = join '', @_), ref $class || $class;
  }
  
  sub say {
    my ($self, $handle) = @_;
    $handle ||= \*STDOUT;
    say $handle $$self;
    return $self;
  }
  
  sub secure_compare { Mojo::Util::secure_compare ${shift()}, shift }
  
  sub size { length ${$_[0]} }
  
  # DEPRECATED!
  sub slurp {
    Mojo::Util::deprecated 'Mojo::ByteStream::slurp is DEPRECATED'
      . ' in favor of Mojo::File::slurp';
    require Mojo::File;
    my $self = shift;
    $$self = Mojo::File->new($$self)->slurp;
    return $self;
  }
  
  sub split {
    my ($self, $pattern) = @_;
    return Mojo::Collection->new(map { $self->new($_) } split $pattern, $$self);
  }
  
  # DEPRECATED!
  sub spurt {
    Mojo::Util::deprecated 'Mojo::ByteStream::spurt is DEPRECATED'
      . ' in favor of Mojo::File::spurt';
    require Mojo::File;
    my $self = shift;
    Mojo::File->new(shift)->spurt($$self);
    return $self;
  }
  
  sub tap { shift->Mojo::Base::tap(@_) }
  
  sub to_string { ${$_[0]} }
  
  sub _delegate {
    my ($self, $sub) = (shift, shift);
    $$self = $sub->(shift || 'UTF-8', $$self);
    return $self;
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojo::ByteStream - ByteStream
  
  =head1 SYNOPSIS
  
    use Mojo::ByteStream;
  
    # Manipulate bytestream
    my $stream = Mojo::ByteStream->new('foo_bar_baz');
    say $stream->camelize;
  
    # Chain methods
    my $stream = Mojo::ByteStream->new('foo bar baz')->quote;
    $stream = $stream->unquote->encode('UTF-8')->b64_encode('');
    say "$stream";
  
    # Use the alternative constructor
    use Mojo::ByteStream 'b';
    my $stream = b('foobarbaz')->b64_encode('')->say;
  
  =head1 DESCRIPTION
  
  L<Mojo::ByteStream> is a scalar-based container for bytestreams that provides a
  more friendly API for many of the functions in L<Mojo::Util>.
  
    # Access scalar directly to manipulate bytestream
    my $stream = Mojo::ByteStream->new('foo');
    $$stream .= 'bar';
  
  =head1 FUNCTIONS
  
  L<Mojo::ByteStream> implements the following functions, which can be imported
  individually.
  
  =head2 b
  
    my $stream = b('test123');
  
  Construct a new scalar-based L<Mojo::ByteStream> object.
  
  =head1 METHODS
  
  L<Mojo::ByteStream> implements the following methods.
  
  =head2 b64_decode
  
    $stream = $stream->b64_decode;
  
  Base64 decode bytestream with L<Mojo::Util/"b64_decode">.
  
  =head2 b64_encode
  
    $stream = $stream->b64_encode;
    $stream = $stream->b64_encode("\n");
  
  Base64 encode bytestream with L<Mojo::Util/"b64_encode">.
  
    # "Zm9vIGJhciBiYXo="
    b('foo bar baz')->b64_encode('');
  
  =head2 camelize
  
    $stream = $stream->camelize;
  
  Camelize bytestream with L<Mojo::Util/"camelize">.
  
  =head2 clone
  
    my $stream2 = $stream->clone;
  
  Clone bytestream.
  
  =head2 decamelize
  
    $stream = $stream->decamelize;
  
  Decamelize bytestream with L<Mojo::Util/"decamelize">.
  
  =head2 decode
  
    $stream = $stream->decode;
    $stream = $stream->decode('iso-8859-1');
  
  Decode bytestream with L<Mojo::Util/"decode">, defaults to using C<UTF-8>.
  
    # ""
    b('%E2%99%A5')->url_unescape->decode;
  
  =head2 encode
  
    $stream = $stream->encode;
    $stream = $stream->encode('iso-8859-1');
  
  Encode bytestream with L<Mojo::Util/"encode">, defaults to using C<UTF-8>.
  
    # "%E2%99%A5"
    b('')->encode->url_escape;
  
  =head2 hmac_sha1_sum
  
    $stream = $stream->hmac_sha1_sum('passw0rd');
  
  Generate HMAC-SHA1 checksum for bytestream with L<Mojo::Util/"hmac_sha1_sum">.
  
    # "7fbdc89263974a89210ea71f171c77d3f8c21471"
    b('foo bar baz')->hmac_sha1_sum('secr3t');
  
  =head2 html_unescape
  
    $stream = $stream->html_unescape;
  
  Unescape all HTML entities in bytestream with L<Mojo::Util/"html_unescape">.
  
    # "%3Chtml%3E"
    b('&lt;html&gt;')->html_unescape->url_escape;
  
  =head2 md5_bytes
  
    $stream = $stream->md5_bytes;
  
  Generate binary MD5 checksum for bytestream with L<Mojo::Util/"md5_bytes">.
  
  =head2 md5_sum
  
    $stream = $stream->md5_sum;
  
  Generate MD5 checksum for bytestream with L<Mojo::Util/"md5_sum">.
  
  =head2 new
  
    my $stream = Mojo::ByteStream->new('test123');
  
  Construct a new scalar-based L<Mojo::ByteStream> object.
  
  =head2 punycode_decode
  
    $stream = $stream->punycode_decode;
  
  Punycode decode bytestream with L<Mojo::Util/"punycode_decode">.
  
  =head2 punycode_encode
  
    $stream = $stream->punycode_encode;
  
  Punycode encode bytestream with L<Mojo::Util/"punycode_encode">.
  
  =head2 quote
  
    $stream = $stream->quote;
  
  Quote bytestream with L<Mojo::Util/"quote">.
  
  =head2 say
  
    $stream = $stream->say;
    $stream = $stream->say(*STDERR);
  
  Print bytestream to handle and append a newline, defaults to using C<STDOUT>.
  
  =head2 secure_compare
  
    my $bool = $stream->secure_compare($str);
  
  Compare bytestream with L<Mojo::Util/"secure_compare">.
  
  =head2 sha1_bytes
  
    $stream = $stream->sha1_bytes;
  
  Generate binary SHA1 checksum for bytestream with L<Mojo::Util/"sha1_bytes">.
  
  =head2 sha1_sum
  
    $stream = $stream->sha1_sum;
  
  Generate SHA1 checksum for bytestream with L<Mojo::Util/"sha1_sum">.
  
  =head2 size
  
    my $size = $stream->size;
  
  Size of bytestream.
  
  =head2 split
  
    my $collection = $stream->split(',');
  
  Turn bytestream into L<Mojo::Collection> object containing L<Mojo::ByteStream>
  objects.
  
    # "One,Two,Three"
    b("one,two,three")->split(',')->map('camelize')->join(',');
  
  =head2 tap
  
    $stream = $stream->tap(sub {...});
  
  Alias for L<Mojo::Base/"tap">.
  
  =head2 term_escape
  
    $stream = $stream->term_escape;
  
  Escape POSIX control characters in bytestream with L<Mojo::Util/"term_escape">.
  
    # Print binary checksum to terminal
    b('foo')->sha1_bytes->term_escape->say;
  
  =head2 to_string
  
    my $str = $stream->to_string;
  
  Stringify bytestream.
  
  =head2 trim
  
    $stream = $stream->trim;
  
  Trim whitespace characters from both ends of bytestream with
  L<Mojo::Util/"trim">.
  
  =head2 unindent
  
    $stream = $stream->unindent;
  
  Unindent bytestream with L<Mojo::Util/"unindent">.
  
  =head2 unquote
  
    $stream = $stream->unquote;
  
  Unquote bytestream with L<Mojo::Util/"unquote">.
  
  =head2 url_escape
  
    $stream = $stream->url_escape;
    $stream = $stream->url_escape('^A-Za-z0-9\-._~');
  
  Percent encode all unsafe characters in bytestream with
  L<Mojo::Util/"url_escape">.
  
    # "%E2%98%83"
    b('')->encode->url_escape;
  
  =head2 url_unescape
  
    $stream = $stream->url_unescape;
  
  Decode percent encoded characters in bytestream with
  L<Mojo::Util/"url_unescape">.
  
    # "&lt;html&gt;"
    b('%3Chtml%3E')->url_unescape->xml_escape;
  
  =head2 xml_escape
  
    $stream = $stream->xml_escape;
  
  Escape only the characters C<&>, C<E<lt>>, C<E<gt>>, C<"> and C<'> in
  bytestream with L<Mojo::Util/"xml_escape">.
  
  =head2 xor_encode
  
    $stream = $stream->xor_encode($key);
  
  XOR encode bytestream with L<Mojo::Util/"xor_encode">.
  
    # "%04%0E%15B%03%1B%10"
    b('foo bar')->xor_encode('baz')->url_escape;
  
  =head1 OPERATORS
  
  L<Mojo::ByteStream> overloads the following operators.
  
  =head2 bool
  
    my $bool = !!$bytestream;
  
  Always true.
  
  =head2 stringify
  
    my $str = "$bytestream";
  
  Alias for L</"to_string">.
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<http://mojolicious.org>.
  
  =cut
MOJO_BYTESTREAM

$fatpacked{"Mojo/Cache.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJO_CACHE';
  package Mojo::Cache;
  use Mojo::Base -base;
  
  has 'max_keys' => 100;
  
  sub get { (shift->{cache} || {})->{shift()} }
  
  sub set {
    my ($self, $key, $value) = @_;
  
    return $self unless (my $max = $self->max_keys) > 0;
  
    my $cache = $self->{cache} ||= {};
    my $queue = $self->{queue} ||= [];
    delete $cache->{shift @$queue} while @$queue >= $max;
    push @$queue, $key unless exists $cache->{$key};
    $cache->{$key} = $value;
  
    return $self;
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojo::Cache - Naive in-memory cache
  
  =head1 SYNOPSIS
  
    use Mojo::Cache;
  
    my $cache = Mojo::Cache->new(max_keys => 50);
    $cache->set(foo => 'bar');
    my $foo = $cache->get('foo');
  
  =head1 DESCRIPTION
  
  L<Mojo::Cache> is a naive in-memory cache with size limits.
  
  =head1 ATTRIBUTES
  
  L<Mojo::Cache> implements the following attributes.
  
  =head2 max_keys
  
    my $max = $cache->max_keys;
    $cache  = $cache->max_keys(50);
  
  Maximum number of cache keys, defaults to C<100>. Setting the value to C<0>
  will disable caching.
  
  =head1 METHODS
  
  L<Mojo::Cache> inherits all methods from L<Mojo::Base> and implements the
  following new ones.
  
  =head2 get
  
    my $value = $cache->get('foo');
  
  Get cached value.
  
  =head2 set
  
    $cache = $cache->set(foo => 'bar');
  
  Set cached value.
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<http://mojolicious.org>.
  
  =cut
MOJO_CACHE

$fatpacked{"Mojo/Collection.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJO_COLLECTION';
  package Mojo::Collection;
  use Mojo::Base -strict;
  
  use Carp 'croak';
  use Exporter 'import';
  use List::Util;
  use Mojo::ByteStream;
  use Scalar::Util 'blessed';
  
  our @EXPORT_OK = ('c');
  
  sub TO_JSON { [@{shift()}] }
  
  sub c { __PACKAGE__->new(@_) }
  
  sub compact {
    my $self = shift;
    return $self->new(grep { defined && (ref || length) } @$self);
  }
  
  sub each {
    my ($self, $cb) = @_;
    return @$self unless $cb;
    my $i = 1;
    $_->$cb($i++) for @$self;
    return $self;
  }
  
  sub first {
    my ($self, $cb) = (shift, shift);
    return $self->[0] unless $cb;
    return List::Util::first { $_ =~ $cb } @$self if ref $cb eq 'Regexp';
    return List::Util::first { $_->$cb(@_) } @$self;
  }
  
  sub flatten { $_[0]->new(_flatten(@{$_[0]})) }
  
  sub grep {
    my ($self, $cb) = (shift, shift);
    return $self->new(grep { $_ =~ $cb } @$self) if ref $cb eq 'Regexp';
    return $self->new(grep { $_->$cb(@_) } @$self);
  }
  
  sub join {
    Mojo::ByteStream->new(join $_[1] // '', map {"$_"} @{$_[0]});
  }
  
  sub last { shift->[-1] }
  
  sub map {
    my ($self, $cb) = (shift, shift);
    return $self->new(map { $_->$cb(@_) } @$self);
  }
  
  sub new {
    my $class = shift;
    return bless [@_], ref $class || $class;
  }
  
  sub reduce {
    my $self = shift;
    @_ = (@_, @$self);
    goto &List::Util::reduce;
  }
  
  sub reverse { $_[0]->new(reverse @{$_[0]}) }
  
  sub shuffle { $_[0]->new(List::Util::shuffle @{$_[0]}) }
  
  sub size { scalar @{$_[0]} }
  
  sub slice {
    my $self = shift;
    return $self->new(@$self[@_]);
  }
  
  sub sort {
    my ($self, $cb) = @_;
  
    return $self->new(sort @$self) unless $cb;
  
    my $caller = caller;
    no strict 'refs';
    my @sorted = sort {
      local (*{"${caller}::a"}, *{"${caller}::b"}) = (\$a, \$b);
      $a->$cb($b);
    } @$self;
    return $self->new(@sorted);
  }
  
  sub tap { shift->Mojo::Base::tap(@_) }
  
  sub to_array { [@{shift()}] }
  
  sub uniq {
    my ($self, $cb) = (shift, shift);
    my %seen;
    return $self->new(grep { !$seen{$_->$cb(@_)}++ } @$self) if $cb;
    return $self->new(grep { !$seen{$_}++ } @$self);
  }
  
  sub _flatten {
    map { _ref($_) ? _flatten(@$_) : $_ } @_;
  }
  
  sub _ref { ref $_[0] eq 'ARRAY' || blessed $_[0] && $_[0]->isa(__PACKAGE__) }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojo::Collection - Collection
  
  =head1 SYNOPSIS
  
    use Mojo::Collection;
  
    # Manipulate collection
    my $collection = Mojo::Collection->new(qw(just works));
    unshift @$collection, 'it';
    say $collection->join("\n");
  
    # Chain methods
    $collection->map(sub { ucfirst })->shuffle->each(sub {
      my ($word, $num) = @_;
      say "$num: $word";
    });
  
    # Use the alternative constructor
    use Mojo::Collection 'c';
    c(qw(a b c))->join('/')->url_escape->say;
  
  =head1 DESCRIPTION
  
  L<Mojo::Collection> is an array-based container for collections.
  
    # Access array directly to manipulate collection
    my $collection = Mojo::Collection->new(1 .. 25);
    $collection->[23] += 100;
    say for @$collection;
  
  =head1 FUNCTIONS
  
  L<Mojo::Collection> implements the following functions, which can be imported
  individually.
  
  =head2 c
  
    my $collection = c(1, 2, 3);
  
  Construct a new array-based L<Mojo::Collection> object.
  
  =head1 METHODS
  
  L<Mojo::Collection> implements the following methods.
  
  =head2 TO_JSON
  
    my $array = $collection->TO_JSON;
  
  Alias for L</"to_array">.
  
  =head2 compact
  
    my $new = $collection->compact;
  
  Create a new collection with all elements that are defined and not an empty
  string.
  
    # "0, 1, 2, 3"
    c(0, 1, undef, 2, '', 3)->compact->join(', ');
  
  =head2 each
  
    my @elements = $collection->each;
    $collection  = $collection->each(sub {...});
  
  Evaluate callback for each element in collection, or return all elements as a
  list if none has been provided. The element will be the first argument passed
  to the callback, and is also available as C<$_>.
  
    # Make a numbered list
    $collection->each(sub {
      my ($e, $num) = @_;
      say "$num: $e";
    });
  
  =head2 first
  
    my $first = $collection->first;
    my $first = $collection->first(qr/foo/);
    my $first = $collection->first(sub {...});
    my $first = $collection->first('some_method');
    my $first = $collection->first('some_method', @args);
  
  Evaluate regular expression/callback for, or call method on, each element in
  collection and return the first one that matched the regular expression, or for
  which the callback/method returned true. The element will be the first argument
  passed to the callback, and is also available as C<$_>.
  
    # Longer version
    my $first = $collection->first(sub { $_->some_method(@args) });
  
    # Find first value that contains the word "mojo"
    my $interesting = $collection->first(qr/mojo/i);
  
    # Find first value that is greater than 5
    my $greater = $collection->first(sub { $_ > 5 });
  
  =head2 flatten
  
    my $new = $collection->flatten;
  
  Flatten nested collections/arrays recursively and create a new collection with
  all elements.
  
    # "1, 2, 3, 4, 5, 6, 7"
    c(1, [2, [3, 4], 5, [6]], 7)->flatten->join(', ');
  
  =head2 grep
  
    my $new = $collection->grep(qr/foo/);
    my $new = $collection->grep(sub {...});
    my $new = $collection->grep('some_method');
    my $new = $collection->grep('some_method', @args);
  
  Evaluate regular expression/callback for, or call method on, each element in
  collection and create a new collection with all elements that matched the
  regular expression, or for which the callback/method returned true. The element
  will be the first argument passed to the callback, and is also available as
  C<$_>.
  
    # Longer version
    my $new = $collection->grep(sub { $_->some_method(@args) });
  
    # Find all values that contain the word "mojo"
    my $interesting = $collection->grep(qr/mojo/i);
  
    # Find all values that are greater than 5
    my $greater = $collection->grep(sub { $_ > 5 });
  
  =head2 join
  
    my $stream = $collection->join;
    my $stream = $collection->join("\n");
  
  Turn collection into L<Mojo::ByteStream>.
  
    # Join all values with commas
    $collection->join(', ')->say;
  
  =head2 last
  
    my $last = $collection->last;
  
  Return the last element in collection.
  
  =head2 map
  
    my $new = $collection->map(sub {...});
    my $new = $collection->map('some_method');
    my $new = $collection->map('some_method', @args);
  
  Evaluate callback for, or call method on, each element in collection and create
  a new collection from the results. The element will be the first argument
  passed to the callback, and is also available as C<$_>.
  
    # Longer version
    my $new = $collection->map(sub { $_->some_method(@args) });
  
    # Append the word "mojo" to all values
    my $mojoified = $collection->map(sub { $_ . 'mojo' });
  
  =head2 new
  
    my $collection = Mojo::Collection->new(1, 2, 3);
  
  Construct a new array-based L<Mojo::Collection> object.
  
  =head2 reduce
  
    my $result = $collection->reduce(sub {...});
    my $result = $collection->reduce(sub {...}, $initial);
  
  Reduce elements in collection with a callback and return its final result,
  setting C<$a> and C<$b> each time the callback is executed. The first time C<$a>
  will be set to an optional initial value or the first element in the collection.
  And from then on C<$a> will be set to the return value of the callback, while
  C<$b> will always be set to the next element in the collection.
  
    # Calculate the sum of all values
    my $sum = $collection->reduce(sub { $a + $b });
  
    # Count how often each value occurs in collection
    my $hash = $collection->reduce(sub { $a->{$b}++; $a }, {});
  
  =head2 reverse
  
    my $new = $collection->reverse;
  
  Create a new collection with all elements in reverse order.
  
  =head2 slice
  
    my $new = $collection->slice(4 .. 7);
  
  Create a new collection with all selected elements.
  
    # "B C E"
    c('A', 'B', 'C', 'D', 'E')->slice(1, 2, 4)->join(' ');
  
  =head2 shuffle
  
    my $new = $collection->shuffle;
  
  Create a new collection with all elements in random order.
  
  =head2 size
  
    my $size = $collection->size;
  
  Number of elements in collection.
  
  =head2 sort
  
    my $new = $collection->sort;
    my $new = $collection->sort(sub {...});
  
  Sort elements based on return value of a callback and create a new collection
  from the results, setting C<$a> and C<$b> to the elements being compared, each
  time the callback is executed.
  
    # Sort values case-insensitive
    my $case_insensitive = $collection->sort(sub { uc($a) cmp uc($b) });
  
  =head2 tap
  
    $collection = $collection->tap(sub {...});
  
  Alias for L<Mojo::Base/"tap">.
  
  =head2 to_array
  
    my $array = $collection->to_array;
  
  Turn collection into array reference.
  
  =head2 uniq
  
    my $new = $collection->uniq;
    my $new = $collection->uniq(sub {...});
    my $new = $collection->uniq('some_method');
    my $new = $collection->uniq('some_method', @args);
  
  Create a new collection without duplicate elements, using the string
  representation of either the elements or the return value of the
  callback/method.
  
    # Longer version
    my $new = $collection->uniq(sub { $_->some_method(@args) });
  
    # "foo bar baz"
    c('foo', 'bar', 'bar', 'baz')->uniq->join(' ');
  
    # "[[1, 2], [2, 1]]"
    c([1, 2], [2, 1], [3, 2])->uniq(sub{ $_->[1] })->to_array;
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<http://mojolicious.org>.
  
  =cut
MOJO_COLLECTION

$fatpacked{"Mojo/Content.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJO_CONTENT';
  package Mojo::Content;
  use Mojo::Base 'Mojo::EventEmitter';
  
  use Carp 'croak';
  use Compress::Raw::Zlib qw(WANT_GZIP Z_STREAM_END);
  use Mojo::Headers;
  use Scalar::Util 'looks_like_number';
  
  has [qw(auto_decompress auto_relax expect_close relaxed skip_body)];
  has headers           => sub { Mojo::Headers->new };
  has max_buffer_size   => sub { $ENV{MOJO_MAX_BUFFER_SIZE} || 262144 };
  has max_leftover_size => sub { $ENV{MOJO_MAX_LEFTOVER_SIZE} || 262144 };
  
  my $BOUNDARY_RE
    = qr!multipart.*boundary\s*=\s*(?:"([^"]+)"|([\w'(),.:?\-+/]+))!i;
  
  sub body_contains {
    croak 'Method "body_contains" not implemented by subclass';
  }
  
  sub body_size { croak 'Method "body_size" not implemented by subclass' }
  
  sub boundary {
    (shift->headers->content_type // '') =~ $BOUNDARY_RE ? $1 // $2 : undef;
  }
  
  sub charset {
    my $type = shift->headers->content_type // '';
    return $type =~ /charset\s*=\s*"?([^"\s;]+)"?/i ? $1 : undef;
  }
  
  sub clone {
    my $self = shift;
    return undef if $self->is_dynamic;
    return $self->new(headers => $self->headers->clone);
  }
  
  sub generate_body_chunk {
    my ($self, $offset) = @_;
  
    $self->emit(drain => $offset) unless length($self->{body_buffer} //= '');
    my $len = $self->headers->content_length;
    return '' if looks_like_number $len && $len == $offset;
    my $chunk = delete $self->{body_buffer};
    return $self->{eof} ? '' : undef unless length $chunk;
  
    return $chunk;
  }
  
  sub get_body_chunk {
    croak 'Method "get_body_chunk" not implemented by subclass';
  }
  
  sub get_header_chunk { substr shift->_headers->{header_buffer}, shift, 131072 }
  
  sub header_size { length shift->_headers->{header_buffer} }
  
  sub headers_contain { index(shift->_headers->{header_buffer}, shift) >= 0 }
  
  sub is_chunked { !!shift->headers->transfer_encoding }
  
  sub is_compressed { lc(shift->headers->content_encoding // '') eq 'gzip' }
  
  sub is_dynamic { !!$_[0]{dynamic} }
  
  sub is_finished { (shift->{state} // '') eq 'finished' }
  
  sub is_limit_exceeded { !!shift->{limit} }
  
  sub is_multipart {undef}
  
  sub is_parsing_body { (shift->{state} // '') eq 'body' }
  
  sub leftovers { shift->{buffer} }
  
  sub parse {
    my $self = shift;
  
    # Headers
    $self->_parse_until_body(@_);
    return $self if $self->{state} eq 'headers';
  
    # Chunked content
    $self->{real_size} //= 0;
    if ($self->is_chunked && $self->{state} ne 'headers') {
      $self->_parse_chunked;
      $self->{state} = 'finished' if ($self->{chunk_state} // '') eq 'finished';
    }
  
    # Not chunked, pass through to second buffer
    else {
      $self->{real_size} += length $self->{pre_buffer};
      my $limit = $self->is_finished
        && length($self->{buffer}) > $self->max_leftover_size;
      $self->{buffer} .= $self->{pre_buffer} unless $limit;
      $self->{pre_buffer} = '';
    }
  
    # No content
    if ($self->skip_body) {
      $self->{state} = 'finished';
      return $self;
    }
  
    # Relaxed parsing
    my $headers = $self->headers;
    my $len = $headers->content_length // '';
    if ($self->auto_relax && !length $len) {
      my $connection = lc($headers->connection // '');
      $self->relaxed(1)
        if $connection eq 'close' || (!$connection && $self->expect_close);
    }
  
    # Chunked or relaxed content
    if ($self->is_chunked || $self->relaxed) {
      $self->_decompress($self->{buffer} //= '');
      $self->{size} += length $self->{buffer};
      $self->{buffer} = '';
      return $self;
    }
  
    # Normal content
    $len = 0 unless looks_like_number $len;
    if ((my $need = $len - ($self->{size} ||= 0)) > 0) {
      my $len = length $self->{buffer};
      my $chunk = substr $self->{buffer}, 0, $need > $len ? $len : $need, '';
      $self->_decompress($chunk);
      $self->{size} += length $chunk;
    }
    $self->{state} = 'finished' if $len <= $self->progress;
  
    return $self;
  }
  
  sub parse_body {
    my $self = shift;
    $self->{state} = 'body';
    return $self->parse(@_);
  }
  
  sub progress {
    my $self = shift;
    return 0 unless my $state = $self->{state};
    return 0 unless $state eq 'body' || $state eq 'finished';
    return $self->{raw_size} - ($self->{header_size} || 0);
  }
  
  sub write {
    my ($self, $chunk, $cb) = @_;
  
    $self->{dynamic} = 1;
    $self->{body_buffer} .= $chunk if defined $chunk;
    $self->once(drain => $cb) if $cb;
    $self->{eof} = 1 if defined $chunk && !length $chunk;
  
    return $self;
  }
  
  sub write_chunk {
    my ($self, $chunk, $cb) = @_;
    $self->headers->transfer_encoding('chunked') unless $self->is_chunked;
    $self->write(defined $chunk ? $self->_build_chunk($chunk) : $chunk, $cb);
    $self->{eof} = 1 if defined $chunk && !length $chunk;
    return $self;
  }
  
  sub _build_chunk {
    my ($self, $chunk) = @_;
  
    # End
    return "\x0d\x0a0\x0d\x0a\x0d\x0a" unless length $chunk;
  
    # First chunk has no leading CRLF
    my $crlf = $self->{chunks}++ ? "\x0d\x0a" : '';
    return $crlf . sprintf('%x', length $chunk) . "\x0d\x0a$chunk";
  }
  
  sub _decompress {
    my ($self, $chunk) = @_;
  
    # No compression
    return $self->emit(read => $chunk)
      unless $self->auto_decompress && $self->is_compressed;
  
    # Decompress
    $self->{post_buffer} .= $chunk;
    my $gz = $self->{gz}
      //= Compress::Raw::Zlib::Inflate->new(WindowBits => WANT_GZIP);
    my $status = $gz->inflate(\$self->{post_buffer}, my $out);
    $self->emit(read => $out) if defined $out;
  
    # Replace Content-Encoding with Content-Length
    $self->headers->content_length($gz->total_out)->remove('Content-Encoding')
      if $status == Z_STREAM_END;
  
    # Check buffer size
    @$self{qw(state limit)} = ('finished', 1)
      if length($self->{post_buffer} // '') > $self->max_buffer_size;
  }
  
  sub _headers {
    my $self = shift;
    return $self if defined $self->{header_buffer};
    my $headers = $self->headers->to_string;
    $self->{header_buffer} = $headers ? "$headers\x0d\x0a\x0d\x0a" : "\x0d\x0a";
    return $self;
  }
  
  sub _parse_chunked {
    my $self = shift;
  
    # Trailing headers
    return $self->_parse_chunked_trailing_headers
      if ($self->{chunk_state} // '') eq 'trailing_headers';
  
    while (my $len = length $self->{pre_buffer}) {
  
      # Start new chunk (ignore the chunk extension)
      unless ($self->{chunk_len}) {
        last
          unless $self->{pre_buffer} =~ s/^(?:\x0d?\x0a)?([0-9a-fA-F]+).*\x0a//;
        next if $self->{chunk_len} = hex $1;
  
        # Last chunk
        $self->{chunk_state} = 'trailing_headers';
        last;
      }
  
      # Remove as much as possible from payload
      $len = $self->{chunk_len} if $self->{chunk_len} < $len;
      $self->{buffer} .= substr $self->{pre_buffer}, 0, $len, '';
      $self->{real_size} += $len;
      $self->{chunk_len} -= $len;
    }
  
    # Trailing headers
    $self->_parse_chunked_trailing_headers
      if ($self->{chunk_state} // '') eq 'trailing_headers';
  
    # Check buffer size
    @$self{qw(state limit)} = ('finished', 1)
      if length($self->{pre_buffer} // '') > $self->max_buffer_size;
  }
  
  sub _parse_chunked_trailing_headers {
    my $self = shift;
  
    my $headers = $self->headers->parse(delete $self->{pre_buffer});
    return unless $headers->is_finished;
    $self->{chunk_state} = 'finished';
  
    # Take care of leftover and replace Transfer-Encoding with Content-Length
    $self->{buffer} .= $headers->leftovers;
    $headers->remove('Transfer-Encoding');
    $headers->content_length($self->{real_size}) unless $headers->content_length;
  }
  
  sub _parse_headers {
    my $self = shift;
  
    my $headers = $self->headers->parse(delete $self->{pre_buffer});
    return unless $headers->is_finished;
    $self->{state} = 'body';
  
    # Take care of leftovers
    my $leftovers = $self->{pre_buffer} = $headers->leftovers;
    $self->{header_size} = $self->{raw_size} - length $leftovers;
  }
  
  sub _parse_until_body {
    my ($self, $chunk) = @_;
  
    $self->{raw_size} += length($chunk //= '');
    $self->{pre_buffer} .= $chunk;
    $self->_parse_headers if ($self->{state} ||= 'headers') eq 'headers';
    $self->emit('body') if $self->{state} ne 'headers' && !$self->{body}++;
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojo::Content - HTTP content base class
  
  =head1 SYNOPSIS
  
    package Mojo::Content::MyContent;
    use Mojo::Base 'Mojo::Content';
  
    sub body_contains  {...}
    sub body_size      {...}
    sub get_body_chunk {...}
  
  =head1 DESCRIPTION
  
  L<Mojo::Content> is an abstract base class for HTTP content containers, based on
  L<RFC 7230|http://tools.ietf.org/html/rfc7230> and
  L<RFC 7231|http://tools.ietf.org/html/rfc7231>, like
  L<Mojo::Content::MultiPart> and L<Mojo::Content::Single>.
  
  =head1 EVENTS
  
  L<Mojo::Content> inherits all events from L<Mojo::EventEmitter> and can emit
  the following new ones.
  
  =head2 body
  
    $content->on(body => sub {
      my $content = shift;
      ...
    });
  
  Emitted once all headers have been parsed and the body starts.
  
    $content->on(body => sub {
      my $content = shift;
      $content->auto_upgrade(0) if $content->headers->header('X-No-MultiPart');
    });
  
  =head2 drain
  
    $content->on(drain => sub {
      my ($content, $offset) = @_;
      ...
    });
  
  Emitted once all data has been written.
  
    $content->on(drain => sub {
      my $content = shift;
      $content->write_chunk(time);
    });
  
  =head2 read
  
    $content->on(read => sub {
      my ($content, $bytes) = @_;
      ...
    });
  
  Emitted when a new chunk of content arrives.
  
    $content->unsubscribe('read')->on(read => sub {
      my ($content, $bytes) = @_;
      say "Streaming: $bytes";
    });
  
  =head1 ATTRIBUTES
  
  L<Mojo::Content> implements the following attributes.
  
  =head2 auto_decompress
  
    my $bool = $content->auto_decompress;
    $content = $content->auto_decompress($bool);
  
  Decompress content automatically if L</"is_compressed"> is true.
  
  =head2 auto_relax
  
    my $bool = $content->auto_relax;
    $content = $content->auto_relax($bool);
  
  Try to detect when relaxed parsing is necessary.
  
  =head2 expect_close
  
    my $bool = $content->expect_close;
    $content = $content->expect_close($bool);
  
  Expect a response that is terminated with a connection close.
  
  =head2 headers
  
    my $headers = $content->headers;
    $content    = $content->headers(Mojo::Headers->new);
  
  Content headers, defaults to a L<Mojo::Headers> object.
  
  =head2 max_buffer_size
  
    my $size = $content->max_buffer_size;
    $content = $content->max_buffer_size(1024);
  
  Maximum size in bytes of buffer for content parser, defaults to the value of
  the C<MOJO_MAX_BUFFER_SIZE> environment variable or C<262144> (256KB).
  
  =head2 max_leftover_size
  
    my $size = $content->max_leftover_size;
    $content = $content->max_leftover_size(1024);
  
  Maximum size in bytes of buffer for pipelined HTTP requests, defaults to the
  value of the C<MOJO_MAX_LEFTOVER_SIZE> environment variable or C<262144>
  (256KB).
  
  =head2 relaxed
  
    my $bool = $content->relaxed;
    $content = $content->relaxed($bool);
  
  Activate relaxed parsing for responses that are terminated with a connection
  close.
  
  =head2 skip_body
  
    my $bool = $content->skip_body;
    $content = $content->skip_body($bool);
  
  Skip body parsing and finish after headers.
  
  =head1 METHODS
  
  L<Mojo::Content> inherits all methods from L<Mojo::EventEmitter> and implements
  the following new ones.
  
  =head2 body_contains
  
    my $bool = $content->body_contains('foo bar baz');
  
  Check if content contains a specific string. Meant to be overloaded in a
  subclass.
  
  =head2 body_size
  
    my $size = $content->body_size;
  
  Content size in bytes. Meant to be overloaded in a subclass.
  
  =head2 boundary
  
    my $boundary = $content->boundary;
  
  Extract multipart boundary from C<Content-Type> header.
  
  =head2 charset
  
    my $charset = $content->charset;
  
  Extract charset from C<Content-Type> header.
  
  =head2 clone
  
    my $clone = $content->clone;
  
  Clone content if possible, otherwise return C<undef>.
  
  =head2 generate_body_chunk
  
    my $bytes = $content->generate_body_chunk(0);
  
  Generate dynamic content.
  
  =head2 get_body_chunk
  
    my $bytes = $content->get_body_chunk(0);
  
  Get a chunk of content starting from a specific position. Meant to be
  overloaded in a subclass.
  
  =head2 get_header_chunk
  
    my $bytes = $content->get_header_chunk(13);
  
  Get a chunk of the headers starting from a specific position. Note that this
  method finalizes the content.
  
  =head2 header_size
  
    my $size = $content->header_size;
  
  Size of headers in bytes. Note that this method finalizes the content.
  
  =head2 headers_contain
  
    my $bool = $content->headers_contain('foo bar baz');
  
  Check if headers contain a specific string. Note that this method finalizes the
  content.
  
  =head2 is_chunked
  
    my $bool = $content->is_chunked;
  
  Check if C<Transfer-Encoding> header indicates chunked transfer encoding.
  
  =head2 is_compressed
  
    my $bool = $content->is_compressed;
  
  Check C<Content-Encoding> header for C<gzip> value.
  
  =head2 is_dynamic
  
    my $bool = $content->is_dynamic;
  
  Check if content will be dynamically generated, which prevents L</"clone"> from
  working.
  
  =head2 is_finished
  
    my $bool = $content->is_finished;
  
  Check if parser is finished.
  
  =head2 is_limit_exceeded
  
    my $bool = $content->is_limit_exceeded;
  
  Check if buffer has exceeded L</"max_buffer_size">.
  
  =head2 is_multipart
  
    my $bool = $content->is_multipart;
  
  False, this is not a L<Mojo::Content::MultiPart> object.
  
  =head2 is_parsing_body
  
    my $bool = $content->is_parsing_body;
  
  Check if body parsing started yet.
  
  =head2 leftovers
  
    my $bytes = $content->leftovers;
  
  Get leftover data from content parser.
  
  =head2 parse
  
    $content
      = $content->parse("Content-Length: 12\x0d\x0a\x0d\x0aHello World!");
  
  Parse content chunk.
  
  =head2 parse_body
  
    $content = $content->parse_body('Hi!');
  
  Parse body chunk and skip headers.
  
  =head2 progress
  
    my $size = $content->progress;
  
  Size of content already received from message in bytes.
  
  =head2 write
  
    $content = $content->write;
    $content = $content->write('');
    $content = $content->write($bytes);
    $content = $content->write($bytes => sub {...});
  
  Write dynamic content non-blocking, the optional drain callback will be executed
  once all data has been written. Calling this method without a chunk of data
  will finalize the L</"headers"> and allow for dynamic content to be written
  later. You can write an empty chunk of data at any time to end the stream.
  
    # Make sure previous chunk of data has been written before continuing
    $content->write('He' => sub {
      my $content = shift;
      $content->write('llo!' => sub {
        my $content = shift;
        $content->write('');
      });
    });
  
  =head2 write_chunk
  
    $content = $content->write_chunk;
    $content = $content->write_chunk('');
    $content = $content->write_chunk($bytes);
    $content = $content->write_chunk($bytes => sub {...});
  
  Write dynamic content non-blocking with chunked transfer encoding, the optional
  drain callback will be executed once all data has been written. Calling this
  method without a chunk of data will finalize the L</"headers"> and allow for
  dynamic content to be written later. You can write an empty chunk of data at any
  time to end the stream.
  
    # Make sure previous chunk of data has been written before continuing
    $content->write_chunk('He' => sub {
      my $content = shift;
      $content->write_chunk('llo!' => sub {
        my $content = shift;
        $content->write_chunk('');
      });
    });
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<http://mojolicious.org>.
  
  =cut
MOJO_CONTENT

$fatpacked{"Mojo/Content/MultiPart.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJO_CONTENT_MULTIPART';
  package Mojo::Content::MultiPart;
  use Mojo::Base 'Mojo::Content';
  
  use Mojo::Util 'b64_encode';
  
  has parts => sub { [] };
  
  sub body_contains {
    my ($self, $chunk) = @_;
    ($_->headers_contain($chunk) or $_->body_contains($chunk)) and return 1
      for @{$self->parts};
    return undef;
  }
  
  sub body_size {
    my $self = shift;
  
    # Check for existing Content-Lenght header
    if (my $len = $self->headers->content_length) { return $len }
  
    # Calculate length of whole body
    my $len = my $boundary_len = length($self->build_boundary) + 6;
    $len += $_->header_size + $_->body_size + $boundary_len for @{$self->parts};
  
    return $len;
  }
  
  sub build_boundary {
    my $self = shift;
  
    # Check for existing boundary
    my $boundary;
    return $boundary if defined($boundary = $self->boundary);
  
    # Generate and check boundary
    my $size = 1;
    do {
      $boundary = b64_encode join('', map chr(rand 256), 1 .. $size++ * 3);
      $boundary =~ s/\W/X/g;
    } while $self->body_contains($boundary);
  
    # Add boundary to Content-Type header
    my $headers = $self->headers;
    ($headers->content_type // '') =~ m!^(.*multipart/[^;]+)(.*)$!;
    my $before = $1 || 'multipart/mixed';
    my $after  = $2 || '';
    $headers->content_type("$before; boundary=$boundary$after");
  
    return $boundary;
  }
  
  sub clone {
    my $self = shift;
    return undef unless my $clone = $self->SUPER::clone();
    return $clone->parts($self->parts);
  }
  
  sub get_body_chunk {
    my ($self, $offset) = @_;
  
    # Body generator
    return $self->generate_body_chunk($offset) if $self->{dynamic};
  
    # First boundary
    my $boundary     = $self->build_boundary;
    my $boundary_len = length($boundary) + 6;
    my $len          = $boundary_len - 2;
    return substr "--$boundary\x0d\x0a", $offset if $len > $offset;
  
    # Prepare content part by part
    my $parts = $self->parts;
    for (my $i = 0; $i < @$parts; $i++) {
      my $part = $parts->[$i];
  
      # Headers
      my $header_len = $part->header_size;
      return $part->get_header_chunk($offset - $len)
        if ($len + $header_len) > $offset;
      $len += $header_len;
  
      # Content
      my $content_len = $part->body_size;
      return $part->get_body_chunk($offset - $len)
        if ($len + $content_len) > $offset;
      $len += $content_len;
  
      # Boundary
      if ($#$parts == $i) {
        $boundary .= '--';
        $boundary_len += 2;
      }
      return substr "\x0d\x0a--$boundary\x0d\x0a", $offset - $len
        if ($len + $boundary_len) > $offset;
      $len += $boundary_len;
    }
  }
  
  sub is_multipart {1}
  
  sub new {
    my $self = shift->SUPER::new(@_);
    $self->on(read => \&_read);
    return $self;
  }
  
  sub _parse_multipart_body {
    my ($self, $boundary) = @_;
  
    # Whole part in buffer
    my $pos = index $self->{multipart}, "\x0d\x0a--$boundary";
    if ($pos < 0) {
      my $len = length($self->{multipart}) - (length($boundary) + 8);
      return undef unless $len > 0;
  
      # Store chunk
      my $chunk = substr $self->{multipart}, 0, $len, '';
      $self->parts->[-1] = $self->parts->[-1]->parse($chunk);
      return undef;
    }
  
    # Store chunk
    my $chunk = substr $self->{multipart}, 0, $pos, '';
    $self->parts->[-1] = $self->parts->[-1]->parse($chunk);
    return !!($self->{multi_state} = 'multipart_boundary');
  }
  
  sub _parse_multipart_boundary {
    my ($self, $boundary) = @_;
  
    # Boundary begins
    if ((index $self->{multipart}, "\x0d\x0a--$boundary\x0d\x0a") == 0) {
      substr $self->{multipart}, 0, length($boundary) + 6, '';
  
      # New part
      my $part = Mojo::Content::Single->new(relaxed => 1);
      $self->emit(part => $part);
      push @{$self->parts}, $part;
      return !!($self->{multi_state} = 'multipart_body');
    }
  
    # Boundary ends
    my $end = "\x0d\x0a--$boundary--";
    if ((index $self->{multipart}, $end) == 0) {
      substr $self->{multipart}, 0, length $end, '';
      $self->{multi_state} = 'finished';
    }
  
    return undef;
  }
  
  sub _parse_multipart_preamble {
    my ($self, $boundary) = @_;
  
    # No boundary yet
    return undef if (my $pos = index $self->{multipart}, "--$boundary") < 0;
  
    # Replace preamble with carriage return and line feed
    substr $self->{multipart}, 0, $pos, "\x0d\x0a";
  
    # Parse boundary
    return !!($self->{multi_state} = 'multipart_boundary');
  }
  
  sub _read {
    my ($self, $chunk) = @_;
  
    $self->{multipart} .= $chunk;
    my $boundary = $self->boundary;
    until (($self->{multi_state} //= 'multipart_preamble') eq 'finished') {
  
      # Preamble
      if ($self->{multi_state} eq 'multipart_preamble') {
        last unless $self->_parse_multipart_preamble($boundary);
      }
  
      # Boundary
      elsif ($self->{multi_state} eq 'multipart_boundary') {
        last unless $self->_parse_multipart_boundary($boundary);
      }
  
      # Body
      elsif ($self->{multi_state} eq 'multipart_body') {
        last unless $self->_parse_multipart_body($boundary);
      }
    }
  
    # Check buffer size
    @$self{qw(state limit)} = ('finished', 1)
      if length($self->{multipart} // '') > $self->max_buffer_size;
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojo::Content::MultiPart - HTTP multipart content
  
  =head1 SYNOPSIS
  
    use Mojo::Content::MultiPart;
  
    my $multi = Mojo::Content::MultiPart->new;
    $multi->parse('Content-Type: multipart/mixed; boundary=---foobar');
    my $single = $multi->parts->[4];
  
  =head1 DESCRIPTION
  
  L<Mojo::Content::MultiPart> is a container for HTTP multipart content, based on
  L<RFC 7230|http://tools.ietf.org/html/rfc7230>,
  L<RFC 7231|http://tools.ietf.org/html/rfc7231> and
  L<RFC 2388|http://tools.ietf.org/html/rfc2388>.
  
  =head1 EVENTS
  
  L<Mojo::Content::Multipart> inherits all events from L<Mojo::Content> and can
  emit the following new ones.
  
  =head2 part
  
    $multi->on(part => sub {
      my ($multi, $single) = @_;
      ...
    });
  
  Emitted when a new L<Mojo::Content::Single> part starts.
  
    $multi->on(part => sub {
      my ($multi, $single) = @_;
      return unless $single->headers->content_disposition =~ /name="([^"]+)"/;
      say "Field: $1";
    });
  
  =head1 ATTRIBUTES
  
  L<Mojo::Content::MultiPart> inherits all attributes from L<Mojo::Content> and
  implements the following new ones.
  
  =head2 parts
  
    my $parts = $multi->parts;
    $multi    = $multi->parts([Mojo::Content::Single->new]);
  
  Content parts embedded in this multipart content, usually
  L<Mojo::Content::Single> objects.
  
  =head1 METHODS
  
  L<Mojo::Content::MultiPart> inherits all methods from L<Mojo::Content> and
  implements the following new ones.
  
  =head2 body_contains
  
    my $bool = $multi->body_contains('foobarbaz');
  
  Check if content parts contain a specific string.
  
  =head2 body_size
  
    my $size = $multi->body_size;
  
  Content size in bytes.
  
  =head2 build_boundary
  
    my $boundary = $multi->build_boundary;
  
  Generate a suitable boundary for content and add it to C<Content-Type> header.
  
  =head2 clone
  
    my $clone = $multi->clone;
  
  Clone content if possible, otherwise return C<undef>.
  
  =head2 get_body_chunk
  
    my $bytes = $multi->get_body_chunk(0);
  
  Get a chunk of content starting from a specific position. Note that it might
  not be possible to get the same chunk twice if content was generated
  dynamically.
  
  =head2 is_multipart
  
    my $bool = $multi->is_multipart;
  
  True, this is a L<Mojo::Content::MultiPart> object.
  
  =head2 new
  
    my $multi = Mojo::Content::MultiPart->new;
    my $multi
      = Mojo::Content::MultiPart->new(parts => [Mojo::Content::Single->new]);
    my $multi
      = Mojo::Content::MultiPart->new({parts => [Mojo::Content::Single->new]});
  
  Construct a new L<Mojo::Content::MultiPart> object and subscribe to L</"read">
  event with default content parser.
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<http://mojolicious.org>.
  
  =cut
MOJO_CONTENT_MULTIPART

$fatpacked{"Mojo/Content/Single.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJO_CONTENT_SINGLE';
  package Mojo::Content::Single;
  use Mojo::Base 'Mojo::Content';
  
  use Mojo::Asset::Memory;
  use Mojo::Content::MultiPart;
  
  has asset => sub { Mojo::Asset::Memory->new(auto_upgrade => 1) };
  has auto_upgrade => 1;
  
  sub body_contains { shift->asset->contains(shift) >= 0 }
  
  sub body_size {
    my $self = shift;
    return ($self->headers->content_length || 0) if $self->{dynamic};
    return $self->asset->size;
  }
  
  sub clone {
    my $self = shift;
    return undef unless my $clone = $self->SUPER::clone();
    return $clone->asset($self->asset);
  }
  
  sub get_body_chunk {
    my ($self, $offset) = @_;
    return $self->generate_body_chunk($offset) if $self->{dynamic};
    return $self->asset->get_chunk($offset);
  }
  
  sub new {
    my $self = shift->SUPER::new(@_);
    $self->{read}
      = $self->on(read => sub { $_[0]->asset($_[0]->asset->add_chunk($_[1])) });
    return $self;
  }
  
  sub parse {
    my $self = shift;
  
    # Parse headers
    $self->_parse_until_body(@_);
  
    # Parse body
    return $self->SUPER::parse
      unless $self->auto_upgrade && defined $self->boundary;
  
    # Content needs to be upgraded to multipart
    $self->unsubscribe(read => $self->{read});
    my $multi = Mojo::Content::MultiPart->new(%$self);
    $self->emit(upgrade => $multi);
    return $multi->parse;
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojo::Content::Single - HTTP content
  
  =head1 SYNOPSIS
  
    use Mojo::Content::Single;
  
    my $single = Mojo::Content::Single->new;
    $single->parse("Content-Length: 12\x0d\x0a\x0d\x0aHello World!");
    say $single->headers->content_length;
  
  =head1 DESCRIPTION
  
  L<Mojo::Content::Single> is a container for HTTP content, based on
  L<RFC 7230|http://tools.ietf.org/html/rfc7230> and
  L<RFC 7231|http://tools.ietf.org/html/rfc7231>.
  
  =head1 EVENTS
  
  L<Mojo::Content::Single> inherits all events from L<Mojo::Content> and can emit
  the following new ones.
  
  =head2 upgrade
  
    $single->on(upgrade => sub {
      my ($single, $multi) = @_;
      ...
    });
  
  Emitted when content gets upgraded to a L<Mojo::Content::MultiPart> object.
  
    $single->on(upgrade => sub {
      my ($single, $multi) = @_;
      return unless $multi->headers->content_type =~ /multipart\/([^;]+)/i;
      say "Multipart: $1";
    });
  
  =head1 ATTRIBUTES
  
  L<Mojo::Content::Single> inherits all attributes from L<Mojo::Content> and
  implements the following new ones.
  
  =head2 asset
  
    my $asset = $single->asset;
    $single   = $single->asset(Mojo::Asset::Memory->new);
  
  The actual content, defaults to a L<Mojo::Asset::Memory> object with
  L<Mojo::Asset::Memory/"auto_upgrade"> enabled.
  
  =head2 auto_upgrade
  
    my $bool = $single->auto_upgrade;
    $single  = $single->auto_upgrade($bool);
  
  Try to detect multipart content and automatically upgrade to a
  L<Mojo::Content::MultiPart> object, defaults to a true value.
  
  =head1 METHODS
  
  L<Mojo::Content::Single> inherits all methods from L<Mojo::Content> and
  implements the following new ones.
  
  =head2 body_contains
  
    my $bool = $single->body_contains('1234567');
  
  Check if content contains a specific string.
  
  =head2 body_size
  
    my $size = $single->body_size;
  
  Content size in bytes.
  
  =head2 clone
  
    my $clone = $single->clone;
  
  Clone content if possible, otherwise return C<undef>.
  
  =head2 get_body_chunk
  
    my $bytes = $single->get_body_chunk(0);
  
  Get a chunk of content starting from a specific position. Note that it might
  not be possible to get the same chunk twice if content was generated
  dynamically.
  
  =head2 new
  
    my $single = Mojo::Content::Single->new;
    my $single = Mojo::Content::Single->new(asset => Mojo::Asset::File->new);
    my $single = Mojo::Content::Single->new({asset => Mojo::Asset::File->new});
  
  Construct a new L<Mojo::Content::Single> object and subscribe to L</"read">
  event with default content parser.
  
  =head2 parse
  
    $single = $single->parse("Content-Length: 12\x0d\x0a\x0d\x0aHello World!");
    my $multi
      = $single->parse("Content-Type: multipart/form-data\x0d\x0a\x0d\x0a");
  
  Parse content chunk and upgrade to L<Mojo::Content::MultiPart> object if
  necessary.
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<http://mojolicious.org>.
  
  =cut
MOJO_CONTENT_SINGLE

$fatpacked{"Mojo/Cookie.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJO_COOKIE';
  package Mojo::Cookie;
  use Mojo::Base -base;
  use overload bool => sub {1}, '""' => sub { shift->to_string }, fallback => 1;
  
  use Carp 'croak';
  
  has [qw(name value)];
  
  sub parse     { croak 'Method "parse" not implemented by subclass' }
  sub to_string { croak 'Method "to_string" not implemented by subclass' }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojo::Cookie - HTTP cookie base class
  
  =head1 SYNOPSIS
  
    package Mojo::Cookie::MyCookie;
    use Mojo::Base 'Mojo::Cookie';
  
    sub parse     {...}
    sub to_string {...}
  
  =head1 DESCRIPTION
  
  L<Mojo::Cookie> is an abstract base class for HTTP cookie containers, based on
  L<RFC 6265|http://tools.ietf.org/html/rfc6265>, like L<Mojo::Cookie::Request>
  and L<Mojo::Cookie::Response>.
  
  =head1 ATTRIBUTES
  
  L<Mojo::Cookie> implements the following attributes.
  
  =head2 name
  
    my $name = $cookie->name;
    $cookie  = $cookie->name('foo');
  
  Cookie name.
  
  =head2 value
  
    my $value = $cookie->value;
    $cookie   = $cookie->value('/test');
  
  Cookie value.
  
  =head1 METHODS
  
  L<Mojo::Cookie> inherits all methods from L<Mojo::Base> and implements the
  following new ones.
  
  =head2 parse
  
    my $cookies = $cookie->parse($str);
  
  Parse cookies. Meant to be overloaded in a subclass.
  
  =head2 to_string
  
    my $str = $cookie->to_string;
  
  Render cookie. Meant to be overloaded in a subclass.
  
  =head1 OPERATORS
  
  L<Mojo::Cookie> overloads the following operators.
  
  =head2 bool
  
    my $bool = !!$cookie;
  
  Always true.
  
  =head2 stringify
  
    my $str = "$cookie";
  
  Alias for L</"to_string">.
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<http://mojolicious.org>.
  
  =cut
MOJO_COOKIE

$fatpacked{"Mojo/Cookie/Request.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJO_COOKIE_REQUEST';
  package Mojo::Cookie::Request;
  use Mojo::Base 'Mojo::Cookie';
  
  use Mojo::Util qw(quote split_header);
  
  sub parse {
    my ($self, $str) = @_;
  
    my @cookies;
    my @pairs = map {@$_} @{split_header $str // ''};
    while (my ($name, $value) = splice @pairs, 0, 2) {
      next if $name =~ /^\$/;
      push @cookies, $self->new(name => $name, value => $value // '');
    }
  
    return \@cookies;
  }
  
  sub to_string {
    my $self = shift;
    return '' unless length(my $name = $self->name // '');
    my $value = $self->value // '';
    return join '=', $name, $value =~ /[,;" ]/ ? quote $value : $value;
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojo::Cookie::Request - HTTP request cookie
  
  =head1 SYNOPSIS
  
    use Mojo::Cookie::Request;
  
    my $cookie = Mojo::Cookie::Request->new;
    $cookie->name('foo');
    $cookie->value('bar');
    say "$cookie";
  
  =head1 DESCRIPTION
  
  L<Mojo::Cookie::Request> is a container for HTTP request cookies, based on
  L<RFC 6265|http://tools.ietf.org/html/rfc6265>.
  
  =head1 ATTRIBUTES
  
  L<Mojo::Cookie::Request> inherits all attributes from L<Mojo::Cookie>.
  
  =head1 METHODS
  
  L<Mojo::Cookie::Request> inherits all methods from L<Mojo::Cookie> and
  implements the following new ones.
  
  =head2 parse
  
    my $cookies = Mojo::Cookie::Request->parse('f=b; g=a');
  
  Parse cookies.
  
  =head2 to_string
  
    my $str = $cookie->to_string;
  
  Render cookie.
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<http://mojolicious.org>.
  
  =cut
MOJO_COOKIE_REQUEST

$fatpacked{"Mojo/Cookie/Response.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJO_COOKIE_RESPONSE';
  package Mojo::Cookie::Response;
  use Mojo::Base 'Mojo::Cookie';
  
  use Mojo::Date;
  use Mojo::Util qw(quote split_cookie_header);
  
  has [qw(domain expires httponly max_age origin path secure)];
  
  my %ATTRS = map { $_ => 1 } qw(domain expires httponly max-age path secure);
  
  sub parse {
    my ($self, $str) = @_;
  
    my @cookies;
    my $tree = split_cookie_header $str // '';
    while (my $pairs = shift @$tree) {
      my ($name, $value) = splice @$pairs, 0, 2;
      push @cookies, $self->new(name => $name, value => $value // '');
  
      while (my ($name, $value) = splice @$pairs, 0, 2) {
        next unless $ATTRS{my $attr = lc $name};
        $value =~ s/^\.// if $attr eq 'domain' && defined $value;
        $value = Mojo::Date->new($value // '')->epoch if $attr eq 'expires';
        $value = 1 if $attr eq 'secure' || $attr eq 'httponly';
        $cookies[-1]{$attr eq 'max-age' ? 'max_age' : $attr} = $value;
      }
    }
  
    return \@cookies;
  }
  
  sub to_string {
    my $self = shift;
  
    # Name and value
    return '' unless length(my $name = $self->name // '');
    my $value = $self->value // '';
    my $cookie = join '=', $name, $value =~ /[,;" ]/ ? quote $value : $value;
  
    # "expires"
    my $expires = $self->expires;
    $cookie .= '; expires=' . Mojo::Date->new($expires) if defined $expires;
  
    # "domain"
    if (my $domain = $self->domain) { $cookie .= "; domain=$domain" }
  
    # "path"
    if (my $path = $self->path) { $cookie .= "; path=$path" }
  
    # "secure"
    $cookie .= "; secure" if $self->secure;
  
    # "HttpOnly"
    $cookie .= "; HttpOnly" if $self->httponly;
  
    # "Max-Age"
    if (defined(my $max = $self->max_age)) { $cookie .= "; Max-Age=$max" }
  
    return $cookie;
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojo::Cookie::Response - HTTP response cookie
  
  =head1 SYNOPSIS
  
    use Mojo::Cookie::Response;
  
    my $cookie = Mojo::Cookie::Response->new;
    $cookie->name('foo');
    $cookie->value('bar');
    say "$cookie";
  
  =head1 DESCRIPTION
  
  L<Mojo::Cookie::Response> is a container for HTTP response cookies, based on
  L<RFC 6265|http://tools.ietf.org/html/rfc6265>.
  
  =head1 ATTRIBUTES
  
  L<Mojo::Cookie::Response> inherits all attributes from L<Mojo::Cookie> and
  implements the following new ones.
  
  =head2 domain
  
    my $domain = $cookie->domain;
    $cookie    = $cookie->domain('localhost');
  
  Cookie domain.
  
  =head2 expires
  
    my $expires = $cookie->expires;
    $cookie     = $cookie->expires(time + 60);
  
  Expiration for cookie.
  
  =head2 httponly
  
    my $bool = $cookie->httponly;
    $cookie  = $cookie->httponly($bool);
  
  HttpOnly flag, which can prevent client-side scripts from accessing this
  cookie.
  
  =head2 max_age
  
    my $max_age = $cookie->max_age;
    $cookie     = $cookie->max_age(60);
  
  Max age for cookie.
  
  =head2 origin
  
    my $origin = $cookie->origin;
    $cookie    = $cookie->origin('mojolicious.org');
  
  Origin of the cookie.
  
  =head2 path
  
    my $path = $cookie->path;
    $cookie  = $cookie->path('/test');
  
  Cookie path.
  
  =head2 secure
  
    my $bool = $cookie->secure;
    $cookie  = $cookie->secure($bool);
  
  Secure flag, which instructs browsers to only send this cookie over HTTPS
  connections.
  
  =head1 METHODS
  
  L<Mojo::Cookie::Response> inherits all methods from L<Mojo::Cookie> and
  implements the following new ones.
  
  =head2 parse
  
    my $cookies = Mojo::Cookie::Response->parse('f=b; path=/');
  
  Parse cookies.
  
  =head2 to_string
  
    my $str = $cookie->to_string;
  
  Render cookie.
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<http://mojolicious.org>.
  
  =cut
MOJO_COOKIE_RESPONSE

$fatpacked{"Mojo/DOM.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJO_DOM';
  package Mojo::DOM;
  use Mojo::Base -strict;
  use overload
    '@{}'    => sub { shift->child_nodes },
    '%{}'    => sub { shift->attr },
    bool     => sub {1},
    '""'     => sub { shift->to_string },
    fallback => 1;
  
  # "Fry: This snow is beautiful. I'm glad global warming never happened.
  #  Leela: Actually, it did. But thank God nuclear winter canceled it out."
  use Carp 'croak';
  use Mojo::Collection;
  use Mojo::DOM::CSS;
  use Mojo::DOM::HTML;
  use Scalar::Util qw(blessed weaken);
  
  sub all_text { _text([_nodes(shift->tree)], 1) }
  
  sub ancestors { _select($_[0]->_collect($_[0]->_ancestors), $_[1]) }
  
  sub append { shift->_add(1, @_) }
  sub append_content { shift->_content(1, 0, @_) }
  
  sub at {
    my $self = shift;
    return undef unless my $result = $self->_css->select_one(@_);
    return $self->_build($result, $self->xml);
  }
  
  sub attr {
    my $self = shift;
  
    # Hash
    my $tree = $self->tree;
    my $attrs = $tree->[0] ne 'tag' ? {} : $tree->[2];
    return $attrs unless @_;
  
    # Get
    return $attrs->{$_[0]} unless @_ > 1 || ref $_[0];
  
    # Set
    my $values = ref $_[0] ? $_[0] : {@_};
    @$attrs{keys %$values} = values %$values;
  
    return $self;
  }
  
  sub child_nodes { $_[0]->_collect(_nodes($_[0]->tree)) }
  
  sub children { _select($_[0]->_collect(_nodes($_[0]->tree, 1)), $_[1]) }
  
  sub content {
    my $self = shift;
  
    my $type = $self->type;
    if ($type eq 'root' || $type eq 'tag') {
      return $self->_content(0, 1, @_) if @_;
      my $html = Mojo::DOM::HTML->new(xml => $self->xml);
      return join '', map { $html->tree($_)->render } _nodes($self->tree);
    }
  
    return $self->tree->[1] unless @_;
    $self->tree->[1] = shift;
    return $self;
  }
  
  sub descendant_nodes { $_[0]->_collect(_all(_nodes($_[0]->tree))) }
  
  sub find { $_[0]->_collect(@{$_[0]->_css->select($_[1])}) }
  
  sub following { _select($_[0]->_collect(@{$_[0]->_siblings(1)->[1]}), $_[1]) }
  sub following_nodes { $_[0]->_collect(@{$_[0]->_siblings->[1]}) }
  
  sub matches { shift->_css->matches(@_) }
  
  sub namespace {
    my $self = shift;
  
    return undef if (my $tree = $self->tree)->[0] ne 'tag';
  
    # Extract namespace prefix and search parents
    my $ns = $tree->[1] =~ /^(.*?):/ ? "xmlns:$1" : undef;
    for my $node ($tree, $self->_ancestors) {
  
      # Namespace for prefix
      my $attrs = $node->[2];
      if ($ns) { $_ eq $ns and return $attrs->{$_} for keys %$attrs }
  
      # Namespace attribute
      elsif (defined $attrs->{xmlns}) { return $attrs->{xmlns} }
    }
  
    return undef;
  }
  
  sub new {
    my $class = shift;
    my $self = bless \Mojo::DOM::HTML->new, ref $class || $class;
    return @_ ? $self->parse(@_) : $self;
  }
  
  sub next      { $_[0]->_maybe($_[0]->_siblings(1, 0)->[1]) }
  sub next_node { $_[0]->_maybe($_[0]->_siblings(0, 0)->[1]) }
  
  sub parent {
    my $self = shift;
    return undef if $self->tree->[0] eq 'root';
    return $self->_build($self->_parent, $self->xml);
  }
  
  sub parse { shift->_delegate(parse => @_) }
  
  sub preceding { _select($_[0]->_collect(@{$_[0]->_siblings(1)->[0]}), $_[1]) }
  sub preceding_nodes { $_[0]->_collect(@{$_[0]->_siblings->[0]}) }
  
  sub prepend { shift->_add(0, @_) }
  sub prepend_content { shift->_content(0, 0, @_) }
  
  sub previous      { $_[0]->_maybe($_[0]->_siblings(1, -1)->[0]) }
  sub previous_node { $_[0]->_maybe($_[0]->_siblings(0, -1)->[0]) }
  
  sub remove { shift->replace('') }
  
  sub replace {
    my ($self, $new) = @_;
    return $self->parse($new) if (my $tree = $self->tree)->[0] eq 'root';
    return $self->_replace($self->_parent, $tree, _nodes($self->_parse($new)));
  }
  
  sub root {
    my $self = shift;
    return $self unless my $tree = $self->_ancestors(1);
    return $self->_build($tree, $self->xml);
  }
  
  sub strip {
    my $self = shift;
    return $self if (my $tree = $self->tree)->[0] ne 'tag';
    return $self->_replace($tree->[3], $tree, _nodes($tree));
  }
  
  sub tag {
    my ($self, $tag) = @_;
    return undef if (my $tree = $self->tree)->[0] ne 'tag';
    return $tree->[1] unless $tag;
    $tree->[1] = $tag;
    return $self;
  }
  
  sub tap { shift->Mojo::Base::tap(@_) }
  
  sub text { _text([_nodes(shift->tree)], 0) }
  
  sub to_string { shift->_delegate('render') }
  
  sub tree { shift->_delegate(tree => @_) }
  
  sub type { shift->tree->[0] }
  
  sub val {
    my $self = shift;
  
    # "option"
    return $self->{value} // $self->text if (my $tag = $self->tag) eq 'option';
  
    # "input" ("type=checkbox" and "type=radio")
    my $type = $self->{type} // '';
    return $self->{value} // 'on'
      if $tag eq 'input' && ($type eq 'radio' || $type eq 'checkbox');
  
    # "textarea", "input" or "button"
    return $tag eq 'textarea' ? $self->text : $self->{value} if $tag ne 'select';
  
    # "select"
    my $v = $self->find('option:checked')->map('val');
    return exists $self->{multiple} ? $v->size ? $v->to_array : undef : $v->last;
  }
  
  sub wrap         { shift->_wrap(0, @_) }
  sub wrap_content { shift->_wrap(1, @_) }
  
  sub xml { shift->_delegate(xml => @_) }
  
  sub _add {
    my ($self, $offset, $new) = @_;
  
    return $self if (my $tree = $self->tree)->[0] eq 'root';
  
    my $parent = $self->_parent;
    splice @$parent, _offset($parent, $tree) + $offset, 0,
      _link($parent, _nodes($self->_parse($new)));
  
    return $self;
  }
  
  sub _all {
    map { $_->[0] eq 'tag' ? ($_, _all(_nodes($_))) : ($_) } @_;
  }
  
  sub _ancestors {
    my ($self, $root) = @_;
  
    return () unless my $tree = $self->_parent;
    my @ancestors;
    do { push @ancestors, $tree }
      while ($tree->[0] eq 'tag') && ($tree = $tree->[3]);
    return $root ? $ancestors[-1] : @ancestors[0 .. $#ancestors - 1];
  }
  
  sub _build { shift->new->tree(shift)->xml(shift) }
  
  sub _collect {
    my $self = shift;
    my $xml  = $self->xml;
    return Mojo::Collection->new(map { $self->_build($_, $xml) } @_);
  }
  
  sub _content {
    my ($self, $start, $offset, $new) = @_;
  
    my $tree = $self->tree;
    unless ($tree->[0] eq 'root' || $tree->[0] eq 'tag') {
      my $old = $self->content;
      return $self->content($start ? $old . $new : $new . $old);
    }
  
    $start  = $start  ? ($#$tree + 1) : _start($tree);
    $offset = $offset ? $#$tree       : 0;
    splice @$tree, $start, $offset, _link($tree, _nodes($self->_parse($new)));
  
    return $self;
  }
  
  sub _css { Mojo::DOM::CSS->new(tree => shift->tree) }
  
  sub _delegate {
    my ($self, $method) = (shift, shift);
    return $$self->$method unless @_;
    $$self->$method(@_);
    return $self;
  }
  
  sub _link {
    my ($parent, @children) = @_;
  
    # Link parent to children
    for my $node (@children) {
      my $offset = $node->[0] eq 'tag' ? 3 : 2;
      $node->[$offset] = $parent;
      weaken $node->[$offset];
    }
  
    return @children;
  }
  
  sub _maybe { $_[1] ? $_[0]->_build($_[1], $_[0]->xml) : undef }
  
  sub _nodes {
    return () unless my $tree = shift;
    my @nodes = @$tree[_start($tree) .. $#$tree];
    return shift() ? grep { $_->[0] eq 'tag' } @nodes : @nodes;
  }
  
  sub _offset {
    my ($parent, $child) = @_;
    my $i = _start($parent);
    $_ eq $child ? last : $i++ for @$parent[$i .. $#$parent];
    return $i;
  }
  
  sub _parent { $_[0]->tree->[$_[0]->type eq 'tag' ? 3 : 2] }
  
  sub _parse { Mojo::DOM::HTML->new(xml => shift->xml)->parse(shift)->tree }
  
  sub _replace {
    my ($self, $parent, $child, @nodes) = @_;
    splice @$parent, _offset($parent, $child), 1, _link($parent, @nodes);
    return $self->parent;
  }
  
  sub _select {
    my ($collection, $selector) = @_;
    return $collection unless $selector;
    return $collection->new(grep { $_->matches($selector) } @$collection);
  }
  
  sub _siblings {
    my ($self, $tags, $i) = @_;
  
    return [] unless my $parent = $self->parent;
  
    my $tree = $self->tree;
    my (@before, @after, $match);
    for my $node (_nodes($parent->tree)) {
      ++$match and next if !$match && $node eq $tree;
      next if $tags && $node->[0] ne 'tag';
      $match ? push @after, $node : push @before, $node;
    }
  
    return defined $i ? [$before[$i], $after[$i]] : [\@before, \@after];
  }
  
  sub _start { $_[0][0] eq 'root' ? 1 : 4 }
  
  sub _text {
    my ($nodes, $all) = @_;
  
    my $text = '';
    while (my $node = shift @$nodes) {
      my $type = $node->[0];
  
      # Text
      if ($type eq 'text' || $type eq 'cdata' || $type eq 'raw') {
        $text .= $node->[1];
      }
  
      # Nested tag
      elsif ($type eq 'tag' && $all) { unshift @$nodes, _nodes($node) }
    }
  
    return $text;
  }
  
  sub _wrap {
    my ($self, $content, $new) = @_;
  
    return $self if (my $tree = $self->tree)->[0] eq 'root' && !$content;
    return $self if $tree->[0] ne 'root' && $tree->[0] ne 'tag' && $content;
  
    # Find innermost tag
    my $current;
    my $first = $new = $self->_parse($new);
    $current = $first while $first = (_nodes($first, 1))[0];
    return $self unless $current;
  
    # Wrap content
    if ($content) {
      push @$current, _link($current, _nodes($tree));
      splice @$tree, _start($tree), $#$tree, _link($tree, _nodes($new));
      return $self;
    }
  
    # Wrap element
    $self->_replace($self->_parent, $tree, _nodes($new));
    push @$current, _link($current, $tree);
    return $self;
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojo::DOM - Minimalistic HTML/XML DOM parser with CSS selectors
  
  =head1 SYNOPSIS
  
    use Mojo::DOM;
  
    # Parse
    my $dom = Mojo::DOM->new('<div><p id="a">Test</p><p id="b">123</p></div>');
  
    # Find
    say $dom->at('#b')->text;
    say $dom->find('p')->map('text')->join("\n");
    say $dom->find('[id]')->map(attr => 'id')->join("\n");
  
    # Iterate
    $dom->find('p[id]')->reverse->each(sub { say $_->{id} });
  
    # Loop
    for my $e ($dom->find('p[id]')->each) {
      say $e->{id}, ':', $e->text;
    }
  
    # Modify
    $dom->find('div p')->last->append('<p id="c">456</p>');
    $dom->find(':not(p)')->map('strip');
  
    # Render
    say "$dom";
  
  =head1 DESCRIPTION
  
  L<Mojo::DOM> is a minimalistic and relaxed HTML/XML DOM parser with CSS
  selector support. It will even try to interpret broken HTML and XML, so you
  should not use it for validation.
  
  =head1 NODES AND ELEMENTS
  
  When we parse an HTML/XML fragment, it gets turned into a tree of nodes.
  
    <!DOCTYPE html>
    <html>
      <head><title>Hello</title></head>
      <body>World!</body>
    </html>
  
  There are currently eight different kinds of nodes, C<cdata>, C<comment>,
  C<doctype>, C<pi>, C<raw>, C<root>, C<tag> and C<text>. Elements are nodes of
  the type C<tag>.
  
    root
    |- doctype (html)
    +- tag (html)
       |- tag (head)
       |  +- tag (title)
       |     +- raw (Hello)
       +- tag (body)
          +- text (World!)
  
  While all node types are represented as L<Mojo::DOM> objects, some methods like
  L</"attr"> and L</"namespace"> only apply to elements.
  
  =head1 CASE-SENSITIVITY
  
  L<Mojo::DOM> defaults to HTML semantics, that means all tags and attribute
  names are lowercased and selectors need to be lowercase as well.
  
    # HTML semantics
    my $dom = Mojo::DOM->new('<P ID="greeting">Hi!</P>');
    say $dom->at('p[id]')->text;
  
  If an XML declaration is found, the parser will automatically switch into XML
  mode and everything becomes case-sensitive.
  
    # XML semantics
    my $dom = Mojo::DOM->new('<?xml version="1.0"?><P ID="greeting">Hi!</P>');
    say $dom->at('P[ID]')->text;
  
  XML detection can also be disabled with the L</"xml"> method.
  
    # Force XML semantics
    my $dom = Mojo::DOM->new->xml(1)->parse('<P ID="greeting">Hi!</P>');
    say $dom->at('P[ID]')->text;
  
    # Force HTML semantics
    my $dom = Mojo::DOM->new->xml(0)->parse('<P ID="greeting">Hi!</P>');
    say $dom->at('p[id]')->text;
  
  =head1 METHODS
  
  L<Mojo::DOM> implements the following methods.
  
  =head2 all_text
  
    my $text = $dom->all_text;
  
  Extract text content from all descendant nodes of this element.
  
    # "foo\nbarbaz\n"
    $dom->parse("<div>foo\n<p>bar</p>baz\n</div>")->at('div')->all_text;
  
  =head2 ancestors
  
    my $collection = $dom->ancestors;
    my $collection = $dom->ancestors('div ~ p');
  
  Find all ancestor elements of this node matching the CSS selector and return a
  L<Mojo::Collection> object containing these elements as L<Mojo::DOM> objects.
  All selectors from L<Mojo::DOM::CSS/"SELECTORS"> are supported.
  
    # List tag names of ancestor elements
    say $dom->ancestors->map('tag')->join("\n");
  
  =head2 append
  
    $dom = $dom->append('<p>I  Mojolicious!</p>');
  
  Append HTML/XML fragment to this node (for all node types other than C<root>).
  
    # "<div><h1>Test</h1><h2>123</h2></div>"
    $dom->parse('<div><h1>Test</h1></div>')
      ->at('h1')->append('<h2>123</h2>')->root;
  
    # "<p>Test 123</p>"
    $dom->parse('<p>Test</p>')->at('p')
      ->child_nodes->first->append(' 123')->root;
  
  =head2 append_content
  
    $dom = $dom->append_content('<p>I  Mojolicious!</p>');
  
  Append HTML/XML fragment (for C<root> and C<tag> nodes) or raw content to this
  node's content.
  
    # "<div><h1>Test123</h1></div>"
    $dom->parse('<div><h1>Test</h1></div>')
      ->at('h1')->append_content('123')->root;
  
    # "<!-- Test 123 --><br>"
    $dom->parse('<!-- Test --><br>')
      ->child_nodes->first->append_content('123 ')->root;
  
    # "<p>Test<i>123</i></p>"
    $dom->parse('<p>Test</p>')->at('p')->append_content('<i>123</i>')->root;
  
  =head2 at
  
    my $result = $dom->at('div ~ p');
  
  Find first descendant element of this element matching the CSS selector and
  return it as a L<Mojo::DOM> object, or C<undef> if none could be found. All
  selectors from L<Mojo::DOM::CSS/"SELECTORS"> are supported.
  
    # Find first element with "svg" namespace definition
    my $namespace = $dom->at('[xmlns\:svg]')->{'xmlns:svg'};
  
  =head2 attr
  
    my $hash = $dom->attr;
    my $foo  = $dom->attr('foo');
    $dom     = $dom->attr({foo => 'bar'});
    $dom     = $dom->attr(foo => 'bar');
  
  This element's attributes.
  
    # Remove an attribute
    delete $dom->attr->{id};
  
    # Attribute without value
    $dom->attr(selected => undef);
  
    # List id attributes
    say $dom->find('*')->map(attr => 'id')->compact->join("\n");
  
  =head2 child_nodes
  
    my $collection = $dom->child_nodes;
  
  Return a L<Mojo::Collection> object containing all child nodes of this element
  as L<Mojo::DOM> objects.
  
    # "<p><b>123</b></p>"
    $dom->parse('<p>Test<b>123</b></p>')->at('p')->child_nodes->first->remove;
  
    # "<!DOCTYPE html>"
    $dom->parse('<!DOCTYPE html><b>123</b>')->child_nodes->first;
  
    # " Test "
    $dom->parse('<b>123</b><!-- Test -->')->child_nodes->last->content;
  
  =head2 children
  
    my $collection = $dom->children;
    my $collection = $dom->children('div ~ p');
  
  Find all child elements of this element matching the CSS selector and return a
  L<Mojo::Collection> object containing these elements as L<Mojo::DOM> objects.
  All selectors from L<Mojo::DOM::CSS/"SELECTORS"> are supported.
  
    # Show tag name of random child element
    say $dom->children->shuffle->first->tag;
  
  =head2 content
  
    my $str = $dom->content;
    $dom    = $dom->content('<p>I  Mojolicious!</p>');
  
  Return this node's content or replace it with HTML/XML fragment (for C<root>
  and C<tag> nodes) or raw content.
  
    # "<b>Test</b>"
    $dom->parse('<div><b>Test</b></div>')->at('div')->content;
  
    # "<div><h1>123</h1></div>"
    $dom->parse('<div><h1>Test</h1></div>')->at('h1')->content('123')->root;
  
    # "<p><i>123</i></p>"
    $dom->parse('<p>Test</p>')->at('p')->content('<i>123</i>')->root;
  
    # "<div><h1></h1></div>"
    $dom->parse('<div><h1>Test</h1></div>')->at('h1')->content('')->root;
  
    # " Test "
    $dom->parse('<!-- Test --><br>')->child_nodes->first->content;
  
    # "<div><!-- 123 -->456</div>"
    $dom->parse('<div><!-- Test -->456</div>')
      ->at('div')->child_nodes->first->content(' 123 ')->root;
  
  =head2 descendant_nodes
  
    my $collection = $dom->descendant_nodes;
  
  Return a L<Mojo::Collection> object containing all descendant nodes of this
  element as L<Mojo::DOM> objects.
  
    # "<p><b>123</b></p>"
    $dom->parse('<p><!-- Test --><b>123<!-- 456 --></b></p>')
      ->descendant_nodes->grep(sub { $_->type eq 'comment' })
      ->map('remove')->first;
  
    # "<p><b>test</b>test</p>"
    $dom->parse('<p><b>123</b>456</p>')
      ->at('p')->descendant_nodes->grep(sub { $_->type eq 'text' })
      ->map(content => 'test')->first->root;
  
  =head2 find
  
    my $collection = $dom->find('div ~ p');
  
  Find all descendant elements of this element matching the CSS selector and
  return a L<Mojo::Collection> object containing these elements as L<Mojo::DOM>
  objects. All selectors from L<Mojo::DOM::CSS/"SELECTORS"> are supported.
  
    # Find a specific element and extract information
    my $id = $dom->find('div')->[23]{id};
  
    # Extract information from multiple elements
    my @headers = $dom->find('h1, h2, h3')->map('text')->each;
  
    # Count all the different tags
    my $hash = $dom->find('*')->reduce(sub { $a->{$b->tag}++; $a }, {});
  
    # Find elements with a class that contains dots
    my @divs = $dom->find('div.foo\.bar')->each;
  
  =head2 following
  
    my $collection = $dom->following;
    my $collection = $dom->following('div ~ p');
  
  Find all sibling elements after this node matching the CSS selector and return
  a L<Mojo::Collection> object containing these elements as L<Mojo::DOM> objects.
  All selectors from L<Mojo::DOM::CSS/"SELECTORS"> are supported.
  
    # List tags of sibling elements after this node
    say $dom->following->map('tag')->join("\n");
  
  =head2 following_nodes
  
    my $collection = $dom->following_nodes;
  
  Return a L<Mojo::Collection> object containing all sibling nodes after this
  node as L<Mojo::DOM> objects.
  
    # "C"
    $dom->parse('<p>A</p><!-- B -->C')->at('p')->following_nodes->last->content;
  
  =head2 matches
  
    my $bool = $dom->matches('div ~ p');
  
  Check if this element matches the CSS selector. All selectors from
  L<Mojo::DOM::CSS/"SELECTORS"> are supported.
  
    # True
    $dom->parse('<p class="a">A</p>')->at('p')->matches('.a');
    $dom->parse('<p class="a">A</p>')->at('p')->matches('p[class]');
  
    # False
    $dom->parse('<p class="a">A</p>')->at('p')->matches('.b');
    $dom->parse('<p class="a">A</p>')->at('p')->matches('p[id]');
  
  =head2 namespace
  
    my $namespace = $dom->namespace;
  
  Find this element's namespace, or return C<undef> if none could be found.
  
    # Find namespace for an element with namespace prefix
    my $namespace = $dom->at('svg > svg\:circle')->namespace;
  
    # Find namespace for an element that may or may not have a namespace prefix
    my $namespace = $dom->at('svg > circle')->namespace;
  
  =head2 new
  
    my $dom = Mojo::DOM->new;
    my $dom = Mojo::DOM->new('<foo bar="baz">I  Mojolicious!</foo>');
  
  Construct a new scalar-based L<Mojo::DOM> object and L</"parse"> HTML/XML
  fragment if necessary.
  
  =head2 next
  
    my $sibling = $dom->next;
  
  Return L<Mojo::DOM> object for next sibling element, or C<undef> if there are no
  more siblings.
  
    # "<h2>123</h2>"
    $dom->parse('<div><h1>Test</h1><h2>123</h2></div>')->at('h1')->next;
  
  =head2 next_node
  
    my $sibling = $dom->next_node;
  
  Return L<Mojo::DOM> object for next sibling node, or C<undef> if there are no
  more siblings.
  
    # "456"
    $dom->parse('<p><b>123</b><!-- Test -->456</p>')
      ->at('b')->next_node->next_node;
  
    # " Test "
    $dom->parse('<p><b>123</b><!-- Test -->456</p>')
      ->at('b')->next_node->content;
  
  =head2 parent
  
    my $parent = $dom->parent;
  
  Return L<Mojo::DOM> object for parent of this node, or C<undef> if this node has
  no parent.
  
    # "<b><i>Test</i></b>"
    $dom->parse('<p><b><i>Test</i></b></p>')->at('i')->parent;
  
  =head2 parse
  
    $dom = $dom->parse('<foo bar="baz">I  Mojolicious!</foo>');
  
  Parse HTML/XML fragment with L<Mojo::DOM::HTML>.
  
    # Parse XML
    my $dom = Mojo::DOM->new->xml(1)->parse('<foo>I  Mojolicious!</foo>');
  
  =head2 preceding
  
    my $collection = $dom->preceding;
    my $collection = $dom->preceding('div ~ p');
  
  Find all sibling elements before this node matching the CSS selector and return
  a L<Mojo::Collection> object containing these elements as L<Mojo::DOM> objects.
  All selectors from L<Mojo::DOM::CSS/"SELECTORS"> are supported.
  
    # List tags of sibling elements before this node
    say $dom->preceding->map('tag')->join("\n");
  
  =head2 preceding_nodes
  
    my $collection = $dom->preceding_nodes;
  
  Return a L<Mojo::Collection> object containing all sibling nodes before this
  node as L<Mojo::DOM> objects.
  
    # "A"
    $dom->parse('A<!-- B --><p>C</p>')->at('p')->preceding_nodes->first->content;
  
  =head2 prepend
  
    $dom = $dom->prepend('<p>I  Mojolicious!</p>');
  
  Prepend HTML/XML fragment to this node (for all node types other than C<root>).
  
    # "<div><h1>Test</h1><h2>123</h2></div>"
    $dom->parse('<div><h2>123</h2></div>')
      ->at('h2')->prepend('<h1>Test</h1>')->root;
  
    # "<p>Test 123</p>"
    $dom->parse('<p>123</p>')
      ->at('p')->child_nodes->first->prepend('Test ')->root;
  
  =head2 prepend_content
  
    $dom = $dom->prepend_content('<p>I  Mojolicious!</p>');
  
  Prepend HTML/XML fragment (for C<root> and C<tag> nodes) or raw content to this
  node's content.
  
    # "<div><h2>Test123</h2></div>"
    $dom->parse('<div><h2>123</h2></div>')
      ->at('h2')->prepend_content('Test')->root;
  
    # "<!-- Test 123 --><br>"
    $dom->parse('<!-- 123 --><br>')
      ->child_nodes->first->prepend_content(' Test')->root;
  
    # "<p><i>123</i>Test</p>"
    $dom->parse('<p>Test</p>')->at('p')->prepend_content('<i>123</i>')->root;
  
  =head2 previous
  
    my $sibling = $dom->previous;
  
  Return L<Mojo::DOM> object for previous sibling element, or C<undef> if there
  are no more siblings.
  
    # "<h1>Test</h1>"
    $dom->parse('<div><h1>Test</h1><h2>123</h2></div>')->at('h2')->previous;
  
  =head2 previous_node
  
    my $sibling = $dom->previous_node;
  
  Return L<Mojo::DOM> object for previous sibling node, or C<undef> if there are
  no more siblings.
  
    # "123"
    $dom->parse('<p>123<!-- Test --><b>456</b></p>')
      ->at('b')->previous_node->previous_node;
  
    # " Test "
    $dom->parse('<p>123<!-- Test --><b>456</b></p>')
      ->at('b')->previous_node->content;
  
  =head2 remove
  
    my $parent = $dom->remove;
  
  Remove this node and return L</"root"> (for C<root> nodes) or L</"parent">.
  
    # "<div></div>"
    $dom->parse('<div><h1>Test</h1></div>')->at('h1')->remove;
  
    # "<p><b>456</b></p>"
    $dom->parse('<p>123<b>456</b></p>')
      ->at('p')->child_nodes->first->remove->root;
  
  =head2 replace
  
    my $parent = $dom->replace('<div>I  Mojolicious!</div>');
  
  Replace this node with HTML/XML fragment and return L</"root"> (for C<root>
  nodes) or L</"parent">.
  
    # "<div><h2>123</h2></div>"
    $dom->parse('<div><h1>Test</h1></div>')->at('h1')->replace('<h2>123</h2>');
  
    # "<p><b>123</b></p>"
    $dom->parse('<p>Test</p>')
      ->at('p')->child_nodes->[0]->replace('<b>123</b>')->root;
  
  =head2 root
  
    my $root = $dom->root;
  
  Return L<Mojo::DOM> object for C<root> node.
  
  =head2 strip
  
    my $parent = $dom->strip;
  
  Remove this element while preserving its content and return L</"parent">.
  
    # "<div>Test</div>"
    $dom->parse('<div><h1>Test</h1></div>')->at('h1')->strip;
  
  =head2 tag
  
    my $tag = $dom->tag;
    $dom    = $dom->tag('div');
  
  This element's tag name.
  
    # List tag names of child elements
    say $dom->children->map('tag')->join("\n");
  
  =head2 tap
  
    $dom = $dom->tap(sub {...});
  
  Alias for L<Mojo::Base/"tap">.
  
  =head2 text
  
    my $text = $dom->text;
  
  Extract text content from this element only (not including child elements).
  
    # "bar"
    $dom->parse("<div>foo<p>bar</p>baz</div>")->at('p')->text;
  
    # "foo\nbaz\n"
    $dom->parse("<div>foo\n<p>bar</p>baz\n</div>")->at('div')->text;
  
  =head2 to_string
  
    my $str = $dom->to_string;
  
  Render this node and its content to HTML/XML.
  
    # "<b>Test</b>"
    $dom->parse('<div><b>Test</b></div>')->at('div b')->to_string;
  
  =head2 tree
  
    my $tree = $dom->tree;
    $dom     = $dom->tree(['root']);
  
  Document Object Model. Note that this structure should only be used very
  carefully since it is very dynamic.
  
  =head2 type
  
    my $type = $dom->type;
  
  This node's type, usually C<cdata>, C<comment>, C<doctype>, C<pi>, C<raw>,
  C<root>, C<tag> or C<text>.
  
    # "cdata"
    $dom->parse('<![CDATA[Test]]>')->child_nodes->first->type;
  
    # "comment"
    $dom->parse('<!-- Test -->')->child_nodes->first->type;
  
    # "doctype"
    $dom->parse('<!DOCTYPE html>')->child_nodes->first->type;
  
    # "pi"
    $dom->parse('<?xml version="1.0"?>')->child_nodes->first->type;
  
    # "raw"
    $dom->parse('<title>Test</title>')->at('title')->child_nodes->first->type;
  
    # "root"
    $dom->parse('<p>Test</p>')->type;
  
    # "tag"
    $dom->parse('<p>Test</p>')->at('p')->type;
  
    # "text"
    $dom->parse('<p>Test</p>')->at('p')->child_nodes->first->type;
  
  =head2 val
  
    my $value = $dom->val;
  
  Extract value from form element (such as C<button>, C<input>, C<option>,
  C<select> and C<textarea>), or return C<undef> if this element has no value. In
  the case of C<select> with C<multiple> attribute, find C<option> elements with
  C<selected> attribute and return an array reference with all values, or C<undef>
  if none could be found.
  
    # "a"
    $dom->parse('<input name=test value=a>')->at('input')->val;
  
    # "b"
    $dom->parse('<textarea>b</textarea>')->at('textarea')->val;
  
    # "c"
    $dom->parse('<option value="c">Test</option>')->at('option')->val;
  
    # "d"
    $dom->parse('<select><option selected>d</option></select>')
      ->at('select')->val;
  
    # "e"
    $dom->parse('<select multiple><option selected>e</option></select>')
      ->at('select')->val->[0];
  
    # "on"
    $dom->parse('<input name=test type=checkbox>')->at('input')->val;
  
  =head2 wrap
  
    $dom = $dom->wrap('<div></div>');
  
  Wrap HTML/XML fragment around this node (for all node types other than C<root>),
  placing it as the last child of the first innermost element.
  
    # "<p>123<b>Test</b></p>"
    $dom->parse('<b>Test</b>')->at('b')->wrap('<p>123</p>')->root;
  
    # "<div><p><b>Test</b></p>123</div>"
    $dom->parse('<b>Test</b>')->at('b')->wrap('<div><p></p>123</div>')->root;
  
    # "<p><b>Test</b></p><p>123</p>"
    $dom->parse('<b>Test</b>')->at('b')->wrap('<p></p><p>123</p>')->root;
  
    # "<p><b>Test</b></p>"
    $dom->parse('<p>Test</p>')->at('p')->child_nodes->first->wrap('<b>')->root;
  
  =head2 wrap_content
  
    $dom = $dom->wrap_content('<div></div>');
  
  Wrap HTML/XML fragment around this node's content (for C<root> and C<tag>
  nodes), placing it as the last children of the first innermost element.
  
    # "<p><b>123Test</b></p>"
    $dom->parse('<p>Test<p>')->at('p')->wrap_content('<b>123</b>')->root;
  
    # "<p><b>Test</b></p><p>123</p>"
    $dom->parse('<b>Test</b>')->wrap_content('<p></p><p>123</p>');
  
  =head2 xml
  
    my $bool = $dom->xml;
    $dom     = $dom->xml($bool);
  
  Disable HTML semantics in parser and activate case-sensitivity, defaults to
  auto-detection based on XML declarations.
  
  =head1 OPERATORS
  
  L<Mojo::DOM> overloads the following operators.
  
  =head2 array
  
    my @nodes = @$dom;
  
  Alias for L</"child_nodes">.
  
    # "<!-- Test -->"
    $dom->parse('<!-- Test --><b>123</b>')->[0];
  
  =head2 bool
  
    my $bool = !!$dom;
  
  Always true.
  
  =head2 hash
  
    my %attrs = %$dom;
  
  Alias for L</"attr">.
  
    # "test"
    $dom->parse('<div id="test">Test</div>')->at('div')->{id};
  
  =head2 stringify
  
    my $str = "$dom";
  
  Alias for L</"to_string">.
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<http://mojolicious.org>.
  
  =cut
MOJO_DOM

$fatpacked{"Mojo/DOM/CSS.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJO_DOM_CSS';
  package Mojo::DOM::CSS;
  use Mojo::Base -base;
  
  use Mojo::Util 'trim';
  
  has 'tree';
  
  my $ESCAPE_RE = qr/\\[^0-9a-fA-F]|\\[0-9a-fA-F]{1,6}/;
  my $ATTR_RE   = qr/
    \[
    ((?:$ESCAPE_RE|[\w\-])+)                              # Key
    (?:
      (\W)?=                                              # Operator
      (?:"((?:\\"|[^"])*)"|'((?:\\'|[^'])*)'|([^\]]+?))   # Value
      (?:\s+(i))?                                         # Case-sensitivity
    )?
    \]
  /x;
  
  sub matches {
    my $tree = shift->tree;
    return $tree->[0] ne 'tag' ? undef : _match(_compile(shift), $tree, $tree);
  }
  
  sub select     { _select(0, shift->tree, _compile(@_)) }
  sub select_one { _select(1, shift->tree, _compile(@_)) }
  
  sub _ancestor {
    my ($selectors, $current, $tree, $one, $pos) = @_;
  
    while ($current = $current->[3]) {
      return undef if $current->[0] eq 'root' || $current eq $tree;
      return 1 if _combinator($selectors, $current, $tree, $pos);
      last if $one;
    }
  
    return undef;
  }
  
  sub _attr {
    my ($name_re, $value_re, $current) = @_;
  
    my $attrs = $current->[2];
    for my $name (keys %$attrs) {
      my $value = $attrs->{$name};
      next if $name !~ $name_re || (!defined $value && defined $value_re);
      return 1 if !(defined $value && defined $value_re) || $value =~ $value_re;
    }
  
    return undef;
  }
  
  sub _combinator {
    my ($selectors, $current, $tree, $pos) = @_;
  
    # Selector
    return undef unless my $c = $selectors->[$pos];
    if (ref $c) {
      return undef unless _selector($c, $current);
      return 1 unless $c = $selectors->[++$pos];
    }
  
    # ">" (parent only)
    return _ancestor($selectors, $current, $tree, 1, ++$pos) if $c eq '>';
  
    # "~" (preceding siblings)
    return _sibling($selectors, $current, $tree, 0, ++$pos) if $c eq '~';
  
    # "+" (immediately preceding siblings)
    return _sibling($selectors, $current, $tree, 1, ++$pos) if $c eq '+';
  
    # " " (ancestor)
    return _ancestor($selectors, $current, $tree, 0, ++$pos);
  }
  
  sub _compile {
    my $css = trim "$_[0]";
  
    my $group = [[]];
    while (my $selectors = $group->[-1]) {
      push @$selectors, [] unless @$selectors && ref $selectors->[-1];
      my $last = $selectors->[-1];
  
      # Separator
      if ($css =~ /\G\s*,\s*/gc) { push @$group, [] }
  
      # Combinator
      elsif ($css =~ /\G\s*([ >+~])\s*/gc) { push @$selectors, $1 }
  
      # Class or ID
      elsif ($css =~ /\G([.#])((?:$ESCAPE_RE\s|\\.|[^,.#:[ >~+])+)/gco) {
        my ($name, $op) = $1 eq '.' ? ('class', '~') : ('id', '');
        push @$last, ['attr', _name($name), _value($op, $2)];
      }
  
      # Attributes
      elsif ($css =~ /\G$ATTR_RE/gco) {
        push @$last, ['attr', _name($1), _value($2 // '', $3 // $4 // $5, $6)];
      }
  
      # Pseudo-class
      elsif ($css =~ /\G:([\w\-]+)(?:\(((?:\([^)]+\)|[^)])+)\))?/gcs) {
        my ($name, $args) = (lc $1, $2);
  
        # ":not" (contains more selectors)
        $args = _compile($args) if $name eq 'not';
  
        # ":nth-*" (with An+B notation)
        $args = _equation($args) if $name =~ /^nth-/;
  
        # ":first-*" (rewrite to ":nth-*")
        ($name, $args) = ("nth-$1", [0, 1]) if $name =~ /^first-(.+)$/;
  
        # ":last-*" (rewrite to ":nth-*")
        ($name, $args) = ("nth-$name", [-1, 1]) if $name =~ /^last-/;
  
        push @$last, ['pc', $name, $args];
      }
  
      # Tag
      elsif ($css =~ /\G((?:$ESCAPE_RE\s|\\.|[^,.#:[ >~+])+)/gco) {
        push @$last, ['tag', _name($1)] unless $1 eq '*';
      }
  
      else {last}
    }
  
    return $group;
  }
  
  sub _empty { $_[0][0] eq 'comment' || $_[0][0] eq 'pi' }
  
  sub _equation {
    return [0, 0] unless my $equation = shift;
  
    # "even"
    return [2, 2] if $equation =~ /^\s*even\s*$/i;
  
    # "odd"
    return [2, 1] if $equation =~ /^\s*odd\s*$/i;
  
    # "4", "+4" or "-4"
    return [0, $1] if $equation =~ /^\s*((?:\+|-)?\d+)\s*$/;
  
    # "n", "4n", "+4n", "-4n", "n+1", "4n-1", "+4n-1" (and other variations)
    return [0, 0]
      unless $equation =~ /^\s*((?:\+|-)?(?:\d+)?)?n\s*((?:\+|-)\s*\d+)?\s*$/i;
    return [$1 eq '-' ? -1 : !length $1 ? 1 : $1, join('', split(' ', $2 // 0))];
  }
  
  sub _match {
    my ($group, $current, $tree) = @_;
    _combinator([reverse @$_], $current, $tree, 0) and return 1 for @$group;
    return undef;
  }
  
  sub _name {qr/(?:^|:)\Q@{[_unescape(shift)]}\E$/}
  
  sub _pc {
    my ($class, $args, $current) = @_;
  
    # ":checked"
    return exists $current->[2]{checked} || exists $current->[2]{selected}
      if $class eq 'checked';
  
    # ":not"
    return !_match($args, $current, $current) if $class eq 'not';
  
    # ":empty"
    return !grep { !_empty($_) } @$current[4 .. $#$current] if $class eq 'empty';
  
    # ":root"
    return $current->[3] && $current->[3][0] eq 'root' if $class eq 'root';
  
    # ":nth-child", ":nth-last-child", ":nth-of-type" or ":nth-last-of-type"
    if (ref $args) {
      my $type = $class =~ /of-type$/ ? $current->[1] : undef;
      my @siblings = @{_siblings($current, $type)};
      @siblings = reverse @siblings if $class =~ /^nth-last/;
  
      for my $i (0 .. $#siblings) {
        next if (my $result = $args->[0] * $i + $args->[1]) < 1;
        last unless my $sibling = $siblings[$result - 1];
        return 1 if $sibling eq $current;
      }
    }
  
    # ":only-child" or ":only-of-type"
    elsif ($class eq 'only-child' || $class eq 'only-of-type') {
      my $type = $class eq 'only-of-type' ? $current->[1] : undef;
      $_ ne $current and return undef for @{_siblings($current, $type)};
      return 1;
    }
  
    return undef;
  }
  
  sub _select {
    my ($one, $tree, $group) = @_;
  
    my @results;
    my @queue = @$tree[($tree->[0] eq 'root' ? 1 : 4) .. $#$tree];
    while (my $current = shift @queue) {
      next unless $current->[0] eq 'tag';
  
      unshift @queue, @$current[4 .. $#$current];
      next unless _match($group, $current, $tree);
      $one ? return $current : push @results, $current;
    }
  
    return $one ? undef : \@results;
  }
  
  sub _selector {
    my ($selector, $current) = @_;
  
    for my $s (@$selector) {
      my $type = $s->[0];
  
      # Tag
      if ($type eq 'tag') { return undef unless $current->[1] =~ $s->[1] }
  
      # Attribute
      elsif ($type eq 'attr') { return undef unless _attr(@$s[1, 2], $current) }
  
      # Pseudo-class
      elsif ($type eq 'pc') { return undef unless _pc(@$s[1, 2], $current) }
    }
  
    return 1;
  }
  
  sub _sibling {
    my ($selectors, $current, $tree, $immediate, $pos) = @_;
  
    my $found;
    for my $sibling (@{_siblings($current)}) {
      return $found if $sibling eq $current;
  
      # "+" (immediately preceding sibling)
      if ($immediate) { $found = _combinator($selectors, $sibling, $tree, $pos) }
  
      # "~" (preceding sibling)
      else { return 1 if _combinator($selectors, $sibling, $tree, $pos) }
    }
  
    return undef;
  }
  
  sub _siblings {
    my ($current, $type) = @_;
  
    my $parent = $current->[3];
    my @siblings = grep { $_->[0] eq 'tag' }
      @$parent[($parent->[0] eq 'root' ? 1 : 4) .. $#$parent];
    @siblings = grep { $type eq $_->[1] } @siblings if defined $type;
  
    return \@siblings;
  }
  
  sub _unescape {
    my $value = shift;
  
    # Remove escaped newlines
    $value =~ s/\\\n//g;
  
    # Unescape Unicode characters
    $value =~ s/\\([0-9a-fA-F]{1,6})\s?/pack 'U', hex $1/ge;
  
    # Remove backslash
    $value =~ s/\\//g;
  
    return $value;
  }
  
  sub _value {
    my ($op, $value, $insensitive) = @_;
    return undef unless defined $value;
    $value = ($insensitive ? '(?i)' : '') . quotemeta _unescape($value);
  
    # "~=" (word)
    return qr/(?:^|\s+)$value(?:\s+|$)/ if $op eq '~';
  
    # "*=" (contains)
    return qr/$value/ if $op eq '*';
  
    # "^=" (begins with)
    return qr/^$value/ if $op eq '^';
  
    # "$=" (ends with)
    return qr/$value$/ if $op eq '$';
  
    # Everything else
    return qr/^$value$/;
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojo::DOM::CSS - CSS selector engine
  
  =head1 SYNOPSIS
  
    use Mojo::DOM::CSS;
  
    # Select elements from DOM tree
    my $css = Mojo::DOM::CSS->new(tree => $tree);
    my $elements = $css->select('h1, h2, h3');
  
  =head1 DESCRIPTION
  
  L<Mojo::DOM::CSS> is the CSS selector engine used by L<Mojo::DOM>, based on the
  L<HTML Living Standard|https://html.spec.whatwg.org> and
  L<Selectors Level 3|http://www.w3.org/TR/css3-selectors/>.
  
  =head1 SELECTORS
  
  All CSS selectors that make sense for a standalone parser are supported.
  
  =head2 *
  
  Any element.
  
    my $all = $css->select('*');
  
  =head2 E
  
  An element of type C<E>.
  
    my $title = $css->select('title');
  
  =head2 E[foo]
  
  An C<E> element with a C<foo> attribute.
  
    my $links = $css->select('a[href]');
  
  =head2 E[foo="bar"]
  
  An C<E> element whose C<foo> attribute value is exactly equal to C<bar>.
  
    my $case_sensitive = $css->select('input[type="hidden"]');
    my $case_sensitive = $css->select('input[type=hidden]');
  
  =head2 E[foo="bar" i]
  
  An C<E> element whose C<foo> attribute value is exactly equal to any
  (ASCII-range) case-permutation of C<bar>. Note that this selector is
  EXPERIMENTAL and might change without warning!
  
    my $case_insensitive = $css->select('input[type="hidden" i]');
    my $case_insensitive = $css->select('input[type=hidden i]');
    my $case_insensitive = $css->select('input[class~="foo" i]');
  
  This selector is part of
  L<Selectors Level 4|http://dev.w3.org/csswg/selectors-4>, which is still a work
  in progress.
  
  =head2 E[foo~="bar"]
  
  An C<E> element whose C<foo> attribute value is a list of whitespace-separated
  values, one of which is exactly equal to C<bar>.
  
    my $foo = $css->select('input[class~="foo"]');
    my $foo = $css->select('input[class~=foo]');
  
  =head2 E[foo^="bar"]
  
  An C<E> element whose C<foo> attribute value begins exactly with the string
  C<bar>.
  
    my $begins_with = $css->select('input[name^="f"]');
    my $begins_with = $css->select('input[name^=f]');
  
  =head2 E[foo$="bar"]
  
  An C<E> element whose C<foo> attribute value ends exactly with the string
  C<bar>.
  
    my $ends_with = $css->select('input[name$="o"]');
    my $ends_with = $css->select('input[name$=o]');
  
  =head2 E[foo*="bar"]
  
  An C<E> element whose C<foo> attribute value contains the substring C<bar>.
  
    my $contains = $css->select('input[name*="fo"]');
    my $contains = $css->select('input[name*=fo]');
  
  =head2 E:root
  
  An C<E> element, root of the document.
  
    my $root = $css->select(':root');
  
  =head2 E:nth-child(n)
  
  An C<E> element, the C<n-th> child of its parent.
  
    my $third = $css->select('div:nth-child(3)');
    my $odd   = $css->select('div:nth-child(odd)');
    my $even  = $css->select('div:nth-child(even)');
    my $top3  = $css->select('div:nth-child(-n+3)');
  
  =head2 E:nth-last-child(n)
  
  An C<E> element, the C<n-th> child of its parent, counting from the last one.
  
    my $third    = $css->select('div:nth-last-child(3)');
    my $odd      = $css->select('div:nth-last-child(odd)');
    my $even     = $css->select('div:nth-last-child(even)');
    my $bottom3  = $css->select('div:nth-last-child(-n+3)');
  
  =head2 E:nth-of-type(n)
  
  An C<E> element, the C<n-th> sibling of its type.
  
    my $third = $css->select('div:nth-of-type(3)');
    my $odd   = $css->select('div:nth-of-type(odd)');
    my $even  = $css->select('div:nth-of-type(even)');
    my $top3  = $css->select('div:nth-of-type(-n+3)');
  
  =head2 E:nth-last-of-type(n)
  
  An C<E> element, the C<n-th> sibling of its type, counting from the last one.
  
    my $third    = $css->select('div:nth-last-of-type(3)');
    my $odd      = $css->select('div:nth-last-of-type(odd)');
    my $even     = $css->select('div:nth-last-of-type(even)');
    my $bottom3  = $css->select('div:nth-last-of-type(-n+3)');
  
  =head2 E:first-child
  
  An C<E> element, first child of its parent.
  
    my $first = $css->select('div p:first-child');
  
  =head2 E:last-child
  
  An C<E> element, last child of its parent.
  
    my $last = $css->select('div p:last-child');
  
  =head2 E:first-of-type
  
  An C<E> element, first sibling of its type.
  
    my $first = $css->select('div p:first-of-type');
  
  =head2 E:last-of-type
  
  An C<E> element, last sibling of its type.
  
    my $last = $css->select('div p:last-of-type');
  
  =head2 E:only-child
  
  An C<E> element, only child of its parent.
  
    my $lonely = $css->select('div p:only-child');
  
  =head2 E:only-of-type
  
  An C<E> element, only sibling of its type.
  
    my $lonely = $css->select('div p:only-of-type');
  
  =head2 E:empty
  
  An C<E> element that has no children (including text nodes).
  
    my $empty = $css->select(':empty');
  
  =head2 E:checked
  
  A user interface element C<E> which is checked (for instance a radio-button or
  checkbox).
  
    my $input = $css->select(':checked');
  
  =head2 E.warning
  
  An C<E> element whose class is "warning".
  
    my $warning = $css->select('div.warning');
  
  =head2 E#myid
  
  An C<E> element with C<ID> equal to "myid".
  
    my $foo = $css->select('div#foo');
  
  =head2 E:not(s)
  
  An C<E> element that does not match simple selector C<s>.
  
    my $others = $css->select('div p:not(:first-child)');
  
  =head2 E F
  
  An C<F> element descendant of an C<E> element.
  
    my $headlines = $css->select('div h1');
  
  =head2 E E<gt> F
  
  An C<F> element child of an C<E> element.
  
    my $headlines = $css->select('html > body > div > h1');
  
  =head2 E + F
  
  An C<F> element immediately preceded by an C<E> element.
  
    my $second = $css->select('h1 + h2');
  
  =head2 E ~ F
  
  An C<F> element preceded by an C<E> element.
  
    my $second = $css->select('h1 ~ h2');
  
  =head2 E, F, G
  
  Elements of type C<E>, C<F> and C<G>.
  
    my $headlines = $css->select('h1, h2, h3');
  
  =head2 E[foo=bar][bar=baz]
  
  An C<E> element whose attributes match all following attribute selectors.
  
    my $links = $css->select('a[foo^=b][foo$=ar]');
  
  =head1 ATTRIBUTES
  
  L<Mojo::DOM::CSS> implements the following attributes.
  
  =head2 tree
  
    my $tree = $css->tree;
    $css     = $css->tree(['root']);
  
  Document Object Model. Note that this structure should only be used very
  carefully since it is very dynamic.
  
  =head1 METHODS
  
  L<Mojo::DOM::CSS> inherits all methods from L<Mojo::Base> and implements the
  following new ones.
  
  =head2 matches
  
    my $bool = $css->matches('head > title');
  
  Check if first node in L</"tree"> matches the CSS selector.
  
  =head2 select
  
    my $results = $css->select('head > title');
  
  Run CSS selector against L</"tree">.
  
  =head2 select_one
  
    my $result = $css->select_one('head > title');
  
  Run CSS selector against L</"tree"> and stop as soon as the first node matched.
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<http://mojolicious.org>.
  
  =cut
MOJO_DOM_CSS

$fatpacked{"Mojo/DOM/HTML.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJO_DOM_HTML';
  package Mojo::DOM::HTML;
  use Mojo::Base -base;
  
  use Mojo::Util qw(html_attr_unescape html_unescape xml_escape);
  use Scalar::Util 'weaken';
  
  has tree => sub { ['root'] };
  has 'xml';
  
  my $ATTR_RE = qr/
    ([^<>=\s\/]+|\/)                     # Key
    (?:
      \s*=\s*
      (?s:(["'])(.*?)\g{-2}|([^>\s]*))   # Value
    )?
    \s*
  /x;
  my $TOKEN_RE = qr/
    ([^<]+)?                                            # Text
    (?:
      <(?:
        !(?:
          DOCTYPE(
          \s+\w+                                        # Doctype
          (?:(?:\s+\w+)?(?:\s+(?:"[^"]*"|'[^']*'))+)?   # External ID
          (?:\s+\[.+?\])?                               # Int Subset
          \s*)
        |
          --(.*?)--\s*                                  # Comment
        |
          \[CDATA\[(.*?)\]\]                            # CDATA
        )
      |
        \?(.*?)\?                                       # Processing Instruction
      |
        \s*([^<>\s]+\s*(?:(?:$ATTR_RE){0,32766})*+)     # Tag
      )>
    |
      (<)                                               # Runaway "<"
    )??
  /xis;
  
  # HTML elements that only contain raw text
  my %RAW = map { $_ => 1 } qw(script style);
  
  # HTML elements that only contain raw text and entities
  my %RCDATA = map { $_ => 1 } qw(title textarea);
  
  # HTML elements with optional end tags
  my %END = (body => 'head', optgroup => 'optgroup', option => 'option');
  
  # HTML elements that break paragraphs
  map { $END{$_} = 'p' } (
    qw(address article aside blockquote dir div dl fieldset footer form h1 h2),
    qw(h3 h4 h5 h6 header hr main menu nav ol p pre section table ul)
  );
  
  # HTML table elements with optional end tags
  my %TABLE = map { $_ => 1 } qw(colgroup tbody td tfoot th thead tr);
  
  # HTML elements with optional end tags and scoping rules
  my %CLOSE
    = (li => [{li => 1}, {ul => 1, ol => 1}], tr => [{tr => 1}, {table => 1}]);
  $CLOSE{$_} = [\%TABLE, {table => 1}] for qw(colgroup tbody tfoot thead);
  $CLOSE{$_} = [{dd => 1, dt => 1}, {dl    => 1}] for qw(dd dt);
  $CLOSE{$_} = [{rp => 1, rt => 1}, {ruby  => 1}] for qw(rp rt);
  $CLOSE{$_} = [{th => 1, td => 1}, {table => 1}] for qw(td th);
  
  # HTML elements without end tags
  my %EMPTY = map { $_ => 1 } (
    qw(area base br col embed hr img input keygen link menuitem meta param),
    qw(source track wbr)
  );
  
  # HTML elements categorized as phrasing content (and obsolete inline elements)
  my @PHRASING = (
    qw(a abbr area audio b bdi bdo br button canvas cite code data datalist),
    qw(del dfn em embed i iframe img input ins kbd keygen label link map mark),
    qw(math meta meter noscript object output picture progress q ruby s samp),
    qw(script select slot small span strong sub sup svg template textarea time u),
    qw(var video wbr)
  );
  my @OBSOLETE = qw(acronym applet basefont big font strike tt);
  my %PHRASING = map { $_ => 1 } @OBSOLETE, @PHRASING;
  
  # HTML elements that don't get their self-closing flag acknowledged
  my %BLOCK = map { $_ => 1 } (
    qw(a address applet article aside b big blockquote body button caption),
    qw(center code col colgroup dd details dialog dir div dl dt em fieldset),
    qw(figcaption figure font footer form frameset h1 h2 h3 h4 h5 h6 head),
    qw(header hgroup html i iframe li listing main marquee menu nav nobr),
    qw(noembed noframes noscript object ol optgroup option p plaintext pre rp),
    qw(rt s script section select small strike strong style summary table),
    qw(tbody td template textarea tfoot th thead title tr tt u ul xmp)
  );
  
  sub parse {
    my ($self, $html) = (shift, "$_[0]");
  
    my $xml = $self->xml;
    my $current = my $tree = ['root'];
    while ($html =~ /\G$TOKEN_RE/gcso) {
      my ($text, $doctype, $comment, $cdata, $pi, $tag, $runaway)
        = ($1, $2, $3, $4, $5, $6, $11);
  
      # Text (and runaway "<")
      $text .= '<' if defined $runaway;
      _node($current, 'text', html_unescape $text) if defined $text;
  
      # Tag
      if (defined $tag) {
  
        # End
        if ($tag =~ /^\/\s*(\S+)/) { _end($xml ? $1 : lc $1, $xml, \$current) }
  
        # Start
        elsif ($tag =~ m!^([^\s/]+)([\s\S]*)!) {
          my ($start, $attr) = ($xml ? $1 : lc $1, $2);
  
          # Attributes
          my (%attrs, $closing);
          while ($attr =~ /$ATTR_RE/go) {
            my ($key, $value) = ($xml ? $1 : lc $1, $3 // $4);
  
            # Empty tag
            ++$closing and next if $key eq '/';
  
            $attrs{$key} = defined $value ? html_attr_unescape $value : $value;
          }
  
          # "image" is an alias for "img"
          $start = 'img' if !$xml && $start eq 'image';
          _start($start, \%attrs, $xml, \$current);
  
          # Element without end tag (self-closing)
          _end($start, $xml, \$current)
            if !$xml && $EMPTY{$start} || ($xml || !$BLOCK{$start}) && $closing;
  
          # Raw text elements
          next if $xml || !$RAW{$start} && !$RCDATA{$start};
          next unless $html =~ m!\G(.*?)<\s*/\s*\Q$start\E\s*>!gcsi;
          _node($current, 'raw', $RCDATA{$start} ? html_unescape $1 : $1);
          _end($start, 0, \$current);
        }
      }
  
      # DOCTYPE
      elsif (defined $doctype) { _node($current, 'doctype', $doctype) }
  
      # Comment
      elsif (defined $comment) { _node($current, 'comment', $comment) }
  
      # CDATA
      elsif (defined $cdata) { _node($current, 'cdata', $cdata) }
  
      # Processing instruction (try to detect XML)
      elsif (defined $pi) {
        $self->xml($xml = 1) if !exists $self->{xml} && $pi =~ /xml/i;
        _node($current, 'pi', $pi);
      }
    }
  
    return $self->tree($tree);
  }
  
  sub render { _render($_[0]->tree, $_[0]->xml) }
  
  sub _end {
    my ($end, $xml, $current) = @_;
  
    # Search stack for start tag
    my $next = $$current;
    do {
  
      # Ignore useless end tag
      return if $next->[0] eq 'root';
  
      # Right tag
      return $$current = $next->[3] if $next->[1] eq $end;
  
      # Phrasing content can only cross phrasing content
      return if !$xml && $PHRASING{$end} && !$PHRASING{$next->[1]};
  
    } while $next = $next->[3];
  }
  
  sub _node {
    my ($current, $type, $content) = @_;
    push @$current, my $new = [$type, $content, $current];
    weaken $new->[2];
  }
  
  sub _render {
    my ($tree, $xml) = @_;
  
    # Text (escaped)
    my $type = $tree->[0];
    return xml_escape $tree->[1] if $type eq 'text';
  
    # Raw text
    return $tree->[1] if $type eq 'raw';
  
    # DOCTYPE
    return '<!DOCTYPE' . $tree->[1] . '>' if $type eq 'doctype';
  
    # Comment
    return '<!--' . $tree->[1] . '-->' if $type eq 'comment';
  
    # CDATA
    return '<![CDATA[' . $tree->[1] . ']]>' if $type eq 'cdata';
  
    # Processing instruction
    return '<?' . $tree->[1] . '?>' if $type eq 'pi';
  
    # Root
    return join '', map { _render($_, $xml) } @$tree[1 .. $#$tree]
      if $type eq 'root';
  
    # Start tag
    my $tag    = $tree->[1];
    my $result = "<$tag";
  
    # Attributes
    for my $key (sort keys %{$tree->[2]}) {
      my $value = $tree->[2]{$key};
      $result .= $xml ? qq{ $key="$key"} : " $key" and next unless defined $value;
      $result .= qq{ $key="} . xml_escape($value) . '"';
    }
  
    # No children
    return $xml ? "$result />" : $EMPTY{$tag} ? "$result>" : "$result></$tag>"
      unless $tree->[4];
  
    # Children
    no warnings 'recursion';
    $result .= '>' . join '', map { _render($_, $xml) } @$tree[4 .. $#$tree];
  
    # End tag
    return "$result</$tag>";
  }
  
  sub _start {
    my ($start, $attrs, $xml, $current) = @_;
  
    # Autoclose optional HTML elements
    if (!$xml && $$current->[0] ne 'root') {
      if (my $end = $END{$start}) { _end($end, 0, $current) }
  
      elsif (my $close = $CLOSE{$start}) {
        my ($allowed, $scope) = @$close;
  
        # Close allowed parent elements in scope
        my $parent = $$current;
        while ($parent->[0] ne 'root' && !$scope->{$parent->[1]}) {
          _end($parent->[1], 0, $current) if $allowed->{$parent->[1]};
          $parent = $parent->[3];
        }
      }
    }
  
    # New tag
    push @$$current, my $new = ['tag', $start, $attrs, $$current];
    weaken $new->[3];
    $$current = $new;
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojo::DOM::HTML - HTML/XML engine
  
  =head1 SYNOPSIS
  
    use Mojo::DOM::HTML;
  
    # Turn HTML into DOM tree
    my $html = Mojo::DOM::HTML->new;
    $html->parse('<div><p id="a">Test</p><p id="b">123</p></div>');
    my $tree = $html->tree;
  
  =head1 DESCRIPTION
  
  L<Mojo::DOM::HTML> is the HTML/XML engine used by L<Mojo::DOM>, based on the
  L<HTML Living Standard|https://html.spec.whatwg.org> and the
  L<Extensible Markup Language (XML) 1.0|http://www.w3.org/TR/xml/>.
  
  =head1 ATTRIBUTES
  
  L<Mojo::DOM::HTML> implements the following attributes.
  
  =head2 tree
  
    my $tree = $html->tree;
    $html    = $html->tree(['root']);
  
  Document Object Model. Note that this structure should only be used very
  carefully since it is very dynamic.
  
  =head2 xml
  
    my $bool = $html->xml;
    $html    = $html->xml($bool);
  
  Disable HTML semantics in parser and activate case-sensitivity, defaults to
  auto-detection based on XML declarations.
  
  =head1 METHODS
  
  L<Mojo::DOM::HTML> inherits all methods from L<Mojo::Base> and implements the
  following new ones.
  
  =head2 parse
  
    $html = $html->parse('<foo bar="baz">I  Mojolicious!</foo>');
  
  Parse HTML/XML fragment.
  
  =head2 render
  
    my $str = $html->render;
  
  Render DOM to HTML/XML.
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<http://mojolicious.org>.
  
  =cut
MOJO_DOM_HTML

$fatpacked{"Mojo/Date.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJO_DATE';
  package Mojo::Date;
  use Mojo::Base -base;
  use overload bool => sub {1}, '""' => sub { shift->to_string }, fallback => 1;
  
  use Time::Local 'timegm';
  
  has epoch => sub {time};
  
  my $RFC3339_RE = qr/
    ^(\d+)-(\d+)-(\d+)\D+(\d+):(\d+):(\d+(?:\.\d+)?)   # Date and time
    (?:Z|([+-])(\d+):(\d+))?$                          # Offset
  /xi;
  
  my @DAYS   = qw(Sun Mon Tue Wed Thu Fri Sat);
  my @MONTHS = qw(Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec);
  my %MONTHS;
  @MONTHS{@MONTHS} = (0 .. 11);
  
  sub new { @_ > 1 ? shift->SUPER::new->parse(@_) : shift->SUPER::new }
  
  sub parse {
    my ($self, $date) = @_;
  
    # epoch (784111777)
    return $self->epoch($date) if $date =~ /^\d+$|^\d+\.\d+$/;
  
    # RFC 822/1123 (Sun, 06 Nov 1994 08:49:37 GMT)
    # RFC 850/1036 (Sunday, 06-Nov-94 08:49:37 GMT)
    my $offset = 0;
    my ($day, $month, $year, $h, $m, $s);
    if ($date =~ /^\w+\W+(\d+)\W+(\w+)\W+(\d+)\W+(\d+):(\d+):(\d+)\W*\w+$/) {
      ($day, $month, $year, $h, $m, $s) = ($1, $MONTHS{$2}, $3, $4, $5, $6);
    }
  
    # RFC 3339 (1994-11-06T08:49:37Z)
    elsif ($date =~ $RFC3339_RE) {
      ($year, $month, $day, $h, $m, $s) = ($1, $2 - 1, $3, $4, $5, $6);
      $offset = (($8 * 3600) + ($9 * 60)) * ($7 eq '+' ? -1 : 1) if $7;
    }
  
    # ANSI C asctime() (Sun Nov  6 08:49:37 1994)
    elsif ($date =~ /^\w+\s+(\w+)\s+(\d+)\s+(\d+):(\d+):(\d+)\s+(\d+)$/) {
      ($month, $day, $h, $m, $s, $year) = ($MONTHS{$1}, $2, $3, $4, $5, $6);
    }
  
    # Invalid
    else { return $self->epoch(undef) }
  
    my $epoch = eval { timegm $s, $m, $h, $day, $month, $year };
    return $self->epoch(
      (defined $epoch && ($epoch += $offset) >= 0) ? $epoch : undef);
  }
  
  sub to_datetime {
  
    # RFC 3339 (1994-11-06T08:49:37Z)
    my ($s, $m, $h, $day, $month, $year) = gmtime(my $epoch = shift->epoch);
    my $str = sprintf '%04d-%02d-%02dT%02d:%02d:%02d', $year + 1900, $month + 1,
      $day, $h, $m, $s;
    return $str . ($epoch =~ /(\.\d+)$/ ? $1 : '') . 'Z';
  }
  
  sub to_string {
  
    # RFC 7231 (Sun, 06 Nov 1994 08:49:37 GMT)
    my ($s, $m, $h, $mday, $month, $year, $wday) = gmtime shift->epoch;
    return sprintf '%s, %02d %s %04d %02d:%02d:%02d GMT', $DAYS[$wday], $mday,
      $MONTHS[$month], $year + 1900, $h, $m, $s;
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojo::Date - HTTP date
  
  =head1 SYNOPSIS
  
    use Mojo::Date;
  
    # Parse
    my $date = Mojo::Date->new('Sun, 06 Nov 1994 08:49:37 GMT');
    say $date->epoch;
  
    # Build
    my $date = Mojo::Date->new(time + 60);
    say "$date";
  
  =head1 DESCRIPTION
  
  L<Mojo::Date> implements HTTP date and time functions, based on
  L<RFC 7230|http://tools.ietf.org/html/rfc7230>,
  L<RFC 7231|http://tools.ietf.org/html/rfc7231> and
  L<RFC 3339|http://tools.ietf.org/html/rfc3339>.
  
  =head1 ATTRIBUTES
  
  L<Mojo::Date> implements the following attributes.
  
  =head2 epoch
  
    my $epoch = $date->epoch;
    $date     = $date->epoch(784111777);
  
  Epoch seconds, defaults to the current time.
  
  =head1 METHODS
  
  L<Mojo::Date> inherits all methods from L<Mojo::Base> and implements the
  following new ones.
  
  =head2 new
  
    my $date = Mojo::Date->new;
    my $date = Mojo::Date->new('Sun Nov  6 08:49:37 1994');
  
  Construct a new L<Mojo::Date> object and L</"parse"> date if necessary.
  
  =head2 parse
  
    $date = $date->parse('Sun Nov  6 08:49:37 1994');
  
  Parse date.
  
    # Epoch
    say Mojo::Date->new('784111777')->epoch;
    say Mojo::Date->new('784111777.21')->epoch;
  
    # RFC 822/1123
    say Mojo::Date->new('Sun, 06 Nov 1994 08:49:37 GMT')->epoch;
  
    # RFC 850/1036
    say Mojo::Date->new('Sunday, 06-Nov-94 08:49:37 GMT')->epoch;
  
    # Ansi C asctime()
    say Mojo::Date->new('Sun Nov  6 08:49:37 1994')->epoch;
  
    # RFC 3339
    say Mojo::Date->new('1994-11-06T08:49:37Z')->epoch;
    say Mojo::Date->new('1994-11-06T08:49:37')->epoch;
    say Mojo::Date->new('1994-11-06T08:49:37.21Z')->epoch;
    say Mojo::Date->new('1994-11-06T08:49:37+01:00')->epoch;
    say Mojo::Date->new('1994-11-06T08:49:37-01:00')->epoch;
  
  =head2 to_datetime
  
    my $str = $date->to_datetime;
  
  Render L<RFC 3339|http://tools.ietf.org/html/rfc3339> date and time.
  
    # "1994-11-06T08:49:37Z"
    Mojo::Date->new(784111777)->to_datetime;
  
    # "1994-11-06T08:49:37.21Z"
    Mojo::Date->new(784111777.21)->to_datetime;
  
  =head2 to_string
  
    my $str = $date->to_string;
  
  Render date suitable for HTTP messages.
  
    # "Sun, 06 Nov 1994 08:49:37 GMT"
    Mojo::Date->new(784111777)->to_string;
  
  =head1 OPERATORS
  
  L<Mojo::Date> overloads the following operators.
  
  =head2 bool
  
    my $bool = !!$date;
  
  Always true.
  
  =head2 stringify
  
    my $str = "$date";
  
  Alias for L</"to_string">.
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<http://mojolicious.org>.
  
  =cut
MOJO_DATE

$fatpacked{"Mojo/EventEmitter.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJO_EVENTEMITTER';
  package Mojo::EventEmitter;
  use Mojo::Base -base;
  
  use Scalar::Util qw(blessed weaken);
  
  use constant DEBUG => $ENV{MOJO_EVENTEMITTER_DEBUG} || 0;
  
  sub catch { $_[0]->on(error => $_[1]) and return $_[0] }
  
  sub emit {
    my ($self, $name) = (shift, shift);
  
    if (my $s = $self->{events}{$name}) {
      warn "-- Emit $name in @{[blessed $self]} (@{[scalar @$s]})\n" if DEBUG;
      for my $cb (@$s) { $self->$cb(@_) }
    }
    else {
      warn "-- Emit $name in @{[blessed $self]} (0)\n" if DEBUG;
      die "@{[blessed $self]}: $_[0]" if $name eq 'error';
    }
  
    return $self;
  }
  
  sub has_subscribers { !!shift->{events}{shift()} }
  
  sub on { push @{$_[0]{events}{$_[1]}}, $_[2] and return $_[2] }
  
  sub once {
    my ($self, $name, $cb) = @_;
  
    weaken $self;
    my $wrapper;
    $wrapper = sub {
      $self->unsubscribe($name => $wrapper);
      $cb->(@_);
    };
    $self->on($name => $wrapper);
    weaken $wrapper;
  
    return $wrapper;
  }
  
  sub subscribers { shift->{events}{shift()} ||= [] }
  
  sub unsubscribe {
    my ($self, $name, $cb) = @_;
  
    # One
    if ($cb) {
      $self->{events}{$name} = [grep { $cb ne $_ } @{$self->{events}{$name}}];
      delete $self->{events}{$name} unless @{$self->{events}{$name}};
    }
  
    # All
    else { delete $self->{events}{$name} }
  
    return $self;
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojo::EventEmitter - Event emitter base class
  
  =head1 SYNOPSIS
  
    package Cat;
    use Mojo::Base 'Mojo::EventEmitter';
  
    # Emit events
    sub poke {
      my $self = shift;
      $self->emit(roar => 3);
    }
  
    package main;
  
    # Subscribe to events
    my $tiger = Cat->new;
    $tiger->on(roar => sub {
      my ($tiger, $times) = @_;
      say 'RAWR!' for 1 .. $times;
    });
    $tiger->poke;
  
  =head1 DESCRIPTION
  
  L<Mojo::EventEmitter> is a simple base class for event emitting objects.
  
  =head1 EVENTS
  
  L<Mojo::EventEmitter> can emit the following events.
  
  =head2 error
  
    $e->on(error => sub {
      my ($e, $err) = @_;
      ...
    });
  
  This is a special event for errors, it will not be emitted directly by this
  class, but is fatal if unhandled. Subclasses may choose to emit it, but are not
  required to do so.
  
    $e->on(error => sub {
      my ($e, $err) = @_;
      say "This looks bad: $err";
    });
  
  =head1 METHODS
  
  L<Mojo::EventEmitter> inherits all methods from L<Mojo::Base> and implements
  the following new ones.
  
  =head2 catch
  
    $e = $e->catch(sub {...});
  
  Subscribe to L</"error"> event.
  
    # Longer version
    $e->on(error => sub {...});
  
  =head2 emit
  
    $e = $e->emit('foo');
    $e = $e->emit('foo', 123);
  
  Emit event.
  
  =head2 has_subscribers
  
    my $bool = $e->has_subscribers('foo');
  
  Check if event has subscribers.
  
  =head2 on
  
    my $cb = $e->on(foo => sub {...});
  
  Subscribe to event.
  
    $e->on(foo => sub {
      my ($e, @args) = @_;
      ...
    });
  
  =head2 once
  
    my $cb = $e->once(foo => sub {...});
  
  Subscribe to event and unsubscribe again after it has been emitted once.
  
    $e->once(foo => sub {
      my ($e, @args) = @_;
      ...
    });
  
  =head2 subscribers
  
    my $subscribers = $e->subscribers('foo');
  
  All subscribers for event.
  
    # Unsubscribe last subscriber
    $e->unsubscribe(foo => $e->subscribers('foo')->[-1]);
  
    # Change order of subscribers
    @{$e->subscribers('foo')} = reverse @{$e->subscribers('foo')};
  
  =head2 unsubscribe
  
    $e = $e->unsubscribe('foo');
    $e = $e->unsubscribe(foo => $cb);
  
  Unsubscribe from event.
  
  =head1 DEBUGGING
  
  You can set the C<MOJO_EVENTEMITTER_DEBUG> environment variable to get some
  advanced diagnostics information printed to C<STDERR>.
  
    MOJO_EVENTEMITTER_DEBUG=1
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<http://mojolicious.org>.
  
  =cut
MOJO_EVENTEMITTER

$fatpacked{"Mojo/Exception.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJO_EXCEPTION';
  package Mojo::Exception;
  use Mojo::Base -base;
  use overload bool => sub {1}, '""' => sub { shift->to_string }, fallback => 1;
  
  has [qw(frames line lines_after lines_before)] => sub { [] };
  has message => 'Exception!';
  has 'verbose';
  
  sub inspect {
    my ($self, @sources) = @_;
  
    # Extract file and line from message
    my @files;
    my $msg = $self->lines_before([])->line([])->lines_after([])->message;
    while ($msg =~ /at\s+(.+?)\s+line\s+(\d+)/g) { unshift @files, [$1, $2] }
  
    # Extract file and line from stack trace
    if (my $zero = $self->frames->[0]) { push @files, [$zero->[1], $zero->[2]] }
  
    # Search for context in files
    for my $file (@files) {
      next unless -r $file->[0] && open my $handle, '<:utf8', $file->[0];
      $self->_context($file->[1], [[<$handle>]]);
      return $self;
    }
  
    # Search for context in sources
    $self->_context($files[-1][1], [map { [split "\n"] } @sources]) if @sources;
  
    return $self;
  }
  
  sub new { @_ > 1 ? shift->SUPER::new(message => shift) : shift->SUPER::new }
  
  sub to_string {
    my $self = shift;
  
    my $str = $self->message;
    return $str unless $self->verbose;
  
    $str .= "\n" unless $str =~ /\n$/;
    $str .= $_->[0] . ': ' . $_->[1] . "\n" for @{$self->lines_before};
    $str .= $self->line->[0] . ': ' . $self->line->[1] . "\n" if $self->line->[0];
    $str .= $_->[0] . ': ' . $_->[1] . "\n" for @{$self->lines_after};
  
    return $str;
  }
  
  sub throw { CORE::die shift->new(shift)->trace(2)->inspect }
  
  sub trace {
    my ($self, $start) = (shift, shift // 1);
    my @frames;
    while (my @trace = caller($start++)) { push @frames, \@trace }
    return $self->frames(\@frames);
  }
  
  sub _append {
    my ($stack, $line) = @_;
    chomp $line;
    push @$stack, $line;
  }
  
  sub _context {
    my ($self, $num, $sources) = @_;
  
    # Line
    return unless defined $sources->[0][$num - 1];
    $self->line([$num]);
    _append($self->line, $_->[$num - 1]) for @$sources;
  
    # Before
    for my $i (2 .. 6) {
      last if ((my $previous = $num - $i) < 0);
      unshift @{$self->lines_before}, [$previous + 1];
      _append($self->lines_before->[0], $_->[$previous]) for @$sources;
    }
  
    # After
    for my $i (0 .. 4) {
      next if ((my $next = $num + $i) < 0);
      next unless defined $sources->[0][$next];
      push @{$self->lines_after}, [$next + 1];
      _append($self->lines_after->[-1], $_->[$next]) for @$sources;
    }
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojo::Exception - Exceptions with context
  
  =head1 SYNOPSIS
  
    use Mojo::Exception;
  
    # Throw exception and show stack trace
    eval { Mojo::Exception->throw('Something went wrong!') };
    say "$_->[1]:$_->[2]" for @{$@->frames};
  
    # Customize exception
    eval {
      my $e = Mojo::Exception->new('Died at test.pl line 3.');
      die $e->trace(2)->inspect->verbose(1);
    };
    say $@;
  
  =head1 DESCRIPTION
  
  L<Mojo::Exception> is a container for exceptions with context information.
  
  =head1 ATTRIBUTES
  
  L<Mojo::Exception> implements the following attributes.
  
  =head2 frames
  
    my $frames = $e->frames;
    $e         = $e->frames([$frame1, $frame2]);
  
  Stack trace if available.
  
    # Extract information from the last frame
    my ($package, $filename, $line, $subroutine, $hasargs, $wantarray, $evaltext,
        $is_require, $hints, $bitmask, $hinthash) = @{$e->frames->[-1]};
  
  =head2 line
  
    my $line = $e->line;
    $e       = $e->line([3, 'die;']);
  
  The line where the exception occurred if available.
  
  =head2 lines_after
  
    my $lines = $e->lines_after;
    $e        = $e->lines_after([[4, 'say $foo;'], [5, 'say $bar;']]);
  
  Lines after the line where the exception occurred if available.
  
  =head2 lines_before
  
    my $lines = $e->lines_before;
    $e        = $e->lines_before([[1, 'my $foo = 23;'], [2, 'my $bar = 24;']]);
  
  Lines before the line where the exception occurred if available.
  
  =head2 message
  
    my $msg = $e->message;
    $e      = $e->message('Died at test.pl line 3.');
  
  Exception message, defaults to C<Exception!>.
  
  =head2 verbose
  
    my $bool = $e->verbose;
    $e       = $e->verbose($bool);
  
  Enable context information for L</"to_string">.
  
  =head1 METHODS
  
  L<Mojo::Exception> inherits all methods from L<Mojo::Base> and implements the
  following new ones.
  
  =head2 inspect
  
    $e = $e->inspect;
    $e = $e->inspect($source1, $source2);
  
  Inspect L</"message">, L</"frames"> and optional additional sources to fill
  L</"lines_before">, L</"line"> and L</"lines_after"> with context information.
  
  =head2 new
  
    my $e = Mojo::Exception->new;
    my $e = Mojo::Exception->new('Died at test.pl line 3.');
  
  Construct a new L<Mojo::Exception> object and assign L</"message"> if necessary.
  
  =head2 to_string
  
    my $str = $e->to_string;
  
  Render exception.
  
    # Render exception with context
    say $e->verbose(1)->to_string;
  
  =head2 throw
  
    Mojo::Exception->throw('Something went wrong!');
  
  Throw exception from the current execution context.
  
    # Longer version
    die Mojo::Exception->new('Something went wrong!')->trace->inspect;
  
  =head2 trace
  
    $e = $e->trace;
    $e = $e->trace($skip);
  
  Generate stack trace and store all L</"frames">, defaults to skipping C<1> call
  frame.
  
    # Skip 3 call frames
    $e->trace(3);
  
    # Skip no call frames
    $e->trace(0);
  
  =head1 OPERATORS
  
  L<Mojo::Exception> overloads the following operators.
  
  =head2 bool
  
    my $bool = !!$e;
  
  Always true.
  
  =head2 stringify
  
    my $str = "$e";
  
  Alias for L</"to_string">.
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<http://mojolicious.org>.
  
  =cut
MOJO_EXCEPTION

$fatpacked{"Mojo/File.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJO_FILE';
  package Mojo::File;
  use Mojo::Base -strict;
  use overload
    '@{}'    => sub { shift->to_array },
    bool     => sub {1},
    '""'     => sub { ${$_[0]} },
    fallback => 1;
  
  use Carp 'croak';
  use Cwd 'getcwd';
  use Exporter 'import';
  use File::Basename ();
  use File::Copy qw(copy move);
  use File::Find 'find';
  use File::Path ();
  use File::Spec::Functions
    qw(abs2rel canonpath catfile file_name_is_absolute rel2abs splitdir);
  use File::Temp ();
  use IO::File   ();
  use Mojo::Collection;
  
  our @EXPORT_OK = ('path', 'tempdir', 'tempfile');
  
  sub basename { File::Basename::basename ${$_[0]}, @_ }
  
  sub child { $_[0]->new(@_) }
  
  sub copy_to {
    my ($self, $to) = @_;
    copy($$self, $to) or croak qq{Can't copy file "$$self" to "$to": $!};
    return $self->new(-d $to ? ($to, File::Basename::basename $self) : $to);
  }
  
  sub dirname { $_[0]->new(scalar File::Basename::dirname ${$_[0]}) }
  
  sub is_abs { file_name_is_absolute ${shift()} }
  
  sub list {
    my ($self, $options) = (shift, shift // {});
  
    return Mojo::Collection->new unless -d $$self;
    opendir(my $dir, $$self) or croak qq{Can't open directory "$$self": $!};
    my @files = grep { $_ ne '.' && $_ ne '..' } readdir $dir;
    @files = grep { !/^\./ } @files unless $options->{hidden};
    @files = map { catfile $$self, $_ } @files;
    @files = grep { !-d } @files unless $options->{dir};
  
    return Mojo::Collection->new(map { $self->new($_) } sort @files);
  }
  
  sub list_tree {
    my ($self, $options) = (shift, shift // {});
  
    # This may break in the future, but is worth it for performance
    local $File::Find::skip_pattern = qr/^\./ unless $options->{hidden};
  
    my %all;
    my $wanted = {wanted => sub { $all{$File::Find::name}++ }, no_chdir => 1};
    $wanted->{postprocess} = sub { delete $all{$File::Find::dir} }
      unless $options->{dir};
    find $wanted, $$self if -d $$self;
    delete $all{$$self};
  
    return Mojo::Collection->new(map { $self->new(canonpath $_) } sort keys %all);
  }
  
  sub make_path {
    my $self = shift;
    File::Path::make_path $$self, @_;
    return $self;
  }
  
  sub move_to {
    my ($self, $to) = @_;
    move($$self, $to) or croak qq{Can't move file "$$self" to "$to": $!};
    return $self->new(-d $to ? ($to, File::Basename::basename $self) : $to);
  }
  
  sub new {
    my $class = shift;
    my $value = @_ == 1 ? $_[0] : @_ > 1 ? catfile @_ : canonpath getcwd;
    return bless \$value, ref $class || $class;
  }
  
  sub open {
    my $self   = shift;
    my $handle = IO::File->new;
    $handle->open($$self, @_) or croak qq{Can't open file "$$self": $!};
    return $handle;
  }
  
  sub path { __PACKAGE__->new(@_) }
  
  sub realpath { $_[0]->new(Cwd::realpath ${$_[0]}) }
  
  sub remove_tree {
    my $self = shift;
    File::Path::remove_tree $$self, @_;
    return $self;
  }
  
  sub sibling {
    my $self = shift;
    return $self->new(scalar File::Basename::dirname($self), @_);
  }
  
  sub slurp {
    my $self = shift;
  
    CORE::open my $file, '<', $$self or croak qq{Can't open file "$$self": $!};
    my $ret = my $content = '';
    while ($ret = $file->sysread(my $buffer, 131072, 0)) { $content .= $buffer }
    croak qq{Can't read from file "$$self": $!} unless defined $ret;
  
    return $content;
  }
  
  sub spurt {
    my ($self, $content) = (shift, join '', @_);
    CORE::open my $file, '>', $$self or croak qq{Can't open file "$$self": $!};
    ($file->syswrite($content) // -1) == length $content
      or croak qq{Can't write to file "$$self": $!};
    return $self;
  }
  
  sub tap { shift->Mojo::Base::tap(@_) }
  
  sub tempdir { __PACKAGE__->new(File::Temp->newdir(@_)) }
  
  sub tempfile { __PACKAGE__->new(File::Temp->new(@_)) }
  
  sub to_abs { $_[0]->new(rel2abs ${$_[0]}) }
  
  sub to_array { [splitdir ${shift()}] }
  
  sub to_rel { $_[0]->new(abs2rel(${$_[0]}, $_[1])) }
  
  sub to_string {"${$_[0]}"}
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojo::File - File system paths
  
  =head1 SYNOPSIS
  
    use Mojo::File;
  
    # Portably deal with file system paths
    my $path = Mojo::File->new('/home/sri/.vimrc');
    say $path->slurp;
    say $path->dirname;
    say $path->basename;
    say $path->sibling('.bashrc');
  
    # Use the alternative constructor
    use Mojo::File 'path';
    my $path = path('/tmp/foo/bar')->make_path;
    $path->child('test.txt')->spurt('Hello Mojo!');
  
  =head1 DESCRIPTION
  
  L<Mojo::File> is a scalar-based container for file system paths that provides a
  friendly API for dealing with different operating systems.
  
    # Access scalar directly to manipulate path
    my $path = Mojo::File->new('/home/sri/test');
    $$path .= '.txt';
  
  =head1 FUNCTIONS
  
  L<Mojo::File> implements the following functions, which can be imported
  individually.
  
  =head2 path
  
    my $path = path;
    my $path = path('/home/sri/.vimrc');
    my $path = path('/home', 'sri', '.vimrc');
    my $path = path(File::Temp->newdir);
  
  Construct a new scalar-based L<Mojo::File> object, defaults to using the current
  working directory.
  
    # "foo/bar/baz.txt" (on UNIX)
    path('foo', 'bar', 'baz.txt');
  
  =head2 tempdir
  
    my $path = tempdir;
    my $path = tempdir('tempXXXXX');
  
  Construct a new scalar-based L<Mojo::File> object for a temporary directory with
  L<File::Temp>.
  
    # Longer version
    my $path = path(File::Temp->newdir('tempXXXXX'));
  
  =head2 tempfile
  
    my $path = tempfile;
    my $path = tempfile(DIR => '/tmp');
  
  Construct a new scalar-based L<Mojo::File> object for a temporary file with
  L<File::Temp>.
  
    # Longer version
    my $path = path(File::Temp->new(DIR => '/tmp'));
  
  =head1 METHODS
  
  L<Mojo::File> implements the following methods.
  
  =head2 basename
  
    my $name = $path->basename;
    my $name = $path->basename('.txt');
  
  Return the last level of the path with L<File::Basename>.
  
    # ".vimrc" (on UNIX)
    path('/home/sri/.vimrc')->basename;
  
    # "test" (on UNIX)
    path('/home/sri/test.txt')->basename('.txt');
  
  =head2 child
  
    my $child = $path->child('.vimrc');
  
  Return a new L<Mojo::File> object relative to the path.
  
    # "/home/sri/.vimrc" (on UNIX)
    path('/home')->child('sri', '.vimrc');
  
  =head2 copy_to
  
    my $destination = $path->copy_to('/home/sri');
    my $destination = $path->copy_to('/home/sri/.vimrc.backup');
  
  Copy file with L<File::Copy> and return the destination as a L<Mojo::File>
  object.
  
  =head2 dirname
  
    my $name = $path->dirname;
  
  Return all but the last level of the path with L<File::Basename> as a
  L<Mojo::File> object.
  
    # "/home/sri" (on UNIX)
    path('/home/sri/.vimrc')->dirname;
  
  =head2 is_abs
  
    my $bool = $path->is_abs;
  
  Check if the path is absolute.
  
    # True (on UNIX)
    path('/home/sri/.vimrc')->is_abs;
  
    # False (on UNIX)
    path('.vimrc')->is_abs;
  
  =head2 list
  
    my $collection = $path->list;
    my $collection = $path->list({hidden => 1});
  
  List all files in the directory and return a L<Mojo::Collection> object
  containing the results as L<Mojo::File> objects. The list does not include C<.>
  and C<..>.
  
    # List files
    say for path('/home/sri/myapp')->list->each;
  
  These options are currently available:
  
  =over 2
  
  =item dir
  
    dir => 1
  
  Include directories.
  
  =item hidden
  
    hidden => 1
  
  Include hidden files.
  
  =back
  
  =head2 list_tree
  
    my $collection = $path->list_tree;
    my $collection = $path->list_tree({hidden => 1});
  
  List all files recursively in the directory and return a L<Mojo::Collection>
  object containing the results as L<Mojo::File> objects. The list does not
  include C<.> and C<..>.
  
    # List all templates
    say for path('/home/sri/myapp/templates')->list_tree->each;
  
  These options are currently available:
  
  =over 2
  
  =item dir
  
    dir => 1
  
  Include directories.
  
  =item hidden
  
    hidden => 1
  
  Include hidden files and directories.
  
  =back
  
  =head2 make_path
  
    $path = $path->make_path;
    $path = $path->make_path({mode => 0711});
  
  Create the directories if they don't already exist, any additional arguments are
  passed through to L<File::Path>.
  
  =head2 move_to
  
    my $destination = $path->move_to('/home/sri');
    my $destination = $path->move_to('/home/sri/.vimrc.backup');
  
  Move file with L<File::Copy> and return the destination as a L<Mojo::File>
  object.
  
  =head2 new
  
    my $path = Mojo::File->new;
    my $path = Mojo::File->new('/home/sri/.vimrc');
    my $path = Mojo::File->new('/home', 'sri', '.vimrc');
    my $path = Mojo::File->new(File::Temp->new);
    my $path = Mojo::File->new(File::Temp->newdir);
  
  Construct a new L<Mojo::File> object, defaults to using the current working
  directory.
  
    # "foo/bar/baz.txt" (on UNIX)
    Mojo::File->new('foo', 'bar', 'baz.txt');
  
  =head2 open
  
    my $handle = $path->open('+<');
    my $handle = $path->open('r+');
    my $handle = $path->open(O_RDWR);
    my $handle = $path->open('<:encoding(UTF-8)');
  
  Open file with L<IO::File>.
  
    # Combine "fcntl.h" constants
    use Fcntl qw(O_CREAT O_EXCL O_RDWR);
    my $handle = path('/home/sri/test.pl')->open(O_RDWR | O_CREAT | O_EXCL);
  
  =head2 realpath
  
    my $realpath = $path->realpath;
  
  Resolve the path with L<Cwd> and return the result as a L<Mojo::File> object.
  
  =head2 remove_tree
  
    $path = $path->remove_tree;
    $path = $path->remove_tree({keep_root => 1});
  
  Delete this directory and any files and subdirectories it may contain, any
  additional arguments are passed through to L<File::Path>.
  
  =head2 sibling
  
    my $sibling = $path->sibling('.vimrc');
  
  Return a new L<Mojo::File> object relative to the directory part of the path.
  
    # "/home/sri/.vimrc" (on UNIX)
    path('/home/sri/.bashrc')->sibling('.vimrc');
  
    # "/home/sri/.ssh/known_hosts" (on UNIX)
    path('/home/sri/.bashrc')->sibling('.ssh', 'known_hosts');
  
  =head2 slurp
  
    my $bytes = $path->slurp;
  
  Read all data at once from the file.
  
  =head2 spurt
  
    $path = $path->spurt($bytes);
    $path = $path->spurt(@chunks_of_bytes);
  
  Write all data at once to the file.
  
  =head2 tap
  
    $path = $path->tap(sub {...});
  
  Alias for L<Mojo::Base/"tap">.
  
  =head2 to_abs
  
    my $absolute = $path->to_abs;
  
  Return absolute path as a L<Mojo::File> object, the path does not need to exist
  on the file system.
  
  =head2 to_array
  
    my $parts = $path->to_array;
  
  Split the path on directory separators.
  
    # "home:sri:.vimrc" (on UNIX)
    join ':', @{path('/home/sri/.vimrc')->to_array};
  
  =head2 to_rel
  
    my $relative = $path->to_rel('/some/base/path');
  
  Return a relative path from the original path to the destination path as a
  L<Mojo::File> object.
  
    # "sri/.vimrc" (on UNIX)
    path('/home/sri/.vimrc')->to_rel('/home');
  
  =head2 to_string
  
    my $str = $path->to_string;
  
  Stringify the path.
  
  =head1 OPERATORS
  
  L<Mojo::File> overloads the following operators.
  
  =head2 array
  
    my @parts = @$path;
  
  Alias for L</"to_array">.
  
  =head2 bool
  
    my $bool = !!$path;
  
  Always true.
  
  =head2 stringify
  
    my $str = "$path";
  
  Alias for L</"to_string">.
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<http://mojolicious.org>.
  
  =cut
MOJO_FILE

$fatpacked{"Mojo/Headers.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJO_HEADERS';
  package Mojo::Headers;
  use Mojo::Base -base;
  
  use Mojo::Util 'monkey_patch';
  
  has max_line_size => sub { $ENV{MOJO_MAX_LINE_SIZE} || 8192 };
  has max_lines     => sub { $ENV{MOJO_MAX_LINES}     || 100 };
  
  # Common headers
  my %NAMES = map { lc() => $_ } (
    qw(Accept Accept-Charset Accept-Encoding Accept-Language Accept-Ranges),
    qw(Access-Control-Allow-Origin Allow Authorization Cache-Control Connection),
    qw(Content-Disposition Content-Encoding Content-Language Content-Length),
    qw(Content-Location Content-Range Content-Security-Policy Content-Type),
    qw(Cookie DNT Date ETag Expect Expires Host If-Modified-Since If-None-Match),
    qw(Last-Modified Link Location Origin Proxy-Authenticate),
    qw(Proxy-Authorization Range Sec-WebSocket-Accept Sec-WebSocket-Extensions),
    qw(Sec-WebSocket-Key Sec-WebSocket-Protocol Sec-WebSocket-Version Server),
    qw(Set-Cookie Status Strict-Transport-Security TE Trailer Transfer-Encoding),
    qw(Upgrade User-Agent Vary WWW-Authenticate)
  );
  for my $header (keys %NAMES) {
    my $name = $header;
    $name =~ y/-/_/;
    monkey_patch __PACKAGE__, $name, sub {
      my $self = shift;
      $self->{headers}{$header} = [@_] and return $self if @_;
      return undef unless my $headers = $self->{headers}{$header};
      return join ', ', @$headers;
    };
  }
  
  sub add {
    my ($self, $name) = (shift, shift);
  
    # Make sure we have a normal case entry for name
    my $key = lc $name;
    $self->{names}{$key} //= $name unless $NAMES{$key};
    push @{$self->{headers}{$key}}, @_;
  
    return $self;
  }
  
  sub append {
    my ($self, $name, $value) = @_;
    my $old = $self->header($name);
    return $self->header($name => defined $old ? "$old, $value" : $value);
  }
  
  sub clone { $_[0]->new->from_hash($_[0]->to_hash(1)) }
  
  sub every_header { shift->{headers}{lc shift} || [] }
  
  sub from_hash {
    my ($self, $hash) = @_;
  
    # Empty hash deletes all headers
    delete $self->{headers} if keys %{$hash} == 0;
  
    # Merge
    for my $header (keys %$hash) {
      my $value = $hash->{$header};
      $self->add($header => ref $value eq 'ARRAY' ? @$value : $value);
    }
  
    return $self;
  }
  
  sub header {
    my ($self, $name) = (shift, shift);
  
    # Replace
    return $self->remove($name)->add($name, @_) if @_;
  
    return undef unless my $headers = $self->{headers}{lc $name};
    return join ', ', @$headers;
  }
  
  sub is_finished { (shift->{state} // '') eq 'finished' }
  
  sub is_limit_exceeded { !!shift->{limit} }
  
  sub leftovers { delete shift->{buffer} }
  
  sub names {
    my $self = shift;
    return [map { $NAMES{$_} || $self->{names}{$_} } keys %{$self->{headers}}];
  }
  
  sub parse {
    my ($self, $chunk) = @_;
  
    $self->{state} = 'headers';
    $self->{buffer} .= $chunk;
    my $headers = $self->{cache} ||= [];
    my $size    = $self->max_line_size;
    my $lines   = $self->max_lines;
    while ($self->{buffer} =~ s/^(.*?)\x0d?\x0a//) {
      my $line = $1;
  
      # Check line size limit
      if ($+[0] > $size || @$headers >= $lines) {
        @$self{qw(state limit)} = ('finished', 1);
        return $self;
      }
  
      # New header
      if ($line =~ /^(\S[^:]*)\s*:\s*(.*)$/) { push @$headers, [$1, $2] }
  
      # Multi-line
      elsif ($line =~ s/^\s+// && @$headers) { $headers->[-1][1] .= " $line" }
  
      # Empty line
      else {
        $self->add(@$_) for @$headers;
        @$self{qw(state cache)} = ('finished', []);
        return $self;
      }
    }
  
    # Check line size limit
    @$self{qw(state limit)} = ('finished', 1) if length $self->{buffer} > $size;
  
    return $self;
  }
  
  sub referrer { shift->header(Referer => @_) }
  
  sub remove {
    my ($self, $name) = @_;
    delete $self->{headers}{lc $name};
    return $self;
  }
  
  sub to_hash {
    my ($self, $multi) = @_;
    return {map { $_ => $self->{headers}{lc $_} } @{$self->names}} if $multi;
    return {map { $_ => $self->header($_) } @{$self->names}};
  }
  
  sub to_string {
    my $self = shift;
  
    # Make sure multi-line values are formatted correctly
    my @headers;
    for my $name (@{$self->names}) {
      push @headers, "$name: $_" for @{$self->{headers}{lc $name}};
    }
  
    return join "\x0d\x0a", @headers;
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojo::Headers - HTTP headers
  
  =head1 SYNOPSIS
  
    use Mojo::Headers;
  
    # Parse
    my $headers = Mojo::Headers->new;
    $headers->parse("Content-Length: 42\x0d\x0a");
    $headers->parse("Content-Type: text/html\x0d\x0a\x0d\x0a");
    say $headers->content_length;
    say $headers->content_type;
  
    # Build
    my $headers = Mojo::Headers->new;
    $headers->content_length(42);
    $headers->content_type('text/plain');
    say $headers->to_string;
  
  =head1 DESCRIPTION
  
  L<Mojo::Headers> is a container for HTTP headers, based on
  L<RFC 7230|http://tools.ietf.org/html/rfc7230> and
  L<RFC 7231|http://tools.ietf.org/html/rfc7231>.
  
  =head1 ATTRIBUTES
  
  L<Mojo::Headers> implements the following attributes.
  
  =head2 max_line_size
  
    my $size = $headers->max_line_size;
    $headers = $headers->max_line_size(1024);
  
  Maximum header line size in bytes, defaults to the value of the
  C<MOJO_MAX_LINE_SIZE> environment variable or C<8192> (8KB).
  
  =head2 max_lines
  
    my $num  = $headers->max_lines;
    $headers = $headers->max_lines(200);
  
  Maximum number of header lines, defaults to the value of the C<MOJO_MAX_LINES>
  environment variable or C<100>.
  
  =head1 METHODS
  
  L<Mojo::Headers> inherits all methods from L<Mojo::Base> and implements the
  following new ones.
  
  =head2 accept
  
    my $accept = $headers->accept;
    $headers   = $headers->accept('application/json');
  
  Get or replace current header value, shortcut for the C<Accept> header.
  
  =head2 accept_charset
  
    my $charset = $headers->accept_charset;
    $headers    = $headers->accept_charset('UTF-8');
  
  Get or replace current header value, shortcut for the C<Accept-Charset> header.
  
  =head2 accept_encoding
  
    my $encoding = $headers->accept_encoding;
    $headers     = $headers->accept_encoding('gzip');
  
  Get or replace current header value, shortcut for the C<Accept-Encoding> header.
  
  =head2 accept_language
  
    my $language = $headers->accept_language;
    $headers     = $headers->accept_language('de, en');
  
  Get or replace current header value, shortcut for the C<Accept-Language> header.
  
  =head2 accept_ranges
  
    my $ranges = $headers->accept_ranges;
    $headers   = $headers->accept_ranges('bytes');
  
  Get or replace current header value, shortcut for the C<Accept-Ranges> header.
  
  =head2 access_control_allow_origin
  
    my $origin = $headers->access_control_allow_origin;
    $headers   = $headers->access_control_allow_origin('*');
  
  Get or replace current header value, shortcut for the
  C<Access-Control-Allow-Origin> header from
  L<Cross-Origin Resource Sharing|http://www.w3.org/TR/cors/>.
  
  =head2 add
  
    $headers = $headers->add(Foo => 'one value');
    $headers = $headers->add(Foo => 'first value', 'second value');
  
  Add header with one or more lines.
  
    # "Vary: Accept
    #  Vary: Accept-Encoding"
    $headers->add(Vary => 'Accept')->add(Vary => 'Accept-Encoding')->to_string;
  
  =head2 allow
  
    my $allow = $headers->allow;
    $headers  = $headers->allow('GET, POST');
  
  Get or replace current header value, shortcut for the C<Allow> header.
  
  =head2 append
  
    $headers = $headers->append(Vary => 'Accept-Encoding');
  
  Append value to header and flatten it if necessary.
  
    # "Vary: Accept"
    $headers->append(Vary => 'Accept')->to_string;
  
    # "Vary: Accept, Accept-Encoding"
    $headers->vary('Accept')->append(Vary => 'Accept-Encoding')->to_string;
  
  =head2 authorization
  
    my $authorization = $headers->authorization;
    $headers          = $headers->authorization('Basic Zm9vOmJhcg==');
  
  Get or replace current header value, shortcut for the C<Authorization> header.
  
  =head2 cache_control
  
    my $cache_control = $headers->cache_control;
    $headers          = $headers->cache_control('max-age=1, no-cache');
  
  Get or replace current header value, shortcut for the C<Cache-Control> header.
  
  =head2 clone
  
    my $clone = $headers->clone;
  
  Clone headers.
  
  =head2 connection
  
    my $connection = $headers->connection;
    $headers       = $headers->connection('close');
  
  Get or replace current header value, shortcut for the C<Connection> header.
  
  =head2 content_disposition
  
    my $disposition = $headers->content_disposition;
    $headers        = $headers->content_disposition('foo');
  
  Get or replace current header value, shortcut for the C<Content-Disposition>
  header.
  
  =head2 content_encoding
  
    my $encoding = $headers->content_encoding;
    $headers     = $headers->content_encoding('gzip');
  
  Get or replace current header value, shortcut for the C<Content-Encoding>
  header.
  
  =head2 content_language
  
    my $language = $headers->content_language;
    $headers     = $headers->content_language('en');
  
  Get or replace current header value, shortcut for the C<Content-Language>
  header.
  
  =head2 content_length
  
    my $len  = $headers->content_length;
    $headers = $headers->content_length(4000);
  
  Get or replace current header value, shortcut for the C<Content-Length> header.
  
  =head2 content_location
  
    my $location = $headers->content_location;
    $headers     = $headers->content_location('http://127.0.0.1/foo');
  
  Get or replace current header value, shortcut for the C<Content-Location>
  header.
  
  =head2 content_range
  
    my $range = $headers->content_range;
    $headers  = $headers->content_range('bytes 2-8/100');
  
  Get or replace current header value, shortcut for the C<Content-Range> header.
  
  =head2 content_security_policy
  
    my $policy = $headers->content_security_policy;
    $headers   = $headers->content_security_policy('default-src https:');
  
  Get or replace current header value, shortcut for the C<Content-Security-Policy>
  header from L<Content Security Policy 1.0|http://www.w3.org/TR/CSP/>.
  
  =head2 content_type
  
    my $type = $headers->content_type;
    $headers = $headers->content_type('text/plain');
  
  Get or replace current header value, shortcut for the C<Content-Type> header.
  
  =head2 cookie
  
    my $cookie = $headers->cookie;
    $headers   = $headers->cookie('f=b');
  
  Get or replace current header value, shortcut for the C<Cookie> header from
  L<RFC 6265|http://tools.ietf.org/html/rfc6265>.
  
  =head2 date
  
    my $date = $headers->date;
    $headers = $headers->date('Sun, 17 Aug 2008 16:27:35 GMT');
  
  Get or replace current header value, shortcut for the C<Date> header.
  
  =head2 dnt
  
    my $dnt  = $headers->dnt;
    $headers = $headers->dnt(1);
  
  Get or replace current header value, shortcut for the C<DNT> (Do Not Track)
  header, which has no specification yet, but is very commonly used.
  
  =head2 etag
  
    my $etag = $headers->etag;
    $headers = $headers->etag('"abc321"');
  
  Get or replace current header value, shortcut for the C<ETag> header.
  
  =head2 every_header
  
    my $all = $headers->every_header('Location');
  
  Similar to L</"header">, but returns all headers sharing the same name as an
  array reference.
  
    # Get first header value
    say $headers->every_header('Location')->[0];
  
  =head2 expect
  
    my $expect = $headers->expect;
    $headers   = $headers->expect('100-continue');
  
  Get or replace current header value, shortcut for the C<Expect> header.
  
  =head2 expires
  
    my $expires = $headers->expires;
    $headers    = $headers->expires('Thu, 01 Dec 1994 16:00:00 GMT');
  
  Get or replace current header value, shortcut for the C<Expires> header.
  
  =head2 from_hash
  
    $headers = $headers->from_hash({'Cookie' => 'a=b'});
    $headers = $headers->from_hash({'Cookie' => ['a=b', 'c=d']});
    $headers = $headers->from_hash({});
  
  Parse headers from a hash reference, an empty hash removes all headers.
  
  =head2 header
  
    my $value = $headers->header('Foo');
    $headers  = $headers->header(Foo => 'one value');
    $headers  = $headers->header(Foo => 'first value', 'second value');
  
  Get or replace the current header values.
  
  =head2 host
  
    my $host = $headers->host;
    $headers = $headers->host('127.0.0.1');
  
  Get or replace current header value, shortcut for the C<Host> header.
  
  =head2 if_modified_since
  
    my $date = $headers->if_modified_since;
    $headers = $headers->if_modified_since('Sun, 17 Aug 2008 16:27:35 GMT');
  
  Get or replace current header value, shortcut for the C<If-Modified-Since>
  header.
  
  =head2 if_none_match
  
    my $etag = $headers->if_none_match;
    $headers = $headers->if_none_match('"abc321"');
  
  Get or replace current header value, shortcut for the C<If-None-Match> header.
  
  =head2 is_finished
  
    my $bool = $headers->is_finished;
  
  Check if header parser is finished.
  
  =head2 is_limit_exceeded
  
    my $bool = $headers->is_limit_exceeded;
  
  Check if headers have exceeded L</"max_line_size"> or L</"max_lines">.
  
  =head2 last_modified
  
    my $date = $headers->last_modified;
    $headers = $headers->last_modified('Sun, 17 Aug 2008 16:27:35 GMT');
  
  Get or replace current header value, shortcut for the C<Last-Modified> header.
  
  =head2 leftovers
  
    my $bytes = $headers->leftovers;
  
  Get and remove leftover data from header parser.
  
  =head2 link
  
    my $link = $headers->link;
    $headers = $headers->link('<http://127.0.0.1/foo/3>; rel="next"');
  
  Get or replace current header value, shortcut for the C<Link> header from
  L<RFC 5988|http://tools.ietf.org/html/rfc5988>.
  
  =head2 location
  
    my $location = $headers->location;
    $headers     = $headers->location('http://127.0.0.1/foo');
  
  Get or replace current header value, shortcut for the C<Location> header.
  
  =head2 names
  
    my $names = $headers->names;
  
  Return an array reference with all currently defined headers.
  
    # Names of all headers
    say for @{$headers->names};
  
  =head2 origin
  
    my $origin = $headers->origin;
    $headers   = $headers->origin('http://example.com');
  
  Get or replace current header value, shortcut for the C<Origin> header from
  L<RFC 6454|http://tools.ietf.org/html/rfc6454>.
  
  =head2 parse
  
    $headers = $headers->parse("Content-Type: text/plain\x0d\x0a\x0d\x0a");
  
  Parse formatted headers.
  
  =head2 proxy_authenticate
  
    my $authenticate = $headers->proxy_authenticate;
    $headers         = $headers->proxy_authenticate('Basic "realm"');
  
  Get or replace current header value, shortcut for the C<Proxy-Authenticate>
  header.
  
  =head2 proxy_authorization
  
    my $authorization = $headers->proxy_authorization;
    $headers          = $headers->proxy_authorization('Basic Zm9vOmJhcg==');
  
  Get or replace current header value, shortcut for the C<Proxy-Authorization>
  header.
  
  =head2 range
  
    my $range = $headers->range;
    $headers  = $headers->range('bytes=2-8');
  
  Get or replace current header value, shortcut for the C<Range> header.
  
  =head2 referrer
  
    my $referrer = $headers->referrer;
    $headers     = $headers->referrer('http://example.com');
  
  Get or replace current header value, shortcut for the C<Referer> header, there
  was a typo in L<RFC 2068|http://tools.ietf.org/html/rfc2068> which resulted in
  C<Referer> becoming an official header.
  
  =head2 remove
  
    $headers = $headers->remove('Foo');
  
  Remove a header.
  
  =head2 sec_websocket_accept
  
    my $accept = $headers->sec_websocket_accept;
    $headers   = $headers->sec_websocket_accept('s3pPLMBiTxaQ9kYGzzhZRbK+xOo=');
  
  Get or replace current header value, shortcut for the C<Sec-WebSocket-Accept>
  header from L<RFC 6455|http://tools.ietf.org/html/rfc6455>.
  
  =head2 sec_websocket_extensions
  
    my $extensions = $headers->sec_websocket_extensions;
    $headers       = $headers->sec_websocket_extensions('foo');
  
  Get or replace current header value, shortcut for the
  C<Sec-WebSocket-Extensions> header from
  L<RFC 6455|http://tools.ietf.org/html/rfc6455>.
  
  =head2 sec_websocket_key
  
    my $key  = $headers->sec_websocket_key;
    $headers = $headers->sec_websocket_key('dGhlIHNhbXBsZSBub25jZQ==');
  
  Get or replace current header value, shortcut for the C<Sec-WebSocket-Key>
  header from L<RFC 6455|http://tools.ietf.org/html/rfc6455>.
  
  =head2 sec_websocket_protocol
  
    my $proto = $headers->sec_websocket_protocol;
    $headers  = $headers->sec_websocket_protocol('sample');
  
  Get or replace current header value, shortcut for the C<Sec-WebSocket-Protocol>
  header from L<RFC 6455|http://tools.ietf.org/html/rfc6455>.
  
  =head2 sec_websocket_version
  
    my $version = $headers->sec_websocket_version;
    $headers    = $headers->sec_websocket_version(13);
  
  Get or replace current header value, shortcut for the C<Sec-WebSocket-Version>
  header from L<RFC 6455|http://tools.ietf.org/html/rfc6455>.
  
  =head2 server
  
    my $server = $headers->server;
    $headers   = $headers->server('Mojo');
  
  Get or replace current header value, shortcut for the C<Server> header.
  
  =head2 set_cookie
  
    my $cookie = $headers->set_cookie;
    $headers   = $headers->set_cookie('f=b; path=/');
  
  Get or replace current header value, shortcut for the C<Set-Cookie> header from
  L<RFC 6265|http://tools.ietf.org/html/rfc6265>.
  
  =head2 status
  
    my $status = $headers->status;
    $headers   = $headers->status('200 OK');
  
  Get or replace current header value, shortcut for the C<Status> header from
  L<RFC 3875|http://tools.ietf.org/html/rfc3875>.
  
  =head2 strict_transport_security
  
    my $policy = $headers->strict_transport_security;
    $headers   = $headers->strict_transport_security('max-age=31536000');
  
  Get or replace current header value, shortcut for the
  C<Strict-Transport-Security> header from
  L<RFC 6797|http://tools.ietf.org/html/rfc6797>.
  
  =head2 te
  
    my $te   = $headers->te;
    $headers = $headers->te('chunked');
  
  Get or replace current header value, shortcut for the C<TE> header.
  
  =head2 to_hash
  
    my $single = $headers->to_hash;
    my $multi  = $headers->to_hash(1);
  
  Turn headers into hash reference, array references to represent multiple
  headers with the same name are disabled by default.
  
    say $headers->to_hash->{DNT};
  
  =head2 to_string
  
    my $str = $headers->to_string;
  
  Turn headers into a string, suitable for HTTP messages.
  
  =head2 trailer
  
    my $trailer = $headers->trailer;
    $headers    = $headers->trailer('X-Foo');
  
  Get or replace current header value, shortcut for the C<Trailer> header.
  
  =head2 transfer_encoding
  
    my $encoding = $headers->transfer_encoding;
    $headers     = $headers->transfer_encoding('chunked');
  
  Get or replace current header value, shortcut for the C<Transfer-Encoding>
  header.
  
  =head2 upgrade
  
    my $upgrade = $headers->upgrade;
    $headers    = $headers->upgrade('websocket');
  
  Get or replace current header value, shortcut for the C<Upgrade> header.
  
  =head2 user_agent
  
    my $agent = $headers->user_agent;
    $headers  = $headers->user_agent('Mojo/1.0');
  
  Get or replace current header value, shortcut for the C<User-Agent> header.
  
  =head2 vary
  
    my $vary = $headers->vary;
    $headers = $headers->vary('*');
  
  Get or replace current header value, shortcut for the C<Vary> header.
  
  =head2 www_authenticate
  
    my $authenticate = $headers->www_authenticate;
    $headers         = $headers->www_authenticate('Basic realm="realm"');
  
  Get or replace current header value, shortcut for the C<WWW-Authenticate>
  header.
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<http://mojolicious.org>.
  
  =cut
MOJO_HEADERS

$fatpacked{"Mojo/HelloWorld.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJO_HELLOWORLD';
  package Mojo::HelloWorld;
  use Mojolicious::Lite;
  
  app->log->level('error')->path(undef);
  
  any '/*whatever' => {whatever => '', text => 'Your Mojo is working!'};
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojo::HelloWorld - Hello World!
  
  =head1 SYNOPSIS
  
    use Mojo::HelloWorld;
  
    my $hello = Mojo::HelloWorld->new;
    $hello->start;
  
  =head1 DESCRIPTION
  
  L<Mojo::HelloWorld> is the default L<Mojolicious> application, used mostly for
  testing.
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<http://mojolicious.org>.
  
  =cut
MOJO_HELLOWORLD

$fatpacked{"Mojo/Home.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJO_HOME';
  package Mojo::Home;
  use Mojo::Base 'Mojo::File';
  
  use Mojo::Util qw(class_to_path deprecated);
  
  sub detect {
    my ($self, $class) = @_;
  
    # Environment variable
    my $home;
    if ($ENV{MOJO_HOME}) { $home = Mojo::File->new($ENV{MOJO_HOME})->to_array }
  
    # Location of the application class (Windows mixes backslash and slash)
    elsif ($class && (my $path = $INC{my $file = class_to_path $class})) {
      $home = Mojo::File->new($path)->to_array;
      splice @$home, (my @dummy = split('/', $file)) * -1;
      pop @$home if @$home && $home->[-1] eq 'lib';
      pop @$home if @$home && $home->[-1] eq 'blib';
    }
  
    $$self = Mojo::File->new(@$home)->to_abs->to_string if $home;
    return $self;
  }
  
  # DEPRECATED!
  sub lib_dir {
    deprecated 'Mojo::Home::lib_dir is DEPRECATED';
    shift->child('lib')->to_string;
  }
  
  # DEPRECATED!
  sub list_files {
    deprecated
      'Mojo::Home::list_files is DEPRECATED in favor of Mojo::Files::list_tree';
    my ($self, $dir, $options) = (shift, shift // '', shift);
    my $base = $self->child(split('/', $dir));
    $base->list_tree($options)->map(sub { join '/', @{$_->to_rel($base)} })
      ->to_array;
  }
  
  sub mojo_lib_dir { shift->new(__FILE__)->sibling('..') }
  
  # DEPRECATED!
  sub parse {
    deprecated 'Mojo::Home::parse is DEPRECATED';
    my $self = shift;
    $$self = shift;
    return $self;
  }
  
  # DEPRECATED!
  sub parts {
    deprecated 'Mojo::Home::parts is DEPRECATED';
    my $self = shift;
    return $self->to_array unless @_;
    $$self = Mojo::File->new(@{shift()})->to_string;
    return $self;
  }
  
  # DEPRECATED!
  sub rel_dir {
    deprecated
      'Mojo::Home::rel_dir is DEPRECATED in favor of Mojo::Home::rel_file';
    Mojo::File->new(@{shift->parts}, split('/', shift))->to_string;
  }
  
  sub rel_file { shift->child(split('/', shift)) }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojo::Home - Home sweet home
  
  =head1 SYNOPSIS
  
    use Mojo::Home;
  
    # Find and manage the project root directory
    my $home = Mojo::Home->new;
    $home->detect;
    say $home->child('templates', 'layouts', 'default.html.ep');
    say "$home";
  
  =head1 DESCRIPTION
  
  L<Mojo::Home> is a container for home directories based on L<Mojo::File>.
  
  =head1 METHODS
  
  L<Mojo::Home> inherits all methods from L<Mojo::File> and implements the
  following new ones.
  
  =head2 detect
  
    $home = $home->detect;
    $home = $home->detect('My::App');
  
  Detect home directory from the value of the C<MOJO_HOME> environment variable or
  the location of the application class.
  
  =head2 mojo_lib_dir
  
    my $path = $home->mojo_lib_dir;
  
  Path to C<lib> directory in which L<Mojolicious> is installed as a L<Mojo::Home>
  object.
  
  =head2 rel_file
  
    my $path = $home->rel_file('foo/bar.html');
  
  Return a new L<Mojo::Home> object relative to the home directory.
  
  =head1 OPERATORS
  
  L<Mojo::Home> inherits all overloaded operators from L<Mojo::File>.
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<http://mojolicious.org>.
  
  =cut
MOJO_HOME

$fatpacked{"Mojo/IOLoop.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJO_IOLOOP';
  package Mojo::IOLoop;
  use Mojo::Base 'Mojo::EventEmitter';
  
  # "Professor: Amy, technology isn't intrinsically good or evil. It's how it's
  #             used. Like the death ray."
  use Carp 'croak';
  use Mojo::IOLoop::Client;
  use Mojo::IOLoop::Delay;
  use Mojo::IOLoop::Server;
  use Mojo::IOLoop::Stream;
  use Mojo::IOLoop::Subprocess;
  use Mojo::Reactor::Poll;
  use Mojo::Util qw(md5_sum steady_time);
  use Scalar::Util qw(blessed weaken);
  
  use constant DEBUG => $ENV{MOJO_IOLOOP_DEBUG} || 0;
  
  has max_accepts     => 0;
  has max_connections => 1000;
  has reactor         => sub {
    my $class = Mojo::Reactor::Poll->detect;
    warn "-- Reactor initialized ($class)\n" if DEBUG;
    return $class->new->catch(sub { warn "@{[blessed $_[0]]}: $_[1]" });
  };
  
  # Ignore PIPE signal
  $SIG{PIPE} = 'IGNORE';
  
  # Initialize singleton reactor early
  __PACKAGE__->singleton->reactor;
  
  sub acceptor {
    my ($self, $acceptor) = (_instance(shift), @_);
  
    # Find acceptor for id
    return $self->{acceptors}{$acceptor} unless ref $acceptor;
  
    # Connect acceptor with reactor
    $self->{acceptors}{my $id = $self->_id} = $acceptor;
    weaken $acceptor->reactor($self->reactor)->{reactor};
  
    # Allow new acceptor to get picked up
    $self->_not_accepting->_maybe_accepting;
  
    return $id;
  }
  
  sub client {
    my ($self, $cb) = (_instance(shift), pop);
  
    my $id = $self->_id;
    my $client = $self->{out}{$id}{client} = Mojo::IOLoop::Client->new;
    weaken $client->reactor($self->reactor)->{reactor};
  
    weaken $self;
    $client->on(
      connect => sub {
        delete $self->{out}{$id}{client};
        my $stream = Mojo::IOLoop::Stream->new(pop);
        $self->_stream($stream => $id);
        $self->$cb(undef, $stream);
      }
    );
    $client->on(error => sub { $self->_remove($id); $self->$cb(pop, undef) });
    $client->connect(@_);
  
    return $id;
  }
  
  sub delay {
    my $delay = Mojo::IOLoop::Delay->new;
    weaken $delay->ioloop(_instance(shift))->{ioloop};
    return @_ ? $delay->steps(@_) : $delay;
  }
  
  sub is_running { _instance(shift)->reactor->is_running }
  
  sub next_tick {
    my ($self, $cb) = (_instance(shift), @_);
    weaken $self;
    return $self->reactor->next_tick(sub { $self->$cb });
  }
  
  sub one_tick {
    my $self = _instance(shift);
    croak 'Mojo::IOLoop already running' if $self->is_running;
    $self->reactor->one_tick;
  }
  
  sub recurring { shift->_timer(recurring => @_) }
  
  sub remove {
    my ($self, $id) = (_instance(shift), @_);
    my $c = $self->{in}{$id} || $self->{out}{$id};
    if ($c && (my $stream = $c->{stream})) { return $stream->close_gracefully }
    $self->_remove($id);
  }
  
  sub reset {
    my $self = _instance(shift);
    delete @$self{qw(accepting acceptors in out stop)};
    $self->reactor->reset;
    $self->stop;
  }
  
  sub server {
    my ($self, $cb) = (_instance(shift), pop);
  
    my $server = Mojo::IOLoop::Server->new;
    weaken $self;
    $server->on(
      accept => sub {
        my $stream = Mojo::IOLoop::Stream->new(pop);
        $self->$cb($stream, $self->_stream($stream, $self->_id, 1));
  
        # Enforce connection limit (randomize to improve load balancing)
        if (my $max = $self->max_accepts) {
          $self->{accepts} //= $max - int rand $max / 2;
          $self->stop_gracefully if ($self->{accepts} -= 1) <= 0;
        }
  
        # Stop accepting if connection limit has been reached
        $self->_not_accepting if $self->_limit;
      }
    );
    $server->listen(@_);
  
    return $self->acceptor($server);
  }
  
  sub singleton { state $loop = shift->SUPER::new }
  
  sub start {
    my $self = _instance(shift);
    croak 'Mojo::IOLoop already running' if $self->is_running;
    $self->reactor->start;
  }
  
  sub stop { _instance(shift)->reactor->stop }
  
  sub stop_gracefully {
    my $self = _instance(shift)->_not_accepting;
    ++$self->{stop} and !$self->emit('finish')->_in and $self->stop;
  }
  
  sub stream {
    my ($self, $stream) = (_instance(shift), @_);
    return $self->_stream($stream => $self->_id) if ref $stream;
    my $c = $self->{in}{$stream} || $self->{out}{$stream} || {};
    return $c->{stream};
  }
  
  sub subprocess {
    my $subprocess = Mojo::IOLoop::Subprocess->new;
    weaken $subprocess->ioloop(_instance(shift))->{ioloop};
    return $subprocess->run(@_);
  }
  
  sub timer { shift->_timer(timer => @_) }
  
  sub _id {
    my $self = shift;
    my $id;
    do { $id = md5_sum 'c' . steady_time . rand }
      while $self->{in}{$id} || $self->{out}{$id} || $self->{acceptors}{$id};
    return $id;
  }
  
  sub _in { scalar keys %{shift->{in} || {}} }
  
  sub _instance { ref $_[0] ? $_[0] : $_[0]->singleton }
  
  sub _limit { $_[0]{stop} ? 1 : $_[0]->_in >= $_[0]->max_connections }
  
  sub _maybe_accepting {
    my $self = shift;
    return if $self->{accepting} || $self->_limit;
    $_->start for values %{$self->{acceptors} || {}};
    $self->{accepting} = 1;
  }
  
  sub _not_accepting {
    my $self = shift;
    return $self unless delete $self->{accepting};
    $_->stop for values %{$self->{acceptors} || {}};
    return $self;
  }
  
  sub _out { scalar keys %{shift->{out} || {}} }
  
  sub _remove {
    my ($self, $id) = @_;
  
    # Timer
    return unless my $reactor = $self->reactor;
    return if $reactor->remove($id);
  
    # Acceptor
    return $self->_not_accepting->_maybe_accepting
      if delete $self->{acceptors}{$id};
  
    # Connection
    return unless delete $self->{in}{$id} || delete $self->{out}{$id};
    return $self->stop if $self->{stop} && !$self->_in;
    $self->_maybe_accepting;
    warn "-- $id <<< $$ (@{[$self->_in]}:@{[$self->_out]})\n" if DEBUG;
  }
  
  sub _stream {
    my ($self, $stream, $id, $server) = @_;
  
    # Connect stream with reactor
    $self->{$server ? 'in' : 'out'}{$id}{stream} = $stream;
    warn "-- $id >>> $$ (@{[$self->_in]}:@{[$self->_out]})\n" if DEBUG;
    weaken $stream->reactor($self->reactor)->{reactor};
    weaken $self;
    $stream->on(close => sub { $self && $self->_remove($id) });
    $stream->start;
  
    return $id;
  }
  
  sub _timer {
    my ($self, $method, $after, $cb) = (_instance(shift), @_);
    weaken $self;
    return $self->reactor->$method($after => sub { $self->$cb });
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojo::IOLoop - Minimalistic event loop
  
  =head1 SYNOPSIS
  
    use Mojo::IOLoop;
  
    # Listen on port 3000
    Mojo::IOLoop->server({port => 3000} => sub {
      my ($loop, $stream) = @_;
  
      $stream->on(read => sub {
        my ($stream, $bytes) = @_;
  
        # Process input chunk
        say $bytes;
  
        # Write response
        $stream->write('HTTP/1.1 200 OK');
      });
    });
  
    # Connect to port 3000
    my $id = Mojo::IOLoop->client({port => 3000} => sub {
      my ($loop, $err, $stream) = @_;
  
      $stream->on(read => sub {
        my ($stream, $bytes) = @_;
  
        # Process input
        say "Input: $bytes";
      });
  
      # Write request
      $stream->write("GET / HTTP/1.1\x0d\x0a\x0d\x0a");
    });
  
    # Add a timer
    Mojo::IOLoop->timer(5 => sub {
      my $loop = shift;
      $loop->remove($id);
    });
  
    # Start event loop if necessary
    Mojo::IOLoop->start unless Mojo::IOLoop->is_running;
  
  =head1 DESCRIPTION
  
  L<Mojo::IOLoop> is a very minimalistic event loop based on L<Mojo::Reactor>, it
  has been reduced to the absolute minimal feature set required to build solid
  and scalable non-blocking clients and servers.
  
  Depending on operating system, the default per-process and system-wide file
  descriptor limits are often very low and need to be tuned for better
  scalability. The C<LIBEV_FLAGS> environment variable should also be used to
  select the best possible L<EV> backend, which usually defaults to the not very
  scalable C<select>.
  
    LIBEV_FLAGS=1   # select
    LIBEV_FLAGS=2   # poll
    LIBEV_FLAGS=4   # epoll (Linux)
    LIBEV_FLAGS=8   # kqueue (*BSD, OS X)
  
  The event loop will be resilient to time jumps if a monotonic clock is
  available through L<Time::HiRes>. A TLS certificate and key are also built
  right in, to make writing test servers as easy as possible. Also note that for
  convenience the C<PIPE> signal will be set to C<IGNORE> when L<Mojo::IOLoop> is
  loaded.
  
  For better scalability (epoll, kqueue) and to provide non-blocking name
  resolution, SOCKS5 as well as TLS support, the optional modules L<EV> (4.0+),
  L<Net::DNS::Native> (0.15+), L<IO::Socket::Socks> (0.64+) and
  L<IO::Socket::SSL> (1.94+) will be used automatically if possible. Individual
  features can also be disabled with the C<MOJO_NO_NNR>, C<MOJO_NO_SOCKS> and
  C<MOJO_NO_TLS> environment variables.
  
  See L<Mojolicious::Guides::Cookbook/"REAL-TIME WEB"> for more.
  
  =head1 EVENTS
  
  L<Mojo::IOLoop> inherits all events from L<Mojo::EventEmitter> and can emit the
  following new ones.
  
  =head2 finish
  
    $loop->on(finish => sub {
      my $loop = shift;
      ...
    });
  
  Emitted when the event loop wants to shut down gracefully and is just waiting
  for all existing connections to be closed.
  
  =head1 ATTRIBUTES
  
  L<Mojo::IOLoop> implements the following attributes.
  
  =head2 max_accepts
  
    my $max = $loop->max_accepts;
    $loop   = $loop->max_accepts(1000);
  
  The maximum number of connections this event loop is allowed to accept, before
  shutting down gracefully without interrupting existing connections, defaults to
  C<0>. Setting the value to C<0> will allow this event loop to accept new
  connections indefinitely. Note that up to half of this value can be subtracted
  randomly to improve load balancing between multiple server processes, and to
  make sure that not all of them restart at the same time.
  
  =head2 max_connections
  
    my $max = $loop->max_connections;
    $loop   = $loop->max_connections(100);
  
  The maximum number of accepted connections this event loop is allowed to handle
  concurrently, before stopping to accept new incoming connections, defaults to
  C<1000>.
  
  =head2 reactor
  
    my $reactor = $loop->reactor;
    $loop       = $loop->reactor(Mojo::Reactor->new);
  
  Low-level event reactor, usually a L<Mojo::Reactor::Poll> or
  L<Mojo::Reactor::EV> object with a default subscriber to the event
  L<Mojo::Reactor/"error">.
  
    # Watch if handle becomes readable or writable
    Mojo::IOLoop->singleton->reactor->io($handle => sub {
      my ($reactor, $writable) = @_;
      say $writable ? 'Handle is writable' : 'Handle is readable';
    });
  
    # Change to watching only if handle becomes writable
    Mojo::IOLoop->singleton->reactor->watch($handle, 0, 1);
  
    # Remove handle again
    Mojo::IOLoop->singleton->reactor->remove($handle);
  
  =head1 METHODS
  
  L<Mojo::IOLoop> inherits all methods from L<Mojo::EventEmitter> and implements
  the following new ones.
  
  =head2 acceptor
  
    my $server = Mojo::IOLoop->acceptor($id);
    my $server = $loop->acceptor($id);
    my $id     = $loop->acceptor(Mojo::IOLoop::Server->new);
  
  Get L<Mojo::IOLoop::Server> object for id or turn object into an acceptor.
  
  =head2 client
  
    my $id
      = Mojo::IOLoop->client(address => '127.0.0.1', port => 3000, sub {...});
    my $id = $loop->client(address => '127.0.0.1', port => 3000, sub {...});
    my $id = $loop->client({address => '127.0.0.1', port => 3000} => sub {...});
  
  Open a TCP/IP or UNIX domain socket connection with L<Mojo::IOLoop::Client>,
  takes the same arguments as L<Mojo::IOLoop::Client/"connect">.
  
    # Connect to 127.0.0.1 on port 3000
    Mojo::IOLoop->client({port => 3000} => sub {
      my ($loop, $err, $stream) = @_;
      ...
    });
  
  =head2 delay
  
    my $delay = Mojo::IOLoop->delay;
    my $delay = $loop->delay;
    my $delay = $loop->delay(sub {...});
    my $delay = $loop->delay(sub {...}, sub {...});
  
  Build L<Mojo::IOLoop::Delay> object to manage callbacks and control the flow of
  events for this event loop, which can help you avoid deep nested closures that
  often result from continuation-passing style. Callbacks will be passed along to
  L<Mojo::IOLoop::Delay/"steps">.
  
    # Synchronize multiple non-blocking operations
    my $delay = Mojo::IOLoop->delay(sub { say 'BOOM!' });
    for my $i (1 .. 10) {
      my $end = $delay->begin;
      Mojo::IOLoop->timer($i => sub {
        say 10 - $i;
        $end->();
      });
    }
    $delay->wait;
  
    # Sequentialize multiple non-blocking operations
    Mojo::IOLoop->delay(
  
      # First step (simple timer)
      sub {
        my $delay = shift;
        Mojo::IOLoop->timer(2 => $delay->begin);
        say 'Second step in 2 seconds.';
      },
  
      # Second step (concurrent timers)
      sub {
        my $delay = shift;
        Mojo::IOLoop->timer(1 => $delay->begin);
        Mojo::IOLoop->timer(3 => $delay->begin);
        say 'Third step in 3 seconds.';
      },
  
      # Third step (the end)
      sub { say 'And done after 5 seconds total.' }
    )->wait;
  
    # Handle exceptions in all steps
    Mojo::IOLoop->delay(
      sub {
        my $delay = shift;
        die 'Intentional error';
      },
      sub {
        my ($delay, @args) = @_;
        say 'Never actually reached.';
      }
    )->catch(sub {
      my ($delay, $err) = @_;
      say "Something went wrong: $err";
    })->wait;
  
  =head2 is_running
  
    my $bool = Mojo::IOLoop->is_running;
    my $bool = $loop->is_running;
  
  Check if event loop is running.
  
    exit unless Mojo::IOLoop->is_running;
  
  =head2 next_tick
  
    my $undef = Mojo::IOLoop->next_tick(sub {...});
    my $undef = $loop->next_tick(sub {...});
  
  Execute callback as soon as possible, but not before returning or other
  callbacks that have been registered with this method, always returns C<undef>.
  
    # Perform operation on next reactor tick
    Mojo::IOLoop->next_tick(sub {
      my $loop = shift;
      ...
    });
  
  =head2 one_tick
  
    Mojo::IOLoop->one_tick;
    $loop->one_tick;
  
  Run event loop until an event occurs.
  
    # Don't block longer than 0.5 seconds
    my $id = Mojo::IOLoop->timer(0.5 => sub {});
    Mojo::IOLoop->one_tick;
    Mojo::IOLoop->remove($id);
  
  =head2 recurring
  
    my $id = Mojo::IOLoop->recurring(3 => sub {...});
    my $id = $loop->recurring(0 => sub {...});
    my $id = $loop->recurring(0.25 => sub {...});
  
  Create a new recurring timer, invoking the callback repeatedly after a given
  amount of time in seconds.
  
    # Perform operation every 5 seconds
    Mojo::IOLoop->recurring(5 => sub {
      my $loop = shift;
      ...
    });
  
  =head2 remove
  
    Mojo::IOLoop->remove($id);
    $loop->remove($id);
  
  Remove anything with an id, connections will be dropped gracefully by allowing
  them to finish writing all data in their write buffers.
  
  =head2 reset
  
    Mojo::IOLoop->reset;
    $loop->reset;
  
  Remove everything and stop the event loop.
  
  =head2 server
  
    my $id = Mojo::IOLoop->server(port => 3000, sub {...});
    my $id = $loop->server(port => 3000, sub {...});
    my $id = $loop->server({port => 3000} => sub {...});
  
  Accept TCP/IP and UNIX domain socket connections with L<Mojo::IOLoop::Server>,
  takes the same arguments as L<Mojo::IOLoop::Server/"listen">.
  
    # Listen on port 3000
    Mojo::IOLoop->server({port => 3000} => sub {
      my ($loop, $stream, $id) = @_;
      ...
    });
  
    # Listen on random port
    my $id = Mojo::IOLoop->server({address => '127.0.0.1'} => sub {
      my ($loop, $stream, $id) = @_;
      ...
    });
    my $port = Mojo::IOLoop->acceptor($id)->port;
  
  =head2 singleton
  
    my $loop = Mojo::IOLoop->singleton;
  
  The global L<Mojo::IOLoop> singleton, used to access a single shared event loop
  object from everywhere inside the process.
  
    # Many methods also allow you to take shortcuts
    Mojo::IOLoop->timer(2 => sub { Mojo::IOLoop->stop });
    Mojo::IOLoop->start;
  
    # Restart active timer
    my $id = Mojo::IOLoop->timer(3 => sub { say 'Timeout!' });
    Mojo::IOLoop->singleton->reactor->again($id);
  
    # Turn file descriptor into handle and watch if it becomes readable
    my $handle = IO::Handle->new_from_fd($fd, 'r');
    Mojo::IOLoop->singleton->reactor->io($handle => sub {
      my ($reactor, $writable) = @_;
      say $writable ? 'Handle is writable' : 'Handle is readable';
    })->watch($handle, 1, 0);
  
  =head2 start
  
    Mojo::IOLoop->start;
    $loop->start;
  
  Start the event loop, this will block until L</"stop"> is called. Note that
  some reactors stop automatically if there are no events being watched anymore.
  
    # Start event loop only if it is not running already
    Mojo::IOLoop->start unless Mojo::IOLoop->is_running;
  
  =head2 stop
  
    Mojo::IOLoop->stop;
    $loop->stop;
  
  Stop the event loop, this will not interrupt any existing connections and the
  event loop can be restarted by running L</"start"> again.
  
  =head2 stop_gracefully
  
    Mojo::IOLoop->stop_gracefully;
    $loop->stop_gracefully;
  
  Stop accepting new connections and wait for already accepted connections to be
  closed, before stopping the event loop.
  
  =head2 stream
  
    my $stream = Mojo::IOLoop->stream($id);
    my $stream = $loop->stream($id);
    my $id     = $loop->stream(Mojo::IOLoop::Stream->new);
  
  Get L<Mojo::IOLoop::Stream> object for id or turn object into a connection.
  
    # Increase inactivity timeout for connection to 300 seconds
    Mojo::IOLoop->stream($id)->timeout(300);
  
  =head2 subprocess
  
    my $subprocess = Mojo::IOLoop->subprocess(sub {...}, sub {...});
    my $subprocess = $loop->subprocess(sub {...}, sub {...});
  
  Build L<Mojo::IOLoop::Subprocess> object to perform computationally expensive
  operations in subprocesses, without blocking the event loop. Callbacks will be
  passed along to L<Mojo::IOLoop::Subprocess/"run">.
  
    # Operation that would block the event loop for 5 seconds
    Mojo::IOLoop->subprocess(
      sub {
        my $subprocess = shift;
        sleep 5;
        return '', 'Mojolicious';
      },
      sub {
        my ($subprocess, $err, @results) = @_;
        say "Subprocess error: $err" and return if $err;
        say "I $results[0] $results[1]!";
      }
    );
  
  =head2 timer
  
    my $id = Mojo::IOLoop->timer(3 => sub {...});
    my $id = $loop->timer(0 => sub {...});
    my $id = $loop->timer(0.25 => sub {...});
  
  Create a new timer, invoking the callback after a given amount of time in
  seconds.
  
    # Perform operation in 5 seconds
    Mojo::IOLoop->timer(5 => sub {
      my $loop = shift;
      ...
    });
  
  =head1 DEBUGGING
  
  You can set the C<MOJO_IOLOOP_DEBUG> environment variable to get some advanced
  diagnostics information printed to C<STDERR>.
  
    MOJO_IOLOOP_DEBUG=1
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<http://mojolicious.org>.
  
  =cut
MOJO_IOLOOP

$fatpacked{"Mojo/IOLoop/Client.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJO_IOLOOP_CLIENT';
  package Mojo::IOLoop::Client;
  use Mojo::Base 'Mojo::EventEmitter';
  
  use Errno 'EINPROGRESS';
  use IO::Socket::IP;
  use IO::Socket::UNIX;
  use Mojo::IOLoop;
  use Mojo::IOLoop::TLS;
  use Scalar::Util 'weaken';
  use Socket qw(IPPROTO_TCP SOCK_STREAM TCP_NODELAY);
  
  # Non-blocking name resolution requires Net::DNS::Native
  use constant NNR => $ENV{MOJO_NO_NNR}
    ? 0
    : eval 'use Net::DNS::Native 0.15 (); 1';
  my $NDN = NNR ? Net::DNS::Native->new(pool => 5, extra_thread => 1) : undef;
  
  # SOCKS support requires IO::Socket::Socks
  use constant SOCKS => $ENV{MOJO_NO_SOCKS}
    ? 0
    : eval 'use IO::Socket::Socks 0.64 (); 1';
  use constant READ  => SOCKS ? IO::Socket::Socks::SOCKS_WANT_READ()  : 0;
  use constant WRITE => SOCKS ? IO::Socket::Socks::SOCKS_WANT_WRITE() : 0;
  
  has reactor => sub { Mojo::IOLoop->singleton->reactor };
  
  sub DESTROY { shift->_cleanup }
  
  sub can_nnr   {NNR}
  sub can_socks {SOCKS}
  
  sub connect {
    my ($self, $args) = (shift, ref $_[0] ? $_[0] : {@_});
  
    # Timeout
    weaken $self;
    my $reactor = $self->reactor;
    $self->{timer} = $reactor->timer($args->{timeout} || 10,
      sub { $self->emit(error => 'Connect timeout') });
  
    # Blocking name resolution
    $_ && s/[[\]]//g for @$args{qw(address socks_address)};
    my $address = $args->{socks_address} || ($args->{address} ||= '127.0.0.1');
    return $reactor->next_tick(sub { $self && $self->_connect($args) })
      if !NNR || $args->{handle} || $args->{path};
  
    # Non-blocking name resolution
    my $handle = $self->{dns} = $NDN->getaddrinfo($address, _port($args),
      {protocol => IPPROTO_TCP, socktype => SOCK_STREAM});
    $reactor->io(
      $handle => sub {
        my $reactor = shift;
  
        $reactor->remove($self->{dns});
        my ($err, @res) = $NDN->get_result(delete $self->{dns});
        return $self->emit(error => "Can't resolve: $err") if $err;
  
        $args->{addr_info} = \@res;
        $self->_connect($args);
      }
    )->watch($handle, 1, 0);
  }
  
  sub _cleanup {
    my $self = shift;
    $NDN->timedout($self->{dns}) if $self->{dns};
    return unless my $reactor = $self->reactor;
    $self->{$_} && $reactor->remove(delete $self->{$_}) for qw(dns timer handle);
    return $self;
  }
  
  sub _connect {
    my ($self, $args) = @_;
  
    my $path = $args->{path};
    my $handle = $self->{handle} = $args->{handle};
  
    unless ($handle) {
      my $class = $path ? 'IO::Socket::UNIX' : 'IO::Socket::IP';
      my %options = (Blocking => 0);
  
      # UNIX domain socket
      if ($path) { $options{Peer} = $path }
  
      # IP socket
      else {
        if (my $info = $args->{addr_info}) { $options{PeerAddrInfo} = $info }
        else {
          $options{PeerAddr} = $args->{socks_address} || $args->{address};
          $options{PeerPort} = _port($args);
        }
        $options{LocalAddr} = $args->{local_address} if $args->{local_address};
      }
  
      return $self->emit(error => "Can't connect: $@")
        unless $self->{handle} = $handle = $class->new(%options);
    }
    $handle->blocking(0);
  
    $path ? $self->_try_socks($args) : $self->_wait('_ready', $handle, $args);
  }
  
  sub _port { $_[0]{socks_port} || $_[0]{port} || ($_[0]{tls} ? 443 : 80) }
  
  sub _ready {
    my ($self, $args) = @_;
  
    # Socket changes in between attempts and needs to be re-added for epoll/kqueue
    my $handle = $self->{handle};
    unless ($handle->connect) {
      return $self->emit(error => $!) unless $! == EINPROGRESS;
      $self->reactor->remove($handle);
      return $self->_wait('_ready', $handle, $args);
    }
  
    return $self->emit(error => $! || 'Not connected') unless $handle->connected;
  
    # Disable Nagle's algorithm
    setsockopt $handle, IPPROTO_TCP, TCP_NODELAY, 1;
  
    $self->_try_socks($args);
  }
  
  sub _socks {
    my ($self, $args) = @_;
  
    # Connected
    my $handle = $self->{handle};
    return $self->_try_tls($args) if $handle->ready;
  
    # Switch between reading and writing
    my $err = $IO::Socket::Socks::SOCKS_ERROR;
    if    ($err == READ)  { $self->reactor->watch($handle, 1, 0) }
    elsif ($err == WRITE) { $self->reactor->watch($handle, 1, 1) }
    else                  { $self->emit(error => $err) }
  }
  
  sub _try_socks {
    my ($self, $args) = @_;
  
    my $handle = $self->{handle};
    return $self->_try_tls($args) unless $args->{socks_address};
    return $self->emit(
      error => 'IO::Socket::Socks 0.64+ required for SOCKS support')
      unless SOCKS;
  
    my %options = (ConnectAddr => $args->{address}, ConnectPort => $args->{port});
    @options{qw(AuthType Username Password)}
      = ('userpass', @$args{qw(socks_user socks_pass)})
      if $args->{socks_user};
    my $reactor = $self->reactor;
    $reactor->remove($handle);
    return $self->emit(error => 'SOCKS upgrade failed')
      unless IO::Socket::Socks->start_SOCKS($handle, %options);
  
    $self->_wait('_socks', $handle, $args);
  }
  
  sub _try_tls {
    my ($self, $args) = @_;
  
    my $handle = $self->{handle};
    return $self->_cleanup->emit(connect => $handle) unless $args->{tls};
    my $reactor = $self->reactor;
    $reactor->remove($handle);
  
    # Start TLS handshake
    my $tls = Mojo::IOLoop::TLS->new($handle)->reactor($self->reactor);
    $tls->on(upgrade => sub { $self->_cleanup->emit(connect => pop) });
    $tls->on(error => sub { $self->emit(error => pop) });
    $tls->negotiate(%$args);
  }
  
  sub _wait {
    my ($self, $next, $handle, $args) = @_;
    weaken $self;
    $self->reactor->io($handle => sub { $self->$next($args) })
      ->watch($handle, 0, 1);
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojo::IOLoop::Client - Non-blocking TCP/IP and UNIX domain socket client
  
  =head1 SYNOPSIS
  
    use Mojo::IOLoop::Client;
  
    # Create socket connection
    my $client = Mojo::IOLoop::Client->new;
    $client->on(connect => sub {
      my ($client, $handle) = @_;
      ...
    });
    $client->on(error => sub {
      my ($client, $err) = @_;
      ...
    });
    $client->connect(address => 'example.com', port => 80);
  
    # Start reactor if necessary
    $client->reactor->start unless $client->reactor->is_running;
  
  =head1 DESCRIPTION
  
  L<Mojo::IOLoop::Client> opens TCP/IP and UNIX domain socket connections for
  L<Mojo::IOLoop>.
  
  =head1 EVENTS
  
  L<Mojo::IOLoop::Client> inherits all events from L<Mojo::EventEmitter> and can
  emit the following new ones.
  
  =head2 connect
  
    $client->on(connect => sub {
      my ($client, $handle) = @_;
      ...
    });
  
  Emitted once the connection is established.
  
  =head2 error
  
    $client->on(error => sub {
      my ($client, $err) = @_;
      ...
    });
  
  Emitted if an error occurs on the connection, fatal if unhandled.
  
  =head1 ATTRIBUTES
  
  L<Mojo::IOLoop::Client> implements the following attributes.
  
  =head2 reactor
  
    my $reactor = $client->reactor;
    $client     = $client->reactor(Mojo::Reactor::Poll->new);
  
  Low-level event reactor, defaults to the C<reactor> attribute value of the
  global L<Mojo::IOLoop> singleton.
  
  =head1 METHODS
  
  L<Mojo::IOLoop::Client> inherits all methods from L<Mojo::EventEmitter> and
  implements the following new ones.
  
  =head2 can_nnr
  
    my $bool = Mojo::IOLoop::Client->can_nnr;
  
  True if L<Net::DNS::Native> 0.15+ is installed and non-blocking name resolution
  support enabled.
  
  =head2 can_socks
  
    my $bool = Mojo::IOLoop::Client->can_socks;
  
  True if L<IO::Socket::SOCKS> 0.64+ is installed and SOCKS5 support enabled.
  
  =head2 connect
  
    $client->connect(address => '127.0.0.1', port => 3000);
    $client->connect({address => '127.0.0.1', port => 3000});
  
  Open a socket connection to a remote host. Note that non-blocking name
  resolution depends on L<Net::DNS::Native> (0.15+), SOCKS5 support on
  L<IO::Socket::Socks> (0.64), and TLS support on L<IO::Socket::SSL> (1.94+).
  
  These options are currently available:
  
  =over 2
  
  =item address
  
    address => 'mojolicious.org'
  
  Address or host name of the peer to connect to, defaults to C<127.0.0.1>.
  
  =item handle
  
    handle => $handle
  
  Use an already prepared L<IO::Socket::IP> object.
  
  =item local_address
  
    local_address => '127.0.0.1'
  
  Local address to bind to.
  
  =item path
  
    path => '/tmp/myapp.sock'
  
  Path of UNIX domain socket to connect to.
  
  =item port
  
    port => 80
  
  Port to connect to, defaults to C<80> or C<443> with C<tls> option.
  
  =item socks_address
  
    socks_address => '127.0.0.1'
  
  Address or host name of SOCKS5 proxy server to use for connection.
  
  =item socks_pass
  
    socks_pass => 'secr3t'
  
  Password to use for SOCKS5 authentication.
  
  =item socks_port
  
    socks_port => 9050
  
  Port of SOCKS5 proxy server to use for connection.
  
  =item socks_user
  
    socks_user => 'sri'
  
  Username to use for SOCKS5 authentication.
  
  =item timeout
  
    timeout => 15
  
  Maximum amount of time in seconds establishing connection may take before
  getting canceled, defaults to C<10>.
  
  =item tls
  
    tls => 1
  
  Enable TLS.
  
  =item tls_ca
  
    tls_ca => '/etc/tls/ca.crt'
  
  Path to TLS certificate authority file. Also activates hostname verification.
  
  =item tls_cert
  
    tls_cert => '/etc/tls/client.crt'
  
  Path to the TLS certificate file.
  
  =item tls_key
  
    tls_key => '/etc/tls/client.key'
  
  Path to the TLS key file.
  
  =back
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<http://mojolicious.org>.
  
  =cut
MOJO_IOLOOP_CLIENT

$fatpacked{"Mojo/IOLoop/Delay.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJO_IOLOOP_DELAY';
  package Mojo::IOLoop::Delay;
  use Mojo::Base 'Mojo::EventEmitter';
  
  use Mojo::IOLoop;
  use Mojo::Util;
  
  has ioloop    => sub { Mojo::IOLoop->singleton };
  has remaining => sub { [] };
  
  sub begin {
    my ($self, $offset, $len) = @_;
    $self->{pending}++;
    my $id = $self->{counter}++;
    return sub { $self->_step($id, $offset // 1, $len, @_) };
  }
  
  sub data { Mojo::Util::_stash(data => @_) }
  
  sub pass { $_[0]->begin->(@_) }
  
  sub steps {
    my $self = shift->remaining([@_]);
    $self->ioloop->next_tick($self->begin);
    return $self;
  }
  
  sub wait {
    my $self = shift;
    return if $self->ioloop->is_running;
    $self->once(error => \&_die);
    $self->once(finish => sub { shift->ioloop->stop });
    $self->ioloop->start;
  }
  
  sub _die { $_[0]->has_subscribers('error') ? $_[0]->ioloop->stop : die $_[1] }
  
  sub _step {
    my ($self, $id, $offset, $len) = (shift, shift, shift, shift);
  
    $self->{args}[$id]
      = [@_ ? defined $len ? splice @_, $offset, $len : splice @_, $offset : ()];
    return $self if $self->{fail} || --$self->{pending} || $self->{lock};
    local $self->{lock} = 1;
    my @args = map {@$_} @{delete $self->{args}};
  
    $self->{counter} = 0;
    if (my $cb = shift @{$self->remaining}) {
      eval { $self->$cb(@args); 1 }
        or (++$self->{fail} and return $self->remaining([])->emit(error => $@));
    }
  
    return $self->remaining([])->emit(finish => @args) unless $self->{counter};
    $self->ioloop->next_tick($self->begin) unless $self->{pending};
    return $self;
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojo::IOLoop::Delay - Manage callbacks and control the flow of events
  
  =head1 SYNOPSIS
  
    use Mojo::IOLoop::Delay;
  
    # Synchronize multiple non-blocking operations
    my $delay = Mojo::IOLoop::Delay->new;
    $delay->steps(sub { say 'BOOM!' });
    for my $i (1 .. 10) {
      my $end = $delay->begin;
      Mojo::IOLoop->timer($i => sub {
        say 10 - $i;
        $end->();
      });
    }
    $delay->wait;
  
    # Sequentialize multiple non-blocking operations
    Mojo::IOLoop::Delay->new->steps(
  
      # First step (simple timer)
      sub {
        my $delay = shift;
        Mojo::IOLoop->timer(2 => $delay->begin);
        say 'Second step in 2 seconds.';
      },
  
      # Second step (concurrent timers)
      sub {
        my ($delay, @args) = @_;
        Mojo::IOLoop->timer(1 => $delay->begin);
        Mojo::IOLoop->timer(3 => $delay->begin);
        say 'Third step in 3 seconds.';
      },
  
      # Third step (the end)
      sub {
        my ($delay, @args) = @_;
        say 'And done after 5 seconds total.';
      }
    )->wait;
  
    # Handle exceptions in all steps
    Mojo::IOLoop::Delay->new->steps(
      sub {
        my $delay = shift;
        die 'Intentional error';
      },
      sub {
        my ($delay, @args) = @_;
        say 'Never actually reached.';
      }
    )->catch(sub {
      my ($delay, $err) = @_;
      say "Something went wrong: $err";
    })->wait;
  
  =head1 DESCRIPTION
  
  L<Mojo::IOLoop::Delay> manages callbacks and controls the flow of events for
  L<Mojo::IOLoop>, which can help you avoid deep nested closures that often
  result from continuation-passing style.
  
    use Mojo::IOLoop;
  
    # These deep nested closures are often referred to as "Callback Hell"
    Mojo::IOLoop->timer(3 => sub {
      my loop = shift;
  
      say '3 seconds';
      Mojo::IOLoop->timer(3 => sub {
        my $loop = shift;
  
        say '6 seconds';
        Mojo::IOLoop->timer(3 => sub {
          my $loop = shift;
  
          say '9 seconds';
          Mojo::IOLoop->stop;
        });
      });
    });
  
    Mojo::IOLoop->start;
  
  The idea behind L<Mojo::IOLoop::Delay> is to turn the nested closures above into
  a flat series of closures. In the example below, the call to L</"begin"> creates
  a code reference that we can pass to L<Mojo::IOLoop/"timer"> as a callback, and
  that leads to the next closure in the series when executed.
  
    use Mojo::IOLoop;
  
    # Instead of nested closures we now have a simple chain
    my $delay = Mojo::IOloop->delay(
      sub {
        my $delay = shift;
        Mojo::IOLoop->timer(3 => $delay->begin);
      },
      sub {
        my $delay = shift;
        say '3 seconds';
        Mojo::IOLoop->timer(3 => $delay->begin);
      },
      sub {
        my $delay = shift;
        say '6 seconds';
        Mojo::IOLoop->timer(3 => $delay->begin);
      },
      sub {
        my $delay = shift;
        say '9 seconds';
      }
    );
    $delay->wait;
  
  Another positive side effect of this pattern is that we do not need to call
  L<Mojo::IOLoop/"start"> and L<Mojo::IOLoop/"stop"> manually, because we know
  exactly when our series of closures has reached the end. So L</"wait"> can stop
  the event loop automatically if it had to be started at all in the first place.
  
  =head1 EVENTS
  
  L<Mojo::IOLoop::Delay> inherits all events from L<Mojo::EventEmitter> and can
  emit the following new ones.
  
  =head2 error
  
    $delay->on(error => sub {
      my ($delay, $err) = @_;
      ...
    });
  
  Emitted if an exception gets thrown in one of the steps, breaking the chain,
  fatal if unhandled.
  
  =head2 finish
  
    $delay->on(finish => sub {
      my ($delay, @args) = @_;
      ...
    });
  
  Emitted once the event counter reaches zero and there are no more steps.
  
  =head1 ATTRIBUTES
  
  L<Mojo::IOLoop::Delay> implements the following attributes.
  
  =head2 ioloop
  
    my $loop = $delay->ioloop;
    $delay   = $delay->ioloop(Mojo::IOLoop->new);
  
  Event loop object to control, defaults to the global L<Mojo::IOLoop> singleton.
  
  =head2 remaining
  
    my $remaining = $delay->remaining;
    $delay        = $delay->remaining([sub {...}]);
  
  Remaining L</"steps"> in chain.
  
  =head1 METHODS
  
  L<Mojo::IOLoop::Delay> inherits all methods from L<Mojo::EventEmitter> and
  implements the following new ones.
  
  =head2 begin
  
    my $cb = $delay->begin;
    my $cb = $delay->begin($offset);
    my $cb = $delay->begin($offset, $len);
  
  Indicate an active event by incrementing the event counter, the returned
  code reference can be used as a callback, and needs to be executed when the
  event has completed to decrement the event counter again. When all code
  references generated by this method have been executed and the event counter has
  reached zero, L</"steps"> will continue.
  
    # Capture all arguments except for the first one (invocant)
    my $delay = Mojo::IOLoop->delay(sub {
      my ($delay, $err, $stream) = @_;
      ...
    });
    Mojo::IOLoop->client({port => 3000} => $delay->begin);
    $delay->wait;
  
  Arguments passed to the returned code reference are spliced with the given
  offset and length, defaulting to an offset of C<1> with no default length. The
  arguments are then combined in the same order L</"begin"> was called, and passed
  together to the next step or L</"finish"> event.
  
    # Capture all arguments
    my $delay = Mojo::IOLoop->delay(sub {
      my ($delay, $loop, $err, $stream) = @_;
      ...
    });
    Mojo::IOLoop->client({port => 3000} => $delay->begin(0));
    $delay->wait;
  
    # Capture only the second argument
    my $delay = Mojo::IOLoop->delay(sub {
      my ($delay, $err) = @_;
      ...
    });
    Mojo::IOLoop->client({port => 3000} => $delay->begin(1, 1));
    $delay->wait;
  
    # Capture and combine arguments
    my $delay = Mojo::IOLoop->delay(sub {
      my ($delay, $three_err, $three_stream, $four_err, $four_stream) = @_;
      ...
    });
    Mojo::IOLoop->client({port => 3000} => $delay->begin);
    Mojo::IOLoop->client({port => 4000} => $delay->begin);
    $delay->wait;
  
  =head2 data
  
    my $hash = $delay->data;
    my $foo  = $delay->data('foo');
    $delay   = $delay->data({foo => 'bar', baz => 23});
    $delay   = $delay->data(foo => 'bar', baz => 23);
  
  Data shared between all L</"steps">.
  
    # Remove value
    my $foo = delete $delay->data->{foo};
  
    # Assign multiple values at once
    $delay->data(foo => 'test', bar => 23);
  
  =head2 pass
  
    $delay = $delay->pass;
    $delay = $delay->pass(@args);
  
  Increment event counter and decrement it again right away to pass values to the
  next step.
  
    # Longer version
    $delay->begin(0)->(@args);
  
  =head2 steps
  
    $delay = $delay->steps(sub {...}, sub {...});
  
  Sequentialize multiple events, every time the event counter reaches zero a
  callback will run, the first one automatically runs during the next reactor tick
  unless it is delayed by incrementing the event counter. This chain will continue
  until there are no L</"remaining"> callbacks, a callback does not increment the
  event counter or an exception gets thrown in a callback.
  
  =head2 wait
  
    $delay->wait;
  
  Start L</"ioloop"> and stop it again once an L</"error"> or L</"finish"> event
  gets emitted, does nothing when L</"ioloop"> is already running.
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<http://mojolicious.org>.
  
  =cut
MOJO_IOLOOP_DELAY

$fatpacked{"Mojo/IOLoop/Server.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJO_IOLOOP_SERVER';
  package Mojo::IOLoop::Server;
  use Mojo::Base 'Mojo::EventEmitter';
  
  use Carp 'croak';
  use IO::Socket::IP;
  use IO::Socket::UNIX;
  use Mojo::IOLoop;
  use Mojo::IOLoop::TLS;
  use Scalar::Util 'weaken';
  use Socket qw(IPPROTO_TCP TCP_NODELAY);
  
  has reactor => sub { Mojo::IOLoop->singleton->reactor };
  
  sub DESTROY {
    my $self = shift;
    $ENV{MOJO_REUSE} =~ s/(?:^|\,)\Q$self->{reuse}\E// if $self->{reuse};
    $self->stop if $self->{handle} && $self->reactor;
  }
  
  sub generate_port {
    IO::Socket::IP->new(Listen => 5, LocalAddr => '127.0.0.1')->sockport;
  }
  
  sub handle { shift->{handle} }
  
  sub is_accepting { !!shift->{active} }
  
  sub listen {
    my ($self, $args) = (shift, ref $_[0] ? $_[0] : {@_});
  
    # Look for reusable file descriptor
    my $path    = $args->{path};
    my $address = $args->{address} || '0.0.0.0';
    my $port    = $args->{port};
    $ENV{MOJO_REUSE} ||= '';
    my $fd
      = ($path && $ENV{MOJO_REUSE} =~ /(?:^|\,)unix:\Q$path\E:(\d+)/)
      || ($port && $ENV{MOJO_REUSE} =~ /(?:^|\,)\Q$address:$port\E:(\d+)/)
      ? $1
      : undef;
  
    # Allow file descriptor inheritance
    local $^F = 1023;
  
    # Reuse file descriptor
    my $handle;
    my $class = $path ? 'IO::Socket::UNIX' : 'IO::Socket::IP';
    if (defined $fd) {
      $handle = $class->new_from_fd($fd, 'r')
        or croak "Can't open file descriptor $fd: $!";
    }
  
    else {
      my %options
        = (Listen => $args->{backlog} // SOMAXCONN, Type => SOCK_STREAM);
  
      # UNIX domain socket
      my $reuse;
      if ($path) {
        unlink $path if -S $path;
        $options{Local} = $path;
        $handle = $class->new(%options) or croak "Can't create listen socket: $!";
        $reuse = $self->{reuse} = join ':', 'unix', $path, fileno $handle;
      }
  
      # IP socket
      else {
        $options{LocalAddr} = $address;
        $options{LocalAddr} =~ s/[\[\]]//g;
        $options{LocalPort} = $port if $port;
        $options{ReuseAddr} = 1;
        $options{ReusePort} = $args->{reuse};
        $handle = $class->new(%options) or croak "Can't create listen socket: $@";
        $fd     = fileno $handle;
        $reuse  = $self->{reuse} = join ':', $address, $handle->sockport, $fd;
      }
  
      $ENV{MOJO_REUSE} .= length $ENV{MOJO_REUSE} ? ",$reuse" : "$reuse";
    }
    $handle->blocking(0);
    @$self{qw(args handle)} = ($args, $handle);
  
    croak 'IO::Socket::SSL 1.94+ required for TLS support'
      if !Mojo::IOLoop::TLS->can_tls && $args->{tls};
  }
  
  sub port { shift->{handle}->sockport }
  
  sub start {
    my $self = shift;
    weaken $self;
    ++$self->{active}
      and $self->reactor->io($self->{handle} => sub { $self->_accept });
  }
  
  sub stop { delete($_[0]{active}) and $_[0]->reactor->remove($_[0]{handle}) }
  
  sub _accept {
    my $self = shift;
  
    # Greedy accept
    my $args     = $self->{args};
    my $accepted = 0;
    while ($self->{active} && !($args->{single_accept} && $accepted++)) {
      return unless my $handle = $self->{handle}->accept;
      $handle->blocking(0);
  
      # Disable Nagle's algorithm
      setsockopt $handle, IPPROTO_TCP, TCP_NODELAY, 1;
  
      $self->emit(accept => $handle) and next unless $args->{tls};
  
      # Start TLS handshake
      my $tls = Mojo::IOLoop::TLS->new($handle)->reactor($self->reactor);
      $tls->on(upgrade => sub { $self->emit(accept => pop) });
      $tls->on(error => sub { });
      $tls->negotiate(%$args, server => 1);
    }
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojo::IOLoop::Server - Non-blocking TCP and UNIX domain socket server
  
  =head1 SYNOPSIS
  
    use Mojo::IOLoop::Server;
  
    # Create listen socket
    my $server = Mojo::IOLoop::Server->new;
    $server->on(accept => sub {
      my ($server, $handle) = @_;
      ...
    });
    $server->listen(port => 3000);
  
    # Start and stop accepting connections
    $server->start;
    $server->stop;
  
    # Start reactor if necessary
    $server->reactor->start unless $server->reactor->is_running;
  
  =head1 DESCRIPTION
  
  L<Mojo::IOLoop::Server> accepts TCP/IP and UNIX domain socket connections for
  L<Mojo::IOLoop>.
  
  =head1 EVENTS
  
  L<Mojo::IOLoop::Server> inherits all events from L<Mojo::EventEmitter> and can
  emit the following new ones.
  
  =head2 accept
  
    $server->on(accept => sub {
      my ($server, $handle) = @_;
      ...
    });
  
  Emitted for each accepted connection.
  
  =head1 ATTRIBUTES
  
  L<Mojo::IOLoop::Server> implements the following attributes.
  
  =head2 reactor
  
    my $reactor = $server->reactor;
    $server     = $server->reactor(Mojo::Reactor::Poll->new);
  
  Low-level event reactor, defaults to the C<reactor> attribute value of the
  global L<Mojo::IOLoop> singleton.
  
  =head1 METHODS
  
  L<Mojo::IOLoop::Server> inherits all methods from L<Mojo::EventEmitter> and
  implements the following new ones.
  
  =head2 generate_port
  
    my $port = Mojo::IOLoop::Server->generate_port;
  
  Find a free TCP port, primarily used for tests.
  
  =head2 handle
  
    my $handle = $server->handle;
  
  Get handle for server, usually an L<IO::Socket::IP> object.
  
  =head2 is_accepting
  
    my $bool = $server->is_accepting;
  
  Check if connections are currently being accepted.
  
  =head2 listen
  
    $server->listen(port => 3000);
    $server->listen({port => 3000});
  
  Create a new listen socket. Note that TLS support depends on L<IO::Socket::SSL>
  (1.94+).
  
  These options are currently available:
  
  =over 2
  
  =item address
  
    address => '127.0.0.1'
  
  Local address to listen on, defaults to C<0.0.0.0>.
  
  =item backlog
  
    backlog => 128
  
  Maximum backlog size, defaults to C<SOMAXCONN>.
  
  =item path
  
    path => '/tmp/myapp.sock'
  
  Path for UNIX domain socket to listen on.
  
  =item port
  
    port => 80
  
  Port to listen on, defaults to a random port.
  
  =item reuse
  
    reuse => 1
  
  Allow multiple servers to use the same port with the C<SO_REUSEPORT> socket
  option.
  
  =item single_accept
  
    single_accept => 1
  
  Only accept one connection at a time.
  
  =item tls
  
    tls => 1
  
  Enable TLS.
  
  =item tls_ca
  
    tls_ca => '/etc/tls/ca.crt'
  
  Path to TLS certificate authority file.
  
  =item tls_cert
  
    tls_cert => '/etc/tls/server.crt'
    tls_cert => {'mojolicious.org' => '/etc/tls/mojo.crt'}
  
  Path to the TLS cert file, defaults to a built-in test certificate.
  
  =item tls_ciphers
  
    tls_ciphers => 'AES128-GCM-SHA256:RC4:HIGH:!MD5:!aNULL:!EDH'
  
  TLS cipher specification string. For more information about the format see
  L<https://www.openssl.org/docs/manmaster/apps/ciphers.html#CIPHER-STRINGS>.
  
  =item tls_key
  
    tls_key => '/etc/tls/server.key'
    tls_key => {'mojolicious.org' => '/etc/tls/mojo.key'}
  
  Path to the TLS key file, defaults to a built-in test key.
  
  =item tls_verify
  
    tls_verify => 0x00
  
  TLS verification mode, defaults to C<0x03> if a certificate authority file has
  been provided, or C<0x00>.
  
  =item tls_version
  
    tls_version => 'TLSv1_2'
  
  TLS protocol version.
  
  =back
  
  =head2 port
  
    my $port = $server->port;
  
  Get port this server is listening on.
  
  =head2 start
  
    $server->start;
  
  Start or resume accepting connections.
  
  =head2 stop
  
    $server->stop;
  
  Stop accepting connections.
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<http://mojolicious.org>.
  
  =cut
MOJO_IOLOOP_SERVER

$fatpacked{"Mojo/IOLoop/Stream.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJO_IOLOOP_STREAM';
  package Mojo::IOLoop::Stream;
  use Mojo::Base 'Mojo::EventEmitter';
  
  use Errno qw(EAGAIN ECONNRESET EINTR EWOULDBLOCK);
  use Mojo::IOLoop;
  use Mojo::Util;
  use Scalar::Util 'weaken';
  
  has reactor => sub { Mojo::IOLoop->singleton->reactor };
  
  sub DESTROY { Mojo::Util::_global_destruction() or shift->close }
  
  sub close {
    my $self = shift;
    return unless my $reactor = $self->reactor;
    return unless my $handle  = delete $self->timeout(0)->{handle};
    $reactor->remove($handle);
    $self->emit('close');
  }
  
  sub close_gracefully { $_[0]->is_writing ? $_[0]{graceful}++ : $_[0]->close }
  
  sub handle { shift->{handle} }
  
  sub is_readable {
    my $self = shift;
    $self->_again;
    return $self->{handle} && Mojo::Util::_readable(0, fileno $self->{handle});
  }
  
  sub is_writing {
    my $self = shift;
    return undef unless $self->{handle};
    return !!length($self->{buffer}) || $self->has_subscribers('drain');
  }
  
  sub new { shift->SUPER::new(handle => shift, buffer => '', timeout => 15) }
  
  sub start {
    my $self = shift;
  
    # Resume
    my $reactor = $self->reactor;
    return $reactor->watch($self->{handle}, 1, $self->is_writing)
      if delete $self->{paused};
  
    weaken $self;
    my $cb = sub { pop() ? $self->_write : $self->_read };
    $reactor->io($self->timeout($self->{timeout})->{handle} => $cb);
  }
  
  sub steal_handle {
    my $self = shift;
    $self->reactor->remove($self->{handle});
    return delete $self->{handle};
  }
  
  sub stop {
    my $self = shift;
    $self->reactor->watch($self->{handle}, 0, $self->is_writing)
      unless $self->{paused}++;
  }
  
  sub timeout {
    my $self = shift;
  
    return $self->{timeout} unless @_;
  
    my $reactor = $self->reactor;
    $reactor->remove(delete $self->{timer}) if $self->{timer};
    return $self unless my $timeout = $self->{timeout} = shift;
    weaken $self;
    $self->{timer}
      = $reactor->timer($timeout => sub { $self->emit('timeout')->close });
  
    return $self;
  }
  
  sub write {
    my ($self, $chunk, $cb) = @_;
  
    # IO::Socket::SSL will corrupt data with the wrong internal representation
    utf8::downgrade $chunk;
    $self->{buffer} .= $chunk;
    if ($cb) { $self->once(drain => $cb) }
    elsif (!length $self->{buffer}) { return $self }
    $self->reactor->watch($self->{handle}, !$self->{paused}, 1)
      if $self->{handle};
  
    return $self;
  }
  
  sub _again { $_[0]->reactor->again($_[0]{timer}) if $_[0]{timer} }
  
  sub _read {
    my $self = shift;
  
    my $read = $self->{handle}->sysread(my $buffer, 131072, 0);
    return $read == 0 ? $self->close : $self->emit(read => $buffer)->_again
      if defined $read;
  
    # Retry
    return if $! == EAGAIN || $! == EINTR || $! == EWOULDBLOCK;
  
    # Closed (maybe real error)
    $! == ECONNRESET ? $self->close : $self->emit(error => $!)->close;
  }
  
  sub _write {
    my $self = shift;
  
    # Handle errors only when reading (to avoid timing problems)
    my $handle = $self->{handle};
    if (length $self->{buffer}) {
      return unless defined(my $written = $handle->syswrite($self->{buffer}));
      $self->emit(write => substr($self->{buffer}, 0, $written, ''))->_again;
    }
  
    $self->emit('drain') unless length $self->{buffer};
    return if $self->is_writing;
    return $self->close if $self->{graceful};
    $self->reactor->watch($handle, !$self->{paused}, 0) if $self->{handle};
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojo::IOLoop::Stream - Non-blocking I/O stream
  
  =head1 SYNOPSIS
  
    use Mojo::IOLoop::Stream;
  
    # Create stream
    my $stream = Mojo::IOLoop::Stream->new($handle);
    $stream->on(read => sub {
      my ($stream, $bytes) = @_;
      ...
    });
    $stream->on(close => sub {
      my $stream = shift;
      ...
    });
    $stream->on(error => sub {
      my ($stream, $err) = @_;
      ...
    });
  
    # Start and stop watching for new data
    $stream->start;
    $stream->stop;
  
    # Start reactor if necessary
    $stream->reactor->start unless $stream->reactor->is_running;
  
  =head1 DESCRIPTION
  
  L<Mojo::IOLoop::Stream> is a container for I/O streams used by L<Mojo::IOLoop>.
  
  =head1 EVENTS
  
  L<Mojo::IOLoop::Stream> inherits all events from L<Mojo::EventEmitter> and can
  emit the following new ones.
  
  =head2 close
  
    $stream->on(close => sub {
      my $stream = shift;
      ...
    });
  
  Emitted if the stream gets closed.
  
  =head2 drain
  
    $stream->on(drain => sub {
      my $stream = shift;
      ...
    });
  
  Emitted once all data has been written.
  
  =head2 error
  
    $stream->on(error => sub {
      my ($stream, $err) = @_;
      ...
    });
  
  Emitted if an error occurs on the stream, fatal if unhandled.
  
  =head2 read
  
    $stream->on(read => sub {
      my ($stream, $bytes) = @_;
      ...
    });
  
  Emitted if new data arrives on the stream.
  
  =head2 timeout
  
    $stream->on(timeout => sub {
      my $stream = shift;
      ...
    });
  
  Emitted if the stream has been inactive for too long and will get closed
  automatically.
  
  =head2 write
  
    $stream->on(write => sub {
      my ($stream, $bytes) = @_;
      ...
    });
  
  Emitted if new data has been written to the stream.
  
  =head1 ATTRIBUTES
  
  L<Mojo::IOLoop::Stream> implements the following attributes.
  
  =head2 reactor
  
    my $reactor = $stream->reactor;
    $stream     = $stream->reactor(Mojo::Reactor::Poll->new);
  
  Low-level event reactor, defaults to the C<reactor> attribute value of the
  global L<Mojo::IOLoop> singleton.
  
  =head1 METHODS
  
  L<Mojo::IOLoop::Stream> inherits all methods from L<Mojo::EventEmitter> and
  implements the following new ones.
  
  =head2 close
  
    $stream->close;
  
  Close stream immediately.
  
  =head2 close_gracefully
  
    $stream->close_gracefully;
  
  Close stream gracefully.
  
  =head2 handle
  
    my $handle = $stream->handle;
  
  Get handle for stream, usually an L<IO::Socket::IP> or L<IO::Socket::SSL>
  object.
  
  =head2 is_readable
  
    my $bool = $stream->is_readable;
  
  Quick non-blocking check if stream is readable, useful for identifying tainted
  sockets.
  
  =head2 is_writing
  
    my $bool = $stream->is_writing;
  
  Check if stream is writing.
  
  =head2 new
  
    my $stream = Mojo::IOLoop::Stream->new($handle);
  
  Construct a new L<Mojo::IOLoop::Stream> object.
  
  =head2 start
  
    $stream->start;
  
  Start or resume watching for new data on the stream.
  
  =head2 steal_handle
  
    my $handle = $stream->steal_handle;
  
  Steal L</"handle"> and prevent it from getting closed automatically.
  
  =head2 stop
  
    $stream->stop;
  
  Stop watching for new data on the stream.
  
  =head2 timeout
  
    my $timeout = $stream->timeout;
    $stream     = $stream->timeout(45);
  
  Maximum amount of time in seconds stream can be inactive before getting closed
  automatically, defaults to C<15>. Setting the value to C<0> will allow this
  stream to be inactive indefinitely.
  
  =head2 write
  
    $stream = $stream->write($bytes);
    $stream = $stream->write($bytes => sub {...});
  
  Write data to stream, the optional drain callback will be executed once all data
  has been written.
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<http://mojolicious.org>.
  
  =cut
MOJO_IOLOOP_STREAM

$fatpacked{"Mojo/IOLoop/Subprocess.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJO_IOLOOP_SUBPROCESS';
  package Mojo::IOLoop::Subprocess;
  use Mojo::Base -base;
  
  use Carp 'croak';
  use Config;
  use Mojo::IOLoop;
  use Mojo::IOLoop::Stream;
  use POSIX ();
  use Storable;
  
  has deserialize => sub { \&Storable::thaw };
  has ioloop      => sub { Mojo::IOLoop->singleton };
  has serialize   => sub { \&Storable::freeze };
  
  sub pid { shift->{pid} }
  
  sub run {
    my ($self, $child, $parent) = @_;
  
    # No fork emulation support
    croak 'Subprocesses do not support fork emulation' if $Config{d_pseudofork};
  
    # Pipe for subprocess communication
    pipe(my $reader, my $writer) or croak "Can't create pipe: $!";
    $writer->autoflush(1);
  
    # Child
    croak "Can't fork: $!" unless defined(my $pid = $self->{pid} = fork);
    unless ($pid) {
      $self->ioloop->reset;
      my $results = eval { [$self->$child] } || [];
      print $writer $self->serialize->([$@, @$results]);
      POSIX::_exit(0);
    }
  
    # Parent
    my $me     = $$;
    my $stream = Mojo::IOLoop::Stream->new($reader)->timeout(0);
    $self->ioloop->stream($stream);
    my $buffer = '';
    $stream->on(read => sub { $buffer .= pop });
    $stream->on(
      close => sub {
        return unless $$ == $me;
        waitpid $pid, 0;
        my $results = eval { $self->deserialize->($buffer) } || [];
        $self->$parent(shift(@$results) // $@, @$results);
      }
    );
    return $self;
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojo::IOLoop::Subprocess - Subprocesses
  
  =head1 SYNOPSIS
  
    use Mojo::IOLoop::Subprocess;
  
    # Operation that would block the event loop for 5 seconds
    my $subprocess = Mojo::IOLoop::Subprocess->new;
    $subprocess->run(
      sub {
        my $subprocess = shift;
        sleep 5;
        return '', 'Mojolicious';
      },
      sub {
        my ($subprocess, $err, @results) = @_;
        say "Subprocess error: $err" and return if $err;
        say "I $results[0] $results[1]!";
      }
    );
  
    # Start event loop if necessary
    $subprocess->ioloop->start unless $subprocess->ioloop->is_running;
  
  =head1 DESCRIPTION
  
  L<Mojo::IOLoop::Subprocess> allows L<Mojo::IOLoop> to perform computationally
  expensive operations in subprocesses, without blocking the event loop.
  
  =head1 ATTRIBUTES
  
  L<Mojo::IOLoop::Subprocess> implements the following attributes.
  
  =head2 deserialize
  
    my $cb      = $subprocess->deserialize;
    $subprocess = $subprocess->deserialize(sub {...});
  
  A callback used to deserialize subprocess return values, defaults to using
  L<Storable>.
  
    $subprocess->deserialize(sub {
      my $bytes = shift;
      return [];
    });
  
  =head2 ioloop
  
    my $loop    = $subprocess->ioloop;
    $subprocess = $subprocess->ioloop(Mojo::IOLoop->new);
  
  Event loop object to control, defaults to the global L<Mojo::IOLoop> singleton.
  
  =head2 serialize
  
    my $cb      = $subprocess->serialize;
    $subprocess = $subprocess->serialize(sub {...});
  
  A callback used to serialize subprocess return values, defaults to using
  L<Storable>.
  
    $subprocess->serialize(sub {
      my $array = shift;
      return '';
    });
  
  =head1 METHODS
  
  L<Mojo::IOLoop::Subprocess> inherits all methods from L<Mojo::Base> and
  implements the following new ones.
  
  =head2 pid
  
    my $pid = $subprocess->pid;
  
  Process id of the spawned subprocess if available.
  
  =head2 run
  
    $subprocess = $subprocess->run(sub {...}, sub {...});
  
  Execute the first callback in a child process and wait for it to return one or
  more values, without blocking L</"ioloop"> in the parent process. Then execute
  the second callback in the parent process with the results. The return values of
  the first callback and exceptions thrown by it, will be serialized with
  L<Storable>, so they can be shared between processes.
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<http://mojolicious.org>.
  
  =cut
MOJO_IOLOOP_SUBPROCESS

$fatpacked{"Mojo/IOLoop/TLS.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJO_IOLOOP_TLS';
  package Mojo::IOLoop::TLS;
  use Mojo::Base 'Mojo::EventEmitter';
  
  use Mojo::File 'path';
  use Mojo::IOLoop;
  use Scalar::Util 'weaken';
  
  # TLS support requires IO::Socket::SSL
  use constant TLS => $ENV{MOJO_NO_TLS}
    ? 0
    : eval 'use IO::Socket::SSL 1.94 (); 1';
  use constant READ  => TLS ? IO::Socket::SSL::SSL_WANT_READ()  : 0;
  use constant WRITE => TLS ? IO::Socket::SSL::SSL_WANT_WRITE() : 0;
  
  has reactor => sub { Mojo::IOLoop->singleton->reactor };
  
  # To regenerate the certificate run this command (18.04.2012)
  # openssl req -new -x509 -keyout server.key -out server.crt -nodes -days 7300
  my $CERT = path(__FILE__)->sibling('resources', 'server.crt')->to_string;
  my $KEY  = path(__FILE__)->sibling('resources', 'server.key')->to_string;
  
  sub DESTROY { shift->_cleanup }
  
  sub can_tls {TLS}
  
  sub negotiate {
    my ($self, $args) = (shift, ref $_[0] ? $_[0] : {@_});
  
    return $self->emit(error => 'IO::Socket::SSL 1.94+ required for TLS support')
      unless TLS;
  
    my $handle = $self->{handle};
    return $self->emit(error => $IO::Socket::SSL::SSL_ERROR)
      unless IO::Socket::SSL->start_SSL($handle, %{$self->_expand($args)});
    $self->reactor->io($handle
        = $handle => sub { $self->_tls($handle, $args->{server}) });
  }
  
  sub new { shift->SUPER::new(handle => shift) }
  
  sub _cleanup {
    my $self = shift;
    return unless my $reactor = $self->reactor;
    $reactor->remove($self->{handle}) if $self->{handle};
    return $self;
  }
  
  sub _expand {
    my ($self, $args) = @_;
  
    weaken $self;
    my $tls = {
      SSL_ca_file => $args->{tls_ca}
        && -T $args->{tls_ca} ? $args->{tls_ca} : undef,
      SSL_error_trap         => sub { $self->_cleanup->emit(error => $_[1]) },
      SSL_honor_cipher_order => 1,
      SSL_startHandshake     => 0
    };
    $tls->{SSL_cert_file}   = $args->{tls_cert}    if $args->{tls_cert};
    $tls->{SSL_cipher_list} = $args->{tls_ciphers} if $args->{tls_ciphers};
    $tls->{SSL_key_file}    = $args->{tls_key}     if $args->{tls_key};
    $tls->{SSL_server}      = $args->{server}      if $args->{server};
    $tls->{SSL_verify_mode} = $args->{tls_verify}  if exists $args->{tls_verify};
    $tls->{SSL_version}     = $args->{tls_version} if $args->{tls_version};
  
    if ($args->{server}) {
      $tls->{SSL_cert_file} ||= $CERT;
      $tls->{SSL_key_file}  ||= $KEY;
      $tls->{SSL_verify_mode} //= $args->{tls_ca} ? 0x03 : 0x00;
    }
    else {
      $tls->{SSL_hostname}
        = IO::Socket::SSL->can_client_sni ? $args->{address} : '';
      $tls->{SSL_verifycn_scheme} = $args->{tls_ca} ? 'http' : undef;
      $tls->{SSL_verify_mode} //= $args->{tls_ca} ? 0x01 : 0x00;
      $tls->{SSL_verifycn_name} = $args->{address};
    }
  
    return $tls;
  }
  
  sub _tls {
    my ($self, $handle, $server) = @_;
  
    return $self->emit(upgrade => delete $self->{handle})
      if $server ? $handle->accept_SSL : $handle->connect_SSL;
  
    # Switch between reading and writing
    my $err = $IO::Socket::SSL::SSL_ERROR;
    if    ($err == READ)  { $self->reactor->watch($handle, 1, 0) }
    elsif ($err == WRITE) { $self->reactor->watch($handle, 1, 1) }
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojo::IOLoop::TLS - Non-blocking TLS handshake
  
  =head1 SYNOPSIS
  
    use Mojo::IOLoop::TLS;
  
    # Negotiate TLS
    my $tls = Mojo::IOLoop::TLS->new($old_handle);
    $tls->on(upgrade => sub {
      my ($tls, $new_handle) = @_;
      ...
    });
    $tls->on(error => sub {
      my ($tls, $err) = @_;
      ...
    });
    $tls->negotiate(server => 1, tls_version => 'TLSv1_2');
  
    # Start reactor if necessary
    $tls->reactor->start unless $tls->reactor->is_running;
  
  =head1 DESCRIPTION
  
  L<Mojo::IOLoop::TLS> negotiates TLS for L<Mojo::IOLoop>.
  
  =head1 EVENTS
  
  L<Mojo::IOLoop::TLS> inherits all events from L<Mojo::EventEmitter> and can
  emit the following new ones.
  
  =head2 upgrade
  
    $tls->on(upgrade => sub {
      my ($tls, $handle) = @_;
      ...
    });
  
  Emitted once TLS has been negotiated.
  
  =head2 error
  
    $tls->on(error => sub {
      my ($tls, $err) = @_;
      ...
    });
  
  Emitted if an error occurs during negotiation, fatal if unhandled.
  
  =head1 ATTRIBUTES
  
  L<Mojo::IOLoop::TLS> implements the following attributes.
  
  =head2 reactor
  
    my $reactor = $tls->reactor;
    $tls        = $tls->reactor(Mojo::Reactor::Poll->new);
  
  Low-level event reactor, defaults to the C<reactor> attribute value of the
  global L<Mojo::IOLoop> singleton.
  
  =head1 METHODS
  
  L<Mojo::IOLoop::TLS> inherits all methods from L<Mojo::EventEmitter> and
  implements the following new ones.
  
  =head2 can_tls
  
    my $bool = Mojo::IOLoop::TLS->can_tls;
  
  True if L<IO::Socket::SSL> 1.94+ is installed and TLS support enabled.
  
  =head2 negotiate
  
    $tls->negotiate(server => 1, tls_version => 'TLSv1_2');
    $tls->negotiate({server => 1, tls_version => 'TLSv1_2'});
  
  Negotiate TLS.
  
  These options are currently available:
  
  =over 2
  
  =item server
  
    server => 1
  
  Negotiate TLS from the server-side, defaults to the client-side.
  
  =item tls_ca
  
    tls_ca => '/etc/tls/ca.crt'
  
  Path to TLS certificate authority file. Also activates hostname verification on
  the client-side.
  
  =item tls_cert
  
    tls_cert => '/etc/tls/server.crt'
    tls_cert => {'mojolicious.org' => '/etc/tls/mojo.crt'}
  
  Path to the TLS cert file, defaults to a built-in test certificate on the
  server-side.
  
  =item tls_ciphers
  
    tls_ciphers => 'AES128-GCM-SHA256:RC4:HIGH:!MD5:!aNULL:!EDH'
  
  TLS cipher specification string. For more information about the format see
  L<https://www.openssl.org/docs/manmaster/apps/ciphers.html#CIPHER-STRINGS>.
  
  =item tls_key
  
    tls_key => '/etc/tls/server.key'
    tls_key => {'mojolicious.org' => '/etc/tls/mojo.key'}
  
  Path to the TLS key file, defaults to a built-in test key on the server-side.
  
  =item tls_verify
  
    tls_verify => 0x00
  
  TLS verification mode, defaults to C<0x03> on the server-side and C<0x01> on the
  client-side if a certificate authority file has been provided, or C<0x00>.
  
  =item tls_version
  
    tls_version => 'TLSv1_2'
  
  TLS protocol version.
  
  =back
  
  =head2 new
  
    my $tls = Mojo::IOLoop::TLS->new($handle);
  
  Construct a new L<Mojo::IOLoop::Stream> object.
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<http://mojolicious.org>.
  
  =cut
MOJO_IOLOOP_TLS

$fatpacked{"Mojo/JSON.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJO_JSON';
  package Mojo::JSON;
  use Mojo::Base -strict;
  
  use Carp 'croak';
  use Exporter 'import';
  use JSON::PP ();
  use Mojo::Util;
  use Scalar::Util 'blessed';
  
  our @EXPORT_OK = qw(decode_json encode_json false from_json j to_json true);
  
  # Escaped special character map (with u2028 and u2029)
  my %ESCAPE = (
    '"'     => '"',
    '\\'    => '\\',
    '/'     => '/',
    'b'     => "\x08",
    'f'     => "\x0c",
    'n'     => "\x0a",
    'r'     => "\x0d",
    't'     => "\x09",
    'u2028' => "\x{2028}",
    'u2029' => "\x{2029}"
  );
  my %REVERSE = map { $ESCAPE{$_} => "\\$_" } keys %ESCAPE;
  for (0x00 .. 0x1f) { $REVERSE{pack 'C', $_} //= sprintf '\u%.4X', $_ }
  
  sub decode_json {
    my $err = _decode(\my $value, shift);
    return defined $err ? croak $err : $value;
  }
  
  sub encode_json { Mojo::Util::encode 'UTF-8', _encode_value(shift) }
  
  sub false () {JSON::PP::false}
  
  sub from_json {
    my $err = _decode(\my $value, shift, 1);
    return defined $err ? croak $err : $value;
  }
  
  sub j {
    return encode_json($_[0]) if ref $_[0] eq 'ARRAY' || ref $_[0] eq 'HASH';
    return eval { decode_json($_[0]) };
  }
  
  sub to_json { _encode_value(shift) }
  
  sub true () {JSON::PP::true}
  
  sub _decode {
    my $valueref = shift;
  
    eval {
  
      # Missing input
      die "Missing or empty input\n" unless length(local $_ = shift);
  
      # UTF-8
      $_ = Mojo::Util::decode 'UTF-8', $_ unless shift;
      die "Input is not UTF-8 encoded\n" unless defined;
  
      # Value
      $$valueref = _decode_value();
  
      # Leftover data
      /\G[\x20\x09\x0a\x0d]*\z/gc or _throw('Unexpected data');
    } ? return undef : chomp $@;
  
    return $@;
  }
  
  sub _decode_array {
    my @array;
    until (m/\G[\x20\x09\x0a\x0d]*\]/gc) {
  
      # Value
      push @array, _decode_value();
  
      # Separator
      redo if /\G[\x20\x09\x0a\x0d]*,/gc;
  
      # End
      last if /\G[\x20\x09\x0a\x0d]*\]/gc;
  
      # Invalid character
      _throw('Expected comma or right square bracket while parsing array');
    }
  
    return \@array;
  }
  
  sub _decode_object {
    my %hash;
    until (m/\G[\x20\x09\x0a\x0d]*\}/gc) {
  
      # Quote
      /\G[\x20\x09\x0a\x0d]*"/gc
        or _throw('Expected string while parsing object');
  
      # Key
      my $key = _decode_string();
  
      # Colon
      /\G[\x20\x09\x0a\x0d]*:/gc or _throw('Expected colon while parsing object');
  
      # Value
      $hash{$key} = _decode_value();
  
      # Separator
      redo if /\G[\x20\x09\x0a\x0d]*,/gc;
  
      # End
      last if /\G[\x20\x09\x0a\x0d]*\}/gc;
  
      # Invalid character
      _throw('Expected comma or right curly bracket while parsing object');
    }
  
    return \%hash;
  }
  
  sub _decode_string {
    my $pos = pos;
  
    # Extract string with escaped characters
    m!\G((?:(?:[^\x00-\x1f\\"]|\\(?:["\\/bfnrt]|u[0-9a-fA-F]{4})){0,32766})*)!gc;
    my $str = $1;
  
    # Invalid character
    unless (m/\G"/gc) {
      _throw('Unexpected character or invalid escape while parsing string')
        if /\G[\x00-\x1f\\]/;
      _throw('Unterminated string');
    }
  
    # Unescape popular characters
    if (index($str, '\\u') < 0) {
      $str =~ s!\\(["\\/bfnrt])!$ESCAPE{$1}!gs;
      return $str;
    }
  
    # Unescape everything else
    my $buffer = '';
    while ($str =~ /\G([^\\]*)\\(?:([^u])|u(.{4}))/gc) {
      $buffer .= $1;
  
      # Popular character
      if ($2) { $buffer .= $ESCAPE{$2} }
  
      # Escaped
      else {
        my $ord = hex $3;
  
        # Surrogate pair
        if (($ord & 0xf800) == 0xd800) {
  
          # High surrogate
          ($ord & 0xfc00) == 0xd800
            or pos = $pos + pos($str), _throw('Missing high-surrogate');
  
          # Low surrogate
          $str =~ /\G\\u([Dd][C-Fc-f]..)/gc
            or pos = $pos + pos($str), _throw('Missing low-surrogate');
  
          $ord = 0x10000 + ($ord - 0xd800) * 0x400 + (hex($1) - 0xdc00);
        }
  
        # Character
        $buffer .= pack 'U', $ord;
      }
    }
  
    # The rest
    return $buffer . substr $str, pos($str), length($str);
  }
  
  sub _decode_value {
  
    # Leading whitespace
    /\G[\x20\x09\x0a\x0d]*/gc;
  
    # String
    return _decode_string() if /\G"/gc;
  
    # Object
    return _decode_object() if /\G\{/gc;
  
    # Array
    return _decode_array() if /\G\[/gc;
  
    # Number
    return 0 + $1
      if /\G([-]?(?:0|[1-9][0-9]*)(?:\.[0-9]*)?(?:[eE][+-]?[0-9]+)?)/gc;
  
    # True
    return true() if /\Gtrue/gc;
  
    # False
    return false() if /\Gfalse/gc;
  
    # Null
    return undef if /\Gnull/gc;
  
    # Invalid character
    _throw('Expected string, array, object, number, boolean or null');
  }
  
  sub _encode_array {
    '[' . join(',', map { _encode_value($_) } @{$_[0]}) . ']';
  }
  
  sub _encode_object {
    my $object = shift;
    my @pairs = map { _encode_string($_) . ':' . _encode_value($object->{$_}) }
      sort keys %$object;
    return '{' . join(',', @pairs) . '}';
  }
  
  sub _encode_string {
    my $str = shift;
    $str =~ s!([\x00-\x1f\x{2028}\x{2029}\\"/])!$REVERSE{$1}!gs;
    return "\"$str\"";
  }
  
  sub _encode_value {
    my $value = shift;
  
    # Reference
    if (my $ref = ref $value) {
  
      # Object
      return _encode_object($value) if $ref eq 'HASH';
  
      # Array
      return _encode_array($value) if $ref eq 'ARRAY';
  
      # True or false
      return $$value ? 'true' : 'false' if $ref eq 'SCALAR';
      return $value  ? 'true' : 'false' if $ref eq 'JSON::PP::Boolean';
  
      # Everything else
      return _encode_string($value)
        unless blessed $value && (my $sub = $value->can('TO_JSON'));
      return _encode_value($value->$sub);
    }
  
    # Null
    return 'null' unless defined $value;
  
    # Number
    no warnings 'numeric';
    return $value
      if length((my $dummy = '') & $value)
      && 0 + $value eq $value
      && $value * 0 == 0;
  
    # String
    return _encode_string($value);
  }
  
  sub _throw {
  
    # Leading whitespace
    /\G[\x20\x09\x0a\x0d]*/gc;
  
    # Context
    my $context = 'Malformed JSON: ' . shift;
    if (m/\G\z/gc) { $context .= ' before end of data' }
    else {
      my @lines = split "\n", substr($_, 0, pos);
      $context .= ' at line ' . @lines . ', offset ' . length(pop @lines || '');
    }
  
    die "$context\n";
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojo::JSON - Minimalistic JSON
  
  =head1 SYNOPSIS
  
    use Mojo::JSON qw(decode_json encode_json);
  
    my $bytes = encode_json {foo => [1, 2], bar => 'hello!', baz => \1};
    my $hash  = decode_json $bytes;
  
  =head1 DESCRIPTION
  
  L<Mojo::JSON> is a minimalistic and possibly the fastest pure-Perl
  implementation of L<RFC 7159|http://tools.ietf.org/html/rfc7159>.
  
  It supports normal Perl data types like scalar, array reference, hash reference
  and will try to call the C<TO_JSON> method on blessed references, or stringify
  them if it doesn't exist. Differentiating between strings and numbers in Perl
  is hard, depending on how it has been used, a scalar can be both at the same
  time. The string value has a higher precedence unless both representations are
  equivalent.
  
    [1, -2, 3]     -> [1, -2, 3]
    {"foo": "bar"} -> {foo => 'bar'}
  
  Literal names will be translated to and from L<Mojo::JSON> constants or a
  similar native Perl value.
  
    true  -> Mojo::JSON->true
    false -> Mojo::JSON->false
    null  -> undef
  
  In addition scalar references will be used to generate booleans, based on if
  their values are true or false.
  
    \1 -> true
    \0 -> false
  
  The two Unicode whitespace characters C<u2028> and C<u2029> will always be
  escaped to make JSONP easier, and the character C</> to prevent XSS attacks.
  
    "\x{2028}\x{2029}</script>" -> "\u2028\u2029<\/script>"
  
  =head1 FUNCTIONS
  
  L<Mojo::JSON> implements the following functions, which can be imported
  individually.
  
  =head2 decode_json
  
    my $value = decode_json $bytes;
  
  Decode JSON to Perl value and die if decoding fails.
  
  =head2 encode_json
  
    my $bytes = encode_json {i => ' mojolicious'};
  
  Encode Perl value to JSON.
  
  =head2 false
  
    my $false = false;
  
  False value, used because Perl has no native equivalent.
  
  =head2 from_json
  
    my $value = from_json $chars;
  
  Decode JSON text that is not C<UTF-8> encoded to Perl value and die if decoding
  fails.
  
  =head2 j
  
    my $bytes = j [1, 2, 3];
    my $bytes = j {i => ' mojolicious'};
    my $value = j $bytes;
  
  Encode Perl data structure (which may only be an array reference or hash
  reference) or decode JSON, an C<undef> return value indicates a bare C<null> or
  that decoding failed.
  
  =head2 to_json
  
    my $chars = to_json {i => ' mojolicious'};
  
  Encode Perl value to JSON text without C<UTF-8> encoding it.
  
  =head2 true
  
    my $true = true;
  
  True value, used because Perl has no native equivalent.
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<http://mojolicious.org>.
  
  =cut
MOJO_JSON

$fatpacked{"Mojo/JSON/Pointer.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJO_JSON_POINTER';
  package Mojo::JSON::Pointer;
  use Mojo::Base -base;
  
  has 'data';
  
  sub contains { shift->_pointer(1, @_) }
  sub get      { shift->_pointer(0, @_) }
  
  sub new { @_ > 1 ? shift->SUPER::new(data => shift) : shift->SUPER::new }
  
  sub _pointer {
    my ($self, $contains, $pointer) = @_;
  
    my $data = $self->data;
    return $contains ? 1 : $data unless $pointer =~ s!^/!!;
    for my $p (length $pointer ? (split '/', $pointer, -1) : ($pointer)) {
      $p =~ s!~1!/!g;
      $p =~ s/~0/~/g;
  
      # Hash
      if (ref $data eq 'HASH' && exists $data->{$p}) { $data = $data->{$p} }
  
      # Array
      elsif (ref $data eq 'ARRAY' && $p =~ /^\d+$/ && @$data > $p) {
        $data = $data->[$p];
      }
  
      # Nothing
      else { return undef }
    }
  
    return $contains ? 1 : $data;
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojo::JSON::Pointer - JSON Pointers
  
  =head1 SYNOPSIS
  
    use Mojo::JSON::Pointer;
  
    my $pointer = Mojo::JSON::Pointer->new({foo => [23, 'bar']});
    say $pointer->get('/foo/1');
    say 'Contains "/foo".' if $pointer->contains('/foo');
  
  =head1 DESCRIPTION
  
  L<Mojo::JSON::Pointer> is an implementation of
  L<RFC 6901|http://tools.ietf.org/html/rfc6901>.
  
  =head1 ATTRIBUTES
  
  L<Mojo::JSON::Pointer> implements the following attributes.
  
  =head2 data
  
    my $data = $pointer->data;
    $pointer = $pointer->data({foo => 'bar'});
  
  Data structure to be processed.
  
  =head1 METHODS
  
  L<Mojo::JSON::Pointer> inherits all methods from L<Mojo::Base> and implements
  the following new ones.
  
  =head2 contains
  
    my $bool = $pointer->contains('/foo/1');
  
  Check if L</"data"> contains a value that can be identified with the given JSON
  Pointer.
  
    # True
    Mojo::JSON::Pointer->new('just a string')->contains('');
    Mojo::JSON::Pointer->new({'' => 'mojolicious'})->contains('/');
    Mojo::JSON::Pointer->new({foo => 'bar', baz => [4, 5]})->contains('/foo');
    Mojo::JSON::Pointer->new({foo => 'bar', baz => [4, 5]})->contains('/baz/1');
  
    # False
    Mojo::JSON::Pointer->new({'' => 'mojolicious'})->contains('/');
    Mojo::JSON::Pointer->new({foo => 'bar', baz => [4, 5]})->contains('/bar');
    Mojo::JSON::Pointer->new({foo => 'bar', baz => [4, 5]})->contains('/baz/9');
  
  =head2 get
  
    my $value = $pointer->get('/foo/bar');
  
  Extract value from L</"data"> identified by the given JSON Pointer.
  
    # "just a string"
    Mojo::JSON::Pointer->new('just a string')->get('');
  
    # "mojolicious"
    Mojo::JSON::Pointer->new({'' => 'mojolicious'})->get('/');
  
    # "bar"
    Mojo::JSON::Pointer->new({foo => 'bar', baz => [4, 5, 6]})->get('/foo');
  
    # "4"
    Mojo::JSON::Pointer->new({foo => 'bar', baz => [4, 5, 6]})->get('/baz/0');
  
    # "6"
    Mojo::JSON::Pointer->new({foo => 'bar', baz => [4, 5, 6]})->get('/baz/2');
  
  =head2 new
  
    my $pointer = Mojo::JSON::Pointer->new;
    my $pointer = Mojo::JSON::Pointer->new({foo => 'bar'});
  
  Build new L<Mojo::JSON::Pointer> object.
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<http://mojolicious.org>.
  
  =cut
MOJO_JSON_POINTER

$fatpacked{"Mojo/Loader.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJO_LOADER';
  package Mojo::Loader;
  use Mojo::Base -strict;
  
  use Exporter 'import';
  use Mojo::Exception;
  use Mojo::File 'path';
  use Mojo::Util qw(b64_decode class_to_path);
  
  our @EXPORT_OK
    = qw(data_section file_is_binary find_modules find_packages load_class);
  
  my (%BIN, %CACHE);
  
  sub data_section { $_[0] ? $_[1] ? _all($_[0])->{$_[1]} : _all($_[0]) : undef }
  
  sub file_is_binary { keys %{_all($_[0])} ? !!$BIN{$_[0]}{$_[1]} : undef }
  
  sub find_modules {
    my $ns = shift;
  
    my %modules;
    for my $directory (@INC) {
      next unless -d (my $path = path($directory, split(/::|'/, $ns)));
      $modules{"${ns}::$_"}++
        for $path->list->grep(qr/\.pm$/)->map('basename', '.pm')->each;
    }
  
    return sort keys %modules;
  }
  
  sub find_packages {
    my $ns = shift;
    no strict 'refs';
    return sort map { /^(.+)::$/ ? "${ns}::$1" : () } keys %{"${ns}::"};
  }
  
  sub load_class {
    my $class = shift;
  
    # Invalid class name
    return 1 if ($class || '') !~ /^\w(?:[\w:']*\w)?$/;
  
    # Already loaded
    return undef if $class->can('new');
  
    # Success
    eval "require $class; 1" ? return undef : Mojo::Util::_teardown($class);
  
    # Does not exist
    return 1 if $@ =~ /^Can't locate \Q@{[class_to_path $class]}\E in \@INC/;
  
    # Real error
    return Mojo::Exception->new($@)->inspect;
  }
  
  sub _all {
    my $class = shift;
  
    return $CACHE{$class} if $CACHE{$class};
    local $.;
    my $handle = do { no strict 'refs'; \*{"${class}::DATA"} };
    return {} unless fileno $handle;
    seek $handle, 0, 0;
    my $data = join '', <$handle>;
  
    # Ignore everything before __DATA__ (some versions seek to start of file)
    $data =~ s/^.*\n__DATA__\r?\n/\n/s;
  
    # Ignore everything after __END__
    $data =~ s/\n__END__\r?\n.*$/\n/s;
  
    # Split files
    (undef, my @files) = split /^@@\s*(.+?)\s*\r?\n/m, $data;
  
    # Find data
    my $all = $CACHE{$class} = {};
    while (@files) {
      my ($name, $data) = splice @files, 0, 2;
      $all->{$name} = $name =~ s/\s*\(\s*base64\s*\)$//
        && ++$BIN{$class}{$name} ? b64_decode $data : $data;
    }
  
    return $all;
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojo::Loader - Load all kinds of things
  
  =head1 SYNOPSIS
  
    use Mojo::Loader qw(data_section find_modules load_class);
  
    # Find modules in a namespace
    for my $module (find_modules 'Some::Namespace') {
  
      # Load them safely
      my $e = load_class $module;
      warn qq{Loading "$module" failed: $e} and next if ref $e;
  
      # And extract files from the DATA section
      say data_section($module, 'some_file.txt');
    }
  
  =head1 DESCRIPTION
  
  L<Mojo::Loader> is a class loader and plugin framework. Aside from finding
  modules and loading classes, it allows multiple files to be stored in the
  C<DATA> section of a class, which can then be accessed individually.
  
    package Foo;
  
    1;
    __DATA__
  
    @@ test.txt
    This is the first file.
  
    @@ test2.html (base64)
    VGhpcyBpcyB0aGUgc2Vjb25kIGZpbGUu
  
    @@ test
    This is the
    third file.
  
  Each file has a header starting with C<@@>, followed by the file name and
  optional instructions for decoding its content. Currently only the Base64
  encoding is supported, which can be quite convenient for the storage of binary
  data.
  
  =head1 FUNCTIONS
  
  L<Mojo::Loader> implements the following functions, which can be imported
  individually.
  
  =head2 data_section
  
    my $all   = data_section 'Foo::Bar';
    my $index = data_section 'Foo::Bar', 'index.html';
  
  Extract embedded file from the C<DATA> section of a class, all files will be
  cached once they have been accessed for the first time.
  
    # List embedded files
    say for keys %{data_section 'Foo::Bar'};
  
  =head2 file_is_binary
  
    my $bool = file_is_binary 'Foo::Bar', 'test.png';
  
  Check if embedded file from the C<DATA> section of a class was Base64 encoded.
  
  =head2 find_packages
  
    my @pkgs = find_packages 'MyApp::Namespace';
  
  Search for packages in a namespace non-recursively.
  
  =head2 find_modules
  
    my @modules = find_modules 'MyApp::Namespace';
  
  Search for modules in a namespace non-recursively.
  
  =head2 load_class
  
    my $e = load_class 'Foo::Bar';
  
  Load a class and catch exceptions, returns a false value if loading was
  successful, a true value if the class was not found, or a L<Mojo::Exception>
  object if loading failed. Note that classes are checked for a C<new> method to
  see if they are already loaded.
  
    # Handle exceptions
    if (my $e = load_class 'Foo::Bar') {
      die ref $e ? "Exception: $e" : 'Not found!';
    }
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<http://mojolicious.org>.
  
  =cut
MOJO_LOADER

$fatpacked{"Mojo/Log.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJO_LOG';
  package Mojo::Log;
  use Mojo::Base 'Mojo::EventEmitter';
  
  use Carp 'croak';
  use Fcntl ':flock';
  use Mojo::File;
  use Mojo::Util 'encode';
  
  has format => sub { \&_format };
  has handle => sub {
  
    # STDERR
    return \*STDERR unless my $path = shift->path;
  
    # File
    return Mojo::File->new($path)->open('>>');
  };
  has history => sub { [] };
  has level => 'debug';
  has max_history_size => 10;
  has 'path';
  
  # Supported log levels
  my %LEVEL = (debug => 1, info => 2, warn => 3, error => 4, fatal => 5);
  
  sub append {
    my ($self, $msg) = @_;
  
    return unless my $handle = $self->handle;
    flock $handle, LOCK_EX;
    $handle->print(encode('UTF-8', $msg)) or croak "Can't write to log: $!";
    flock $handle, LOCK_UN;
  }
  
  sub debug { shift->_log(debug => @_) }
  sub error { shift->_log(error => @_) }
  sub fatal { shift->_log(fatal => @_) }
  sub info  { shift->_log(info  => @_) }
  
  sub is_level { $LEVEL{pop()} >= $LEVEL{$ENV{MOJO_LOG_LEVEL} || shift->level} }
  
  sub new {
    my $self = shift->SUPER::new(@_);
    $self->on(message => \&_message);
    return $self;
  }
  
  sub warn { shift->_log(warn => @_) }
  
  sub _format {
    '[' . localtime(shift) . '] [' . shift() . '] ' . join "\n", @_, '';
  }
  
  sub _log { shift->emit('message', shift, @_) }
  
  sub _message {
    my ($self, $level) = (shift, shift);
  
    return unless $self->is_level($level);
  
    my $max     = $self->max_history_size;
    my $history = $self->history;
    push @$history, my $msg = [time, $level, @_];
    shift @$history while @$history > $max;
  
    $self->append($self->format->(@$msg));
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojo::Log - Simple logger
  
  =head1 SYNOPSIS
  
    use Mojo::Log;
  
    # Log to STDERR
    my $log = Mojo::Log->new;
  
    # Customize log file location and minimum log level
    my $log = Mojo::Log->new(path => '/var/log/mojo.log', level => 'warn');
  
    # Log messages
    $log->debug('Not sure what is happening here');
    $log->info('FYI: it happened again');
    $log->warn('This might be a problem');
    $log->error('Garden variety error');
    $log->fatal('Boom');
  
  =head1 DESCRIPTION
  
  L<Mojo::Log> is a simple logger for L<Mojo> projects.
  
  =head1 EVENTS
  
  L<Mojo::Log> inherits all events from L<Mojo::EventEmitter> and can emit the
  following new ones.
  
  =head2 message
  
    $log->on(message => sub {
      my ($log, $level, @lines) = @_;
      ...
    });
  
  Emitted when a new message gets logged.
  
    $log->unsubscribe('message')->on(message => sub {
      my ($log, $level, @lines) = @_;
      say "$level: ", @lines;
    });
  
  =head1 ATTRIBUTES
  
  L<Mojo::Log> implements the following attributes.
  
  =head2 format
  
    my $cb = $log->format;
    $log   = $log->format(sub {...});
  
  A callback for formatting log messages.
  
    $log->format(sub {
      my ($time, $level, @lines) = @_;
      return "[Thu May 15 17:47:04 2014] [info] I  Mojolicious\n";
    });
  
  =head2 handle
  
    my $handle = $log->handle;
    $log       = $log->handle(IO::Handle->new);
  
  Log filehandle used by default L</"message"> event, defaults to opening
  L</"path"> or C<STDERR>.
  
  =head2 history
  
    my $history = $log->history;
    $log        = $log->history([[time, 'debug', 'That went wrong']]);
  
  The last few logged messages.
  
  =head2 level
  
    my $level = $log->level;
    $log      = $log->level('debug');
  
  Active log level, defaults to C<debug>. Available log levels are C<debug>,
  C<info>, C<warn>, C<error> and C<fatal>, in that order. Note that the
  C<MOJO_LOG_LEVEL> environment variable can override this value.
  
  =head2 max_history_size
  
    my $size = $log->max_history_size;
    $log     = $log->max_history_size(5);
  
  Maximum number of logged messages to store in L</"history">, defaults to C<10>.
  
  =head2 path
  
    my $path = $log->path
    $log     = $log->path('/var/log/mojo.log');
  
  Log file path used by L</"handle">.
  
  =head1 METHODS
  
  L<Mojo::Log> inherits all methods from L<Mojo::EventEmitter> and implements the
  following new ones.
  
  =head2 append
  
    $log->append("[Thu May 15 17:47:04 2014] [info] I  Mojolicious\n");
  
  Append message to L</"handle">.
  
  =head2 debug
  
    $log = $log->debug('You screwed up, but that is ok');
    $log = $log->debug('All', 'cool');
  
  Emit L</"message"> event and log C<debug> message.
  
  =head2 error
  
    $log = $log->error('You really screwed up this time');
    $log = $log->error('Wow', 'seriously');
  
  Emit L</"message"> event and log C<error> message.
  
  =head2 fatal
  
    $log = $log->fatal('Its over...');
    $log = $log->fatal('Bye', 'bye');
  
  Emit L</"message"> event and log C<fatal> message.
  
  =head2 info
  
    $log = $log->info('You are bad, but you prolly know already');
    $log = $log->info('Ok', 'then');
  
  Emit L</"message"> event and log C<info> message.
  
  =head2 is_level
  
    my $bool = $log->is_level('debug');
  
  Check active log L</"level">.
  
    # True
    $log->level('debug')->is_level('debug');
    $log->level('debug')->is_level('info');
  
    # False
    $log->level('info')->is_level('debug');
    $log->level('fatal')->is_level('warn');
  
  =head2 new
  
    my $log = Mojo::Log->new;
  
  Construct a new L<Mojo::Log> object and subscribe to L</"message"> event with
  default logger.
  
  =head2 warn
  
    $log = $log->warn('Dont do that Dave...');
    $log = $log->warn('No', 'really');
  
  Emit L</"message"> event and log C<warn> message.
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<http://mojolicious.org>.
  
  =cut
MOJO_LOG

$fatpacked{"Mojo/Message.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJO_MESSAGE';
  package Mojo::Message;
  use Mojo::Base 'Mojo::EventEmitter';
  
  use Carp 'croak';
  use Mojo::Asset::Memory;
  use Mojo::Content::Single;
  use Mojo::DOM;
  use Mojo::JSON 'j';
  use Mojo::JSON::Pointer;
  use Mojo::Parameters;
  use Mojo::Upload;
  use Mojo::Util 'decode';
  
  has content => sub { Mojo::Content::Single->new };
  has default_charset  => 'UTF-8';
  has max_line_size    => sub { $ENV{MOJO_MAX_LINE_SIZE} || 8192 };
  has max_message_size => sub { $ENV{MOJO_MAX_MESSAGE_SIZE} // 16777216 };
  has version          => '1.1';
  
  sub body {
    my $self = shift;
  
    # Get
    my $content = $self->content;
    return $content->is_multipart ? '' : $content->asset->slurp unless @_;
  
    # Set (multipart content needs to be downgraded)
    $content = $self->content(Mojo::Content::Single->new)->content
      if $content->is_multipart;
    $content->asset(Mojo::Asset::Memory->new->add_chunk(@_));
  
    return $self;
  }
  
  sub body_params {
    my $self = shift;
  
    return $self->{body_params} if $self->{body_params};
    my $params = $self->{body_params} = Mojo::Parameters->new;
    $params->charset($self->content->charset || $self->default_charset);
  
    # "application/x-www-form-urlencoded"
    my $type = $self->headers->content_type // '';
    if ($type =~ m!application/x-www-form-urlencoded!i) {
      $params->parse($self->content->asset->slurp);
    }
  
    # "multipart/form-data"
    elsif ($type =~ m!multipart/form-data!i) {
      $params->append(@$_[0, 1]) for @{$self->_parse_formdata};
    }
  
    return $params;
  }
  
  sub body_size { shift->content->body_size }
  
  sub build_body       { shift->_build('get_body_chunk') }
  sub build_headers    { shift->_build('get_header_chunk') }
  sub build_start_line { shift->_build('get_start_line_chunk') }
  
  sub cookie { shift->_cache('cookies', 0, @_) }
  
  sub cookies { croak 'Method "cookies" not implemented by subclass' }
  
  sub dom {
    my $self = shift;
    return undef if $self->content->is_multipart;
    my $dom = $self->{dom} ||= Mojo::DOM->new($self->text);
    return @_ ? $dom->find(@_) : $dom;
  }
  
  sub error {
    my $self = shift;
    return $self->{error} unless @_;
    $self->{error} = shift;
    return $self->finish;
  }
  
  sub every_cookie { shift->_cache('cookies', 1, @_) }
  sub every_upload { shift->_cache('uploads', 1, @_) }
  
  sub extract_start_line {
    croak 'Method "extract_start_line" not implemented by subclass';
  }
  
  sub finish {
    my $self = shift;
    $self->{state} = 'finished';
    return $self->{finished}++ ? $self : $self->emit('finish');
  }
  
  sub fix_headers {
    my $self = shift;
    return $self if $self->{fix}++;
  
    # Content-Length or Connection (unless chunked transfer encoding is used)
    my $content = $self->content;
    my $headers = $content->headers;
    if ($content->is_multipart) { $headers->remove('Content-Length') }
    elsif ($content->is_chunked || $headers->content_length) { return $self }
    if   ($content->is_dynamic) { $headers->connection('close') }
    else                        { $headers->content_length($self->body_size) }
  
    return $self;
  }
  
  sub get_body_chunk {
    my ($self, $offset) = @_;
  
    $self->emit('progress', 'body', $offset);
    my $chunk = $self->content->get_body_chunk($offset);
    return $chunk if !defined $chunk || length $chunk;
    $self->finish;
  
    return $chunk;
  }
  
  sub get_header_chunk {
    my ($self, $offset) = @_;
    $self->emit('progress', 'headers', $offset);
    return $self->fix_headers->content->get_header_chunk($offset);
  }
  
  sub get_start_line_chunk {
    croak 'Method "get_start_line_chunk" not implemented by subclass';
  }
  
  sub header_size { shift->fix_headers->content->header_size }
  
  sub headers { shift->content->headers }
  
  sub is_finished { (shift->{state} // '') eq 'finished' }
  
  sub is_limit_exceeded { !!shift->{limit} }
  
  sub json {
    my ($self, $pointer) = @_;
    return undef if $self->content->is_multipart;
    my $data = $self->{json} //= j($self->body);
    return $pointer ? Mojo::JSON::Pointer->new($data)->get($pointer) : $data;
  }
  
  sub parse {
    my ($self, $chunk) = @_;
  
    return $self if $self->{error};
    $self->{raw_size} += length $chunk;
    $self->{buffer} .= $chunk;
  
    # Start-line
    unless ($self->{state}) {
  
      # Check start-line size
      my $len = index $self->{buffer}, "\x0a";
      $len = length $self->{buffer} if $len < 0;
      return $self->_limit('Maximum start-line size exceeded')
        if $len > $self->max_line_size;
  
      $self->{state} = 'content' if $self->extract_start_line(\$self->{buffer});
    }
  
    # Content
    my $state = $self->{state} // '';
    $self->content($self->content->parse(delete $self->{buffer}))
      if $state eq 'content' || $state eq 'finished';
  
    # Check message size
    my $max = $self->max_message_size;
    return $self->_limit('Maximum message size exceeded')
      if $max && $max < $self->{raw_size};
  
    # Check header size
    return $self->_limit('Maximum header size exceeded')
      if $self->headers->is_limit_exceeded;
  
    # Check buffer size
    return $self->_limit('Maximum buffer size exceeded')
      if $self->content->is_limit_exceeded;
  
    return $self->emit('progress')->content->is_finished ? $self->finish : $self;
  }
  
  sub start_line_size {
    croak 'Method "start_line_size" not implemented by subclass';
  }
  
  sub text {
    my $self    = shift;
    my $body    = $self->body;
    my $charset = $self->content->charset || $self->default_charset;
    return $charset ? decode($charset, $body) // $body : $body;
  }
  
  sub to_string {
    my $self = shift;
    return $self->build_start_line . $self->build_headers . $self->build_body;
  }
  
  sub upload { shift->_cache('uploads', 0, @_) }
  
  sub uploads {
    my $self = shift;
  
    my @uploads;
    for my $data (@{$self->_parse_formdata(1)}) {
      my $upload = Mojo::Upload->new(
        name     => $data->[0],
        filename => $data->[2],
        asset    => $data->[1]->asset,
        headers  => $data->[1]->headers
      );
      push @uploads, $upload;
    }
  
    return \@uploads;
  }
  
  sub _build {
    my ($self, $method) = @_;
  
    my ($buffer, $offset) = ('', 0);
    while (1) {
  
      # No chunk yet, try again
      next unless defined(my $chunk = $self->$method($offset));
  
      # End of part
      last unless my $len = length $chunk;
  
      $offset += $len;
      $buffer .= $chunk;
    }
  
    return $buffer;
  }
  
  sub _cache {
    my ($self, $method, $all, $name) = @_;
  
    # Cache objects by name
    unless ($self->{$method}) {
      $self->{$method} = {};
      push @{$self->{$method}{$_->name}}, $_ for @{$self->$method};
    }
  
    my $objects = $self->{$method}{$name} || [];
    return $all ? $objects : $objects->[-1];
  }
  
  sub _limit { ++$_[0]{limit} and return $_[0]->error({message => $_[1]}) }
  
  sub _parse_formdata {
    my ($self, $upload) = @_;
  
    my @formdata;
    my $content = $self->content;
    return \@formdata unless $content->is_multipart;
    my $charset = $content->charset || $self->default_charset;
  
    # Check all parts recursively
    my @parts = ($content);
    while (my $part = shift @parts) {
  
      if ($part->is_multipart) {
        unshift @parts, @{$part->parts};
        next;
      }
  
      next unless my $disposition = $part->headers->content_disposition;
      my ($filename) = $disposition =~ /[; ]filename="((?:\\"|[^"])*)"/;
      next if $upload && !defined $filename || !$upload && defined $filename;
      my ($name) = $disposition =~ /[; ]name="((?:\\"|[^;"])*)"/;
      $part = $part->asset->slurp unless $upload;
  
      if ($charset) {
        $name     = decode($charset, $name)     // $name     if $name;
        $filename = decode($charset, $filename) // $filename if $filename;
        $part = decode($charset, $part) // $part unless $upload;
      }
  
      push @formdata, [$name, $part, $filename];
    }
  
    return \@formdata;
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojo::Message - HTTP message base class
  
  =head1 SYNOPSIS
  
    package Mojo::Message::MyMessage;
    use Mojo::Base 'Mojo::Message';
  
    sub cookies              {...}
    sub extract_start_line   {...}
    sub get_start_line_chunk {...}
    sub start_line_size      {...}
  
  =head1 DESCRIPTION
  
  L<Mojo::Message> is an abstract base class for HTTP message containers, based on
  L<RFC 7230|http://tools.ietf.org/html/rfc7230>,
  L<RFC 7231|http://tools.ietf.org/html/rfc7231> and
  L<RFC 2388|http://tools.ietf.org/html/rfc2388>, like L<Mojo::Message::Request>
  and L<Mojo::Message::Response>.
  
  =head1 EVENTS
  
  L<Mojo::Message> inherits all events from L<Mojo::EventEmitter> and can emit
  the following new ones.
  
  =head2 finish
  
    $msg->on(finish => sub {
      my $msg = shift;
      ...
    });
  
  Emitted after message building or parsing is finished.
  
    my $before = time;
    $msg->on(finish => sub {
      my $msg = shift;
      $msg->headers->header('X-Parser-Time' => time - $before);
    });
  
  =head2 progress
  
    $msg->on(progress => sub {
      my $msg = shift;
      ...
    });
  
  Emitted when message building or parsing makes progress.
  
    # Building
    $msg->on(progress => sub {
      my ($msg, $state, $offset) = @_;
      say qq{Building "$state" at offset $offset};
    });
  
    # Parsing
    $msg->on(progress => sub {
      my $msg = shift;
      return unless my $len = $msg->headers->content_length;
      my $size = $msg->content->progress;
      say 'Progress: ', $size == $len ? 100 : int($size / ($len / 100)), '%';
    });
  
  =head1 ATTRIBUTES
  
  L<Mojo::Message> implements the following attributes.
  
  =head2 content
  
    my $msg = $msg->content;
    $msg    = $msg->content(Mojo::Content::Single->new);
  
  Message content, defaults to a L<Mojo::Content::Single> object.
  
  =head2 default_charset
  
    my $charset = $msg->default_charset;
    $msg        = $msg->default_charset('UTF-8');
  
  Default charset used by L</"text"> and to extract data from
  C<application/x-www-form-urlencoded> or C<multipart/form-data> message body,
  defaults to C<UTF-8>.
  
  =head2 max_line_size
  
    my $size = $msg->max_line_size;
    $msg     = $msg->max_line_size(1024);
  
  Maximum start-line size in bytes, defaults to the value of the
  C<MOJO_MAX_LINE_SIZE> environment variable or C<8192> (8KB).
  
  =head2 max_message_size
  
    my $size = $msg->max_message_size;
    $msg     = $msg->max_message_size(1024);
  
  Maximum message size in bytes, defaults to the value of the
  C<MOJO_MAX_MESSAGE_SIZE> environment variable or C<16777216> (16MB). Setting
  the value to C<0> will allow messages of indefinite size.
  
  =head2 version
  
    my $version = $msg->version;
    $msg        = $msg->version('1.1');
  
  HTTP version of message, defaults to C<1.1>.
  
  =head1 METHODS
  
  L<Mojo::Message> inherits all methods from L<Mojo::EventEmitter> and implements
  the following new ones.
  
  =head2 body
  
    my $bytes = $msg->body;
    $msg      = $msg->body('Hello!');
  
  Slurp or replace L</"content">, L<Mojo::Content::MultiPart> will be
  automatically downgraded to L<Mojo::Content::Single>.
  
  =head2 body_params
  
    my $params = $msg->body_params;
  
  C<POST> parameters extracted from C<application/x-www-form-urlencoded> or
  C<multipart/form-data> message body, usually a L<Mojo::Parameters> object. Note
  that this method caches all data, so it should not be called before the entire
  message body has been received. Parts of the message body need to be loaded
  into memory to parse C<POST> parameters, so you have to make sure it is not
  excessively large. There's a 16MB limit for requests and a 2GB limit for
  responses by default.
  
    # Get POST parameter names and values
    my $hash = $msg->body_params->to_hash;
  
  =head2 body_size
  
    my $size = $msg->body_size;
  
  Content size in bytes.
  
  =head2 build_body
  
    my $bytes = $msg->build_body;
  
  Render whole body with L</"get_body_chunk">.
  
  =head2 build_headers
  
    my $bytes = $msg->build_headers;
  
  Render all headers with L</"get_header_chunk">.
  
  =head2 build_start_line
  
    my $bytes = $msg->build_start_line;
  
  Render start-line with L</"get_start_line_chunk">.
  
  =head2 cookie
  
    my $cookie = $msg->cookie('foo');
  
  Access message cookies, usually L<Mojo::Cookie::Request> or
  L<Mojo::Cookie::Response> objects. If there are multiple cookies sharing the
  same name, and you want to access more than just the last one, you can use
  L</"every_cookie">. Note that this method caches all data, so it should not be
  called before all headers have been received.
  
    # Get cookie value
    say $msg->cookie('foo')->value;
  
  =head2 cookies
  
    my $cookies = $msg->cookies;
  
  Access message cookies. Meant to be overloaded in a subclass.
  
  =head2 dom
  
    my $dom        = $msg->dom;
    my $collection = $msg->dom('a[href]');
  
  Retrieve message body from L</"text"> and turn it into a L<Mojo::DOM> object,
  an optional selector can be used to call the method L<Mojo::DOM/"find"> on it
  right away, which then returns a L<Mojo::Collection> object. Note that this
  method caches all data, so it should not be called before the entire message
  body has been received. The whole message body needs to be loaded into memory
  to parse it, so you have to make sure it is not excessively large. There's a
  16MB limit for requests and a 2GB limit for responses by default.
  
    # Perform "find" right away
    say $msg->dom('h1, h2, h3')->map('text')->join("\n");
  
    # Use everything else Mojo::DOM has to offer
    say $msg->dom->at('title')->text;
    say $msg->dom->at('body')->children->map('tag')->uniq->join("\n");
  
  =head2 error
  
    my $err = $msg->error;
    $msg    = $msg->error({message => 'Parser error'});
  
  Get or set message error, an C<undef> return value indicates that there is no
  error.
  
    # Connection or parser error
    $msg->error({message => 'Connection refused'});
  
    # 4xx/5xx response
    $msg->error({message => 'Internal Server Error', code => 500});
  
  =head2 every_cookie
  
    my $cookies = $msg->every_cookie('foo');
  
  Similar to L</"cookie">, but returns all message cookies sharing the same name
  as an array reference.
  
    # Get first cookie value
    say $msg->every_cookie('foo')->[0]->value;
  
  =head2 every_upload
  
    my $uploads = $msg->every_upload('foo');
  
  Similar to L</"upload">, but returns all file uploads sharing the same name as
  an array reference.
  
    # Get content of first uploaded file
    say $msg->every_upload('foo')->[0]->asset->slurp;
  
  =head2 extract_start_line
  
    my $bool = $msg->extract_start_line(\$str);
  
  Extract start-line from string. Meant to be overloaded in a subclass.
  
  =head2 finish
  
    $msg = $msg->finish;
  
  Finish message parser/generator.
  
  =head2 fix_headers
  
    $msg = $msg->fix_headers;
  
  Make sure message has all required headers.
  
  =head2 get_body_chunk
  
    my $bytes = $msg->get_body_chunk($offset);
  
  Get a chunk of body data starting from a specific position. Note that it might
  not be possible to get the same chunk twice if content was generated
  dynamically.
  
  =head2 get_header_chunk
  
    my $bytes = $msg->get_header_chunk($offset);
  
  Get a chunk of header data, starting from a specific position. Note that this
  method finalizes the message.
  
  =head2 get_start_line_chunk
  
    my $bytes = $msg->get_start_line_chunk($offset);
  
  Get a chunk of start-line data starting from a specific position. Meant to be
  overloaded in a subclass.
  
  =head2 header_size
  
    my $size = $msg->header_size;
  
  Size of headers in bytes. Note that this method finalizes the message.
  
  =head2 headers
  
    my $headers = $msg->headers;
  
  Message headers, usually a L<Mojo::Headers> object.
  
    # Longer version
    my $headers = $msg->content->headers;
  
  =head2 is_finished
  
    my $bool = $msg->is_finished;
  
  Check if message parser/generator is finished.
  
  =head2 is_limit_exceeded
  
    my $bool = $msg->is_limit_exceeded;
  
  Check if message has exceeded L</"max_line_size">, L</"max_message_size">,
  L<Mojo::Content/"max_buffer_size"> or L<Mojo::Headers/"max_line_size">.
  
  =head2 json
  
    my $value = $msg->json;
    my $value = $msg->json('/foo/bar');
  
  Decode JSON message body directly using L<Mojo::JSON> if possible, an C<undef>
  return value indicates a bare C<null> or that decoding failed. An optional JSON
  Pointer can be used to extract a specific value with L<Mojo::JSON::Pointer>.
  Note that this method caches all data, so it should not be called before the
  entire message body has been received. The whole message body needs to be
  loaded into memory to parse it, so you have to make sure it is not excessively
  large. There's a 16MB limit for requests and a 2GB limit for responses by
  default.
  
    # Extract JSON values
    say $msg->json->{foo}{bar}[23];
    say $msg->json('/foo/bar/23');
  
  =head2 parse
  
    $msg = $msg->parse('HTTP/1.1 200 OK...');
  
  Parse message chunk.
  
  =head2 start_line_size
  
    my $size = $msg->start_line_size;
  
  Size of the start-line in bytes. Meant to be overloaded in a subclass.
  
  =head2 text
  
    my $str = $msg->text;
  
  Retrieve L</"body"> and try to decode it with L<Mojo::Content/"charset"> or
  L</"default_charset">.
  
  =head2 to_string
  
    my $str = $msg->to_string;
  
  Render whole message. Note that this method finalizes the message, and that it
  might not be possible to render the same message twice if content was generated
  dynamically.
  
  =head2 upload
  
    my $upload = $msg->upload('foo');
  
  Access C<multipart/form-data> file uploads, usually L<Mojo::Upload> objects. If
  there are multiple uploads sharing the same name, and you want to access more
  than just the last one, you can use L</"every_upload">. Note that this method
  caches all data, so it should not be called before the entire message body has
  been received.
  
    # Get content of uploaded file
    say $msg->upload('foo')->asset->slurp;
  
  =head2 uploads
  
    my $uploads = $msg->uploads;
  
  All C<multipart/form-data> file uploads, usually L<Mojo::Upload> objects.
  
    # Names of all uploads
    say $_->name for @{$msg->uploads};
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<http://mojolicious.org>.
  
  =cut
MOJO_MESSAGE

$fatpacked{"Mojo/Message/Request.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJO_MESSAGE_REQUEST';
  package Mojo::Message::Request;
  use Mojo::Base 'Mojo::Message';
  
  use Mojo::Cookie::Request;
  use Mojo::Util qw(b64_encode b64_decode);
  use Mojo::URL;
  
  has env => sub { {} };
  has method => 'GET';
  has [qw(proxy reverse_proxy)];
  has url => sub { Mojo::URL->new };
  has via_proxy => 1;
  
  sub clone {
    my $self = shift;
  
    # Dynamic requests cannot be cloned
    return undef unless my $content = $self->content->clone;
    my $clone = $self->new(
      content => $content,
      method  => $self->method,
      url     => $self->url->clone,
      version => $self->version
    );
    $clone->{proxy} = $self->{proxy}->clone if $self->{proxy};
  
    return $clone;
  }
  
  sub cookies {
    my $self = shift;
  
    # Parse cookies
    my $headers = $self->headers;
    return [map { @{Mojo::Cookie::Request->parse($_)} } $headers->cookie]
      unless @_;
  
    # Add cookies
    my @cookies = map { ref $_ eq 'HASH' ? Mojo::Cookie::Request->new($_) : $_ }
      $headers->cookie || (), @_;
    $headers->cookie(join '; ', @cookies);
  
    return $self;
  }
  
  sub every_param { shift->params->every_param(@_) }
  
  sub extract_start_line {
    my ($self, $bufref) = @_;
  
    # Ignore any leading empty lines
    return undef unless $$bufref =~ s/^\s*(.*?)\x0d?\x0a//;
  
    # We have a (hopefully) full request-line
    return !$self->error({message => 'Bad request start-line'})
      unless $1 =~ /^(\S+)\s+(\S+)\s+HTTP\/(\d\.\d)$/;
    my $url = $self->method($1)->version($3)->url;
    return !!($1 eq 'CONNECT' ? $url->host_port($2) : $url->parse($2));
  }
  
  sub fix_headers {
    my $self = shift;
    $self->{fix} ? return $self : $self->SUPER::fix_headers(@_);
  
    # Host
    my $url     = $self->url;
    my $headers = $self->headers;
    $headers->host($url->host_port) unless $headers->host;
  
    # Basic authentication
    if ((my $info = $url->userinfo) && !$headers->authorization) {
      $headers->authorization('Basic ' . b64_encode($info, ''));
    }
  
    # Basic proxy authentication
    return $self unless (my $proxy = $self->proxy) && $self->via_proxy;
    return $self unless my $info = $proxy->userinfo;
    $headers->proxy_authorization('Basic ' . b64_encode($info, ''))
      unless $headers->proxy_authorization;
    return $self;
  }
  
  sub get_start_line_chunk {
    my ($self, $offset) = @_;
    $self->_start_line->emit(progress => 'start_line', $offset);
    return substr $self->{start_buffer}, $offset, 131072;
  }
  
  sub is_handshake { lc($_[0]->headers->upgrade // '') eq 'websocket' }
  
  sub is_secure {
    my $url = shift->url;
    return ($url->protocol || $url->base->protocol) eq 'https';
  }
  
  sub is_xhr {
    (shift->headers->header('X-Requested-With') // '') =~ /XMLHttpRequest/i;
  }
  
  sub param { shift->params->param(@_) }
  
  sub params {
    my $self = shift;
    return $self->{params}
      ||= $self->body_params->clone->append($self->query_params);
  }
  
  sub parse {
    my $self = shift;
    my ($env, $chunk) = ref $_[0] ? (shift, '') : (undef, shift);
  
    # Parse CGI environment
    $self->env($env)->_parse_env($env) if $env;
  
    # Parse normal message
    if (($self->{state} // '') ne 'cgi') { $self->SUPER::parse($chunk) }
  
    # Parse CGI content
    else { $self->content($self->content->parse_body($chunk))->SUPER::parse('') }
  
    # Check if we can fix things that require all headers
    return $self unless $self->is_finished;
  
    # Base URL
    my $base = $self->url->base;
    $base->scheme('http') unless $base->scheme;
    my $headers = $self->headers;
    if (!$base->host && (my $host = $headers->host)) { $base->host_port($host) }
  
    # Basic authentication
    if (my $basic = _basic($headers->authorization)) { $base->userinfo($basic) }
  
    # Basic proxy authentication
    my $basic = _basic($headers->proxy_authorization);
    $self->proxy(Mojo::URL->new->userinfo($basic)) if $basic;
  
    # "X-Forwarded-Proto"
    $base->scheme('https')
      if $self->reverse_proxy
      && ($headers->header('X-Forwarded-Proto') // '') eq 'https';
  
    return $self;
  }
  
  sub query_params { shift->url->query }
  
  sub start_line_size { length shift->_start_line->{start_buffer} }
  
  sub _basic { $_[0] && $_[0] =~ /Basic (.+)$/ ? b64_decode $1 : undef }
  
  sub _parse_env {
    my ($self, $env) = @_;
  
    # Bypass normal message parser
    $self->{state} = 'cgi';
  
    # Extract headers
    my $headers = $self->headers;
    my $url     = $self->url;
    my $base    = $url->base;
    for my $name (keys %$env) {
      my $value = $env->{$name};
      next unless $name =~ s/^HTTP_//i;
      $name =~ y/_/-/;
      $headers->header($name => $value);
  
      # Host/Port
      $value =~ s/:(\d+)$// ? $base->host($value)->port($1) : $base->host($value)
        if $name eq 'HOST';
    }
  
    # Content-Type is a special case on some servers
    $headers->content_type($env->{CONTENT_TYPE}) if $env->{CONTENT_TYPE};
  
    # Content-Length is a special case on some servers
    $headers->content_length($env->{CONTENT_LENGTH}) if $env->{CONTENT_LENGTH};
  
    # Query
    $url->query->parse($env->{QUERY_STRING}) if $env->{QUERY_STRING};
  
    # Method
    $self->method($env->{REQUEST_METHOD}) if $env->{REQUEST_METHOD};
  
    # Scheme/Version
    $base->scheme($1) and $self->version($2)
      if ($env->{SERVER_PROTOCOL} // '') =~ m!^([^/]+)/([^/]+)$!;
  
    # HTTPS
    $base->scheme('https') if uc($env->{HTTPS} // '') eq 'ON';
  
    # Path
    my $path = $url->path->parse($env->{PATH_INFO} ? $env->{PATH_INFO} : '');
  
    # Base path
    if (my $value = $env->{SCRIPT_NAME}) {
  
      # Make sure there is a trailing slash (important for merging)
      $base->path->parse($value =~ m!/$! ? $value : "$value/");
  
      # Remove SCRIPT_NAME prefix if necessary
      my $buffer = $path->to_string;
      $value =~ s!^/|/$!!g;
      $buffer =~ s!^/?\Q$value\E/?!!;
      $buffer =~ s!^/!!;
      $path->parse($buffer);
    }
  }
  
  sub _start_line {
    my $self = shift;
  
    return $self if defined $self->{start_buffer};
  
    # Path
    my $url  = $self->url;
    my $path = $url->path_query;
    $path = "/$path" unless $path =~ m!^/!;
  
    # CONNECT
    my $method = uc $self->method;
    if ($method eq 'CONNECT') {
      my $port = $url->port // ($url->protocol eq 'https' ? '443' : '80');
      $path = $url->ihost . ":$port";
    }
  
    # Proxy
    elsif ($self->proxy && $self->via_proxy && $url->protocol ne 'https') {
      $path = $url->clone->userinfo(undef) unless $self->is_handshake;
    }
  
    $self->{start_buffer} = "$method $path HTTP/@{[$self->version]}\x0d\x0a";
  
    return $self;
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojo::Message::Request - HTTP request
  
  =head1 SYNOPSIS
  
    use Mojo::Message::Request;
  
    # Parse
    my $req = Mojo::Message::Request->new;
    $req->parse("GET /foo HTTP/1.0\x0d\x0a");
    $req->parse("Content-Length: 12\x0d\x0a");
    $req->parse("Content-Type: text/plain\x0d\x0a\x0d\x0a");
    $req->parse('Hello World!');
    say $req->method;
    say $req->headers->content_type;
    say $req->body;
  
    # Build
    my $req = Mojo::Message::Request->new;
    $req->url->parse('http://127.0.0.1/foo/bar');
    $req->method('GET');
    say $req->to_string;
  
  =head1 DESCRIPTION
  
  L<Mojo::Message::Request> is a container for HTTP requests, based on
  L<RFC 7230|http://tools.ietf.org/html/rfc7230>,
  L<RFC 7231|http://tools.ietf.org/html/rfc7231>,
  L<RFC 7235|http://tools.ietf.org/html/rfc7235> and
  L<RFC 2817|http://tools.ietf.org/html/rfc2817>.
  
  =head1 EVENTS
  
  L<Mojo::Message::Request> inherits all events from L<Mojo::Message>.
  
  =head1 ATTRIBUTES
  
  L<Mojo::Message::Request> inherits all attributes from L<Mojo::Message> and
  implements the following new ones.
  
  =head2 env
  
    my $env = $req->env;
    $req    = $req->env({PATH_INFO => '/'});
  
  Direct access to the C<CGI> or C<PSGI> environment hash if available.
  
    # Check CGI version
    my $version = $req->env->{GATEWAY_INTERFACE};
  
    # Check PSGI version
    my $version = $req->env->{'psgi.version'};
  
  =head2 method
  
    my $method = $req->method;
    $req       = $req->method('POST');
  
  HTTP request method, defaults to C<GET>.
  
  =head2 proxy
  
    my $url = $req->proxy;
    $req    = $req->proxy(Mojo::URL->new('http://127.0.0.1:3000'));
  
  Proxy URL for request.
  
  =head2 reverse_proxy
  
    my $bool = $req->reverse_proxy;
    $req     = $req->reverse_proxy($bool);
  
  Request has been performed through a reverse proxy.
  
  =head2 url
  
    my $url = $req->url;
    $req    = $req->url(Mojo::URL->new);
  
  HTTP request URL, defaults to a L<Mojo::URL> object.
  
    # Get request information
    my $info = $req->url->to_abs->userinfo;
    my $host = $req->url->to_abs->host;
    my $path = $req->url->to_abs->path;
  
  =head2 via_proxy
  
    my $bool = $req->via_proxy;
    $req     = $req->via_proxy($bool);
  
  Request can be performed through a proxy server.
  
  =head1 METHODS
  
  L<Mojo::Message::Request> inherits all methods from L<Mojo::Message> and
  implements the following new ones.
  
  =head2 clone
  
    my $clone = $req->clone;
  
  Clone request if possible, otherwise return C<undef>.
  
  =head2 cookies
  
    my $cookies = $req->cookies;
    $req        = $req->cookies(Mojo::Cookie::Request->new);
    $req        = $req->cookies({name => 'foo', value => 'bar'});
  
  Access request cookies, usually L<Mojo::Cookie::Request> objects.
  
    # Names of all cookies
    say $_->name for @{$req->cookies};
  
  =head2 every_param
  
    my $values = $req->every_param('foo');
  
  Similar to L</"param">, but returns all values sharing the same name as an
  array reference.
  
    # Get first value
    say $req->every_param('foo')->[0];
  
  =head2 extract_start_line
  
    my $bool = $req->extract_start_line(\$str);
  
  Extract request-line from string.
  
  =head2 fix_headers
  
    $req = $req->fix_headers;
  
  Make sure request has all required headers.
  
  =head2 get_start_line_chunk
  
    my $bytes = $req->get_start_line_chunk($offset);
  
  Get a chunk of request-line data starting from a specific position. Note that
  this method finalizes the request.
  
  =head2 is_handshake
  
    my $bool = $req->is_handshake;
  
  Check C<Upgrade> header for C<websocket> value.
  
  =head2 is_secure
  
    my $bool = $req->is_secure;
  
  Check if connection is secure.
  
  =head2 is_xhr
  
    my $bool = $req->is_xhr;
  
  Check C<X-Requested-With> header for C<XMLHttpRequest> value.
  
  =head2 param
  
    my $value = $req->param('foo');
  
  Access C<GET> and C<POST> parameters extracted from the query string and
  C<application/x-www-form-urlencoded> or C<multipart/form-data> message body. If
  there are multiple values sharing the same name, and you want to access more
  than just the last one, you can use L</"every_param">. Note that this method
  caches all data, so it should not be called before the entire request body has
  been received. Parts of the request body need to be loaded into memory to parse
  C<POST> parameters, so you have to make sure it is not excessively large.
  There's a 16MB limit for requests by default.
  
  =head2 params
  
    my $params = $req->params;
  
  All C<GET> and C<POST> parameters extracted from the query string and
  C<application/x-www-form-urlencoded> or C<multipart/form-data> message body,
  usually a L<Mojo::Parameters> object. Note that this method caches all data, so
  it should not be called before the entire request body has been received. Parts
  of the request body need to be loaded into memory to parse C<POST> parameters,
  so you have to make sure it is not excessively large. There's a 16MB limit for
  requests by default.
  
    # Get parameter names and values
    my $hash = $req->params->to_hash;
  
  =head2 parse
  
    $req = $req->parse('GET /foo/bar HTTP/1.1');
    $req = $req->parse({PATH_INFO => '/'});
  
  Parse HTTP request chunks or environment hash.
  
  =head2 query_params
  
    my $params = $req->query_params;
  
  All C<GET> parameters, usually a L<Mojo::Parameters> object.
  
    # Turn GET parameters to hash and extract value
    say $req->query_params->to_hash->{foo};
  
  =head2 start_line_size
  
    my $size = $req->start_line_size;
  
  Size of the request-line in bytes. Note that this method finalizes the request.
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<http://mojolicious.org>.
  
  =cut
MOJO_MESSAGE_REQUEST

$fatpacked{"Mojo/Message/Response.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJO_MESSAGE_RESPONSE';
  package Mojo::Message::Response;
  use Mojo::Base 'Mojo::Message';
  
  use Mojo::Cookie::Response;
  use Mojo::Date;
  use Mojo::Util 'deprecated';
  
  has [qw(code message)];
  has max_message_size => sub { $ENV{MOJO_MAX_MESSAGE_SIZE} // 2147483648 };
  
  # Umarked codes are from RFC 7231
  my %MESSAGES = (
    100 => 'Continue',
    101 => 'Switching Protocols',
    102 => 'Processing',                         # RFC 2518 (WebDAV)
    200 => 'OK',
    201 => 'Created',
    202 => 'Accepted',
    203 => 'Non-Authoritative Information',
    204 => 'No Content',
    205 => 'Reset Content',
    206 => 'Partial Content',
    207 => 'Multi-Status',                       # RFC 2518 (WebDAV)
    208 => 'Already Reported',                   # RFC 5842
    226 => 'IM Used',                            # RFC 3229
    300 => 'Multiple Choices',
    301 => 'Moved Permanently',
    302 => 'Found',
    303 => 'See Other',
    304 => 'Not Modified',
    305 => 'Use Proxy',
    307 => 'Temporary Redirect',
    308 => 'Permanent Redirect',                 # RFC 7538
    400 => 'Bad Request',
    401 => 'Unauthorized',
    402 => 'Payment Required',
    403 => 'Forbidden',
    404 => 'Not Found',
    405 => 'Method Not Allowed',
    406 => 'Not Acceptable',
    407 => 'Proxy Authentication Required',
    408 => 'Request Timeout',
    409 => 'Conflict',
    410 => 'Gone',
    411 => 'Length Required',
    412 => 'Precondition Failed',
    413 => 'Request Entity Too Large',
    414 => 'Request-URI Too Long',
    415 => 'Unsupported Media Type',
    416 => 'Request Range Not Satisfiable',
    417 => 'Expectation Failed',
    418 => "I'm a teapot",                       # RFC 2324 :)
    422 => 'Unprocessable Entity',               # RFC 2518 (WebDAV)
    423 => 'Locked',                             # RFC 2518 (WebDAV)
    424 => 'Failed Dependency',                  # RFC 2518 (WebDAV)
    425 => 'Unordered Colection',                # RFC 3648 (WebDAV)
    426 => 'Upgrade Required',                   # RFC 2817
    428 => 'Precondition Required',              # RFC 6585
    429 => 'Too Many Requests',                  # RFC 6585
    431 => 'Request Header Fields Too Large',    # RFC 6585
    451 => 'Unavailable For Legal Reasons',      # RFC 7725
    500 => 'Internal Server Error',
    501 => 'Not Implemented',
    502 => 'Bad Gateway',
    503 => 'Service Unavailable',
    504 => 'Gateway Timeout',
    505 => 'HTTP Version Not Supported',
    506 => 'Variant Also Negotiates',            # RFC 2295
    507 => 'Insufficient Storage',               # RFC 2518 (WebDAV)
    508 => 'Loop Detected',                      # RFC 5842
    509 => 'Bandwidth Limit Exceeded',           # Unofficial
    510 => 'Not Extended',                       # RFC 2774
    511 => 'Network Authentication Required'     # RFC 6585
  );
  
  sub cookies {
    my $self = shift;
  
    # Parse cookies
    my $headers = $self->headers;
    return [@{Mojo::Cookie::Response->parse($headers->set_cookie)}] unless @_;
  
    # Add cookies
    $headers->add('Set-Cookie' => "$_")
      for map { ref $_ eq 'HASH' ? Mojo::Cookie::Response->new($_) : $_ } @_;
  
    return $self;
  }
  
  sub default_message { $MESSAGES{$_[1] || $_[0]->code // 404} || '' }
  
  sub extract_start_line {
    my ($self, $bufref) = @_;
  
    # We have a full response line
    return undef unless $$bufref =~ s/^(.*?)\x0d?\x0a//;
    return !$self->error({message => 'Bad response start-line'})
      unless $1 =~ m!^\s*HTTP/(\d\.\d)\s+(\d\d\d)\s*(.+)?$!;
  
    my $content = $self->content;
    $content->skip_body(1) if $self->code($2)->is_empty;
    defined $content->$_ or $content->$_(1) for qw(auto_decompress auto_relax);
    $content->expect_close(1) if $1 eq '1.0';
    return !!$self->version($1)->message($3);
  }
  
  sub fix_headers {
    my $self = shift;
    $self->{fix} ? return $self : $self->SUPER::fix_headers(@_);
  
    # Date
    my $headers = $self->headers;
    $headers->date(Mojo::Date->new->to_string) unless $headers->date;
  
    return $self;
  }
  
  sub get_start_line_chunk {
    my ($self, $offset) = @_;
    $self->_start_line->emit(progress => 'start_line', $offset);
    return substr $self->{start_buffer}, $offset, 131072;
  }
  
  sub is_client_error { shift->_status_class(400) }
  
  sub is_empty {
    my $self = shift;
    return undef unless my $code = $self->code;
    return $self->is_info || $code == 204 || $code == 304;
  }
  
  sub is_error { shift->_status_class(400, 500) }
  sub is_info { shift->_status_class(100) }
  sub is_redirect     { shift->_status_class(300) }
  sub is_server_error { shift->_status_class(500) }
  
  # DEPRECATED!
  sub is_status_class {
    deprecated 'Mojo::Message::Response::is_status_class is DEPRECATED'
      . ' in favor of new is_* methods';
    shift->_status_class(@_);
  }
  
  sub is_success { shift->_status_class(200) }
  
  sub start_line_size { length shift->_start_line->{start_buffer} }
  
  sub _start_line {
    my $self = shift;
  
    return $self if defined $self->{start_buffer};
    my $code = $self->code    || 404;
    my $msg  = $self->message || $self->default_message;
    $self->{start_buffer} = "HTTP/@{[$self->version]} $code $msg\x0d\x0a";
  
    return $self;
  }
  
  sub _status_class {
    my ($self, @classes) = @_;
    return undef unless my $code = $self->code;
    return !!grep { $code >= $_ && $code < ($_ + 100) } @classes;
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojo::Message::Response - HTTP response
  
  =head1 SYNOPSIS
  
    use Mojo::Message::Response;
  
    # Parse
    my $res = Mojo::Message::Response->new;
    $res->parse("HTTP/1.0 200 OK\x0d\x0a");
    $res->parse("Content-Length: 12\x0d\x0a");
    $res->parse("Content-Type: text/plain\x0d\x0a\x0d\x0a");
    $res->parse('Hello World!');
    say $res->code;
    say $res->headers->content_type;
    say $res->body;
  
    # Build
    my $res = Mojo::Message::Response->new;
    $res->code(200);
    $res->headers->content_type('text/plain');
    $res->body('Hello World!');
    say $res->to_string;
  
  =head1 DESCRIPTION
  
  L<Mojo::Message::Response> is a container for HTTP responses, based on
  L<RFC 7230|http://tools.ietf.org/html/rfc7230> and
  L<RFC 7231|http://tools.ietf.org/html/rfc7231>.
  
  =head1 EVENTS
  
  L<Mojo::Message::Response> inherits all events from L<Mojo::Message>.
  
  =head1 ATTRIBUTES
  
  L<Mojo::Message::Response> inherits all attributes from L<Mojo::Message> and
  implements the following new ones.
  
  =head2 code
  
    my $code = $res->code;
    $res     = $res->code(200);
  
  HTTP response status code.
  
  =head2 max_message_size
  
    my $size = $res->max_message_size;
    $res     = $res->max_message_size(1024);
  
  Maximum message size in bytes, defaults to the value of the
  C<MOJO_MAX_MESSAGE_SIZE> environment variable or C<2147483648> (2GB). Setting
  the value to C<0> will allow messages of indefinite size.
  
  =head2 message
  
    my $msg = $res->message;
    $res    = $res->message('OK');
  
  HTTP response status message.
  
  =head1 METHODS
  
  L<Mojo::Message::Response> inherits all methods from L<Mojo::Message> and
  implements the following new ones.
  
  =head2 cookies
  
    my $cookies = $res->cookies;
    $res        = $res->cookies(Mojo::Cookie::Response->new);
    $res        = $res->cookies({name => 'foo', value => 'bar'});
  
  Access response cookies, usually L<Mojo::Cookie::Response> objects.
  
    # Names of all cookies
    say $_->name for @{$res->cookies};
  
  =head2 default_message
  
    my $msg = $res->default_message;
    my $msg = $res->default_message(418);
  
  Generate default response message for status code, defaults to using
  L</"code">.
  
  =head2 extract_start_line
  
    my $bool = $res->extract_start_line(\$str);
  
  Extract status-line from string.
  
  =head2 fix_headers
  
    $res = $res->fix_headers;
  
  Make sure response has all required headers.
  
  =head2 get_start_line_chunk
  
    my $bytes = $res->get_start_line_chunk($offset);
  
  Get a chunk of status-line data starting from a specific position. Note that
  this method finalizes the response.
  
  =head2 is_client_error
  
    my $bool = $res->is_client_error;
  
  Check if this response has a C<4xx> status L</"code">.
  
  =head2 is_empty
  
    my $bool = $res->is_empty;
  
  Check if this response has a C<1xx>, C<204> or C<304> status L</"code">.
  
  =head2 is_error
  
    my $bool = $res->is_error;
  
  Check if this response has a C<4xx> or C<5xx> status L</"code">.
  
  =head2 is_info
  
    my $bool = $res->is_info;
  
  Check if this response has a C<1xx> status L</"code">.
  
  =head2 is_redirect
  
    my $bool = $res->is_redirect;
  
  Check if this response has a C<3xx> status L</"code">.
  
  =head2 is_server_error
  
    my $bool = $res->is_server_error;
  
  Check if this response has a C<5xx> status L</"code">.
  
  =head2 is_success
  
    my $bool = $res->is_success;
  
  Check if this response has a C<2xx> status L</"code">.
  
  =head2 start_line_size
  
    my $size = $req->start_line_size;
  
  Size of the status-line in bytes. Note that this method finalizes the response.
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<http://mojolicious.org>.
  
  =cut
MOJO_MESSAGE_RESPONSE

$fatpacked{"Mojo/Parameters.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJO_PARAMETERS';
  package Mojo::Parameters;
  use Mojo::Base -base;
  use overload
    '@{}'    => sub { shift->pairs },
    bool     => sub {1},
    '""'     => sub { shift->to_string },
    fallback => 1;
  
  use Mojo::Util qw(decode encode url_escape url_unescape);
  
  has charset => 'UTF-8';
  
  sub append {
    my $self = shift;
  
    my $old = $self->pairs;
    my @new = @_ == 1 ? @{shift->pairs} : @_;
    while (my ($name, $value) = splice @new, 0, 2) {
  
      # Multiple values
      if (ref $value eq 'ARRAY') { push @$old, $name => $_ // '' for @$value }
  
      # Single value
      elsif (defined $value) { push @$old, $name => $value }
    }
  
    return $self;
  }
  
  sub clone {
    my $self = shift;
  
    my $clone = $self->new;
    if   (exists $self->{charset}) { $clone->{charset} = $self->{charset} }
    if   (defined $self->{string}) { $clone->{string}  = $self->{string} }
    else                           { $clone->{pairs}   = [@{$self->pairs}] }
  
    return $clone;
  }
  
  sub every_param {
    my ($self, $name) = @_;
  
    my @values;
    my $pairs = $self->pairs;
    for (my $i = 0; $i < @$pairs; $i += 2) {
      push @values, $pairs->[$i + 1] if $pairs->[$i] eq $name;
    }
  
    return \@values;
  }
  
  sub merge {
    my $self = shift;
  
    my @pairs = @_ == 1 ? @{shift->pairs} : @_;
    while (my ($name, $value) = splice @pairs, 0, 2) {
      defined $value ? $self->param($name => $value) : $self->remove($name);
    }
  
    return $self;
  }
  
  sub names { [sort keys %{shift->to_hash}] }
  
  sub new { @_ > 1 ? shift->SUPER::new->parse(@_) : shift->SUPER::new }
  
  sub pairs {
    my $self = shift;
  
    # Replace parameters
    if (@_) {
      $self->{pairs} = shift;
      delete $self->{string};
      return $self;
    }
  
    # Parse string
    if (defined(my $str = delete $self->{string})) {
      my $pairs = $self->{pairs} = [];
      return $pairs unless length $str;
  
      my $charset = $self->charset;
      for my $pair (split '&', $str) {
        next unless $pair =~ /^([^=]+)(?:=(.*))?$/;
        my ($name, $value) = ($1, $2 // '');
  
        # Replace "+" with whitespace, unescape and decode
        s/\+/ /g for $name, $value;
        $name  = url_unescape $name;
        $name  = decode($charset, $name) // $name if $charset;
        $value = url_unescape $value;
        $value = decode($charset, $value) // $value if $charset;
  
        push @$pairs, $name, $value;
      }
    }
  
    return $self->{pairs} ||= [];
  }
  
  sub param {
    my ($self, $name) = (shift, shift);
    return $self->every_param($name)->[-1] unless @_;
    $self->remove($name);
    return $self->append($name => ref $_[0] eq 'ARRAY' ? $_[0] : [@_]);
  }
  
  sub parse {
    my $self = shift;
  
    # Pairs
    return $self->append(@_) if @_ > 1;
  
    # String
    $self->{string} = shift;
    return $self;
  }
  
  sub remove {
    my ($self, $name) = @_;
    my $pairs = $self->pairs;
    my $i     = 0;
    $pairs->[$i] eq $name ? splice @$pairs, $i, 2 : ($i += 2) while $i < @$pairs;
    return $self;
  }
  
  sub to_hash {
    my $self = shift;
  
    my %hash;
    my $pairs = $self->pairs;
    for (my $i = 0; $i < @$pairs; $i += 2) {
      my ($name, $value) = @{$pairs}[$i, $i + 1];
  
      # Array
      if (exists $hash{$name}) {
        $hash{$name} = [$hash{$name}] if ref $hash{$name} ne 'ARRAY';
        push @{$hash{$name}}, $value;
      }
  
      # String
      else { $hash{$name} = $value }
    }
  
    return \%hash;
  }
  
  sub to_string {
    my $self = shift;
  
    # String (RFC 3986)
    my $charset = $self->charset;
    if (defined(my $str = $self->{string})) {
      $str = encode $charset, $str if $charset;
      return url_escape $str, '^A-Za-z0-9\-._~%!$&\'()*+,;=:@/?';
    }
  
    # Build pairs (HTML Living Standard)
    my $pairs = $self->pairs;
    return '' unless @$pairs;
    my @pairs;
    for (my $i = 0; $i < @$pairs; $i += 2) {
      my ($name, $value) = @{$pairs}[$i, $i + 1];
  
      # Escape and replace whitespace with "+"
      $name  = encode $charset,   $name if $charset;
      $name  = url_escape $name,  '^*\-.0-9A-Z_a-z';
      $value = encode $charset,   $value if $charset;
      $value = url_escape $value, '^*\-.0-9A-Z_a-z';
      s/\%20/\+/g for $name, $value;
  
      push @pairs, "$name=$value";
    }
  
    return join '&', @pairs;
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojo::Parameters - Parameters
  
  =head1 SYNOPSIS
  
    use Mojo::Parameters;
  
    # Parse
    my $params = Mojo::Parameters->new('foo=bar&baz=23');
    say $params->param('baz');
  
    # Build
    my $params = Mojo::Parameters->new(foo => 'bar', baz => 23);
    push @$params, i => ' mojolicious';
    say "$params";
  
  =head1 DESCRIPTION
  
  L<Mojo::Parameters> is a container for form parameters used by L<Mojo::URL>,
  based on L<RFC 3986|http://tools.ietf.org/html/rfc3986> and the
  L<HTML Living Standard|https://html.spec.whatwg.org>.
  
  =head1 ATTRIBUTES
  
  L<Mojo::Parameters> implements the following attributes.
  
  =head2 charset
  
    my $charset = $params->charset;
    $params     = $params->charset('UTF-8');
  
  Charset used for encoding and decoding parameters, defaults to C<UTF-8>.
  
    # Disable encoding and decoding
    $params->charset(undef);
  
  =head1 METHODS
  
  L<Mojo::Parameters> inherits all methods from L<Mojo::Base> and implements the
  following new ones.
  
  =head2 append
  
    $params = $params->append(foo => 'ba&r');
    $params = $params->append(foo => ['ba&r', 'baz']);
    $params = $params->append(foo => ['bar', 'baz'], bar => 23);
    $params = $params->append(Mojo::Parameters->new);
  
  Append parameters. Note that this method will normalize the parameters.
  
    # "foo=bar&foo=baz"
    Mojo::Parameters->new('foo=bar')->append(Mojo::Parameters->new('foo=baz'));
  
    # "foo=bar&foo=baz"
    Mojo::Parameters->new('foo=bar')->append(foo => 'baz');
  
    # "foo=bar&foo=baz&foo=yada"
    Mojo::Parameters->new('foo=bar')->append(foo => ['baz', 'yada']);
  
    # "foo=bar&foo=baz&foo=yada&bar=23"
    Mojo::Parameters->new('foo=bar')->append(foo => ['baz', 'yada'], bar => 23);
  
  =head2 clone
  
    my $params2 = $params->clone;
  
  Clone parameters.
  
  =head2 every_param
  
    my $values = $params->every_param('foo');
  
  Similar to L</"param">, but returns all values sharing the same name as an
  array reference. Note that this method will normalize the parameters.
  
    # Get first value
    say $params->every_param('foo')->[0];
  
  =head2 merge
  
    $params = $params->merge(foo => 'ba&r');
    $params = $params->merge(foo => ['ba&r', 'baz']);
    $params = $params->merge(foo => ['bar', 'baz'], bar => 23);
    $params = $params->merge(Mojo::Parameters->new);
  
  Merge parameters. Note that this method will normalize the parameters.
  
    # "foo=baz"
    Mojo::Parameters->new('foo=bar')->merge(Mojo::Parameters->new('foo=baz'));
  
    # "yada=yada&foo=baz"
    Mojo::Parameters->new('foo=bar&yada=yada')->merge(foo => 'baz');
  
    # "yada=yada"
    Mojo::Parameters->new('foo=bar&yada=yada')->merge(foo => undef);
  
  =head2 names
  
    my $names = $params->names;
  
  Return an array reference with all parameter names.
  
    # Names of all parameters
    say for @{$params->names};
  
  =head2 new
  
    my $params = Mojo::Parameters->new;
    my $params = Mojo::Parameters->new('foo=b%3Bar&baz=23');
    my $params = Mojo::Parameters->new(foo => 'b&ar');
    my $params = Mojo::Parameters->new(foo => ['ba&r', 'baz']);
    my $params = Mojo::Parameters->new(foo => ['bar', 'baz'], bar => 23);
  
  Construct a new L<Mojo::Parameters> object and L</"parse"> parameters if
  necessary.
  
  =head2 pairs
  
    my $array = $params->pairs;
    $params   = $params->pairs([foo => 'b&ar', baz => 23]);
  
  Parsed parameter pairs. Note that this method will normalize the parameters.
  
    # Remove all parameters
    $params->pairs([]);
  
  =head2 param
  
    my $value = $params->param('foo');
    $params   = $params->param(foo => 'ba&r');
    $params   = $params->param(foo => qw(ba&r baz));
    $params   = $params->param(foo => ['ba;r', 'baz']);
  
  Access parameter values. If there are multiple values sharing the same name,
  and you want to access more than just the last one, you can use
  L</"every_param">. Note that this method will normalize the parameters.
  
  =head2 parse
  
    $params = $params->parse('foo=b%3Bar&baz=23');
  
  Parse parameters.
  
  =head2 remove
  
    $params = $params->remove('foo');
  
  Remove parameters. Note that this method will normalize the parameters.
  
    # "bar=yada"
    Mojo::Parameters->new('foo=bar&foo=baz&bar=yada')->remove('foo');
  
  =head2 to_hash
  
    my $hash = $params->to_hash;
  
  Turn parameters into a hash reference. Note that this method will normalize the
  parameters.
  
    # "baz"
    Mojo::Parameters->new('foo=bar&foo=baz')->to_hash->{foo}[1];
  
  =head2 to_string
  
    my $str = $params->to_string;
  
  Turn parameters into a string.
  
    # "foo=bar&baz=23"
    Mojo::Parameters->new->pairs([foo => 'bar', baz => 23])->to_string;
  
  =head1 OPERATORS
  
  L<Mojo::Parameters> overloads the following operators.
  
  =head2 array
  
    my @pairs = @$params;
  
  Alias for L</"pairs">. Note that this will normalize the parameters.
  
    say $params->[0];
    say for @$params;
  
  =head2 bool
  
    my $bool = !!$params;
  
  Always true.
  
  =head2 stringify
  
    my $str = "$params";
  
  Alias for L</"to_string">.
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<http://mojolicious.org>.
  
  =cut
MOJO_PARAMETERS

$fatpacked{"Mojo/Path.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJO_PATH';
  package Mojo::Path;
  use Mojo::Base -base;
  use overload
    '@{}'    => sub { shift->parts },
    bool     => sub {1},
    '""'     => sub { shift->to_string },
    fallback => 1;
  
  use Mojo::Util qw(decode encode url_escape url_unescape);
  
  has charset => 'UTF-8';
  
  sub canonicalize {
    my $self = shift;
  
    my $parts = $self->parts;
    for (my $i = 0; $i <= $#$parts;) {
      if (!length $parts->[$i] || $parts->[$i] eq '.' || $parts->[$i] eq '...') {
        splice @$parts, $i, 1;
      }
      elsif ($i < 1 || $parts->[$i] ne '..' || $parts->[$i - 1] eq '..') { $i++ }
      else { splice @$parts, --$i, 2 }
    }
  
    return @$parts ? $self : $self->trailing_slash(undef);
  }
  
  sub clone {
    my $self = shift;
  
    my $clone = $self->new;
    if (exists $self->{charset}) { $clone->{charset} = $self->{charset} }
    if (my $parts = $self->{parts}) {
      $clone->{$_} = $self->{$_} for qw(leading_slash trailing_slash);
      $clone->{parts} = [@$parts];
    }
    else { $clone->{path} = $self->{path} }
  
    return $clone;
  }
  
  sub contains { $_[1] eq '/' || $_[0]->to_route =~ m!^\Q$_[1]\E(?:/|$)! }
  
  sub leading_slash { shift->_parse(leading_slash => @_) }
  
  sub merge {
    my ($self, $path) = @_;
  
    # Replace
    return $self->parse($path) if $path =~ m!^/!;
  
    # Merge
    pop @{$self->parts} unless $self->trailing_slash;
    $path = $self->new($path);
    push @{$self->parts}, @{$path->parts};
    return $self->trailing_slash($path->trailing_slash);
  }
  
  sub new { @_ > 1 ? shift->SUPER::new->parse(@_) : shift->SUPER::new }
  
  sub parse {
    my $self = shift;
    $self->{path} = shift;
    delete @$self{qw(leading_slash parts trailing_slash)};
    return $self;
  }
  
  sub parts { shift->_parse(parts => @_) }
  
  sub to_abs_string {
    my $path = shift->to_string;
    return $path =~ m!^/! ? $path : "/$path";
  }
  
  sub to_dir {
    my $clone = shift->clone;
    pop @{$clone->parts} unless $clone->trailing_slash;
    return $clone->trailing_slash(!!@{$clone->parts});
  }
  
  sub to_route {
    my $clone = shift->clone;
    return '/' . join '/', @{$clone->parts}, $clone->trailing_slash ? '' : ();
  }
  
  sub to_string {
    my $self = shift;
  
    # Path
    my $charset = $self->charset;
    if (defined(my $path = $self->{path})) {
      $path = encode $charset, $path if $charset;
      return url_escape $path, '^A-Za-z0-9\-._~!$&\'()*+,;=%:@/';
    }
  
    # Build path
    my @parts = @{$self->parts};
    @parts = map { encode $charset, $_ } @parts if $charset;
    my $path = join '/',
      map { url_escape $_, '^A-Za-z0-9\-._~!$&\'()*+,;=:@' } @parts;
    $path = "/$path" if $self->leading_slash;
    $path = "$path/" if $self->trailing_slash;
    return $path;
  }
  
  sub trailing_slash { shift->_parse(trailing_slash => @_) }
  
  sub _parse {
    my ($self, $name) = (shift, shift);
  
    unless ($self->{parts}) {
      my $path = url_unescape delete($self->{path}) // '';
      my $charset = $self->charset;
      $path = decode($charset, $path) // $path if $charset;
      $self->{leading_slash}  = $path =~ s!^/!!;
      $self->{trailing_slash} = $path =~ s!/$!!;
      $self->{parts}          = [split '/', $path, -1];
    }
  
    return $self->{$name} unless @_;
    $self->{$name} = shift;
    return $self;
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojo::Path - Path
  
  =head1 SYNOPSIS
  
    use Mojo::Path;
  
    # Parse
    my $path = Mojo::Path->new('/foo%2Fbar%3B/baz.html');
    say $path->[0];
  
    # Build
    my $path = Mojo::Path->new('/i/');
    push @$path, 'mojolicious';
    say "$path";
  
  =head1 DESCRIPTION
  
  L<Mojo::Path> is a container for paths used by L<Mojo::URL>, based on
  L<RFC 3986|http://tools.ietf.org/html/rfc3986>.
  
  =head1 ATTRIBUTES
  
  L<Mojo::Path> implements the following attributes.
  
  =head2 charset
  
    my $charset = $path->charset;
    $path       = $path->charset('UTF-8');
  
  Charset used for encoding and decoding, defaults to C<UTF-8>.
  
    # Disable encoding and decoding
    $path->charset(undef);
  
  =head1 METHODS
  
  L<Mojo::Path> inherits all methods from L<Mojo::Base> and implements the
  following new ones.
  
  =head2 canonicalize
  
    $path = $path->canonicalize;
  
  Canonicalize path by resolving C<.> and C<..>, in addition C<...> will be
  treated as C<.> to protect from path traversal attacks.
  
    # "/foo/baz"
    Mojo::Path->new('/foo/./bar/../baz')->canonicalize;
  
    # "/../baz"
    Mojo::Path->new('/foo/../bar/../../baz')->canonicalize;
  
    # "/foo/bar"
    Mojo::Path->new('/foo/.../bar')->canonicalize;
  
  =head2 clone
  
    my $clone = $path->clone;
  
  Clone path.
  
  =head2 contains
  
    my $bool = $path->contains('/i//mojolicious');
  
  Check if path contains given prefix.
  
    # True
    Mojo::Path->new('/foo/bar')->contains('/');
    Mojo::Path->new('/foo/bar')->contains('/foo');
    Mojo::Path->new('/foo/bar')->contains('/foo/bar');
  
    # False
    Mojo::Path->new('/foo/bar')->contains('/f');
    Mojo::Path->new('/foo/bar')->contains('/bar');
    Mojo::Path->new('/foo/bar')->contains('/whatever');
  
  =head2 leading_slash
  
    my $bool = $path->leading_slash;
    $path    = $path->leading_slash($bool);
  
  Path has a leading slash. Note that this method will normalize the path and
  that C<%2F> will be treated as C</> for security reasons.
  
    # "/foo/bar"
    Mojo::Path->new('foo/bar')->leading_slash(1);
  
    # "foo/bar"
    Mojo::Path->new('/foo/bar')->leading_slash(0);
  
  =head2 merge
  
    $path = $path->merge('/foo/bar');
    $path = $path->merge('foo/bar');
    $path = $path->merge(Mojo::Path->new);
  
  Merge paths. Note that this method will normalize both paths if necessary and
  that C<%2F> will be treated as C</> for security reasons.
  
    # "/baz/yada"
    Mojo::Path->new('/foo/bar')->merge('/baz/yada');
  
    # "/foo/baz/yada"
    Mojo::Path->new('/foo/bar')->merge('baz/yada');
  
    # "/foo/bar/baz/yada"
    Mojo::Path->new('/foo/bar/')->merge('baz/yada');
  
  =head2 new
  
    my $path = Mojo::Path->new;
    my $path = Mojo::Path->new('/foo%2Fbar%3B/baz.html');
  
  Construct a new L<Mojo::Path> object and L</"parse"> path if necessary.
  
  =head2 parse
  
    $path = $path->parse('/foo%2Fbar%3B/baz.html');
  
  Parse path.
  
  =head2 to_abs_string
  
    my $str = $path->to_abs_string;
  
  Turn path into an absolute string.
  
    # "/i/%E2%99%A5/mojolicious"
    Mojo::Path->new('/i/%E2%99%A5/mojolicious')->to_abs_string;
    Mojo::Path->new('i/%E2%99%A5/mojolicious')->to_abs_string;
  
  =head2 parts
  
    my $parts = $path->parts;
    $path     = $path->parts([qw(foo bar baz)]);
  
  The path parts. Note that this method will normalize the path and that C<%2F>
  will be treated as C</> for security reasons.
  
    # Part with slash
    push @{$path->parts}, 'foo/bar';
  
  =head2 to_dir
  
    my $dir = $route->to_dir;
  
  Clone path and remove everything after the right-most slash.
  
    # "/i/%E2%99%A5/"
    Mojo::Path->new('/i/%E2%99%A5/mojolicious')->to_dir->to_abs_string;
  
    # "i/%E2%99%A5/"
    Mojo::Path->new('i/%E2%99%A5/mojolicious')->to_dir->to_abs_string;
  
  =head2 to_route
  
    my $route = $path->to_route;
  
  Turn path into a route.
  
    # "/i//mojolicious"
    Mojo::Path->new('/i/%E2%99%A5/mojolicious')->to_route;
    Mojo::Path->new('i/%E2%99%A5/mojolicious')->to_route;
  
  =head2 to_string
  
    my $str = $path->to_string;
  
  Turn path into a string.
  
    # "/i/%E2%99%A5/mojolicious"
    Mojo::Path->new('/i/%E2%99%A5/mojolicious')->to_string;
  
    # "i/%E2%99%A5/mojolicious"
    Mojo::Path->new('i/%E2%99%A5/mojolicious')->to_string;
  
  =head2 trailing_slash
  
    my $bool = $path->trailing_slash;
    $path    = $path->trailing_slash($bool);
  
  Path has a trailing slash. Note that this method will normalize the path and
  that C<%2F> will be treated as C</> for security reasons.
  
    # "/foo/bar/"
    Mojo::Path->new('/foo/bar')->trailing_slash(1);
  
    # "/foo/bar"
    Mojo::Path->new('/foo/bar/')->trailing_slash(0);
  
  =head1 OPERATORS
  
  L<Mojo::Path> overloads the following operators.
  
  =head2 array
  
    my @parts = @$path;
  
  Alias for L</"parts">. Note that this will normalize the path and that C<%2F>
  will be treated as C</> for security reasons.
  
    say $path->[0];
    say for @$path;
  
  =head2 bool
  
    my $bool = !!$path;
  
  Always true.
  
  =head2 stringify
  
    my $str = "$path";
  
  Alias for L</"to_string">.
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<http://mojolicious.org>.
  
  =cut
MOJO_PATH

$fatpacked{"Mojo/Reactor.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJO_REACTOR';
  package Mojo::Reactor;
  use Mojo::Base 'Mojo::EventEmitter';
  
  use Carp 'croak';
  use Config;
  use Mojo::Loader 'load_class';
  
  sub again { croak 'Method "again" not implemented by subclass' }
  
  sub detect {
    my $default = 'Mojo::Reactor::' . ($Config{d_pseudofork} ? 'Poll' : 'EV');
    my $try = $ENV{MOJO_REACTOR} || $default;
    return load_class($try) ? 'Mojo::Reactor::Poll' : $try;
  }
  
  sub io         { croak 'Method "io" not implemented by subclass' }
  sub is_running { croak 'Method "is_running" not implemented by subclass' }
  sub next_tick  { croak 'Method "next_tick" not implemented by subclass' }
  sub one_tick   { croak 'Method "one_tick" not implemented by subclass' }
  sub recurring  { croak 'Method "recurring" not implemented by subclass' }
  sub remove     { croak 'Method "remove" not implemented by subclass' }
  sub reset      { croak 'Method "reset" not implemented by subclass' }
  sub start      { croak 'Method "start" not implemented by subclass' }
  sub stop       { croak 'Method "stop" not implemented by subclass' }
  sub timer      { croak 'Method "timer" not implemented by subclass' }
  sub watch      { croak 'Method "watch" not implemented by subclass' }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojo::Reactor - Low-level event reactor base class
  
  =head1 SYNOPSIS
  
    package Mojo::Reactor::MyEventLoop;
    use Mojo::Base 'Mojo::Reactor';
  
    sub again      {...}
    sub io         {...}
    sub is_running {...}
    sub next_tick  {...}
    sub one_tick   {...}
    sub recurring  {...}
    sub remove     {...}
    sub reset      {...}
    sub start      {...}
    sub stop       {...}
    sub timer      {...}
    sub watch      {...}
  
  =head1 DESCRIPTION
  
  L<Mojo::Reactor> is an abstract base class for low-level event reactors, like
  L<Mojo::Reactor::EV> and L<Mojo::Reactor::Poll>.
  
  =head1 EVENTS
  
  L<Mojo::Reactor> inherits all events from L<Mojo::EventEmitter> and can emit
  the following new ones.
  
  =head2 error
  
    $reactor->on(error => sub {
      my ($reactor, $err) = @_;
      ...
    });
  
  Emitted for exceptions caught in callbacks, fatal if unhandled. Note that if
  this event is unhandled or fails it might kill your program, so you need to be
  careful.
  
    $reactor->on(error => sub {
      my ($reactor, $err) = @_;
      say "Something very bad happened: $err";
    });
  
  =head1 METHODS
  
  L<Mojo::Reactor> inherits all methods from L<Mojo::EventEmitter> and implements
  the following new ones.
  
  =head2 again
  
    $reactor->again($id);
  
  Restart timer. Meant to be overloaded in a subclass. Note that this method
  requires an active timer.
  
  =head2 detect
  
    my $class = Mojo::Reactor->detect;
  
  Detect and load the best reactor implementation available, will try the value
  of the C<MOJO_REACTOR> environment variable, L<Mojo::Reactor::EV> or
  L<Mojo::Reactor::Poll>.
  
    # Instantiate best reactor implementation available
    my $reactor = Mojo::Reactor->detect->new;
  
  =head2 io
  
    $reactor = $reactor->io($handle => sub {...});
  
  Watch handle for I/O events, invoking the callback whenever handle becomes
  readable or writable. Meant to be overloaded in a subclass.
  
    # Callback will be executed twice if handle becomes readable and writable
    $reactor->io($handle => sub {
      my ($reactor, $writable) = @_;
      say $writable ? 'Handle is writable' : 'Handle is readable';
    });
  
  =head2 is_running
  
    my $bool = $reactor->is_running;
  
  Check if reactor is running. Meant to be overloaded in a subclass.
  
  =head2 next_tick
  
    my $undef = $reactor->next_tick(sub {...});
  
  Execute callback as soon as possible, but not before returning or other
  callbacks that have been registered with this method, always returns C<undef>.
  Meant to be overloaded in a subclass.
  
  =head2 one_tick
  
    $reactor->one_tick;
  
  Run reactor until an event occurs. Note that this method can recurse back into
  the reactor, so you need to be careful. Meant to be overloaded in a subclass.
  
    # Don't block longer than 0.5 seconds
    my $id = $reactor->timer(0.5 => sub {});
    $reactor->one_tick;
    $reactor->remove($id);
  
  =head2 recurring
  
    my $id = $reactor->recurring(0.25 => sub {...});
  
  Create a new recurring timer, invoking the callback repeatedly after a given
  amount of time in seconds. Meant to be overloaded in a subclass.
  
  =head2 remove
  
    my $bool = $reactor->remove($handle);
    my $bool = $reactor->remove($id);
  
  Remove handle or timer. Meant to be overloaded in a subclass.
  
  =head2 reset
  
    $reactor->reset;
  
  Remove all handles and timers. Meant to be overloaded in a subclass.
  
  =head2 start
  
    $reactor->start;
  
  Start watching for I/O and timer events, this will block until L</"stop"> is
  called. Note that some reactors stop automatically if there are no events being
  watched anymore. Meant to be overloaded in a subclass.
  
    # Start reactor only if it is not running already
    $reactor->start unless $reactor->is_running;
  
  =head2 stop
  
    $reactor->stop;
  
  Stop watching for I/O and timer events. Meant to be overloaded in a subclass.
  
  =head2 timer
  
    my $id = $reactor->timer(0.5 => sub {...});
  
  Create a new timer, invoking the callback after a given amount of time in
  seconds. Meant to be overloaded in a subclass.
  
  =head2 watch
  
    $reactor = $reactor->watch($handle, $readable, $writable);
  
  Change I/O events to watch handle for with true and false values. Meant to be
  overloaded in a subclass. Note that this method requires an active I/O watcher.
  
    # Watch only for readable events
    $reactor->watch($handle, 1, 0);
  
    # Watch only for writable events
    $reactor->watch($handle, 0, 1);
  
    # Watch for readable and writable events
    $reactor->watch($handle, 1, 1);
  
    # Pause watching for events
    $reactor->watch($handle, 0, 0);
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<http://mojolicious.org>.
  
  =cut
MOJO_REACTOR

$fatpacked{"Mojo/Reactor/EV.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJO_REACTOR_EV';
  package Mojo::Reactor::EV;
  use Mojo::Base 'Mojo::Reactor::Poll';
  
  use Carp 'croak';
  use EV 4.0;
  
  my $EV;
  
  sub DESTROY { undef $EV }
  
  sub again {
    croak 'Timer not active' unless my $timer = shift->{timers}{shift()};
    $timer->{watcher}->again;
  }
  
  sub is_running { !!EV::depth }
  
  # We have to fall back to Mojo::Reactor::Poll, since EV is unique
  sub new { $EV++ ? Mojo::Reactor::Poll->new : shift->SUPER::new }
  
  sub one_tick { EV::run(EV::RUN_ONCE) }
  
  sub recurring { shift->_timer(1, @_) }
  
  sub start {EV::run}
  
  sub stop { EV::break(EV::BREAK_ALL) }
  
  sub timer { shift->_timer(0, @_) }
  
  sub watch {
    my ($self, $handle, $read, $write) = @_;
  
    my $fd = fileno $handle;
    croak 'I/O watcher not active' unless my $io = $self->{io}{$fd};
  
    my $mode = 0;
    $mode |= EV::READ  if $read;
    $mode |= EV::WRITE if $write;
  
    if ($mode == 0) { delete $io->{watcher} }
    elsif (my $w = $io->{watcher}) { $w->events($mode) }
    else {
      my $cb = sub {
        my ($w, $revents) = @_;
        $self->_try('I/O watcher', $self->{io}{$fd}{cb}, 0)
          if EV::READ & $revents;
        $self->_try('I/O watcher', $self->{io}{$fd}{cb}, 1)
          if EV::WRITE & $revents && $self->{io}{$fd};
      };
      $io->{watcher} = EV::io($fd, $mode, $cb);
    }
  
    return $self;
  }
  
  sub _timer {
    my ($self, $recurring, $after, $cb) = @_;
    $after ||= 0.0001 if $recurring;
  
    my $id      = $self->_id;
    my $wrapper = sub {
      delete $self->{timers}{$id} unless $recurring;
      $self->_try('Timer', $cb);
    };
    EV::now_update() if $after > 0;
    $self->{timers}{$id}{watcher} = EV::timer($after, $after, $wrapper);
  
    return $id;
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojo::Reactor::EV - Low-level event reactor with libev support
  
  =head1 SYNOPSIS
  
    use Mojo::Reactor::EV;
  
    # Watch if handle becomes readable or writable
    my $reactor = Mojo::Reactor::EV->new;
    $reactor->io($first => sub {
      my ($reactor, $writable) = @_;
      say $writable ? 'First handle is writable' : 'First handle is readable';
    });
  
    # Change to watching only if handle becomes writable
    $reactor->watch($first, 0, 1);
  
    # Turn file descriptor into handle and watch if it becomes readable
    my $second = IO::Handle->new_from_fd($fd, 'r');
    $reactor->io($second => sub {
      my ($reactor, $writable) = @_;
      say $writable ? 'Second handle is writable' : 'Second handle is readable';
    })->watch($second, 1, 0);
  
    # Add a timer
    $reactor->timer(15 => sub {
      my $reactor = shift;
      $reactor->remove($first);
      $reactor->remove($second);
      say 'Timeout!';
    });
  
    # Start reactor if necessary
    $reactor->start unless $reactor->is_running;
  
  =head1 DESCRIPTION
  
  L<Mojo::Reactor::EV> is a low-level event reactor based on L<EV> (4.0+).
  
  =head1 EVENTS
  
  L<Mojo::Reactor::EV> inherits all events from L<Mojo::Reactor::Poll>.
  
  =head1 METHODS
  
  L<Mojo::Reactor::EV> inherits all methods from L<Mojo::Reactor::Poll> and
  implements the following new ones.
  
  =head2 again
  
    $reactor->again($id);
  
  Restart timer. Note that this method requires an active timer.
  
  =head2 is_running
  
    my $bool = $reactor->is_running;
  
  Check if reactor is running.
  
  =head2 new
  
    my $reactor = Mojo::Reactor::EV->new;
  
  Construct a new L<Mojo::Reactor::EV> object.
  
  =head2 one_tick
  
    $reactor->one_tick;
  
  Run reactor until an event occurs or no events are being watched anymore.
  
    # Don't block longer than 0.5 seconds
    my $id = $reactor->timer(0.5 => sub {});
    $reactor->one_tick;
    $reactor->remove($id);
  
  =head2 recurring
  
    my $id = $reactor->recurring(0.25 => sub {...});
  
  Create a new recurring timer, invoking the callback repeatedly after a given
  amount of time in seconds.
  
  =head2 start
  
    $reactor->start;
  
  Start watching for I/O and timer events, this will block until L</"stop"> is
  called or no events are being watched anymore.
  
    # Start reactor only if it is not running already
    $reactor->start unless $reactor->is_running;
  
  =head2 stop
  
    $reactor->stop;
  
  Stop watching for I/O and timer events.
  
  =head2 timer
  
    my $id = $reactor->timer(0.5 => sub {...});
  
  Create a new timer, invoking the callback after a given amount of time in
  seconds.
  
  =head2 watch
  
    $reactor = $reactor->watch($handle, $readable, $writable);
  
  Change I/O events to watch handle for with true and false values. Note that
  this method requires an active I/O watcher.
  
    # Watch only for readable events
    $reactor->watch($handle, 1, 0);
  
    # Watch only for writable events
    $reactor->watch($handle, 0, 1);
  
    # Watch for readable and writable events
    $reactor->watch($handle, 1, 1);
  
    # Pause watching for events
    $reactor->watch($handle, 0, 0);
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<http://mojolicious.org>.
  
  =cut
MOJO_REACTOR_EV

$fatpacked{"Mojo/Reactor/Poll.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJO_REACTOR_POLL';
  package Mojo::Reactor::Poll;
  use Mojo::Base 'Mojo::Reactor';
  
  use Carp 'croak';
  use IO::Poll qw(POLLERR POLLHUP POLLIN POLLNVAL POLLOUT POLLPRI);
  use List::Util 'min';
  use Mojo::Util qw(md5_sum steady_time);
  use Time::HiRes 'usleep';
  
  sub again {
    croak 'Timer not active' unless my $timer = shift->{timers}{shift()};
    $timer->{time} = steady_time + $timer->{after};
  }
  
  sub io {
    my ($self, $handle, $cb) = @_;
    $self->{io}{fileno $handle} = {cb => $cb};
    return $self->watch($handle, 1, 1);
  }
  
  sub is_running { !!shift->{running} }
  
  sub next_tick {
    my ($self, $cb) = @_;
    push @{$self->{next_tick}}, $cb;
    $self->{next_timer} //= $self->timer(0 => \&_next);
    return undef;
  }
  
  sub one_tick {
    my $self = shift;
  
    # Just one tick
    local $self->{running} = 1 unless $self->{running};
  
    # Wait for one event
    my $i;
    until ($i || !$self->{running}) {
  
      # Stop automatically if there is nothing to watch
      return $self->stop unless keys %{$self->{timers}} || keys %{$self->{io}};
  
      # Calculate ideal timeout based on timers and round up to next millisecond
      my $min = min map { $_->{time} } values %{$self->{timers}};
      my $timeout = defined $min ? $min - steady_time : 0.5;
      $timeout = $timeout <= 0 ? 0 : int($timeout * 1000) + 1;
  
      # I/O
      if (keys %{$self->{io}}) {
        my @poll = map { $_ => $self->{io}{$_}{mode} } keys %{$self->{io}};
  
        # This may break in the future, but is worth it for performance
        if (IO::Poll::_poll($timeout, @poll) > 0) {
          while (my ($fd, $mode) = splice @poll, 0, 2) {
  
            if ($mode & (POLLIN | POLLPRI | POLLNVAL | POLLHUP | POLLERR)) {
              next unless my $io = $self->{io}{$fd};
              ++$i and $self->_try('I/O watcher', $io->{cb}, 0);
            }
            next unless $mode & POLLOUT && (my $io = $self->{io}{$fd});
            ++$i and $self->_try('I/O watcher', $io->{cb}, 1);
          }
        }
      }
  
      # Wait for timeout if poll can't be used
      elsif ($timeout) { usleep($timeout * 1000) }
  
      # Timers (time should not change in between timers)
      my $now = steady_time;
      for my $id (keys %{$self->{timers}}) {
        next unless my $t = $self->{timers}{$id};
        next unless $t->{time} <= $now;
  
        # Recurring timer
        if (exists $t->{recurring}) { $t->{time} = $now + $t->{recurring} }
  
        # Normal timer
        else { $self->remove($id) }
  
        ++$i and $self->_try('Timer', $t->{cb}) if $t->{cb};
      }
    }
  }
  
  sub recurring { shift->_timer(1, @_) }
  
  sub remove {
    my ($self, $remove) = @_;
    return !!delete $self->{timers}{$remove} unless ref $remove;
    return !!delete $self->{io}{fileno $remove};
  }
  
  sub reset { delete @{shift()}{qw(io next_tick next_timer timers)} }
  
  sub start {
    my $self = shift;
    $self->{running}++;
    $self->one_tick while $self->{running};
  }
  
  sub stop { delete shift->{running} }
  
  sub timer { shift->_timer(0, @_) }
  
  sub watch {
    my ($self, $handle, $read, $write) = @_;
  
    croak 'I/O watcher not active' unless my $io = $self->{io}{fileno $handle};
    $io->{mode} = 0;
    $io->{mode} |= POLLIN | POLLPRI if $read;
    $io->{mode} |= POLLOUT if $write;
  
    return $self;
  }
  
  sub _id {
    my $self = shift;
    my $id;
    do { $id = md5_sum 't' . steady_time . rand } while $self->{timers}{$id};
    return $id;
  }
  
  sub _next {
    my $self = shift;
    delete $self->{next_timer};
    while (my $cb = shift @{$self->{next_tick}}) { $self->$cb }
  }
  
  sub _timer {
    my ($self, $recurring, $after, $cb) = @_;
  
    my $id    = $self->_id;
    my $timer = $self->{timers}{$id}
      = {cb => $cb, after => $after, time => steady_time + $after};
    $timer->{recurring} = $after if $recurring;
  
    return $id;
  }
  
  sub _try {
    my ($self, $what, $cb) = (shift, shift, shift);
    eval { $self->$cb(@_); 1 } or $self->emit(error => "$what failed: $@");
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojo::Reactor::Poll - Low-level event reactor with poll support
  
  =head1 SYNOPSIS
  
    use Mojo::Reactor::Poll;
  
    # Watch if handle becomes readable or writable
    my $reactor = Mojo::Reactor::Poll->new;
    $reactor->io($first => sub {
      my ($reactor, $writable) = @_;
      say $writable ? 'First handle is writable' : 'First handle is readable';
    });
  
    # Change to watching only if handle becomes writable
    $reactor->watch($first, 0, 1);
  
    # Turn file descriptor into handle and watch if it becomes readable
    my $second = IO::Handle->new_from_fd($fd, 'r');
    $reactor->io($second => sub {
      my ($reactor, $writable) = @_;
      say $writable ? 'Second handle is writable' : 'Second handle is readable';
    })->watch($second, 1, 0);
  
    # Add a timer
    $reactor->timer(15 => sub {
      my $reactor = shift;
      $reactor->remove($first);
      $reactor->remove($second);
      say 'Timeout!';
    });
  
    # Start reactor if necessary
    $reactor->start unless $reactor->is_running;
  
  =head1 DESCRIPTION
  
  L<Mojo::Reactor::Poll> is a low-level event reactor based on L<IO::Poll>.
  
  =head1 EVENTS
  
  L<Mojo::Reactor::Poll> inherits all events from L<Mojo::Reactor>.
  
  =head1 METHODS
  
  L<Mojo::Reactor::Poll> inherits all methods from L<Mojo::Reactor> and
  implements the following new ones.
  
  =head2 again
  
    $reactor->again($id);
  
  Restart timer. Note that this method requires an active timer.
  
  =head2 io
  
    $reactor = $reactor->io($handle => sub {...});
  
  Watch handle for I/O events, invoking the callback whenever handle becomes
  readable or writable.
  
    # Callback will be executed twice if handle becomes readable and writable
    $reactor->io($handle => sub {
      my ($reactor, $writable) = @_;
      say $writable ? 'Handle is writable' : 'Handle is readable';
    });
  
  =head2 is_running
  
    my $bool = $reactor->is_running;
  
  Check if reactor is running.
  
  =head2 next_tick
  
    my $undef = $reactor->next_tick(sub {...});
  
  Execute callback as soon as possible, but not before returning or other
  callbacks that have been registered with this method, always returns C<undef>.
  
  =head2 one_tick
  
    $reactor->one_tick;
  
  Run reactor until an event occurs or no events are being watched anymore.
  
    # Don't block longer than 0.5 seconds
    my $id = $reactor->timer(0.5 => sub {});
    $reactor->one_tick;
    $reactor->remove($id);
  
  =head2 recurring
  
    my $id = $reactor->recurring(0.25 => sub {...});
  
  Create a new recurring timer, invoking the callback repeatedly after a given
  amount of time in seconds.
  
  =head2 remove
  
    my $bool = $reactor->remove($handle);
    my $bool = $reactor->remove($id);
  
  Remove handle or timer.
  
  =head2 reset
  
    $reactor->reset;
  
  Remove all handles and timers.
  
  =head2 start
  
    $reactor->start;
  
  Start watching for I/O and timer events, this will block until L</"stop"> is
  called or no events are being watched anymore.
  
    # Start reactor only if it is not running already
    $reactor->start unless $reactor->is_running;
  
  =head2 stop
  
    $reactor->stop;
  
  Stop watching for I/O and timer events.
  
  =head2 timer
  
    my $id = $reactor->timer(0.5 => sub {...});
  
  Create a new timer, invoking the callback after a given amount of time in
  seconds.
  
  =head2 watch
  
    $reactor = $reactor->watch($handle, $readable, $writable);
  
  Change I/O events to watch handle for with true and false values. Note that
  this method requires an active I/O watcher.
  
    # Watch only for readable events
    $reactor->watch($handle, 1, 0);
  
    # Watch only for writable events
    $reactor->watch($handle, 0, 1);
  
    # Watch for readable and writable events
    $reactor->watch($handle, 1, 1);
  
    # Pause watching for events
    $reactor->watch($handle, 0, 0);
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<http://mojolicious.org>.
  
  =cut
MOJO_REACTOR_POLL

$fatpacked{"Mojo/Server.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJO_SERVER';
  package Mojo::Server;
  use Mojo::Base 'Mojo::EventEmitter';
  
  use Carp 'croak';
  use Mojo::File 'path';
  use Mojo::Loader 'load_class';
  use Mojo::Util 'md5_sum';
  use POSIX ();
  use Scalar::Util 'blessed';
  
  has app           => sub { shift->build_app('Mojo::HelloWorld') };
  has reverse_proxy => sub { $ENV{MOJO_REVERSE_PROXY} };
  
  sub build_app {
    my ($self, $app) = (shift, shift);
    local $ENV{MOJO_EXE};
    return $self->app($app->new(@_))->app unless my $e = load_class $app;
    die ref $e ? $e : qq{Can't find application class "$app" in \@INC. (@INC)\n};
  }
  
  sub build_tx {
    my $self = shift;
    my $tx   = $self->app->build_tx;
    $tx->req->reverse_proxy(1) if $self->reverse_proxy;
    return $tx;
  }
  
  sub daemonize {
  
    # Fork and kill parent
    die "Can't fork: $!" unless defined(my $pid = fork);
    exit 0 if $pid;
    POSIX::setsid or die "Can't start a new session: $!";
  
    # Close filehandles
    open STDIN,  '</dev/null';
    open STDOUT, '>/dev/null';
    open STDERR, '>&STDOUT';
  }
  
  sub load_app {
    my ($self, $path) = @_;
  
    # Clean environment (reset FindBin defensively)
    {
      local $0 = $path = path($path)->to_abs->to_string;
      require FindBin;
      FindBin->again;
      local $ENV{MOJO_APP_LOADER} = 1;
      local $ENV{MOJO_EXE};
  
      # Try to load application from script into sandbox
      delete $INC{$path};
      my $app = eval
        "package Mojo::Server::Sandbox::@{[md5_sum $path]}; require \$path";
      die qq{Can't load application from file "$path": $@} if $@;
      die qq{File "$path" did not return an application object.\n}
        unless blessed $app && $app->isa('Mojo');
      $self->app($app);
    };
    FindBin->again;
  
    return $self->app;
  }
  
  sub new {
    my $self = shift->SUPER::new(@_);
    $self->on(request => sub { shift->app->handler(shift) });
    return $self;
  }
  
  sub run { croak 'Method "run" not implemented by subclass' }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojo::Server - HTTP/WebSocket server base class
  
  =head1 SYNOPSIS
  
    package Mojo::Server::MyServer;
    use Mojo::Base 'Mojo::Server';
  
    sub run {
      my $self = shift;
  
      # Get a transaction
      my $tx = $self->build_tx;
  
      # Emit "request" event
      $self->emit(request => $tx);
    }
  
  =head1 DESCRIPTION
  
  L<Mojo::Server> is an abstract base class for HTTP/WebSocket servers and server
  interfaces, like L<Mojo::Server::CGI>, L<Mojo::Server::Daemon>,
  L<Mojo::Server::Hypnotoad>, L<Mojo::Server::Morbo>, L<Mojo::Server::Prefork>
  and L<Mojo::Server::PSGI>.
  
  =head1 EVENTS
  
  L<Mojo::Server> inherits all events from L<Mojo::EventEmitter> and can emit the
  following new ones.
  
  =head2 request
  
    $server->on(request => sub {
      my ($server, $tx) = @_;
      ...
    });
  
  Emitted when a request is ready and needs to be handled.
  
    $server->unsubscribe('request')->on(request => sub {
      my ($server, $tx) = @_;
      $tx->res->code(200);
      $tx->res->headers->content_type('text/plain');
      $tx->res->body('Hello World!');
      $tx->resume;
    });
  
  =head1 ATTRIBUTES
  
  L<Mojo::Server> implements the following attributes.
  
  =head2 app
  
    my $app = $server->app;
    $server = $server->app(MojoSubclass->new);
  
  Application this server handles, defaults to a L<Mojo::HelloWorld> object.
  
  =head2 reverse_proxy
  
    my $bool = $server->reverse_proxy;
    $server  = $server->reverse_proxy($bool);
  
  This server operates behind a reverse proxy, defaults to the value of the
  C<MOJO_REVERSE_PROXY> environment variable.
  
  =head1 METHODS
  
  L<Mojo::Server> inherits all methods from L<Mojo::EventEmitter> and implements
  the following new ones.
  
  =head2 build_app
  
    my $app = $server->build_app('MyApp');
    my $app = $server->build_app('MyApp', log => Mojo::Log->new);
    my $app = $server->build_app('MyApp', {log => Mojo::Log->new});
  
  Build application from class and assign it to L</"app">.
  
  =head2 build_tx
  
    my $tx = $server->build_tx;
  
  Let application build a transaction.
  
  =head2 daemonize
  
    $server->daemonize;
  
  Daemonize server process.
  
  =head2 load_app
  
    my $app = $server->load_app('/home/sri/myapp.pl');
  
  Load application from script and assign it to L</"app">.
  
    say Mojo::Server->new->load_app('./myapp.pl')->home;
  
  =head2 new
  
    my $server = Mojo::Server->new;
    my $server = Mojo::Server->new(reverse_proxy => 1);
    my $server = Mojo::Server->new({reverse_proxy => 1});
  
  Construct a new L<Mojo::Server> object and subscribe to L</"request"> event
  with default request handling.
  
  =head2 run
  
    $server->run;
  
  Run server. Meant to be overloaded in a subclass.
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<http://mojolicious.org>.
  
  =cut
MOJO_SERVER

$fatpacked{"Mojo/Server/CGI.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJO_SERVER_CGI';
  package Mojo::Server::CGI;
  use Mojo::Base 'Mojo::Server';
  
  has 'nph';
  
  sub run {
    my $self = shift;
  
    my $tx  = $self->build_tx;
    my $req = $tx->req->parse(\%ENV);
    $tx->local_port($ENV{SERVER_PORT})->remote_address($ENV{REMOTE_ADDR});
  
    # Request body (may block if we try to read too much)
    binmode STDIN;
    my $len = $req->headers->content_length;
    until ($req->is_finished) {
      my $chunk = ($len && $len < 131072) ? $len : 131072;
      last unless my $read = STDIN->read(my $buffer, $chunk, 0);
      $req->parse($buffer);
      last if ($len -= $read) <= 0;
    }
  
    $self->emit(request => $tx);
  
    # Response start-line
    STDOUT->autoflush(1);
    binmode STDOUT;
    my $res = $tx->res->fix_headers;
    return undef if $self->nph && !_write($res, 'get_start_line_chunk');
  
    # Response headers
    my $code = $res->code    || 404;
    my $msg  = $res->message || $res->default_message;
    $res->headers->status("$code $msg") unless $self->nph;
    return undef unless _write($res, 'get_header_chunk');
  
    # Response body
    return undef unless $tx->is_empty || _write($res, 'get_body_chunk');
  
    # Finish transaction
    $tx->closed;
  
    return $res->code;
  }
  
  sub _write {
    my ($res, $method) = @_;
  
    my $offset = 0;
    while (1) {
  
      # No chunk yet, try again
      sleep 1 and next unless defined(my $chunk = $res->$method($offset));
  
      # End of part
      last unless my $len = length $chunk;
  
      # Make sure we can still write
      $offset += $len;
      return undef unless STDOUT->opened;
      print STDOUT $chunk;
    }
  
    return 1;
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojo::Server::CGI - CGI server
  
  =head1 SYNOPSIS
  
    use Mojo::Server::CGI;
  
    my $cgi = Mojo::Server::CGI->new;
    $cgi->unsubscribe('request')->on(request => sub {
      my ($cgi, $tx) = @_;
  
      # Request
      my $method = $tx->req->method;
      my $path   = $tx->req->url->path;
  
      # Response
      $tx->res->code(200);
      $tx->res->headers->content_type('text/plain');
      $tx->res->body("$method request for $path!");
  
      # Resume transaction
      $tx->resume;
    });
    $cgi->run;
  
  =head1 DESCRIPTION
  
  L<Mojo::Server::CGI> is a simple and portable implementation of
  L<RFC 3875|http://tools.ietf.org/html/rfc3875>.
  
  See L<Mojolicious::Guides::Cookbook/"DEPLOYMENT"> for more.
  
  =head1 EVENTS
  
  L<Mojo::Server::CGI> inherits all events from L<Mojo::Server>.
  
  =head1 ATTRIBUTES
  
  L<Mojo::Server::CGI> inherits all attributes from L<Mojo::Server> and
  implements the following new ones.
  
  =head2 nph
  
    my $bool = $cgi->nph;
    $cgi     = $cgi->nph($bool);
  
  Activate non-parsed header mode.
  
  =head1 METHODS
  
  L<Mojo::Server::CGI> inherits all methods from L<Mojo::Server> and implements
  the following new ones.
  
  =head2 run
  
    my $status = $cgi->run;
  
  Run CGI.
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<http://mojolicious.org>.
  
  =cut
MOJO_SERVER_CGI

$fatpacked{"Mojo/Server/Daemon.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJO_SERVER_DAEMON';
  package Mojo::Server::Daemon;
  use Mojo::Base 'Mojo::Server';
  
  use Carp 'croak';
  use Mojo::IOLoop;
  use Mojo::Transaction::WebSocket;
  use Mojo::URL;
  use Mojo::Util 'term_escape';
  use Mojo::WebSocket 'server_handshake';
  use Scalar::Util 'weaken';
  
  use constant DEBUG => $ENV{MOJO_DAEMON_DEBUG} || 0;
  
  has acceptors => sub { [] };
  has [qw(backlog max_clients silent)];
  has inactivity_timeout => sub { $ENV{MOJO_INACTIVITY_TIMEOUT} // 15 };
  has ioloop => sub { Mojo::IOLoop->singleton };
  has listen => sub { [split ',', $ENV{MOJO_LISTEN} || 'http://*:3000'] };
  has max_requests => 100;
  
  sub DESTROY {
    return if Mojo::Util::_global_destruction();
    my $self = shift;
    my $loop = $self->ioloop;
    $loop->remove($_) for keys %{$self->{connections} || {}}, @{$self->acceptors};
  }
  
  sub close_idle_connections {
    my $self = shift;
    my $c    = $self->{connections};
    my $loop = $self->ioloop;
    !$c->{$_}{tx} and $c->{$_}{requests} and $loop->remove($_) for keys %$c;
  }
  
  sub ports {
    [map { $_[0]->ioloop->acceptor($_)->port } @{$_[0]->acceptors}];
  }
  
  sub run {
    my $self = shift;
  
    # Make sure the event loop can be stopped in regular intervals
    my $loop = $self->ioloop;
    my $int = $loop->recurring(1 => sub { });
    local $SIG{INT} = local $SIG{TERM} = sub { $loop->stop };
    $self->start->ioloop->start;
    $loop->remove($int);
  }
  
  sub start {
    my $self = shift;
  
    my $loop = $self->ioloop;
    if (my $max = $self->max_clients) { $loop->max_connections($max) }
  
    # Resume accepting connections
    if (my $servers = $self->{servers}) {
      push @{$self->acceptors}, $loop->acceptor(delete $servers->{$_})
        for keys %$servers;
    }
  
    # Start listening
    elsif (!@{$self->acceptors}) { $self->_listen($_) for @{$self->listen} }
  
    return $self;
  }
  
  sub stop {
    my $self = shift;
  
    # Suspend accepting connections but keep listen sockets open
    my $loop = $self->ioloop;
    while (my $id = shift @{$self->acceptors}) {
      my $server = $self->{servers}{$id} = $loop->acceptor($id);
      $loop->remove($id);
      $server->stop;
    }
  
    return $self;
  }
  
  sub _build_tx {
    my ($self, $id, $c) = @_;
  
    my $tx = $self->build_tx->connection($id);
    $tx->res->headers->server('Mojolicious (Perl)');
    my $handle = $self->ioloop->stream($id)->handle;
    unless ($handle->isa('IO::Socket::UNIX')) {
      $tx->local_address($handle->sockhost)->local_port($handle->sockport);
      $tx->remote_address($handle->peerhost)->remote_port($handle->peerport);
    }
    $tx->req->url->base->scheme('https') if $c->{tls};
  
    weaken $self;
    $tx->on(
      request => sub {
        my $tx = shift;
  
        # WebSocket
        if ($tx->req->is_handshake) {
          my $ws = $self->{connections}{$id}{next}
            = Mojo::Transaction::WebSocket->new(handshake => $tx);
          $self->emit(request => server_handshake $ws);
        }
  
        # HTTP
        else { $self->emit(request => $tx) }
  
        # Last keep-alive request or corrupted connection
        my $c = $self->{connections}{$id};
        $tx->res->headers->connection('close')
          if $c->{requests} >= $self->max_requests || $tx->req->error;
  
        $tx->on(resume => sub { $self->_write($id) });
        $self->_write($id);
      }
    );
  
    # Kept alive if we have more than one request on the connection
    return ++$c->{requests} > 1 ? $tx->kept_alive(1) : $tx;
  }
  
  sub _close {
    my ($self, $id) = @_;
    if (my $tx = $self->{connections}{$id}{tx}) { $tx->closed }
    delete $self->{connections}{$id};
  }
  
  sub _debug { $_[0]->app->log->debug($_[2]) if $_[0]{connections}{$_[1]}{tx} }
  
  sub _finish {
    my ($self, $id) = @_;
  
    # Always remove connection for WebSockets
    my $c = $self->{connections}{$id};
    return unless my $tx = $c->{tx};
    return $self->_remove($id) if $tx->is_websocket;
  
    # Finish transaction
    delete($c->{tx})->closed;
  
    # Upgrade connection to WebSocket
    if (my $ws = delete $c->{next}) {
  
      # Successful upgrade
      if ($ws->handshake->res->code == 101) {
        $c->{tx} = $ws->established(1);
        weaken $self;
        $ws->on(resume => sub { $self->_write($id) });
        $self->_write($id);
      }
  
      # Failed upgrade
      else { $ws->closed }
    }
  
    # Close connection if necessary
    return $self->_remove($id) if $tx->error || !$tx->keep_alive;
  
    # Build new transaction for leftovers
    return unless length(my $leftovers = $tx->req->content->leftovers);
    $tx = $c->{tx} = $self->_build_tx($id, $c);
    $tx->server_read($leftovers);
  }
  
  sub _listen {
    my ($self, $listen) = @_;
  
    my $url   = Mojo::URL->new($listen);
    my $proto = $url->protocol;
    croak qq{Invalid listen location "$listen"}
      unless $proto eq 'http' || $proto eq 'https' || $proto eq 'http+unix';
  
    my $query   = $url->query;
    my $options = {
      backlog       => $self->backlog,
      single_accept => $query->param('single_accept'),
      reuse         => $query->param('reuse')
    };
    if ($proto eq 'http+unix') { $options->{path} = $url->host }
    else {
      if ((my $host = $url->host) ne '*') { $options->{address} = $host }
      if (my $port = $url->port) { $options->{port} = $port }
    }
    $options->{"tls_$_"} = $query->param($_) for qw(ca ciphers version);
    /^(.*)_(cert|key)$/ and $options->{"tls_$2"}{$1} = $query->param($_)
      for @{$query->names};
    if (my $cert = $query->param('cert')) { $options->{'tls_cert'}{''} = $cert }
    if (my $key  = $query->param('key'))  { $options->{'tls_key'}{''}  = $key }
    my $verify = $query->param('verify');
    $options->{tls_verify} = hex $verify if defined $verify;
    my $tls = $options->{tls} = $proto eq 'https';
  
    weaken $self;
    push @{$self->acceptors}, $self->ioloop->server(
      $options => sub {
        my ($loop, $stream, $id) = @_;
  
        $self->{connections}{$id} = {tls => $tls};
        warn "-- Accept $id (@{[$stream->handle->peerhost]})\n" if DEBUG;
        $stream->timeout($self->inactivity_timeout);
  
        $stream->on(close => sub { $self && $self->_close($id) });
        $stream->on(error =>
            sub { $self && $self->app->log->error(pop) && $self->_close($id) });
        $stream->on(read => sub { $self->_read($id => pop) });
        $stream->on(timeout => sub { $self->_debug($id, 'Inactivity timeout') });
      }
    );
  
    return if $self->silent;
    $self->app->log->info(qq{Listening at "$url"});
    $query->pairs([]);
    $url->host('127.0.0.1') if $url->host eq '*';
    say 'Server available at ', $options->{path} // $url;
  }
  
  sub _read {
    my ($self, $id, $chunk) = @_;
  
    # Make sure we have a transaction
    my $c = $self->{connections}{$id};
    my $tx = $c->{tx} ||= $self->_build_tx($id, $c);
    warn term_escape "-- Server <<< Client (@{[_url($tx)]})\n$chunk\n" if DEBUG;
    $tx->server_read($chunk);
  }
  
  sub _remove {
    my ($self, $id) = @_;
    $self->ioloop->remove($id);
    $self->_close($id);
  }
  
  sub _url { shift->req->url->to_abs }
  
  sub _write {
    my ($self, $id) = @_;
  
    # Protect from resume event recursion
    my $c = $self->{connections}{$id};
    return if !(my $tx = $c->{tx}) || $c->{writing};
    local $c->{writing} = 1;
    my $chunk = $tx->server_write;
    warn term_escape "-- Server >>> Client (@{[_url($tx)]})\n$chunk\n" if DEBUG;
    my $next = $tx->is_finished ? '_finish' : length $chunk ? '_write' : undef;
    return $self->ioloop->stream($id)->write($chunk) unless $next;
    weaken $self;
    $self->ioloop->stream($id)->write($chunk => sub { $self->$next($id) });
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojo::Server::Daemon - Non-blocking I/O HTTP and WebSocket server
  
  =head1 SYNOPSIS
  
    use Mojo::Server::Daemon;
  
    my $daemon = Mojo::Server::Daemon->new(listen => ['http://*:8080']);
    $daemon->unsubscribe('request')->on(request => sub {
      my ($daemon, $tx) = @_;
  
      # Request
      my $method = $tx->req->method;
      my $path   = $tx->req->url->path;
  
      # Response
      $tx->res->code(200);
      $tx->res->headers->content_type('text/plain');
      $tx->res->body("$method request for $path!");
  
      # Resume transaction
      $tx->resume;
    });
    $daemon->run;
  
  =head1 DESCRIPTION
  
  L<Mojo::Server::Daemon> is a full featured, highly portable non-blocking I/O
  HTTP and WebSocket server, with IPv6, TLS, SNI, Comet (long polling), keep-alive
  and multiple event loop support.
  
  For better scalability (epoll, kqueue) and to provide non-blocking name
  resolution, SOCKS5 as well as TLS support, the optional modules L<EV> (4.0+),
  L<Net::DNS::Native> (0.15+), L<IO::Socket::Socks> (0.64+) and
  L<IO::Socket::SSL> (1.94+) will be used automatically if possible. Individual
  features can also be disabled with the C<MOJO_NO_NNR>, C<MOJO_NO_SOCKS> and
  C<MOJO_NO_TLS> environment variables.
  
  See L<Mojolicious::Guides::Cookbook/"DEPLOYMENT"> for more.
  
  =head1 SIGNALS
  
  The L<Mojo::Server::Daemon> process can be controlled at runtime with the
  following signals.
  
  =head2 INT, TERM
  
  Shut down server immediately.
  
  =head1 EVENTS
  
  L<Mojo::Server::Daemon> inherits all events from L<Mojo::Server>.
  
  =head1 ATTRIBUTES
  
  L<Mojo::Server::Daemon> inherits all attributes from L<Mojo::Server> and
  implements the following new ones.
  
  =head2 acceptors
  
    my $acceptors = $daemon->acceptors;
    $daemon       = $daemon->acceptors(['6be0c140ef00a389c5d039536b56d139']);
  
  Active acceptor ids.
  
    # Check port
    mu $port = $daemon->ioloop->acceptor($daemon->acceptors->[0])->port;
  
  =head2 backlog
  
    my $backlog = $daemon->backlog;
    $daemon     = $daemon->backlog(128);
  
  Listen backlog size, defaults to C<SOMAXCONN>.
  
  =head2 inactivity_timeout
  
    my $timeout = $daemon->inactivity_timeout;
    $daemon     = $daemon->inactivity_timeout(5);
  
  Maximum amount of time in seconds a connection can be inactive before getting
  closed, defaults to the value of the C<MOJO_INACTIVITY_TIMEOUT> environment
  variable or C<15>. Setting the value to C<0> will allow connections to be
  inactive indefinitely.
  
  =head2 ioloop
  
    my $loop = $daemon->ioloop;
    $daemon  = $daemon->ioloop(Mojo::IOLoop->new);
  
  Event loop object to use for I/O operations, defaults to the global
  L<Mojo::IOLoop> singleton.
  
  =head2 listen
  
    my $listen = $daemon->listen;
    $daemon    = $daemon->listen(['https://127.0.0.1:8080']);
  
  Array reference with one or more locations to listen on, defaults to the value
  of the C<MOJO_LISTEN> environment variable or C<http://*:3000> (shortcut for
  C<http://0.0.0.0:3000>).
  
    # Listen on all IPv4 interfaces
    $daemon->listen(['http://*:3000']);
  
    # Listen on all IPv4 and IPv6 interfaces
    $daemon->listen(['http://[::]:3000']);
  
    # Listen on IPv6 interface
    $daemon->listen(['http://[::1]:4000']);
  
    # Listen on IPv4 and IPv6 interfaces
    $daemon->listen(['http://127.0.0.1:3000', 'http://[::1]:3000']);
  
    # Listen on UNIX domain socket "/tmp/myapp.sock" (percent encoded slash)
    $daemon->listen(['http+unix://%2Ftmp%2Fmyapp.sock']);
  
    # Allow multiple servers to use the same port (SO_REUSEPORT)
    $daemon->listen(['http://*:8080?reuse=1']);
  
    # Listen on two ports with HTTP and HTTPS at the same time
    $daemon->listen(['http://*:3000', 'https://*:4000']);
  
    # Use a custom certificate and key
    $daemon->listen(['https://*:3000?cert=/x/server.crt&key=/y/server.key']);
  
    # Domain specific certificates and keys (SNI)
    $daemon->listen(
      ['https://*:3000?example.com_cert=/x/my.crt&example.com_key=/y/my.key']);
  
    # Or even a custom certificate authority
    $daemon->listen(
      ['https://*:3000?cert=/x/server.crt&key=/y/server.key&ca=/z/ca.crt']);
  
  These parameters are currently available:
  
  =over 2
  
  =item ca
  
    ca=/etc/tls/ca.crt
  
  Path to TLS certificate authority file used to verify the peer certificate.
  
  =item cert
  
    cert=/etc/tls/server.crt
    mojolicious.org_cert=/etc/tls/mojo.crt
  
  Path to the TLS cert file, defaults to a built-in test certificate.
  
  =item ciphers
  
    ciphers=AES128-GCM-SHA256:RC4:HIGH:!MD5:!aNULL:!EDH
  
  TLS cipher specification string. For more information about the format see
  L<https://www.openssl.org/docs/manmaster/apps/ciphers.html#CIPHER-STRINGS>.
  
  =item key
  
    key=/etc/tls/server.key
    mojolicious.org_key=/etc/tls/mojo.key
  
  Path to the TLS key file, defaults to a built-in test key.
  
  =item reuse
  
    reuse=1
  
  Allow multiple servers to use the same port with the C<SO_REUSEPORT> socket
  option.
  
  =item single_accept
  
    single_accept=1
  
  Only accept one connection at a time.
  
  =item verify
  
    verify=0x00
  
  TLS verification mode, defaults to C<0x03> if a certificate authority file has
  been provided, or C<0x00>.
  
  =item version
  
    version=TLSv1_2
  
  TLS protocol version.
  
  =back
  
  =head2 max_clients
  
    my $max = $daemon->max_clients;
    $daemon = $daemon->max_clients(100);
  
  Maximum number of accepted connections this server is allowed to handle
  concurrently, before stopping to accept new incoming connections, passed along
  to L<Mojo::IOLoop/"max_connections">.
  
  =head2 max_requests
  
    my $max = $daemon->max_requests;
    $daemon = $daemon->max_requests(250);
  
  Maximum number of keep-alive requests per connection, defaults to C<100>.
  
  =head2 silent
  
    my $bool = $daemon->silent;
    $daemon  = $daemon->silent($bool);
  
  Disable console messages.
  
  =head1 METHODS
  
  L<Mojo::Server::Daemon> inherits all methods from L<Mojo::Server> and
  implements the following new ones.
  
  =head2 close_idle_connections
  
    $daemon->close_idle_connections;
  
  Close all connections without active requests. Note that this method is
  EXPERIMENTAL and might change without warning!
  
  =head2 ports
  
    my $ports = $daemon->ports;
  
  Get all ports this server is currently listening on.
  
    # All ports
    say for @{$daemon->ports};
  
  =head2 run
  
    $daemon->run;
  
  Run server and wait for L</"SIGNALS">.
  
  =head2 start
  
    $daemon = $daemon->start;
  
  Start or resume accepting connections through L</"ioloop">.
  
    # Listen on random port
    my $port = $daemon->listen(['http://127.0.0.1'])->start->ports->[0];
  
    # Run multiple web servers concurrently
    my $daemon1 = Mojo::Server::Daemon->new(listen => ['http://*:3000'])->start;
    my $daemon2 = Mojo::Server::Daemon->new(listen => ['http://*:4000'])->start;
    Mojo::IOLoop->start unless Mojo::IOLoop->is_running;
  
  =head2 stop
  
    $daemon = $daemon->stop;
  
  Stop accepting connections through L</"ioloop">.
  
  =head1 DEBUGGING
  
  You can set the C<MOJO_DAEMON_DEBUG> environment variable to get some advanced
  diagnostics information printed to C<STDERR>.
  
    MOJO_DAEMON_DEBUG=1
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<http://mojolicious.org>.
  
  =cut
MOJO_SERVER_DAEMON

$fatpacked{"Mojo/Server/Hypnotoad.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJO_SERVER_HYPNOTOAD';
  package Mojo::Server::Hypnotoad;
  use Mojo::Base -base;
  
  # "Bender: I was God once.
  #  God: Yes, I saw. You were doing well, until everyone died."
  use Config;
  use Mojo::File 'path';
  use Mojo::Server::Prefork;
  use Mojo::Util 'steady_time';
  use Scalar::Util 'weaken';
  
  has prefork => sub { Mojo::Server::Prefork->new(listen => ['http://*:8080']) };
  has upgrade_timeout => 60;
  
  sub configure {
    my ($self, $name) = @_;
  
    # Hypnotoad settings
    my $prefork = $self->prefork;
    my $c = $prefork->app->config($name) || {};
    $self->upgrade_timeout($c->{upgrade_timeout}) if $c->{upgrade_timeout};
  
    # Pre-fork settings
    $prefork->reverse_proxy($c->{proxy})   if defined $c->{proxy};
    $prefork->max_clients($c->{clients})   if $c->{clients};
    $prefork->max_requests($c->{requests}) if $c->{requests};
    defined $c->{$_} and $prefork->$_($c->{$_})
      for qw(accepts backlog graceful_timeout heartbeat_interval),
      qw(heartbeat_timeout inactivity_timeout listen pid_file workers);
  }
  
  sub run {
    my ($self, $app) = @_;
  
    # No fork emulation support
    _exit('Hypnotoad does not support fork emulation.') if $Config{d_pseudofork};
  
    # Remember executable and application for later
    $ENV{HYPNOTOAD_EXE} ||= $0;
    $0 = $ENV{HYPNOTOAD_APP} ||= path($app)->to_abs->to_string;
  
    # This is a production server
    $ENV{MOJO_MODE} ||= 'production';
  
    # Clean start (to make sure everything works)
    die "Can't exec: $!"
      if !$ENV{HYPNOTOAD_REV}++ && !exec $^X, $ENV{HYPNOTOAD_EXE};
  
    # Preload application and configure server
    my $prefork = $self->prefork->cleanup(0);
    $prefork->load_app($app)->config->{hypnotoad}{pid_file}
      //= path($ENV{HYPNOTOAD_APP})->sibling('hypnotoad.pid')->to_string;
    $self->configure('hypnotoad');
    weaken $self;
    $prefork->on(wait   => sub { $self->_manage });
    $prefork->on(reap   => sub { $self->_cleanup(pop) });
    $prefork->on(finish => sub { $self->_finish });
  
    # Testing
    _exit('Everything looks good!') if $ENV{HYPNOTOAD_TEST};
  
    # Stop running server
    $self->_stop if $ENV{HYPNOTOAD_STOP};
  
    # Initiate hot deployment
    $self->_hot_deploy unless $ENV{HYPNOTOAD_PID};
  
    # Daemonize as early as possible (but not for restarts)
    $prefork->start;
    $prefork->daemonize if !$ENV{HYPNOTOAD_FOREGROUND} && $ENV{HYPNOTOAD_REV} < 3;
  
    # Start accepting connections
    local $SIG{USR2} = sub { $self->{upgrade} ||= steady_time };
    $prefork->cleanup(1)->run;
  }
  
  sub _cleanup {
    my ($self, $pid) = @_;
  
    # Clean up failed upgrade
    return unless ($self->{new} || '') eq $pid;
    $self->prefork->app->log->error('Zero downtime software upgrade failed');
    delete @$self{qw(new upgrade)};
  }
  
  sub _exit { say shift and exit 0 }
  
  sub _finish {
    my $self = shift;
  
    $self->{finish} = 1;
    return unless my $new = $self->{new};
  
    my $prefork = $self->prefork->cleanup(0);
    unlink $prefork->pid_file;
    $prefork->ensure_pid_file($new);
  }
  
  sub _hot_deploy {
  
    # Make sure server is running
    return unless my $pid = shift->prefork->check_pid;
  
    # Start hot deployment
    kill 'USR2', $pid;
    _exit("Starting hot deployment for Hypnotoad server $pid.");
  }
  
  sub _manage {
    my $self = shift;
  
    # Upgraded (wait for all workers to send a heartbeat)
    my $prefork = $self->prefork;
    my $log     = $prefork->app->log;
    if ($ENV{HYPNOTOAD_PID} && $ENV{HYPNOTOAD_PID} ne $$) {
      return unless $prefork->healthy == $prefork->workers;
      $log->info("Upgrade successful, stopping $ENV{HYPNOTOAD_PID}");
      kill 'QUIT', $ENV{HYPNOTOAD_PID};
    }
    $ENV{HYPNOTOAD_PID} = $$ unless ($ENV{HYPNOTOAD_PID} // '') eq $$;
  
    # Upgrade
    if ($self->{upgrade} && !$self->{finished}) {
  
      # Fresh start
      unless ($self->{new}) {
        $log->info('Starting zero downtime software upgrade');
        die "Can't fork: $!" unless defined(my $pid = $self->{new} = fork);
        exec $^X, $ENV{HYPNOTOAD_EXE} or die "Can't exec: $!" unless $pid;
      }
  
      # Timeout
      kill 'KILL', $self->{new}
        if $self->{upgrade} + $self->upgrade_timeout <= steady_time;
    }
  }
  
  sub _stop {
    _exit('Hypnotoad server not running.')
      unless my $pid = shift->prefork->check_pid;
    kill 'QUIT', $pid;
    _exit("Stopping Hypnotoad server $pid gracefully.");
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojo::Server::Hypnotoad - A production web serv...ALL GLORY TO THE HYPNOTOAD!
  
  =head1 SYNOPSIS
  
    use Mojo::Server::Hypnotoad;
  
    my $hypnotoad = Mojo::Server::Hypnotoad->new;
    $hypnotoad->run('/home/sri/myapp.pl');
  
  =head1 DESCRIPTION
  
  L<Mojo::Server::Hypnotoad> is a full featured, UNIX optimized, pre-forking
  non-blocking I/O HTTP and WebSocket server, built around the very well tested
  and reliable L<Mojo::Server::Prefork>, with IPv6, TLS, SNI, UNIX domain socket,
  Comet (long polling), keep-alive, multiple event loop and hot deployment support
  that just works. Note that the server uses signals for process management, so
  you should avoid modifying signal handlers in your applications.
  
  To start applications with it you can use the L<hypnotoad> script, which
  listens on port C<8080>, automatically daemonizes the server process and
  defaults to C<production> mode for L<Mojolicious> and L<Mojolicious::Lite>
  applications.
  
    $ hypnotoad ./myapp.pl
  
  You can run the same command again for automatic hot deployment.
  
    $ hypnotoad ./myapp.pl
    Starting hot deployment for Hypnotoad server 31841.
  
  This second invocation will load the application again, detect the process id
  file with it, and send a L</"USR2"> signal to the already running server.
  
  For better scalability (epoll, kqueue) and to provide non-blocking name
  resolution, SOCKS5 as well as TLS support, the optional modules L<EV> (4.0+),
  L<Net::DNS::Native> (0.15+), L<IO::Socket::Socks> (0.64+) and
  L<IO::Socket::SSL> (1.94+) will be used automatically if possible. Individual
  features can also be disabled with the C<MOJO_NO_NNR>, C<MOJO_NO_SOCKS> and
  C<MOJO_NO_TLS> environment variables.
  
  See L<Mojolicious::Guides::Cookbook/"DEPLOYMENT"> for more.
  
  =head1 MANAGER SIGNALS
  
  The L<Mojo::Server::Hypnotoad> manager process can be controlled at runtime
  with the following signals.
  
  =head2 INT, TERM
  
  Shut down server immediately.
  
  =head2 QUIT
  
  Shut down server gracefully.
  
  =head2 TTIN
  
  Increase worker pool by one.
  
  =head2 TTOU
  
  Decrease worker pool by one.
  
  =head2 USR2
  
  Attempt zero downtime software upgrade (hot deployment) without losing any
  incoming connections.
  
    Manager (old)
    |- Worker [1]
    |- Worker [2]
    |- Worker [3]
    |- Worker [4]
    +- Manager (new)
       |- Worker [1]
       |- Worker [2]
       |- Worker [3]
       +- Worker [4]
  
  The new manager will automatically send a L</"QUIT"> signal to the old manager
  and take over serving requests after starting up successfully.
  
  =head1 WORKER SIGNALS
  
  L<Mojo::Server::Hypnotoad> worker processes can be controlled at runtime with
  the following signals.
  
  =head2 QUIT
  
  Stop worker gracefully.
  
  =head1 SETTINGS
  
  L<Mojo::Server::Hypnotoad> can be configured with the following settings, see
  L<Mojolicious::Guides::Cookbook/"Hypnotoad"> for examples.
  
  =head2 accepts
  
    accepts => 100
  
  Maximum number of connections a worker is allowed to accept, before stopping
  gracefully and then getting replaced with a newly started worker, defaults to
  the value of L<Mojo::Server::Prefork/"accepts">. Setting the value to C<0> will
  allow workers to accept new connections indefinitely. Note that up to half of
  this value can be subtracted randomly to improve load balancing, and to make
  sure that not all workers restart at the same time.
  
  =head2 backlog
  
    backlog => 128
  
  Listen backlog size, defaults to the value of
  L<Mojo::Server::Daemon/"backlog">.
  
  =head2 clients
  
    clients => 100
  
  Maximum number of accepted connections each worker process is allowed to handle
  concurrently, before stopping to accept new incoming connections, defaults to
  the value of L<Mojo::IOLoop/"max_connections">. Note that high concurrency works
  best with applications that perform mostly non-blocking operations, to optimize
  for blocking operations you can decrease this value and increase L</"workers">
  instead for better performance.
  
  =head2 graceful_timeout
  
    graceful_timeout => 15
  
  Maximum amount of time in seconds stopping a worker gracefully may take before
  being forced, defaults to the value of
  L<Mojo::Server::Prefork/"graceful_timeout">. Note that this value should usually
  be a little larger than the maximum amount of time you expect any one request to
  take.
  
  =head2 heartbeat_interval
  
    heartbeat_interval => 3
  
  Heartbeat interval in seconds, defaults to the value of
  L<Mojo::Server::Prefork/"heartbeat_interval">.
  
  =head2 heartbeat_timeout
  
    heartbeat_timeout => 2
  
  Maximum amount of time in seconds before a worker without a heartbeat will be
  stopped gracefully, defaults to the value of
  L<Mojo::Server::Prefork/"heartbeat_timeout">. Note that this value should
  usually be a little larger than the maximum amount of time you expect any one
  operation to block the event loop.
  
  =head2 inactivity_timeout
  
    inactivity_timeout => 10
  
  Maximum amount of time in seconds a connection can be inactive before getting
  closed, defaults to the value of L<Mojo::Server::Daemon/"inactivity_timeout">.
  Setting the value to C<0> will allow connections to be inactive indefinitely.
  
  =head2 listen
  
    listen => ['http://*:80']
  
  Array reference with one or more locations to listen on, defaults to
  C<http://*:8080>. See also L<Mojo::Server::Daemon/"listen"> for more examples.
  
  =head2 pid_file
  
    pid_file => '/var/run/hypnotoad.pid'
  
  Full path to process id file, defaults to C<hypnotoad.pid> in the same
  directory as the application. Note that this value can only be changed after
  the server has been stopped.
  
  =head2 proxy
  
    proxy => 1
  
  Activate reverse proxy support, which allows for the C<X-Forwarded-For> and
  C<X-Forwarded-Proto> headers to be picked up automatically, defaults to the
  value of L<Mojo::Server/"reverse_proxy">.
  
  =head2 requests
  
    requests => 50
  
  Number of keep-alive requests per connection, defaults to the value of
  L<Mojo::Server::Daemon/"max_requests">.
  
  =head2 upgrade_timeout
  
    upgrade_timeout => 45
  
  Maximum amount of time in seconds a zero downtime software upgrade may take
  before getting canceled, defaults to C<60>.
  
  =head2 workers
  
    workers => 10
  
  Number of worker processes, defaults to the value of
  L<Mojo::Server::Prefork/"workers">. A good rule of thumb is two worker
  processes per CPU core for applications that perform mostly non-blocking
  operations, blocking operations often require more and benefit from decreasing
  concurrency with L</"clients"> (often as low as C<1>). Note that during zero
  downtime software upgrades there will be twice as many workers active for a
  short amount of time.
  
  =head1 ATTRIBUTES
  
  L<Mojo::Server::Hypnotoad> implements the following attributes.
  
  =head2 prefork
  
    my $prefork = $hypnotoad->prefork;
    $hypnotoad  = $hypnotoad->prefork(Mojo::Server::Prefork->new);
  
  L<Mojo::Server::Prefork> object this server manages.
  
  =head2 upgrade_timeout
  
    my $timeout = $hypnotoad->upgrade_timeout;
    $hypnotoad  = $hypnotoad->upgrade_timeout(15);
  
  Maximum amount of time in seconds a zero downtime software upgrade may take
  before getting canceled, defaults to C<60>.
  
  =head1 METHODS
  
  L<Mojo::Server::Hypnotoad> inherits all methods from L<Mojo::Base> and
  implements the following new ones.
  
  =head2 configure
  
    $hypnotoad->configure('hypnotoad');
  
  Configure server from application settings.
  
  =head2 run
  
    $hypnotoad->run('script/my_app');
  
  Run server for application and wait for L</"MANAGER SIGNALS">.
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<http://mojolicious.org>.
  
  =cut
MOJO_SERVER_HYPNOTOAD

$fatpacked{"Mojo/Server/Morbo.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJO_SERVER_MORBO';
  package Mojo::Server::Morbo;
  use Mojo::Base -base;
  
  # "Linda: With Haley's Comet out of ice, Earth is experiencing the devastating
  #         effects of sudden, intense global warming.
  #  Morbo: Morbo is pleased but sticky."
  use Mojo::Loader 'load_class';
  use Mojo::Server::Daemon;
  use Mojo::Util 'deprecated';
  use POSIX 'WNOHANG';
  
  has backend => sub {
    my $backend = $ENV{MOJO_MORBO_BACKEND} || 'Poll';
    $backend = "Mojo::Server::Morbo::Backend::$backend";
    return $backend->new unless my $e = load_class $backend;
    die $e if ref $e;
    die qq{Can't find Morbo backend class "$backend" in \@INC. (@INC)\n};
  };
  has daemon => sub { Mojo::Server::Daemon->new };
  
  sub run {
    my ($self, $app) = @_;
  
    # Clean manager environment
    local $SIG{INT} = local $SIG{TERM} = sub {
      $self->{finished} = 1;
      kill 'TERM', $self->{worker} if $self->{worker};
    };
    unshift @{$self->backend->watch}, $0 = $app;
    $self->{modified} = 1;
  
    # Prepare and cache listen sockets for smooth restarting
    $self->daemon->start->stop;
  
    $self->_manage until $self->{finished} && !$self->{worker};
    exit 0;
  }
  
  # DEPRECATED!
  sub watch {
    deprecated 'Mojo::Server::Morbo::watch is DEPRECATED'
      . ' in favor of Mojo::Server::Morbo::Backend::Poll::watch';
    shift->backend->watch(@_);
  }
  
  sub _manage {
    my $self = shift;
  
    if (my @files = @{$self->backend->modified_files}) {
      say @files == 1
        ? qq{File "@{[$files[0]]}" changed, restarting.}
        : qq{@{[scalar @files]} files changed, restarting.}
        if $ENV{MORBO_VERBOSE};
      kill 'TERM', $self->{worker} if $self->{worker};
      $self->{modified} = 1;
    }
  
    if (my $pid = $self->{worker}) {
      delete $self->{worker} if waitpid($pid, WNOHANG) == $pid;
    }
  
    $self->_spawn if !$self->{worker} && delete $self->{modified};
  }
  
  sub _spawn {
    my $self = shift;
  
    # Manager
    my $manager = $$;
    die "Can't fork: $!" unless defined(my $pid = $self->{worker} = fork);
    return if $pid;
  
    # Worker
    my $daemon = $self->daemon;
    $daemon->load_app($self->backend->watch->[0]);
    $daemon->ioloop->recurring(1 => sub { shift->stop unless kill 0, $manager });
    $daemon->run;
    exit 0;
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojo::Server::Morbo - Tonight at 11...DOOOOOOOOOOOOOOOM!
  
  =head1 SYNOPSIS
  
    use Mojo::Server::Morbo;
  
    my $morbo = Mojo::Server::Morbo->new;
    $morbo->run('/home/sri/myapp.pl');
  
  =head1 DESCRIPTION
  
  L<Mojo::Server::Morbo> is a full featured, self-restart capable non-blocking
  I/O HTTP and WebSocket server, built around the very well tested and reliable
  L<Mojo::Server::Daemon>, with IPv6, TLS, SNI, UNIX domain socket, Comet (long
  polling), keep-alive and multiple event loop support. Note that the server uses
  signals for process management, so you should avoid modifying signal handlers in
  your applications.
  
  To start applications with it you can use the L<morbo> script.
  
    $ morbo ./myapp.pl
    Server available at http://127.0.0.1:3000
  
  For better scalability (epoll, kqueue) and to provide non-blocking name
  resolution, SOCKS5 as well as TLS support, the optional modules L<EV> (4.0+),
  L<Net::DNS::Native> (0.15+), L<IO::Socket::Socks> (0.64+) and
  L<IO::Socket::SSL> (1.94+) will be used automatically if possible. Individual
  features can also be disabled with the C<MOJO_NO_NNR>, C<MOJO_NO_SOCKS> and
  C<MOJO_NO_TLS> environment variables.
  
  See L<Mojolicious::Guides::Cookbook/"DEPLOYMENT"> for more.
  
  =head1 SIGNALS
  
  The L<Mojo::Server::Morbo> process can be controlled at runtime with the
  following signals.
  
  =head2 INT, TERM
  
  Shut down server immediately.
  
  =head1 ATTRIBUTES
  
  L<Mojo::Server::Morbo> implements the following attributes.
  
  =head2 backend
  
    my $backend = $morbo->backend;
    $morbo      = $morbo->backend(Mojo::Server::Morbo::Backend::Poll->new);
  
  Backend, usually a L<Mojo::Server::Morbo::Backend::Poll> object.
  
  =head2 daemon
  
    my $daemon = $morbo->daemon;
    $morbo     = $morbo->daemon(Mojo::Server::Daemon->new);
  
  L<Mojo::Server::Daemon> object this server manages.
  
  =head1 METHODS
  
  L<Mojo::Server::Morbo> inherits all methods from L<Mojo::Base> and implements
  the following new ones.
  
  =head2 run
  
    $morbo->run('script/my_app');
  
  Run server for application and wait for L</"SIGNALS">.
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<http://mojolicious.org>.
  
  =cut
MOJO_SERVER_MORBO

$fatpacked{"Mojo/Server/Morbo/Backend.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJO_SERVER_MORBO_BACKEND';
  package Mojo::Server::Morbo::Backend;
  use Mojo::Base -base;
  
  use Carp 'croak';
  
  has watch => sub { [qw(lib templates)] };
  has watch_timeout => sub { $ENV{MOJO_MORBO_TIMEOUT} || 1 };
  
  sub modified_files {
    croak 'Method "modified_files" not implemented by subclass';
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojo::Server::Morbo::Backend - Morbo backend base class
  
  =head1 SYNOPSIS
  
    package Mojo::Server::Morbo::Backend::Inotify:
    use Mojo::Base 'Mojo::Server::Morbo::Backend';
  
    sub modified_files {...}
  
  =head1 DESCRIPTION
  
  L<Mojo::Server::Morbo::Backend> is an abstract base class for Morbo backends,
  like L<Mojo::Server::Morbo::Backend::Poll>.
  
  =head1 ATTRIBUTES
  
  L<Mojo::Server::Morbo::Backend> implements the following attributes.
  
  =head2 watch
  
    my $watch = $backend->watch;
    $backend  = $backend->watch(['/home/sri/my_app']);
  
  Files and directories to watch for changes, defaults to the application script
  as well as the C<lib> and C<templates> directories in the current working
  directory.
  
  =head2 watch_timeout
  
    my $timeout = $backend->watch_timeout;
    $backend    = $backend->watch_timeout(10);
  
  Maximum amount of time in seconds a backend may block when waiting for files to
  change, defaults to the value of the C<MOJO_MORBO_TIMEOUT> environment variable
  or C<1>.
  
  =head1 METHODS
  
  L<Mojo::Server::Morbo::Backend> inherits all methods from L<Mojo::Base> and
  implements the following new ones.
  
  =head2 modified_files
  
    my $files = $backend->modified_files;
  
  Check if files from L</"watch"> have been modified since the last check and
  return an array reference with the results. Meant to be overloaded in a
  subclass.
  
    # All files that have been modified
    say for @{$backend->modified_files};
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<http://mojolicious.org>.
  
  =cut
MOJO_SERVER_MORBO_BACKEND

$fatpacked{"Mojo/Server/Morbo/Backend/Poll.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJO_SERVER_MORBO_BACKEND_POLL';
  package Mojo::Server::Morbo::Backend::Poll;
  use Mojo::Base 'Mojo::Server::Morbo::Backend';
  
  use Mojo::File 'path';
  
  sub modified_files {
    my $self = shift;
  
    sleep $self->watch_timeout;
    my $cache = $self->{cache} ||= {};
    my @files;
    for my $file (map { -f $_ && -r _ ? $_ : _list($_) } @{$self->watch}) {
      my ($size, $mtime) = (stat $file)[7, 9];
      next unless defined $size and defined $mtime;
      my $stats = $cache->{$file} ||= [$^T, $size];
      next if $mtime <= $stats->[0] && $size == $stats->[1];
      @$stats = ($mtime, $size);
      push @files, $file;
    }
  
    return \@files;
  }
  
  sub _list { path(shift)->list_tree->map('to_string')->each }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojo::Server::Morbo::Backend::Poll - Morbo default backend
  
  =head1 SYNOPSIS
  
    use Mojo::Server::Morbo::Backend::Poll;
  
    my $backend = Mojo::Server::Morbo::Backend::Poll->new;
    if (my $files = $backend->modified_files) {
      ...
    }
  
  =head1 DESCRIPTION
  
  L<Mojo::Server::Morbo::Backend:Poll> is the default backend for
  L<Mojo::Server::Morbo>.
  
  =head1 ATTRIBUTES
  
  L<Mojo::Server::Morbo::Backend::Poll> inherits all attributes from
  L<Mojo::Server::Morbo::Backend>.
  
  =head1 METHODS
  
  L<Mojo::Server::Morbo::Backend::Poll> inherits all methods from
  L<Mojo::Server::Morbo::Backend> and implements the following new ones.
  
  =head2 modified_files
  
    my $files = $backend->modified_files;
  
  Check file size and mtime to determine which files have changed, this is not
  particularly efficient, but very portable.
  
    # All files that have been modified
    say for @{$backend->modified_files};
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<http://mojolicious.org>.
  
  =cut
MOJO_SERVER_MORBO_BACKEND_POLL

$fatpacked{"Mojo/Server/PSGI.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJO_SERVER_PSGI';
  package Mojo::Server::PSGI;
  use Mojo::Base 'Mojo::Server';
  
  sub run {
    my ($self, $env) = @_;
  
    my $tx  = $self->build_tx;
    my $req = $tx->req->parse($env);
    $tx->local_port($env->{SERVER_PORT})->remote_address($env->{REMOTE_ADDR});
  
    # Request body (may block if we try to read too much)
    my $len = $env->{CONTENT_LENGTH};
    until ($req->is_finished) {
      my $chunk = ($len && $len < 131072) ? $len : 131072;
      last unless my $read = $env->{'psgi.input'}->read(my $buffer, $chunk, 0);
      $req->parse($buffer);
      last if ($len -= $read) <= 0;
    }
  
    $self->emit(request => $tx);
  
    # Response headers
    my $res  = $tx->res->fix_headers;
    my $hash = $res->headers->to_hash(1);
    my @headers;
    for my $name (keys %$hash) { push @headers, $name, $_ for @{$hash->{$name}} }
  
    # PSGI response
    my $io = Mojo::Server::PSGI::_IO->new(tx => $tx, empty => $tx->is_empty);
    return [$res->code // 404, \@headers, $io];
  }
  
  sub to_psgi_app {
    my $self = shift;
  
    # Preload application and wrap it
    $self->app;
    return sub { $self->run(@_) }
  }
  
  package Mojo::Server::PSGI::_IO;
  use Mojo::Base -base;
  
  # Finish transaction
  sub close { shift->{tx}->closed }
  
  sub getline {
    my $self = shift;
  
    # Empty
    return undef if $self->{empty};
  
    # No content yet, try again later
    my $chunk = $self->{tx}->res->get_body_chunk($self->{offset} //= 0);
    return '' unless defined $chunk;
  
    # End of content
    return undef unless length $chunk;
  
    $self->{offset} += length $chunk;
    return $chunk;
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojo::Server::PSGI - PSGI server
  
  =head1 SYNOPSIS
  
    use Mojo::Server::PSGI;
  
    my $psgi = Mojo::Server::PSGI->new;
    $psgi->unsubscribe('request')->on(request => sub {
      my ($psgi, $tx) = @_;
  
      # Request
      my $method = $tx->req->method;
      my $path   = $tx->req->url->path;
  
      # Response
      $tx->res->code(200);
      $tx->res->headers->content_type('text/plain');
      $tx->res->body("$method request for $path!");
  
      # Resume transaction
      $tx->resume;
    });
    my $app = $psgi->to_psgi_app;
  
  =head1 DESCRIPTION
  
  L<Mojo::Server::PSGI> allows L<Mojolicious> applications to run on all L<PSGI>
  compatible servers.
  
  See L<Mojolicious::Guides::Cookbook/"DEPLOYMENT"> for more.
  
  =head1 EVENTS
  
  L<Mojo::Server::PSGI> inherits all events from L<Mojo::Server>.
  
  =head1 ATTRIBUTES
  
  L<Mojo::Server::PSGI> inherits all attributes from L<Mojo::Server>.
  
  =head1 METHODS
  
  L<Mojo::Server::PSGI> inherits all methods from L<Mojo::Server> and implements
  the following new ones.
  
  =head2 run
  
    my $res = $psgi->run($env);
  
  Run L<PSGI>.
  
  =head2 to_psgi_app
  
    my $app = $psgi->to_psgi_app;
  
  Turn L<Mojo> application into L<PSGI> application.
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<http://mojolicious.org>.
  
  =cut
MOJO_SERVER_PSGI

$fatpacked{"Mojo/Server/Prefork.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJO_SERVER_PREFORK';
  package Mojo::Server::Prefork;
  use Mojo::Base 'Mojo::Server::Daemon';
  
  use Config;
  use File::Spec::Functions 'tmpdir';
  use Mojo::File 'path';
  use Mojo::Util 'steady_time';
  use POSIX 'WNOHANG';
  use Scalar::Util 'weaken';
  
  has accepts => 10000;
  has cleanup => 1;
  has [qw(graceful_timeout heartbeat_timeout)] => 20;
  has heartbeat_interval => 5;
  has pid_file           => sub { path(tmpdir, 'prefork.pid')->to_string };
  has workers            => 4;
  
  sub DESTROY { unlink $_[0]->pid_file if $_[0]->cleanup }
  
  sub check_pid {
    my $file = shift->pid_file;
    return undef unless open my $handle, '<', $file;
    my $pid = <$handle>;
    chomp $pid;
  
    # Running
    return $pid if $pid && kill 0, $pid;
  
    # Not running
    unlink $file;
    return undef;
  }
  
  sub ensure_pid_file {
    my ($self, $pid) = @_;
  
    # Check if PID file already exists
    return if -e (my $file = $self->pid_file);
  
    # Create PID file
    $self->app->log->error(qq{Can't create process id file "$file": $!})
      and die qq{Can't create process id file "$file": $!}
      unless open my $handle, '>', $file;
    $self->app->log->info(qq{Creating process id file "$file"});
    chmod 0644, $handle;
    print $handle "$pid\n";
  }
  
  sub healthy {
    scalar grep { $_->{healthy} } values %{shift->{pool}};
  }
  
  sub run {
    my $self = shift;
  
    # No fork emulation support
    say 'Pre-forking does not support fork emulation.' and exit 0
      if $Config{d_pseudofork};
  
    # Pipe for worker communication
    pipe($self->{reader}, $self->{writer}) or die "Can't create pipe: $!";
  
    # Clean manager environment
    local $SIG{CHLD} = sub {
      while ((my $pid = waitpid -1, WNOHANG) > 0) {
        $self->emit(reap => $pid)->_stopped($pid);
      }
    };
    local $SIG{INT} = local $SIG{TERM} = sub { $self->_term };
    local $SIG{QUIT} = sub { $self->_term(1) };
    local $SIG{TTIN} = sub { $self->workers($self->workers + 1) };
    local $SIG{TTOU} = sub {
      $self->workers > 0 ? $self->workers($self->workers - 1) : return;
      for my $w (values %{$self->{pool}}) {
        ($w->{graceful} = steady_time) and last unless $w->{graceful};
      }
    };
  
    # Preload application before starting workers
    $self->start->app->log->info("Manager $$ started");
    $self->ioloop->max_accepts($self->accepts);
    $self->{running} = 1;
    $self->_manage while $self->{running};
    $self->app->log->info("Manager $$ stopped");
  }
  
  sub _heartbeat { shift->{writer}->syswrite("$$:$_[0]\n") or exit 0 }
  
  sub _manage {
    my $self = shift;
  
    # Spawn more workers if necessary and check PID file
    if (!$self->{finished}) {
      $self->_spawn while keys %{$self->{pool}} < $self->workers;
      $self->ensure_pid_file($$);
    }
  
    # Shutdown
    elsif (!keys %{$self->{pool}}) { return delete $self->{running} }
  
    # Wait for heartbeats
    $self->_wait;
  
    my $interval = $self->heartbeat_interval;
    my $ht       = $self->heartbeat_timeout;
    my $gt       = $self->graceful_timeout;
    my $log      = $self->app->log;
    my $time     = steady_time;
  
    for my $pid (keys %{$self->{pool}}) {
      next unless my $w = $self->{pool}{$pid};
  
      # No heartbeat (graceful stop)
      $log->error("Worker $pid has no heartbeat, restarting")
        and $w->{graceful} = $time
        if !$w->{graceful} && ($w->{time} + $interval + $ht <= $time);
  
      # Graceful stop with timeout
      my $graceful = $w->{graceful} ||= $self->{graceful} ? $time : undef;
      $log->debug("Stopping worker $pid gracefully")
        and (kill 'QUIT', $pid or $self->_stopped($pid))
        if $graceful && !$w->{quit}++;
      $w->{force} = 1 if $graceful && $graceful + $gt <= $time;
  
      # Normal stop
      $log->debug("Stopping worker $pid")
        and (kill 'KILL', $pid or $self->_stopped($pid))
        if $w->{force} || ($self->{finished} && !$graceful);
    }
  }
  
  sub _spawn {
    my $self = shift;
  
    # Manager
    die "Can't fork: $!" unless defined(my $pid = fork);
    return $self->emit(spawn => $pid)->{pool}{$pid} = {time => steady_time}
      if $pid;
  
    # Heartbeat messages
    my $loop     = $self->cleanup(0)->ioloop;
    my $finished = 0;
    $loop->on(finish => sub { $finished = 1 });
    weaken $self;
    my $cb = sub { $self->_heartbeat($finished) };
    $loop->next_tick($cb);
    $loop->recurring($self->heartbeat_interval => $cb);
  
    # Clean worker environment
    $SIG{$_} = 'DEFAULT' for qw(CHLD INT TERM TTIN TTOU);
    $SIG{QUIT} = sub { $loop->stop_gracefully };
    $loop->on(finish => sub { $self->max_requests(1)->close_idle_connections });
    delete $self->{reader};
    srand;
  
    $self->app->log->debug("Worker $$ started");
    $loop->start;
    exit 0;
  }
  
  sub _stopped {
    my ($self, $pid) = @_;
  
    return unless my $w = delete $self->{pool}{$pid};
  
    my $log = $self->app->log;
    $log->debug("Worker $pid stopped");
    $log->error("Worker $pid stopped too early, shutting down") and $self->_term
      unless $w->{healthy};
  }
  
  sub _term {
    my ($self, $graceful) = @_;
    @{$self->emit(finish => $graceful)}{qw(finished graceful)} = (1, $graceful);
  }
  
  sub _wait {
    my $self = shift;
  
    # Poll for heartbeats
    my $reader = $self->emit('wait')->{reader};
    return unless Mojo::Util::_readable(1000, fileno($reader));
    return unless $reader->sysread(my $chunk, 4194304);
  
    # Update heartbeats (and stop gracefully if necessary)
    my $time = steady_time;
    while ($chunk =~ /(\d+):(\d)\n/g) {
      next unless my $w = $self->{pool}{$1};
      @$w{qw(healthy time)} = (1, $time) and $self->emit(heartbeat => $1);
      $w->{graceful} ||= $time if $2;
    }
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojo::Server::Prefork - Pre-forking non-blocking I/O HTTP and WebSocket server
  
  =head1 SYNOPSIS
  
    use Mojo::Server::Prefork;
  
    my $prefork = Mojo::Server::Prefork->new(listen => ['http://*:8080']);
    $prefork->unsubscribe('request')->on(request => sub {
      my ($prefork, $tx) = @_;
  
      # Request
      my $method = $tx->req->method;
      my $path   = $tx->req->url->path;
  
      # Response
      $tx->res->code(200);
      $tx->res->headers->content_type('text/plain');
      $tx->res->body("$method request for $path!");
  
      # Resume transaction
      $tx->resume;
    });
    $prefork->run;
  
  =head1 DESCRIPTION
  
  L<Mojo::Server::Prefork> is a full featured, UNIX optimized, pre-forking
  non-blocking I/O HTTP and WebSocket server, built around the very well tested
  and reliable L<Mojo::Server::Daemon>, with IPv6, TLS, SNI, UNIX domain socket,
  Comet (long polling), keep-alive and multiple event loop support. Note that the
  server uses signals for process management, so you should avoid modifying signal
  handlers in your applications.
  
  For better scalability (epoll, kqueue) and to provide non-blocking name
  resolution, SOCKS5 as well as TLS support, the optional modules L<EV> (4.0+),
  L<Net::DNS::Native> (0.15+), L<IO::Socket::Socks> (0.64+) and
  L<IO::Socket::SSL> (1.84+) will be used automatically if possible. Individual
  features can also be disabled with the C<MOJO_NO_NNR>, C<MOJO_NO_SOCKS> and
  C<MOJO_NO_TLS> environment variables.
  
  See L<Mojolicious::Guides::Cookbook/"DEPLOYMENT"> for more.
  
  =head1 MANAGER SIGNALS
  
  The L<Mojo::Server::Prefork> manager process can be controlled at runtime with
  the following signals.
  
  =head2 INT, TERM
  
  Shut down server immediately.
  
  =head2 QUIT
  
  Shut down server gracefully.
  
  =head2 TTIN
  
  Increase worker pool by one.
  
  =head2 TTOU
  
  Decrease worker pool by one.
  
  =head1 WORKER SIGNALS
  
  L<Mojo::Server::Prefork> worker processes can be controlled at runtime with the
  following signals.
  
  =head2 QUIT
  
  Stop worker gracefully.
  
  =head1 EVENTS
  
  L<Mojo::Server::Prefork> inherits all events from L<Mojo::Server::Daemon> and
  can emit the following new ones.
  
  =head2 finish
  
    $prefork->on(finish => sub {
      my ($prefork, $graceful) = @_;
      ...
    });
  
  Emitted when the server shuts down.
  
    $prefork->on(finish => sub {
      my ($prefork, $graceful) = @_;
      say $graceful ? 'Graceful server shutdown' : 'Server shutdown';
    });
  
  =head2 heartbeat
  
    $prefork->on(heartbeat => sub {
      my ($prefork, $pid) = @_;
      ...
    });
  
  Emitted when a heartbeat message has been received from a worker.
  
    $prefork->on(heartbeat => sub {
      my ($prefork, $pid) = @_;
      say "Worker $pid has a heartbeat";
    });
  
  =head2 reap
  
    $prefork->on(reap => sub {
      my ($prefork, $pid) = @_;
      ...
    });
  
  Emitted when a child process dies.
  
    $prefork->on(reap => sub {
      my ($prefork, $pid) = @_;
      say "Worker $pid stopped";
    });
  
  =head2 spawn
  
    $prefork->on(spawn => sub {
      my ($prefork, $pid) = @_;
      ...
    });
  
  Emitted when a worker process is spawned.
  
    $prefork->on(spawn => sub {
      my ($prefork, $pid) = @_;
      say "Worker $pid started";
    });
  
  =head2 wait
  
    $prefork->on(wait => sub {
      my $prefork = shift;
      ...
    });
  
  Emitted when the manager starts waiting for new heartbeat messages.
  
    $prefork->on(wait => sub {
      my $prefork = shift;
      my $workers = $prefork->workers;
      say "Waiting for heartbeat messages from $workers workers";
    });
  
  =head1 ATTRIBUTES
  
  L<Mojo::Server::Prefork> inherits all attributes from L<Mojo::Server::Daemon>
  and implements the following new ones.
  
  =head2 accepts
  
    my $accepts = $prefork->accepts;
    $prefork    = $prefork->accepts(100);
  
  Maximum number of connections a worker is allowed to accept, before stopping
  gracefully and then getting replaced with a newly started worker, passed along
  to L<Mojo::IOLoop/"max_accepts">, defaults to C<10000>. Setting the value to
  C<0> will allow workers to accept new connections indefinitely. Note that up to
  half of this value can be subtracted randomly to improve load balancing, and to
  make sure that not all workers restart at the same time.
  
  =head2 cleanup
  
    my $bool = $prefork->cleanup;
    $prefork = $prefork->cleanup($bool);
  
  Delete L</"pid_file"> automatically once it is not needed anymore, defaults to
  a true value.
  
  =head2 graceful_timeout
  
    my $timeout = $prefork->graceful_timeout;
    $prefork    = $prefork->graceful_timeout(15);
  
  Maximum amount of time in seconds stopping a worker gracefully may take before
  being forced, defaults to C<20>. Note that this value should usually be a little
  larger than the maximum amount of time you expect any one request to take.
  
  =head2 heartbeat_interval
  
    my $interval = $prefork->heartbeat_interval;
    $prefork     = $prefork->heartbeat_interval(3);
  
  Heartbeat interval in seconds, defaults to C<5>.
  
  =head2 heartbeat_timeout
  
    my $timeout = $prefork->heartbeat_timeout;
    $prefork    = $prefork->heartbeat_timeout(2);
  
  Maximum amount of time in seconds before a worker without a heartbeat will be
  stopped gracefully, defaults to C<20>. Note that this value should usually be a
  little larger than the maximum amount of time you expect any one operation to
  block the event loop.
  
  =head2 pid_file
  
    my $file = $prefork->pid_file;
    $prefork = $prefork->pid_file('/tmp/prefork.pid');
  
  Full path of process id file, defaults to C<prefork.pid> in a temporary
  directory.
  
  =head2 workers
  
    my $workers = $prefork->workers;
    $prefork    = $prefork->workers(10);
  
  Number of worker processes, defaults to C<4>. A good rule of thumb is two
  worker processes per CPU core for applications that perform mostly non-blocking
  operations, blocking operations often require more and benefit from decreasing
  concurrency with L<Mojo::Server::Daemon/"clients"> (often as low as C<1>).
  
  =head1 METHODS
  
  L<Mojo::Server::Prefork> inherits all methods from L<Mojo::Server::Daemon> and
  implements the following new ones.
  
  =head2 check_pid
  
    my $pid = $prefork->check_pid;
  
  Get process id for running server from L</"pid_file"> or delete it if server is
  not running.
  
    say 'Server is not running' unless $prefork->check_pid;
  
  =head2 ensure_pid_file
  
    $prefork->ensure_pid_file($pid);
  
  Ensure L</"pid_file"> exists.
  
  =head2 healthy
  
    my $healthy = $prefork->healthy;
  
  Number of currently active worker processes with a heartbeat.
  
  =head2 run
  
    $prefork->run;
  
  Run server and wait for L</"MANAGER SIGNALS">.
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<http://mojolicious.org>.
  
  =cut
MOJO_SERVER_PREFORK

$fatpacked{"Mojo/Template.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJO_TEMPLATE';
  package Mojo::Template;
  use Mojo::Base -base;
  
  use Carp 'croak';
  use Mojo::ByteStream;
  use Mojo::Exception;
  use Mojo::File 'path';
  use Mojo::Util qw(decode encode monkey_patch);
  
  use constant DEBUG => $ENV{MOJO_TEMPLATE_DEBUG} || 0;
  
  has [qw(append code prepend unparsed)] => '';
  has [qw(auto_escape compiled vars)];
  has capture_end   => 'end';
  has capture_start => 'begin';
  has comment_mark  => '#';
  has encoding      => 'UTF-8';
  has escape        => sub { \&Mojo::Util::xml_escape };
  has [qw(escape_mark expression_mark trim_mark)] => '=';
  has [qw(line_start replace_mark)] => '%';
  has name      => 'template';
  has namespace => 'Mojo::Template::SandBox';
  has tag_start => '<%';
  has tag_end   => '%>';
  has tree      => sub { [] };
  
  sub parse {
    my ($self, $template) = @_;
  
    # Clean start
    $self->unparsed($template)->tree(\my @tree)->compiled(undef);
  
    my $tag     = $self->tag_start;
    my $replace = $self->replace_mark;
    my $expr    = $self->expression_mark;
    my $escp    = $self->escape_mark;
    my $cpen    = $self->capture_end;
    my $cmnt    = $self->comment_mark;
    my $cpst    = $self->capture_start;
    my $trim    = $self->trim_mark;
    my $end     = $self->tag_end;
    my $start   = $self->line_start;
  
    my $line_re
      = qr/^(\s*)\Q$start\E(?:(\Q$replace\E)|(\Q$cmnt\E)|(\Q$expr\E))?(.*)$/;
    my $token_re = qr/
      (
        \Q$tag\E(?:\Q$replace\E|\Q$cmnt\E)                   # Replace
      |
        \Q$tag$expr\E(?:\Q$escp\E)?(?:\s*\Q$cpen\E(?!\w))?   # Expression
      |
        \Q$tag\E(?:\s*\Q$cpen\E(?!\w))?                      # Code
      |
        (?:(?<!\w)\Q$cpst\E\s*)?(?:\Q$trim\E)?\Q$end\E       # End
      )
    /x;
    my $cpen_re = qr/^\Q$tag\E(?:\Q$expr\E)?(?:\Q$escp\E)?\s*\Q$cpen\E(.*)$/;
    my $end_re  = qr/^(?:(\Q$cpst\E)\s*)?(\Q$trim\E)?\Q$end\E$/;
  
    # Split lines
    my $op = 'text';
    my ($trimming, $capture);
    for my $line (split "\n", $template) {
  
      # Turn Perl line into mixed line
      if ($op eq 'text' && $line =~ $line_re) {
  
        # Escaped start
        if ($2) { $line = "$1$start$5" }
  
        # Comment
        elsif ($3) { $line = "$tag$3 $trim$end" }
  
        # Expression or code
        else { $line = $4 ? "$1$tag$4$5 $end" : "$tag$5 $trim$end" }
      }
  
      # Escaped line ending
      $line .= "\n" if $line !~ s/\\\\$/\\\n/ && $line !~ s/\\$//;
  
      # Mixed line
      for my $token (split $token_re, $line) {
  
        # Capture end
        ($token, $capture) = ("$tag$1", 1) if $token =~ $cpen_re;
  
        # End
        if ($op ne 'text' && $token =~ $end_re) {
  
          # Capture start
          splice @tree, -1, 0, ['cpst'] if $1;
  
          # Trim left side
          _trim(\@tree) if ($trimming = $2) && @tree > 1;
  
          # Hint at end
          push @tree, [$op = 'text', ''];
        }
  
        # Code
        elsif ($token eq $tag) { $op = 'code' }
  
        # Expression
        elsif ($token eq "$tag$expr") { $op = 'expr' }
  
        # Expression that needs to be escaped
        elsif ($token eq "$tag$expr$escp") { $op = 'escp' }
  
        # Comment
        elsif ($token eq "$tag$cmnt") { $op = 'cmnt' }
  
        # Text (comments are just ignored)
        elsif ($op ne 'cmnt') {
  
          # Replace
          $token = $tag if $token eq "$tag$replace";
  
          # Trim right side (convert whitespace to line noise)
          if ($trimming && $token =~ s/^(\s+)//) {
            push @tree, ['code', $1];
            $trimming = 0;
          }
  
          # Token (with optional capture end)
          push @tree, $capture ? ['cpen'] : (), [$op, $token];
          $capture = 0;
        }
      }
  
      # Optimize successive text lines separated by a newline
      push @tree, ['line'] and next
        if $tree[-4] && $tree[-4][0] ne 'line'
        || (!$tree[-3] || $tree[-3][0] ne 'text' || $tree[-3][1] !~ /\n$/)
        || ($tree[-2][0] ne 'line' || $tree[-1][0] ne 'text');
      $tree[-3][1] .= pop(@tree)->[1];
    }
  
    return $self;
  }
  
  sub process {
    my $self = shift;
  
    # Use a local stack trace for compile exceptions
    my $compiled = $self->compiled;
    unless ($compiled) {
      my $code = $self->_compile->code;
      monkey_patch $self->namespace, '_escape', $self->escape;
      return Mojo::Exception->new($@)->inspect($self->unparsed, $code)
        ->trace->verbose(1)
        unless $compiled = eval $self->_wrap($code, @_);
      $self->compiled($compiled);
    }
  
    # Use a real stack trace for normal exceptions
    local $SIG{__DIE__} = sub {
      CORE::die $_[0] if ref $_[0];
      CORE::die Mojo::Exception->new(shift)
        ->trace->inspect($self->unparsed, $self->code)->verbose(1);
    };
  
    my $output;
    return eval { $output = $compiled->(@_); 1 } ? $output : $@;
  }
  
  sub render { shift->parse(shift)->process(@_) }
  
  sub render_file {
    my ($self, $path) = (shift, shift);
  
    $self->name($path) unless defined $self->{name};
    my $template = path($path)->slurp;
    my $encoding = $self->encoding;
    croak qq{Template "$path" has invalid encoding}
      if $encoding && !defined($template = decode $encoding, $template);
  
    return $self->render($template, @_);
  }
  
  sub _compile {
    my $self = shift;
  
    my $tree   = $self->tree;
    my $escape = $self->auto_escape;
  
    my @blocks = ('');
    my ($i, $capture, $multi);
    while (++$i <= @$tree && (my $next = $tree->[$i])) {
      my ($op, $value) = @{$tree->[$i - 1]};
      push @blocks, '' and next if $op eq 'line';
      my $newline = chomp($value //= '');
  
      # Text (quote and fix line ending)
      if ($op eq 'text') {
        $value = join "\n", map { quotemeta $_ } split("\n", $value, -1);
        $value .= '\n' if $newline;
        $blocks[-1] .= "\$_O .= \"" . $value . "\";" if length $value;
      }
  
      # Code or multi-line expression
      elsif ($op eq 'code' || $multi) { $blocks[-1] .= $value }
  
      # Capture end
      elsif ($op eq 'cpen') {
        $blocks[-1] .= 'return Mojo::ByteStream->new($_O) }';
  
        # No following code
        $blocks[-1] .= ';' if ($next->[1] // '') =~ /^\s*$/;
      }
  
      # Expression
      if ($op eq 'expr' || $op eq 'escp') {
  
        # Escaped
        if (!$multi && ($op eq 'escp' && !$escape || $op eq 'expr' && $escape)) {
          $blocks[-1] .= "\$_O .= _escape scalar + $value";
        }
  
        # Raw
        elsif (!$multi) { $blocks[-1] .= "\$_O .= scalar + $value" }
  
        # Multi-line
        $multi = !$next || $next->[0] ne 'text';
  
        # Append semicolon
        $blocks[-1] .= ';' unless $multi || $capture;
      }
  
      # Capture start
      if ($op eq 'cpst') { $capture = 1 }
      elsif ($capture) {
        $blocks[-1] .= "sub { my \$_O = ''; ";
        $capture = 0;
      }
    }
  
    return $self->code(join "\n", @blocks)->tree([]);
  }
  
  sub _line {
    my $name = shift->name;
    $name =~ y/"//d;
    return qq{#line @{[shift]} "$name"};
  }
  
  sub _trim {
    my $tree = shift;
  
    # Skip captures
    my $i = $tree->[-2][0] eq 'cpst' || $tree->[-2][0] eq 'cpen' ? -3 : -2;
  
    # Only trim text
    return unless $tree->[$i][0] eq 'text';
  
    # Convert whitespace text to line noise
    splice @$tree, $i, 0, ['code', $1] if $tree->[$i][1] =~ s/(\s+)$//;
  }
  
  sub _wrap {
    my ($self, $body, $vars) = @_;
  
    # Variables
    my $args = '';
    if ($self->vars && (my @vars = grep {/^\w+$/} keys %$vars)) {
      $args = 'my (' . join(',', map {"\$$_"} @vars) . ')';
      $args .= '= @{shift()}{qw(' . join(' ', @vars) . ')};';
    }
  
    # Wrap lines
    my $num = () = $body =~ /\n/g;
    my $code = $self->_line(1) . "\npackage @{[$self->namespace]};";
    $code .= "use Mojo::Base -strict; no warnings 'ambiguous';";
    $code .= "sub { my \$_O = ''; @{[$self->prepend]};{ $args { $body\n";
    $code .= $self->_line($num + 1) . "\n;}@{[$self->append]}; } \$_O };";
  
    warn "-- Code for @{[$self->name]}\n@{[encode 'UTF-8', $code]}\n\n" if DEBUG;
    return $code;
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojo::Template - Perl-ish templates
  
  =head1 SYNOPSIS
  
    use Mojo::Template;
  
    # Use Perl modules
    my $mt = Mojo::Template->new;
    say $mt->render(<<'EOF');
    % use Time::Piece;
    <div>
      % my $now = localtime;
      Time: <%= $now->hms %>
    </div>
    EOF
  
    # Render with arguments
    say $mt->render(<<'EOF', [1 .. 13], 'Hello World!');
    % my ($numbers, $title) = @_;
    <div>
      <h1><%= $title %></h1>
      % for my $i (@$numbers) {
        Test <%= $i %>
      % }
    </div>
    EOF
  
    # Render with named variables
    say $mt->vars(1)->render(<<'EOF', {title => 'Hello World!'});
    <div>
      <h1><%= $title %></h1>
      %= 5 + 5
    </div>
    EOF
  
  =head1 DESCRIPTION
  
  L<Mojo::Template> is a minimalistic, fast, and very Perl-ish template engine,
  designed specifically for all those small tasks that come up during big
  projects. Like preprocessing a configuration file, generating text from heredocs
  and stuff like that.
  
  See L<Mojolicious::Guides::Rendering> for information on how to generate
  content with the L<Mojolicious> renderer.
  
  =head1 SYNTAX
  
  For all templates L<strict>, L<warnings>, L<utf8> and Perl 5.10
  L<features|feature> are automatically enabled.
  
    <% Perl code %>
    <%= Perl expression, replaced with result %>
    <%== Perl expression, replaced with XML escaped result %>
    <%# Comment, useful for debugging %>
    <%% Replaced with "<%", useful for generating templates %>
    % Perl code line, treated as "<% line =%>" (explained later)
    %= Perl expression line, treated as "<%= line %>"
    %== Perl expression line, treated as "<%== line %>"
    %# Comment line, useful for debugging
    %% Replaced with "%", useful for generating templates
  
  Escaping behavior can be reversed with the L</"auto_escape"> attribute, this is
  the default in L<Mojolicious> C<.ep> templates, for example.
  
    <%= Perl expression, replaced with XML escaped result %>
    <%== Perl expression, replaced with result %>
  
  L<Mojo::ByteStream> objects are always excluded from automatic escaping.
  
    % use Mojo::ByteStream 'b';
    <%= b('<div>excluded!</div>') %>
  
  Whitespace characters around tags can be trimmed by adding an additional equal
  sign to the end of a tag.
  
    <% for (1 .. 3) { %>
      <%= 'Trim all whitespace characters around this expression' =%>
    <% } %>
  
  Newline characters can be escaped with a backslash.
  
    This is <%= 1 + 1 %> a\
    single line
  
  And a backslash in front of a newline character can be escaped with another
  backslash.
  
    This will <%= 1 + 1 %> result\\
    in multiple\\
    lines
  
  A newline character gets appended automatically to every template, unless the
  last character is a backslash. And empty lines at the end of a template are
  ignored.
  
    There is <%= 1 + 1 %> no newline at the end here\
  
  You can capture whole template blocks for reuse later with the C<begin> and
  C<end> keywords. Just be aware that both keywords are part of the surrounding
  tag and not actual Perl code, so there can only be whitespace after C<begin>
  and before C<end>.
  
    <% my $block = begin %>
      <% my $name = shift; =%>
      Hello <%= $name %>.
    <% end %>
    <%= $block->('Baerbel') %>
    <%= $block->('Wolfgang') %>
  
  Perl lines can also be indented freely.
  
    % my $block = begin
      % my $name = shift;
      Hello <%= $name %>.
    % end
    %= $block->('Baerbel')
    %= $block->('Wolfgang')
  
  L<Mojo::Template> templates get compiled to a Perl subroutine, that means you
  can access arguments simply via C<@_>.
  
    % my ($foo, $bar) = @_;
    % my $x = shift;
    test 123 <%= $foo %>
  
  The compilation of templates to Perl code can make debugging a bit tricky, but
  L<Mojo::Template> will return L<Mojo::Exception> objects that stringify to
  error messages with context.
  
    Bareword "xx" not allowed while "strict subs" in use at template line 4.
    2: </head>
    3: <body>
    4: % my $i = 2; xx
    5: %= $i * 2
    6: </body>
  
  =head1 ATTRIBUTES
  
  L<Mojo::Template> implements the following attributes.
  
  =head2 auto_escape
  
    my $bool = $mt->auto_escape;
    $mt      = $mt->auto_escape($bool);
  
  Activate automatic escaping.
  
    # "&lt;html&gt;"
    Mojo::Template->new(auto_escape => 1)->render("<%= '<html>' %>");
  
  =head2 append
  
    my $code = $mt->append;
    $mt      = $mt->append('warn "Processed template"');
  
  Append Perl code to compiled template. Note that this code should not contain
  newline characters, or line numbers in error messages might end up being wrong.
  
  =head2 capture_end
  
    my $end = $mt->capture_end;
    $mt     = $mt->capture_end('end');
  
  Keyword indicating the end of a capture block, defaults to C<end>.
  
    <% my $block = begin %>
      Some data!
    <% end %>
  
  =head2 capture_start
  
    my $start = $mt->capture_start;
    $mt       = $mt->capture_start('begin');
  
  Keyword indicating the start of a capture block, defaults to C<begin>.
  
    <% my $block = begin %>
      Some data!
    <% end %>
  
  =head2 code
  
    my $code = $mt->code;
    $mt      = $mt->code($code);
  
  Perl code for template if available.
  
  =head2 comment_mark
  
    my $mark = $mt->comment_mark;
    $mt      = $mt->comment_mark('#');
  
  Character indicating the start of a comment, defaults to C<#>.
  
    <%# This is a comment %>
  
  =head2 compiled
  
    my $compiled = $mt->compiled;
    $mt          = $mt->compiled($compiled);
  
  Compiled template code if available.
  
  =head2 encoding
  
    my $encoding = $mt->encoding;
    $mt          = $mt->encoding('UTF-8');
  
  Encoding used for template files, defaults to C<UTF-8>.
  
  =head2 escape
  
    my $cb = $mt->escape;
    $mt    = $mt->escape(sub {...});
  
  A callback used to escape the results of escaped expressions, defaults to
  L<Mojo::Util/"xml_escape">.
  
    $mt->escape(sub {
      my $str = shift;
      return reverse $str;
    });
  
  =head2 escape_mark
  
    my $mark = $mt->escape_mark;
    $mt      = $mt->escape_mark('=');
  
  Character indicating the start of an escaped expression, defaults to C<=>.
  
    <%== $foo %>
  
  =head2 expression_mark
  
    my $mark = $mt->expression_mark;
    $mt      = $mt->expression_mark('=');
  
  Character indicating the start of an expression, defaults to C<=>.
  
    <%= $foo %>
  
  =head2 line_start
  
    my $start = $mt->line_start;
    $mt       = $mt->line_start('%');
  
  Character indicating the start of a code line, defaults to C<%>.
  
    % $foo = 23;
  
  =head2 name
  
    my $name = $mt->name;
    $mt      = $mt->name('foo.mt');
  
  Name of template currently being processed, defaults to C<template>. Note that
  this value should not contain quotes or newline characters, or error messages
  might end up being wrong.
  
  =head2 namespace
  
    my $namespace = $mt->namespace;
    $mt           = $mt->namespace('main');
  
  Namespace used to compile templates, defaults to C<Mojo::Template::SandBox>.
  Note that namespaces should only be shared very carefully between templates,
  since functions and global variables will not be cleared automatically.
  
  =head2 prepend
  
    my $code = $mt->prepend;
    $mt      = $mt->prepend('my $self = shift;');
  
  Prepend Perl code to compiled template. Note that this code should not contain
  newline characters, or line numbers in error messages might end up being wrong.
  
  =head2 replace_mark
  
    my $mark = $mt->replace_mark;
    $mt      = $mt->replace_mark('%');
  
  Character used for escaping the start of a tag or line, defaults to C<%>.
  
    <%% my $foo = 23; %>
  
  =head2 tag_start
  
    my $start = $mt->tag_start;
    $mt       = $mt->tag_start('<%');
  
  Characters indicating the start of a tag, defaults to C<E<lt>%>.
  
    <% $foo = 23; %>
  
  =head2 tag_end
  
    my $end = $mt->tag_end;
    $mt     = $mt->tag_end('%>');
  
  Characters indicating the end of a tag, defaults to C<%E<gt>>.
  
    <%= $foo %>
  
  =head2 tree
  
    my $tree = $mt->tree;
    $mt      = $mt->tree([['text', 'foo'], ['line']]);
  
  Template in parsed form if available. Note that this structure should only be
  used very carefully since it is very dynamic.
  
  =head2 trim_mark
  
    my $mark = $mt->trim_mark;
    $mt      = $mt->trim_mark('-');
  
  Character activating automatic whitespace trimming, defaults to C<=>.
  
    <%= $foo =%>
  
  =head2 unparsed
  
    my $unparsed = $mt->unparsed;
    $mt          = $mt->unparsed('<%= 1 + 1 %>');
  
  Raw unparsed template if available.
  
  =head2 vars
  
    my $bool = $mt->vars;
    $mt      = $mt->vars($bool);
  
  Instead of a list of values, use a hash reference with named variables to pass
  data to templates.
  
    # "works!"
    Mojo::Template->new(vars => 1)->render('<%= $test %>!', {test => 'works'});
  
  =head1 METHODS
  
  L<Mojo::Template> inherits all methods from L<Mojo::Base> and implements the
  following new ones.
  
  =head2 parse
  
    $mt = $mt->parse('<%= 1 + 1 %>');
  
  Parse template into L</"tree">.
  
  =head2 process
  
    my $output = $mt->process;
    my $output = $mt->process(@args);
    my $output = $mt->process({foo => 'bar'});
  
  Process previously parsed template and return the result, or a
  L<Mojo::Exception> object if rendering failed.
  
    # Parse and process
    say Mojo::Template->new->parse('Hello <%= $_[0] %>')->process('Bender');
  
    # Reuse template (for much better performance)
    my $mt = Mojo::Template->new;
    say $mt->render('Hello <%= $_[0] %>!', 'Bender');
    say $mt->process('Fry');
    say $mt->process('Leela');
  
  =head2 render
  
    my $output = $mt->render('<%= 1 + 1 %>');
    my $output = $mt->render('<%= shift() + shift() %>', @args);
    my $output = $mt->render('<%= $foo %>', {foo => 'bar'});
  
  Render template and return the result, or a L<Mojo::Exception> object if
  rendering failed.
  
    # Longer version
    my $output = $mt->parse('<%= 1 + 1 %>')->process;
  
    # Render with arguments
    say Mojo::Template->new->render('<%= $_[0] %>', 'bar');
  
    # Render with named variables
    say Mojo::Template->new(vars => 1)->render('<%= $foo %>', {foo => 'bar'});
  
  =head2 render_file
  
    my $output = $mt->render_file('/tmp/foo.mt');
    my $output = $mt->render_file('/tmp/foo.mt', @args);
    my $output = $mt->render_file('/tmp/bar.mt', {foo => 'bar'});
  
  Same as L</"render">, but renders a template file.
  
  =head1 DEBUGGING
  
  You can set the C<MOJO_TEMPLATE_DEBUG> environment variable to get some
  advanced diagnostics information printed to C<STDERR>.
  
    MOJO_TEMPLATE_DEBUG=1
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<http://mojolicious.org>.
  
  =cut
MOJO_TEMPLATE

$fatpacked{"Mojo/Transaction.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJO_TRANSACTION';
  package Mojo::Transaction;
  use Mojo::Base 'Mojo::EventEmitter';
  
  use Carp 'croak';
  use Mojo::Message::Request;
  use Mojo::Message::Response;
  
  has [
    qw(kept_alive local_address local_port original_remote_address remote_port)];
  has req => sub { Mojo::Message::Request->new };
  has res => sub { Mojo::Message::Response->new };
  
  sub client_read  { croak 'Method "client_read" not implemented by subclass' }
  sub client_write { croak 'Method "client_write" not implemented by subclass' }
  
  sub closed { shift->completed->emit('finish') }
  
  sub completed { ++$_[0]{completed} and return $_[0] }
  
  sub connection {
    my $self = shift;
    return $self->emit(connection => $self->{connection} = shift) if @_;
    return $self->{connection};
  }
  
  sub error { $_[0]->req->error || $_[0]->res->error }
  
  sub is_finished { !!shift->{completed} }
  
  sub is_websocket {undef}
  
  sub remote_address {
    my $self = shift;
  
    return $self->original_remote_address(@_) if @_;
    return $self->original_remote_address unless $self->req->reverse_proxy;
  
    # Reverse proxy
    return ($self->req->headers->header('X-Forwarded-For') // '') =~ /([^,\s]+)$/
      ? $1
      : $self->original_remote_address;
  }
  
  sub result {
    my $self = shift;
    my $err  = $self->error;
    return !$err || $err->{code} ? $self->res : croak $err->{message};
  }
  
  sub server_read  { croak 'Method "server_read" not implemented by subclass' }
  sub server_write { croak 'Method "server_write" not implemented by subclass' }
  
  sub success { $_[0]->error ? undef : $_[0]->res }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojo::Transaction - Transaction base class
  
  =head1 SYNOPSIS
  
    package Mojo::Transaction::MyTransaction;
    use Mojo::Base 'Mojo::Transaction';
  
    sub client_read  {...}
    sub client_write {...}
    sub server_read  {...}
    sub server_write {...}
  
  =head1 DESCRIPTION
  
  L<Mojo::Transaction> is an abstract base class for transactions, like
  L<Mojo::Transaction::HTTP> and L<Mojo::Transaction::WebSocket>.
  
  =head1 EVENTS
  
  L<Mojo::Transaction> inherits all events from L<Mojo::EventEmitter> and can
  emit the following new ones.
  
  =head2 connection
  
    $tx->on(connection => sub {
      my ($tx, $connection) = @_;
      ...
    });
  
  Emitted when a connection has been assigned to transaction.
  
  =head2 finish
  
    $tx->on(finish => sub {
      my $tx = shift;
      ...
    });
  
  Emitted when transaction is finished.
  
  =head1 ATTRIBUTES
  
  L<Mojo::Transaction> implements the following attributes.
  
  =head2 kept_alive
  
    my $bool = $tx->kept_alive;
    $tx      = $tx->kept_alive($bool);
  
  Connection has been kept alive.
  
  =head2 local_address
  
    my $address = $tx->local_address;
    $tx         = $tx->local_address('127.0.0.1');
  
  Local interface address.
  
  =head2 local_port
  
    my $port = $tx->local_port;
    $tx      = $tx->local_port(8080);
  
  Local interface port.
  
  =head2 original_remote_address
  
    my $address = $tx->original_remote_address;
    $tx         = $tx->original_remote_address('127.0.0.1');
  
  Remote interface address.
  
  =head2 remote_port
  
    my $port = $tx->remote_port;
    $tx      = $tx->remote_port(8081);
  
  Remote interface port.
  
  =head2 req
  
    my $req = $tx->req;
    $tx     = $tx->req(Mojo::Message::Request->new);
  
  HTTP request, defaults to a L<Mojo::Message::Request> object.
  
    # Access request information
    my $method = $tx->req->method;
    my $url    = $tx->req->url->to_abs;
    my $info   = $tx->req->url->to_abs->userinfo;
    my $host   = $tx->req->url->to_abs->host;
    my $agent  = $tx->req->headers->user_agent;
    my $custom = $tx->req->headers->header('Custom-Header');
    my $bytes  = $tx->req->body;
    my $str    = $tx->req->text;
    my $hash   = $tx->req->params->to_hash;
    my $all    = $tx->req->uploads;
    my $value  = $tx->req->json;
    my $foo    = $tx->req->json('/23/foo');
    my $dom    = $tx->req->dom;
    my $bar    = $tx->req->dom('div.bar')->first->text;
  
  =head2 res
  
    my $res = $tx->res;
    $tx     = $tx->res(Mojo::Message::Response->new);
  
  HTTP response, defaults to a L<Mojo::Message::Response> object.
  
    # Access response information
    my $code    = $tx->res->code;
    my $message = $tx->res->message;
    my $server  = $tx->res->headers->server;
    my $custom  = $tx->res->headers->header('Custom-Header');
    my $bytes   = $tx->res->body;
    my $str     = $tx->res->text;
    my $value   = $tx->res->json;
    my $foo     = $tx->res->json('/23/foo');
    my $dom     = $tx->res->dom;
    my $bar     = $tx->res->dom('div.bar')->first->text;
  
  =head1 METHODS
  
  L<Mojo::Transaction> inherits all methods from L<Mojo::EventEmitter> and
  implements the following new ones.
  
  =head2 client_read
  
    $tx->client_read($bytes);
  
  Read data client-side, used to implement user agents such as L<Mojo::UserAgent>.
  Meant to be overloaded in a subclass.
  
  =head2 client_write
  
    my $bytes = $tx->client_write;
  
  Write data client-side, used to implement user agents such as
  L<Mojo::UserAgent>. Meant to be overloaded in a subclass.
  
  =head2 closed
  
    $tx = $tx->closed;
  
  Same as L</"completed">, but also indicates that all transaction data has been
  sent.
  
  =head2 completed
  
    $tx = $tx->completed;
  
  Low-level method to finalize transaction.
  
  =head2 connection
  
    my $id = $tx->connection;
    $tx    = $tx->connection($id);
  
  Connection identifier.
  
  =head2 error
  
    my $err = $tx->error;
  
  Get request or response error and return C<undef> if there is no error,
  commonly used together with L</"success">.
  
    # Longer version
    my $err = $tx->req->error || $tx->res->error;
  
    # Check for 4xx/5xx response and connection errors
    if (my $err = $tx->error) {
      die "$err->{code} response: $err->{message}" if $err->{code};
      die "Connection error: $err->{message}";
    }
  
  =head2 is_finished
  
    my $bool = $tx->is_finished;
  
  Check if transaction is finished.
  
  =head2 is_websocket
  
    my $bool = $tx->is_websocket;
  
  False, this is not a L<Mojo::Transaction::WebSocket> object.
  
  =head2 remote_address
  
    my $address = $tx->remote_address;
    $tx         = $tx->remote_address('127.0.0.1');
  
  Same as L</"original_remote_address"> or the last value of the
  C<X-Forwarded-For> header if L</"req"> has been performed through a reverse
  proxy.
  
  =head2 result
  
    my $res = $tx->result;
  
  Returns the L<Mojo::Message::Response> object from L</"res"> or dies if a
  connection error has occurred.
  
    # Fine grained response handling (dies on connection errors)
    my $res = $tx->result;
    if    ($res->is_success)  { say $res->body }
    elsif ($res->is_error)    { say $res->message }
    elsif ($res->code == 301) { say $res->headers->location }
    else                      { say 'Whatever...' }
  
  =head2 server_read
  
    $tx->server_read($bytes);
  
  Read data server-side, used to implement web servers such as
  L<Mojo::Server::Daemon>. Meant to be overloaded in a subclass.
  
  =head2 server_write
  
    my $bytes = $tx->server_write;
  
  Write data server-side, used to implement web servers such as
  L<Mojo::Server::Daemon>. Meant to be overloaded in a subclass.
  
  =head2 success
  
    my $res = $tx->success;
  
  Returns the L<Mojo::Message::Response> object from L</"res"> if transaction was
  successful or C<undef> otherwise. Connection and parser errors have only a
  message in L</"error">, C<400> and C<500> responses also a code.
  
    # Manual exception handling
    if (my $res = $tx->success) { say $res->body }
    else {
      my $err = $tx->error;
      die "$err->{code} response: $err->{message}" if $err->{code};
      die "Connection error: $err->{message}";
    }
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<http://mojolicious.org>.
  
  =cut
MOJO_TRANSACTION

$fatpacked{"Mojo/Transaction/HTTP.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJO_TRANSACTION_HTTP';
  package Mojo::Transaction::HTTP;
  use Mojo::Base 'Mojo::Transaction';
  
  has 'previous';
  
  sub client_read {
    my ($self, $chunk) = @_;
  
    # Skip body for HEAD request
    my $res = $self->res;
    $res->content->skip_body(1) if uc $self->req->method eq 'HEAD';
    return unless $res->parse($chunk)->is_finished;
  
    # Unexpected 1xx response
    return $self->completed if !$res->is_info || $res->headers->upgrade;
    $self->res($res->new)->emit(unexpected => $res);
    return unless length(my $leftovers = $res->content->leftovers);
    $self->client_read($leftovers);
  }
  
  sub client_write { shift->_write(0) }
  
  sub is_empty { !!(uc $_[0]->req->method eq 'HEAD' || $_[0]->res->is_empty) }
  
  sub keep_alive {
    my $self = shift;
  
    # Close
    my $req      = $self->req;
    my $res      = $self->res;
    my $req_conn = lc($req->headers->connection // '');
    my $res_conn = lc($res->headers->connection // '');
    return undef if $req_conn eq 'close' || $res_conn eq 'close';
  
    # Keep-alive is optional for 1.0
    return $res_conn eq 'keep-alive' if $res->version eq '1.0';
    return $req_conn eq 'keep-alive' if $req->version eq '1.0';
  
    # Keep-alive is the default for 1.1
    return 1;
  }
  
  sub redirects {
    my $previous = shift;
    my @redirects;
    unshift @redirects, $previous while $previous = $previous->previous;
    return \@redirects;
  }
  
  sub resume { ++$_[0]{writing} and return $_[0]->emit('resume') }
  
  sub server_read {
    my ($self, $chunk) = @_;
  
    # Parse request
    my $req = $self->req;
    $req->parse($chunk) unless $req->error;
  
    # Generate response
    $self->emit('request') if $req->is_finished && !$self->{handled}++;
  }
  
  sub server_write { shift->_write(1) }
  
  sub _body {
    my ($self, $msg, $finish) = @_;
  
    # Prepare body chunk
    my $buffer = $msg->get_body_chunk($self->{offset});
    my $written = defined $buffer ? length $buffer : 0;
    $self->{write} = $msg->content->is_dynamic ? 1 : ($self->{write} - $written);
    $self->{offset} += $written;
  
    # Delayed
    $self->{writing} = 0 unless defined $buffer;
  
    # Finished
    $finish ? $self->completed : ($self->{writing} = 0)
      if $self->{write} <= 0 || defined $buffer && !length $buffer;
  
    return $buffer // '';
  }
  
  sub _headers {
    my ($self, $msg, $head) = @_;
  
    # Prepare header chunk
    my $buffer = $msg->get_header_chunk($self->{offset});
    my $written = defined $buffer ? length $buffer : 0;
    $self->{write} -= $written;
    $self->{offset} += $written;
  
    # Switch to body
    if ($self->{write} <= 0) {
      @$self{qw(http_state offset)} = ('body', 0);
  
      # Response without body
      if ($head && $self->is_empty) { $self->completed->{http_state} = 'empty' }
  
      # Body
      else { $self->{write} = $msg->content->is_dynamic ? 1 : $msg->body_size }
    }
  
    return $buffer;
  }
  
  sub _start_line {
    my ($self, $msg) = @_;
  
    # Prepare start-line chunk
    my $buffer = $msg->get_start_line_chunk($self->{offset});
    my $written = defined $buffer ? length $buffer : 0;
    $self->{write} -= $written;
    $self->{offset} += $written;
  
    # Switch to headers
    @$self{qw(http_state write offset)} = ('headers', $msg->header_size, 0)
      if $self->{write} <= 0;
  
    return $buffer;
  }
  
  sub _write {
    my ($self, $server) = @_;
  
    # Client starts writing right away
    return '' unless $server ? $self->{writing} : ($self->{writing} //= 1);
  
    # Nothing written yet
    $self->{$_} ||= 0 for qw(offset write);
    my $msg = $server ? $self->res : $self->req;
    @$self{qw(http_state write)} = ('start_line', $msg->start_line_size)
      unless $self->{http_state};
  
    # Start-line
    my $chunk = '';
    $chunk .= $self->_start_line($msg) if $self->{http_state} eq 'start_line';
  
    # Headers
    $chunk .= $self->_headers($msg, $server) if $self->{http_state} eq 'headers';
  
    # Body
    $chunk .= $self->_body($msg, $server) if $self->{http_state} eq 'body';
  
    return $chunk;
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojo::Transaction::HTTP - HTTP transaction
  
  =head1 SYNOPSIS
  
    use Mojo::Transaction::HTTP;
  
    # Client
    my $tx = Mojo::Transaction::HTTP->new;
    $tx->req->method('GET');
    $tx->req->url->parse('http://example.com');
    $tx->req->headers->accept('application/json');
    say $tx->res->code;
    say $tx->res->headers->content_type;
    say $tx->res->body;
    say $tx->remote_address;
  
    # Server
    my $tx = Mojo::Transaction::HTTP->new;
    say $tx->req->method;
    say $tx->req->url->to_abs;
    say $tx->req->headers->accept;
    say $tx->remote_address;
    $tx->res->code(200);
    $tx->res->headers->content_type('text/plain');
    $tx->res->body('Hello World!');
  
  =head1 DESCRIPTION
  
  L<Mojo::Transaction::HTTP> is a container for HTTP transactions, based on
  L<RFC 7230|http://tools.ietf.org/html/rfc7230> and
  L<RFC 7231|http://tools.ietf.org/html/rfc7231>.
  
  =head1 EVENTS
  
  L<Mojo::Transaction::HTTP> inherits all events from L<Mojo::Transaction> and
  can emit the following new ones.
  
  =head2 request
  
    $tx->on(request => sub {
      my $tx = shift;
      ...
    });
  
  Emitted when a request is ready and needs to be handled.
  
    $tx->on(request => sub {
      my $tx = shift;
      $tx->res->headers->header('X-Bender' => 'Bite my shiny metal ass!');
    });
  
  =head2 resume
  
    $tx->on(resume => sub {
      my $tx = shift;
      ...
    });
  
  Emitted when transaction is resumed.
  
  =head2 unexpected
  
    $tx->on(unexpected => sub {
      my ($tx, $res) = @_;
      ...
    });
  
  Emitted for unexpected C<1xx> responses that will be ignored.
  
    $tx->on(unexpected => sub {
      my $tx = shift;
      $tx->res->on(finish => sub { say 'Follow-up response is finished.' });
    });
  
  =head1 ATTRIBUTES
  
  L<Mojo::Transaction::HTTP> inherits all attributes from L<Mojo::Transaction>
  and implements the following new ones.
  
  =head2 previous
  
    my $previous = $tx->previous;
    $tx          = $tx->previous(Mojo::Transaction::HTTP->new);
  
  Previous transaction that triggered this follow-up transaction, usually a
  L<Mojo::Transaction::HTTP> object.
  
    # Paths of previous requests
    say $tx->previous->previous->req->url->path;
    say $tx->previous->req->url->path;
  
  =head1 METHODS
  
  L<Mojo::Transaction::HTTP> inherits all methods from L<Mojo::Transaction> and
  implements the following new ones.
  
  =head2 client_read
  
    $tx->client_read($bytes);
  
  Read data client-side, used to implement user agents such as L<Mojo::UserAgent>.
  
  =head2 client_write
  
    my $bytes = $tx->client_write;
  
  Write data client-side, used to implement user agents such as
  L<Mojo::UserAgent>.
  
  =head2 is_empty
  
    my $bool = $tx->is_empty;
  
  Check transaction for C<HEAD> request and C<1xx>, C<204> or C<304> response.
  
  =head2 keep_alive
  
    my $bool = $tx->keep_alive;
  
  Check if connection can be kept alive.
  
  =head2 redirects
  
    my $redirects = $tx->redirects;
  
  Return an array reference with all previous transactions that preceded this
  follow-up transaction.
  
    # Paths of all previous requests
    say $_->req->url->path for @{$tx->redirects};
  
  =head2 resume
  
    $tx = $tx->resume;
  
  Resume transaction.
  
  =head2 server_read
  
    $tx->server_read($bytes);
  
  Read data server-side, used to implement web servers such as
  L<Mojo::Server::Daemon>.
  
  =head2 server_write
  
    my $bytes = $tx->server_write;
  
  Write data server-side, used to implement web servers such as
  L<Mojo::Server::Daemon>.
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<http://mojolicious.org>.
  
  =cut
MOJO_TRANSACTION_HTTP

$fatpacked{"Mojo/Transaction/WebSocket.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJO_TRANSACTION_WEBSOCKET';
  package Mojo::Transaction::WebSocket;
  use Mojo::Base 'Mojo::Transaction';
  
  use Compress::Raw::Zlib 'Z_SYNC_FLUSH';
  use List::Util 'first';
  use Mojo::JSON qw(encode_json j);
  use Mojo::Util qw(decode encode trim);
  use Mojo::WebSocket
    qw(WS_BINARY WS_CLOSE WS_CONTINUATION WS_PING WS_PONG WS_TEXT);
  
  has [qw(compressed established handshake masked)];
  has max_websocket_size => sub { $ENV{MOJO_MAX_WEBSOCKET_SIZE} || 262144 };
  
  sub build_message {
    my ($self, $frame) = @_;
  
    # Text
    $frame = {text => encode('UTF-8', $frame)} if ref $frame ne 'HASH';
  
    # JSON
    $frame->{text} = encode_json($frame->{json}) if exists $frame->{json};
  
    # Raw text or binary
    if (exists $frame->{text}) { $frame = [1, 0, 0, 0, WS_TEXT, $frame->{text}] }
    else { $frame = [1, 0, 0, 0, WS_BINARY, $frame->{binary}] }
  
    # "permessage-deflate" extension
    return $frame unless $self->compressed;
    my $deflate = $self->{deflate} ||= Compress::Raw::Zlib::Deflate->new(
      AppendOutput => 1,
      MemLevel     => 8,
      WindowBits   => -15
    );
    $deflate->deflate($frame->[5], my $out);
    $deflate->flush($out, Z_SYNC_FLUSH);
    @$frame[1, 5] = (1, substr($out, 0, length($out) - 4));
  
    return $frame;
  }
  
  sub client_read  { shift->server_read(@_) }
  sub client_write { shift->server_write(@_) }
  
  sub closed {
    my $self = shift->completed;
    return $self->emit(finish => $self->{close} ? (@{$self->{close}}) : 1006);
  }
  
  sub connection { shift->handshake->connection }
  
  sub finish {
    my $self = shift;
  
    my $close = $self->{close} = [@_];
    my $payload = $close->[0] ? pack('n', $close->[0]) : '';
    $payload .= encode 'UTF-8', $close->[1] if defined $close->[1];
    $close->[0] //= 1005;
    $self->send([1, 0, 0, 0, WS_CLOSE, $payload])->{closing} = 1;
  
    return $self;
  }
  
  sub is_websocket {1}
  
  sub kept_alive    { shift->handshake->kept_alive }
  sub local_address { shift->handshake->local_address }
  sub local_port    { shift->handshake->local_port }
  
  sub parse_message {
    my ($self, $frame) = @_;
  
    $self->emit(frame => $frame);
  
    # Ping/Pong
    my $op = $frame->[4];
    return $self->send([1, 0, 0, 0, WS_PONG, $frame->[5]]) if $op == WS_PING;
    return if $op == WS_PONG;
  
    # Close
    if ($op == WS_CLOSE) {
      return $self->finish unless length $frame->[5] >= 2;
      return $self->finish(unpack('n', substr($frame->[5], 0, 2, '')),
        decode('UTF-8', $frame->[5]));
    }
  
    # Append chunk and check message size
    $self->{op} = $op unless exists $self->{op};
    $self->{message} .= $frame->[5];
    my $max = $self->max_websocket_size;
    return $self->finish(1009) if length $self->{message} > $max;
  
    # No FIN bit (Continuation)
    return unless $frame->[0];
  
    # "permessage-deflate" extension (handshake and RSV1)
    my $msg = delete $self->{message};
    if ($self->compressed && $frame->[1]) {
      my $inflate = $self->{inflate} ||= Compress::Raw::Zlib::Inflate->new(
        Bufsize     => $max,
        LimitOutput => 1,
        WindowBits  => -15
      );
      $inflate->inflate(($msg .= "\x00\x00\xff\xff"), my $out);
      return $self->finish(1009) if length $msg;
      $msg = $out;
    }
  
    $self->emit(json => j($msg)) if $self->has_subscribers('json');
    $op = delete $self->{op};
    $self->emit($op == WS_TEXT ? 'text' : 'binary' => $msg);
    $self->emit(message => $op == WS_TEXT ? decode 'UTF-8', $msg : $msg)
      if $self->has_subscribers('message');
  }
  
  sub protocol { shift->res->headers->sec_websocket_protocol }
  
  sub remote_address { shift->handshake->remote_address }
  sub remote_port    { shift->handshake->remote_port }
  sub req            { shift->handshake->req }
  sub res            { shift->handshake->res }
  
  sub resume { $_[0]->handshake->resume and return $_[0] }
  
  sub send {
    my ($self, $msg, $cb) = @_;
    $self->once(drain => $cb) if $cb;
    $msg = $self->build_message($msg) unless ref $msg eq 'ARRAY';
    $self->{write} .= Mojo::WebSocket::build_frame($self->masked, @$msg);
    return $self->emit('resume');
  }
  
  sub server_read {
    my ($self, $chunk) = @_;
  
    $self->{read} .= $chunk;
    my $max = $self->max_websocket_size;
    while (my $frame = Mojo::WebSocket::parse_frame(\$self->{read}, $max)) {
      $self->finish(1009) and last unless ref $frame;
      $self->parse_message($frame);
    }
  
    $self->emit('resume');
  }
  
  sub server_write {
    my $self = shift;
    $self->emit('drain') unless length($self->{write} //= '');
    $self->completed if !length $self->{write} && $self->{closing};
    return delete $self->{write};
  }
  
  sub with_compression {
    my $self = shift;
  
    # "permessage-deflate" extension
    $self->compressed(1)
      and $self->res->headers->sec_websocket_extensions('permessage-deflate')
      if ($self->req->headers->sec_websocket_extensions // '')
      =~ /permessage-deflate/;
  }
  
  sub with_protocols {
    my $self = shift;
  
    my %protos = map { trim($_) => 1 } split ',',
      $self->req->headers->sec_websocket_protocol // '';
    return undef unless defined(my $proto = first { $protos{$_} } @_);
  
    $self->res->headers->sec_websocket_protocol($proto);
    return $proto;
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojo::Transaction::WebSocket - WebSocket transaction
  
  =head1 SYNOPSIS
  
    use Mojo::Transaction::WebSocket;
  
    # Send and receive WebSocket messages
    my $ws = Mojo::Transaction::WebSocket->new;
    $ws->send('Hello World!');
    $ws->on(message => sub {
      my ($ws, $msg) = @_;
      say "Message: $msg";
    });
    $ws->on(finish => sub {
      my ($ws, $code, $reason) = @_;
      say "WebSocket closed with status $code.";
    });
  
  =head1 DESCRIPTION
  
  L<Mojo::Transaction::WebSocket> is a container for WebSocket transactions, based
  on L<RFC 6455|http://tools.ietf.org/html/rfc6455> and
  L<RFC 7692|http://tools.ietf.org/html/rfc7692>.
  
  =head1 EVENTS
  
  L<Mojo::Transaction::WebSocket> inherits all events from L<Mojo::Transaction>
  and can emit the following new ones.
  
  =head2 binary
  
    $ws->on(binary => sub {
      my ($ws, $bytes) = @_;
      ...
    });
  
  Emitted when a complete WebSocket binary message has been received.
  
    $ws->on(binary => sub {
      my ($ws, $bytes) = @_;
      say "Binary: $bytes";
    });
  
  =head2 drain
  
    $ws->on(drain => sub {
      my $ws = shift;
      ...
    });
  
  Emitted once all data has been sent.
  
    $ws->on(drain => sub {
      my $ws = shift;
      $ws->send(time);
    });
  
  =head2 finish
  
    $ws->on(finish => sub {
      my ($ws, $code, $reason) = @_;
      ...
    });
  
  Emitted when the WebSocket connection has been closed.
  
  =head2 frame
  
    $ws->on(frame => sub {
      my ($ws, $frame) = @_;
      ...
    });
  
  Emitted when a WebSocket frame has been received.
  
    $ws->on(frame => sub {
      my ($ws, $frame) = @_;
      say "FIN: $frame->[0]";
      say "RSV1: $frame->[1]";
      say "RSV2: $frame->[2]";
      say "RSV3: $frame->[3]";
      say "Opcode: $frame->[4]";
      say "Payload: $frame->[5]";
    });
  
  =head2 json
  
    $ws->on(json => sub {
      my ($ws, $json) = @_;
      ...
    });
  
  Emitted when a complete WebSocket message has been received, all text and
  binary messages will be automatically JSON decoded. Note that this event only
  gets emitted when it has at least one subscriber.
  
    $ws->on(json => sub {
      my ($ws, $hash) = @_;
      say "Message: $hash->{msg}";
    });
  
  =head2 message
  
    $ws->on(message => sub {
      my ($ws, $msg) = @_;
      ...
    });
  
  Emitted when a complete WebSocket message has been received, text messages will
  be automatically decoded. Note that this event only gets emitted when it has at
  least one subscriber.
  
    $ws->on(message => sub {
      my ($ws, $msg) = @_;
      say "Message: $msg";
    });
  
  =head2 resume
  
    $tx->on(resume => sub {
      my $tx = shift;
      ...
    });
  
  Emitted when transaction is resumed.
  
  =head2 text
  
    $ws->on(text => sub {
      my ($ws, $bytes) = @_;
      ...
    });
  
  Emitted when a complete WebSocket text message has been received.
  
    $ws->on(text => sub {
      my ($ws, $bytes) = @_;
      say "Text: $bytes";
    });
  
  =head1 ATTRIBUTES
  
  L<Mojo::Transaction::WebSocket> inherits all attributes from
  L<Mojo::Transaction> and implements the following new ones.
  
  =head2 compressed
  
    my $bool = $ws->compressed;
    $ws      = $ws->compressed($bool);
  
  Compress messages with C<permessage-deflate> extension.
  
  =head2 established
  
    my $bool = $ws->established;
    $ws      = $ws->established($bool);
  
  WebSocket connection established.
  
  =head2 handshake
  
    my $handshake = $ws->handshake;
    $ws           = $ws->handshake(Mojo::Transaction::HTTP->new);
  
  The original handshake transaction, usually a L<Mojo::Transaction::HTTP> object.
  
  =head2 masked
  
    my $bool = $ws->masked;
    $ws      = $ws->masked($bool);
  
  Mask outgoing frames with XOR cipher and a random 32-bit key.
  
  =head2 max_websocket_size
  
    my $size = $ws->max_websocket_size;
    $ws      = $ws->max_websocket_size(1024);
  
  Maximum WebSocket message size in bytes, defaults to the value of the
  C<MOJO_MAX_WEBSOCKET_SIZE> environment variable or C<262144> (256KB).
  
  =head1 METHODS
  
  L<Mojo::Transaction::WebSocket> inherits all methods from L<Mojo::Transaction>
  and implements the following new ones.
  
  =head2 build_message
  
    my $frame = $ws->build_message({binary => $bytes});
    my $frame = $ws->build_message({text   => $bytes});
    my $frame = $ws->build_message({json   => {test => [1, 2, 3]}});
    my $frame = $ws->build_message($chars);
  
  Build WebSocket message.
  
  =head2 client_read
  
    $ws->client_read($data);
  
  Read data client-side, used to implement user agents such as L<Mojo::UserAgent>.
  
  =head2 client_write
  
    my $bytes = $ws->client_write;
  
  Write data client-side, used to implement user agents such as
  L<Mojo::UserAgent>.
  
  =head2 closed
  
    $tx = $tx->closed;
  
  Same as L<Mojo::Transaction/"completed">, but also indicates that all
  transaction data has been sent.
  
  =head2 connection
  
    my $id = $ws->connection;
  
  Connection identifier.
  
  =head2 finish
  
    $ws = $ws->finish;
    $ws = $ws->finish(1000);
    $ws = $ws->finish(1003 => 'Cannot accept data!');
  
  Close WebSocket connection gracefully.
  
  =head2 is_websocket
  
    my $bool = $ws->is_websocket;
  
  True, this is a L<Mojo::Transaction::WebSocket> object.
  
  =head2 kept_alive
  
    my $bool = $ws->kept_alive;
  
  Connection has been kept alive.
  
  =head2 local_address
  
    my $address = $ws->local_address;
  
  Local interface address.
  
  =head2 local_port
  
    my $port = $ws->local_port;
  
  Local interface port.
  
  =head2 parse_message
  
    $ws->parse_message([$fin, $rsv1, $rsv2, $rsv3, $op, $payload]);
  
  Parse WebSocket message.
  
  =head2 protocol
  
    my $proto = $ws->protocol;
  
  Return negotiated subprotocol or C<undef>.
  
  =head2 remote_address
  
    my $address = $ws->remote_address;
  
  Remote interface address.
  
  =head2 remote_port
  
    my $port = $ws->remote_port;
  
  Remote interface port.
  
  =head2 req
  
    my $req = $ws->req;
  
  Handshake request, usually a L<Mojo::Message::Request> object.
  
  =head2 res
  
    my $res = $ws->res;
  
  Handshake response, usually a L<Mojo::Message::Response> object.
  
  =head2 resume
  
    $ws = $ws->resume;
  
  Resume L</"handshake"> transaction.
  
  =head2 send
  
    $ws = $ws->send({binary => $bytes});
    $ws = $ws->send({text   => $bytes});
    $ws = $ws->send({json   => {test => [1, 2, 3]}});
    $ws = $ws->send([$fin, $rsv1, $rsv2, $rsv3, $op, $payload]);
    $ws = $ws->send($chars);
    $ws = $ws->send($chars => sub {...});
  
  Send message or frame non-blocking via WebSocket, the optional drain callback
  will be executed once all data has been written.
  
    # Send "Ping" frame
    use Mojo::WebSocket 'WS_PING';
    $ws->send([1, 0, 0, 0, WS_PING, 'Hello World!']);
  
  =head2 server_read
  
    $ws->server_read($data);
  
  Read data server-side, used to implement web servers such as
  L<Mojo::Server::Daemon>.
  
  =head2 server_write
  
    my $bytes = $ws->server_write;
  
  Write data server-side, used to implement web servers such as
  L<Mojo::Server::Daemon>.
  
  =head2 with_compression
  
    $ws->with_compression;
  
  Negotiate C<permessage-deflate> extension for this WebSocket connection.
  
  =head2 with_protocols
  
    my $proto = $ws->with_protocols('v2.proto', 'v1.proto');
  
  Negotiate subprotocol for this WebSocket connection.
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<http://mojolicious.org>.
  
  =cut
MOJO_TRANSACTION_WEBSOCKET

$fatpacked{"Mojo/URL.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJO_URL';
  package Mojo::URL;
  use Mojo::Base -base;
  use overload bool => sub {1}, '""' => sub { shift->to_string }, fallback => 1;
  
  use Mojo::Parameters;
  use Mojo::Path;
  use Mojo::Util
    qw(decode encode punycode_decode punycode_encode url_escape url_unescape);
  
  has base => sub { Mojo::URL->new };
  has [qw(fragment host port scheme userinfo)];
  
  sub clone {
    my $self  = shift;
    my $clone = $self->new;
    @$clone{keys %$self} = values %$self;
    $clone->{$_} && ($clone->{$_} = $clone->{$_}->clone) for qw(base path query);
    return $clone;
  }
  
  sub host_port {
    my ($self, $host_port) = @_;
  
    if (defined $host_port) {
      $self->port($1) if $host_port =~ s/:(\d+)$//;
      my $host = url_unescape $host_port;
      return $host =~ /[^\x00-\x7f]/ ? $self->ihost($host) : $self->host($host);
    }
  
    return undef unless defined(my $host = $self->ihost);
    return $host unless defined(my $port = $self->port);
    return "$host:$port";
  }
  
  sub ihost {
    my $self = shift;
  
    # Decode
    return $self->host(join '.',
      map { /^xn--(.+)$/ ? punycode_decode $1 : $_ } split(/\./, shift, -1))
      if @_;
  
    # Check if host needs to be encoded
    return undef unless defined(my $host = $self->host);
    return $host unless $host =~ /[^\x00-\x7f]/;
  
    # Encode
    return join '.',
      map { /[^\x00-\x7f]/ ? ('xn--' . punycode_encode $_) : $_ }
      split(/\./, $host, -1);
  }
  
  sub is_abs { !!shift->scheme }
  
  sub new { @_ > 1 ? shift->SUPER::new->parse(@_) : shift->SUPER::new }
  
  sub parse {
    my ($self, $url) = @_;
  
    # Official regex from RFC 3986
    $url =~ m!^(([^:/?#]+):)?(//([^/?#]*))?([^?#]*)(\?([^#]*))?(#(.*))?!;
    $self->scheme($2)                         if defined $2;
    $self->path($5)                           if defined $5;
    $self->query($7)                          if defined $7;
    $self->fragment(_decode(url_unescape $9)) if defined $9;
    if (defined(my $auth = $4)) {
      $self->userinfo(_decode(url_unescape $1)) if $auth =~ s/^([^\@]+)\@//;
      $self->host_port($auth);
    }
  
    return $self;
  }
  
  sub password { (shift->userinfo // '') =~ /:(.*)$/ ? $1 : undef }
  
  sub path {
    my $self = shift;
  
    # Old path
    $self->{path} ||= Mojo::Path->new;
    return $self->{path} unless @_;
  
    # New path
    $self->{path} = ref $_[0] ? $_[0] : $self->{path}->merge($_[0]);
  
    return $self;
  }
  
  sub path_query {
    my $self  = shift;
    my $query = $self->query->to_string;
    return $self->path->to_string . (length $query ? "?$query" : '');
  }
  
  sub protocol { lc(shift->scheme // '') }
  
  sub query {
    my $self = shift;
  
    # Old parameters
    my $q = $self->{query} ||= Mojo::Parameters->new;
    return $q unless @_;
  
    # Replace with list
    if (@_ > 1) { $q->pairs([])->parse(@_) }
  
    # Merge with array
    elsif (ref $_[0] eq 'ARRAY') { $q->merge(@{$_[0]}) }
  
    # Append hash
    elsif (ref $_[0] eq 'HASH') { $q->append(%{$_[0]}) }
  
    # New parameters
    else { $self->{query} = ref $_[0] ? $_[0] : $q->parse($_[0]) }
  
    return $self;
  }
  
  sub to_abs {
    my $self = shift;
  
    my $abs = $self->clone;
    return $abs if $abs->is_abs;
  
    # Scheme
    my $base = shift || $abs->base;
    $abs->base($base)->scheme($base->scheme);
  
    # Authority
    return $abs if $abs->host;
    $abs->userinfo($base->userinfo)->host($base->host)->port($base->port);
  
    # Absolute path
    my $path = $abs->path;
    return $abs if $path->leading_slash;
  
    # Inherit path
    if (!@{$path->parts}) {
      $abs->path($base->path->clone->canonicalize);
  
      # Query
      $abs->query($base->query->clone) unless length $abs->query->to_string;
    }
  
    # Merge paths
    else { $abs->path($base->path->clone->merge($path)->canonicalize) }
  
    return $abs;
  }
  
  sub to_string        { shift->_string(0) }
  sub to_unsafe_string { shift->_string(1) }
  
  sub username { (shift->userinfo // '') =~ /^([^:]+)/ ? $1 : undef }
  
  sub _decode { decode('UTF-8', $_[0]) // $_[0] }
  
  sub _encode { url_escape encode('UTF-8', $_[0]), $_[1] }
  
  sub _string {
    my ($self, $unsafe) = @_;
  
    # Scheme
    my $url = '';
    if (my $proto = $self->protocol) { $url .= "$proto:" }
  
    # Authority
    my $auth = $self->host_port;
    $auth = _encode($auth, '^A-Za-z0-9\-._~!$&\'()*+,;=:\[\]') if defined $auth;
    if ($unsafe && defined(my $info = $self->userinfo)) {
      $auth = _encode($info, '^A-Za-z0-9\-._~!$&\'()*+,;=:') . '@' . $auth;
    }
    $url .= "//$auth" if defined $auth;
  
    # Path and query
    my $path = $self->path_query;
    $url .= !$auth || !length $path || $path =~ m!^[/?]! ? $path : "/$path";
  
    # Fragment
    return $url unless defined(my $fragment = $self->fragment);
    return $url . '#' . _encode($fragment, '^A-Za-z0-9\-._~!$&\'()*+,;=:@/?');
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojo::URL - Uniform Resource Locator
  
  =head1 SYNOPSIS
  
    use Mojo::URL;
  
    # Parse
    my $url = Mojo::URL->new('http://sri:foo@example.com:3000/foo?foo=bar#23');
    say $url->scheme;
    say $url->userinfo;
    say $url->host;
    say $url->port;
    say $url->path;
    say $url->query;
    say $url->fragment;
  
    # Build
    my $url = Mojo::URL->new;
    $url->scheme('http');
    $url->host('example.com');
    $url->port(3000);
    $url->path('/foo/bar');
    $url->query(foo => 'bar');
    $url->fragment(23);
    say "$url";
  
  =head1 DESCRIPTION
  
  L<Mojo::URL> implements a subset of
  L<RFC 3986|http://tools.ietf.org/html/rfc3986>,
  L<RFC 3987|http://tools.ietf.org/html/rfc3987> and the
  L<URL Living Standard|https://url.spec.whatwg.org> for Uniform Resource
  Locators with support for IDNA and IRIs.
  
  =head1 ATTRIBUTES
  
  L<Mojo::URL> implements the following attributes.
  
  =head2 base
  
    my $base = $url->base;
    $url     = $url->base(Mojo::URL->new);
  
  Base of this URL, defaults to a L<Mojo::URL> object.
  
    "http://example.com/a/b?c"
    Mojo::URL->new("/a/b?c")->base(Mojo::URL->new("http://example.com"))->to_abs;
  
  =head2 fragment
  
    my $fragment = $url->fragment;
    $url         = $url->fragment('mojolicious');
  
  Fragment part of this URL.
  
    # "yada"
    Mojo::URL->new('http://example.com/foo?bar=baz#yada')->fragment;
  
  =head2 host
  
    my $host = $url->host;
    $url     = $url->host('127.0.0.1');
  
  Host part of this URL.
  
    # "example.com"
    Mojo::URL->new('http://sri:t3st@example.com:8080/foo')->host;
  
  =head2 port
  
    my $port = $url->port;
    $url     = $url->port(8080);
  
  Port part of this URL.
  
    # "8080"
    Mojo::URL->new('http://sri:t3st@example.com:8080/foo')->port;
  
  =head2 scheme
  
    my $scheme = $url->scheme;
    $url       = $url->scheme('http');
  
  Scheme part of this URL.
  
    # "http"
    Mojo::URL->new('http://example.com/foo')->scheme;
  
  =head2 userinfo
  
    my $info = $url->userinfo;
    $url     = $url->userinfo('root:');
  
  Userinfo part of this URL.
  
    # "sri:t3st"
    Mojo::URL->new('https://sri:t3st@example.com/foo')->userinfo;
  
  =head1 METHODS
  
  L<Mojo::URL> inherits all methods from L<Mojo::Base> and implements the
  following new ones.
  
  =head2 clone
  
    my $url2 = $url->clone;
  
  Clone this URL.
  
  =head2 host_port
  
    my $host_port = $url->host_port;
    $url          = $url->host_port('example.com:8080');
  
  Normalized version of L</"host"> and L</"port">.
  
    # "xn--n3h.net:8080"
    Mojo::URL->new('http://.net:8080/test')->host_port;
  
    # "example.com"
    Mojo::URL->new('http://example.com/test')->host_port;
  
  =head2 ihost
  
    my $ihost = $url->ihost;
    $url      = $url->ihost('xn--bcher-kva.ch');
  
  Host part of this URL in punycode format.
  
    # "xn--n3h.net"
    Mojo::URL->new('http://.net')->ihost;
  
    # "example.com"
    Mojo::URL->new('http://example.com')->ihost;
  
  =head2 is_abs
  
    my $bool = $url->is_abs;
  
  Check if URL is absolute.
  
    # True
    Mojo::URL->new('http://example.com')->is_abs;
    Mojo::URL->new('http://example.com/test/index.html')->is_abs;
  
    # False
    Mojo::URL->new('test/index.html')->is_abs;
    Mojo::URL->new('/test/index.html')->is_abs;
    Mojo::URL->new('//example.com/test/index.html')->is_abs;
  
  =head2 new
  
    my $url = Mojo::URL->new;
    my $url = Mojo::URL->new('http://127.0.0.1:3000/foo?f=b&baz=2#foo');
  
  Construct a new L<Mojo::URL> object and L</"parse"> URL if necessary.
  
  =head2 parse
  
    $url = $url->parse('http://127.0.0.1:3000/foo/bar?fo=o&baz=23#foo');
  
  Parse relative or absolute URL.
  
    # "/test/123"
    $url->parse('/test/123?foo=bar')->path;
  
    # "example.com"
    $url->parse('http://example.com/test/123?foo=bar')->host;
  
    # "sri@example.com"
    $url->parse('mailto:sri@example.com')->path;
  
  =head2 password
  
    my $password = $url->password;
  
  Password part of L</"userinfo">.
  
    # "s3cret"
    Mojo::URL->new('http://isabel:s3cret@mojolicious.org')->password;
  
    # "s:3:c:r:e:t"
    Mojo::URL->new('http://isabel:s:3:c:r:e:t@mojolicious.org')->password;
  
  =head2 path
  
    my $path = $url->path;
    $url     = $url->path('foo/bar');
    $url     = $url->path('/foo/bar');
    $url     = $url->path(Mojo::Path->new);
  
  Path part of this URL, relative paths will be merged with
  L<Mojo::Path/"merge">, defaults to a L<Mojo::Path> object.
  
    # "perldoc"
    Mojo::URL->new('http://example.com/perldoc/Mojo')->path->parts->[0];
  
    # "/perldoc/DOM/HTML"
    Mojo::URL->new('http://example.com/perldoc/Mojo')->path->merge('DOM/HTML');
  
    # "http://example.com/DOM/HTML"
    Mojo::URL->new('http://example.com/perldoc/Mojo')->path('/DOM/HTML');
  
    # "http://example.com/perldoc/DOM/HTML"
    Mojo::URL->new('http://example.com/perldoc/Mojo')->path('DOM/HTML');
  
    # "http://example.com/perldoc/Mojo/DOM/HTML"
    Mojo::URL->new('http://example.com/perldoc/Mojo/')->path('DOM/HTML');
  
  =head2 path_query
  
    my $path_query = $url->path_query;
  
  Normalized version of L</"path"> and L</"query">.
  
    # "/test?a=1&b=2"
    Mojo::URL->new('http://example.com/test?a=1&b=2')->path_query;
  
    # "/"
    Mojo::URL->new('http://example.com/')->path_query;
  
  =head2 protocol
  
    my $proto = $url->protocol;
  
  Normalized version of L</"scheme">.
  
    # "http"
    Mojo::URL->new('HtTp://example.com')->protocol;
  
  =head2 query
  
    my $query = $url->query;
    $url      = $url->query([merge => 'with']);
    $url      = $url->query({append => 'to'});
    $url      = $url->query(replace => 'with');
    $url      = $url->query('a=1&b=2');
    $url      = $url->query(Mojo::Parameters->new);
  
  Query part of this URL, key/value pairs in an array reference will be merged
  with L<Mojo::Parameters/"merge">, and key/value pairs in a hash reference
  appended with L<Mojo::Parameters/"append">, defaults to a L<Mojo::Parameters>
  object.
  
    # "2"
    Mojo::URL->new('http://example.com?a=1&b=2')->query->param('b');
  
    # "a=2&b=2&c=3"
    Mojo::URL->new('http://example.com?a=1&b=2')->query->merge(a => 2, c => 3);
  
    # "http://example.com?a=2&c=3"
    Mojo::URL->new('http://example.com?a=1&b=2')->query(a => 2, c => 3);
  
    # "http://example.com?a=2&a=3"
    Mojo::URL->new('http://example.com?a=1&b=2')->query(a => [2, 3]);
  
    # "http://example.com?a=2&b=2&c=3"
    Mojo::URL->new('http://example.com?a=1&b=2')->query([a => 2, c => 3]);
  
    # "http://example.com?b=2"
    Mojo::URL->new('http://example.com?a=1&b=2')->query([a => undef]);
  
    # "http://example.com?a=1&b=2&a=2&c=3"
    Mojo::URL->new('http://example.com?a=1&b=2')->query({a => 2, c => 3});
  
  =head2 to_abs
  
    my $abs = $url->to_abs;
    my $abs = $url->to_abs(Mojo::URL->new('http://example.com/foo'));
  
  Clone relative URL and turn it into an absolute one using L</"base"> or
  provided base URL.
  
    # "http://example.com/foo/baz.xml?test=123"
    Mojo::URL->new('baz.xml?test=123')
      ->to_abs(Mojo::URL->new('http://example.com/foo/bar.html'));
  
    # "http://example.com/baz.xml?test=123"
    Mojo::URL->new('/baz.xml?test=123')
      ->to_abs(Mojo::URL->new('http://example.com/foo/bar.html'));
  
    # "http://example.com/foo/baz.xml?test=123"
    Mojo::URL->new('//example.com/foo/baz.xml?test=123')
      ->to_abs(Mojo::URL->new('http://example.com/foo/bar.html'));
  
  =head2 to_string
  
    my $str = $url->to_string;
  
  Turn URL into a string. Note that L</"userinfo"> will not be included for
  security reasons.
  
    # "http://mojolicious.org"
    Mojo::URL->new->scheme('http')->host('mojolicious.org')->to_string;
  
    # "http://mojolicious.org"
    Mojo::URL->new('http://daniel:s3cret@mojolicious.org')->to_string;
  
  =head2 to_unsafe_string
  
    my $str = $url->to_unsafe_string;
  
  Same as L</"to_string">, but includes L</"userinfo">.
  
    # "http://daniel:s3cret@mojolicious.org"
    Mojo::URL->new('http://daniel:s3cret@mojolicious.org')->to_unsafe_string;
  
  =head2 username
  
    my $username = $url->username;
  
  Username part of L</"userinfo">.
  
    # "isabel"
    Mojo::URL->new('http://isabel:s3cret@mojolicious.org')->username;
  
  =head1 OPERATORS
  
  L<Mojo::URL> overloads the following operators.
  
  =head2 bool
  
    my $bool = !!$url;
  
  Always true.
  
  =head2 stringify
  
    my $str = "$url";
  
  Alias for L</"to_string">.
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<http://mojolicious.org>.
  
  =cut
MOJO_URL

$fatpacked{"Mojo/Upload.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJO_UPLOAD';
  package Mojo::Upload;
  use Mojo::Base -base;
  
  has [qw(asset filename headers name)];
  
  sub move_to { $_[0]->asset->move_to($_[1]) and return $_[0] }
  
  sub size  { shift->asset->size }
  sub slurp { shift->asset->slurp }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojo::Upload - Upload
  
  =head1 SYNOPSIS
  
    use Mojo::Upload;
  
    my $upload = Mojo::Upload->new;
    say $upload->filename;
    $upload->move_to('/home/sri/foo.txt');
  
  =head1 DESCRIPTION
  
  L<Mojo::Upload> is a container for uploaded files.
  
  =head1 ATTRIBUTES
  
  L<Mojo::Upload> implements the following attributes.
  
  =head2 asset
  
    my $asset = $upload->asset;
    $upload   = $upload->asset(Mojo::Asset::File->new);
  
  Asset containing the uploaded data, usually a L<Mojo::Asset::File> or
  L<Mojo::Asset::Memory> object.
  
  =head2 filename
  
    my $filename = $upload->filename;
    $upload      = $upload->filename('foo.txt');
  
  Name of the uploaded file.
  
  =head2 headers
  
    my $headers = $upload->headers;
    $upload     = $upload->headers(Mojo::Headers->new);
  
  Headers for upload, usually a L<Mojo::Headers> object.
  
  =head2 name
  
    my $name = $upload->name;
    $upload  = $upload->name('foo');
  
  Name of the upload.
  
  =head1 METHODS
  
  L<Mojo::Upload> inherits all methods from L<Mojo::Base> and implements the
  following new ones.
  
  =head2 move_to
  
    $upload = $upload->move_to('/home/sri/foo.txt');
  
  Move uploaded data into a specific file.
  
  =head2 size
  
    my $size = $upload->size;
  
  Size of uploaded data in bytes.
  
  =head2 slurp
  
    my $bytes = $upload->slurp;
  
  Read all uploaded data at once.
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<http://mojolicious.org>.
  
  =cut
MOJO_UPLOAD

$fatpacked{"Mojo/UserAgent.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJO_USERAGENT';
  package Mojo::UserAgent;
  use Mojo::Base 'Mojo::EventEmitter';
  
  # "Fry: Since when is the Internet about robbing people of their privacy?
  #  Bender: August 6, 1991."
  use Mojo::IOLoop;
  use Mojo::Util qw(monkey_patch term_escape);
  use Mojo::UserAgent::CookieJar;
  use Mojo::UserAgent::Proxy;
  use Mojo::UserAgent::Server;
  use Mojo::UserAgent::Transactor;
  use Scalar::Util 'weaken';
  
  use constant DEBUG => $ENV{MOJO_USERAGENT_DEBUG} || 0;
  
  has ca              => sub { $ENV{MOJO_CA_FILE} };
  has cert            => sub { $ENV{MOJO_CERT_FILE} };
  has connect_timeout => sub { $ENV{MOJO_CONNECT_TIMEOUT} || 10 };
  has cookie_jar      => sub { Mojo::UserAgent::CookieJar->new };
  has [qw(local_address max_response_size)];
  has inactivity_timeout => sub { $ENV{MOJO_INACTIVITY_TIMEOUT} // 20 };
  has ioloop             => sub { Mojo::IOLoop->new };
  has key                => sub { $ENV{MOJO_KEY_FILE} };
  has max_connections    => 5;
  has max_redirects => sub { $ENV{MOJO_MAX_REDIRECTS} || 0 };
  has proxy => sub { Mojo::UserAgent::Proxy->new };
  has request_timeout => sub { $ENV{MOJO_REQUEST_TIMEOUT} // 0 };
  has server => sub { Mojo::UserAgent::Server->new(ioloop => shift->ioloop) };
  has transactor => sub { Mojo::UserAgent::Transactor->new };
  
  # Common HTTP methods
  for my $name (qw(DELETE GET HEAD OPTIONS PATCH POST PUT)) {
    monkey_patch __PACKAGE__, lc $name, sub {
      my ($self, $cb) = (shift, ref $_[-1] eq 'CODE' ? pop : undef);
      return $self->start($self->build_tx($name, @_), $cb);
    };
  }
  
  sub DESTROY { Mojo::Util::_global_destruction() or shift->_cleanup }
  
  sub build_tx           { shift->transactor->tx(@_) }
  sub build_websocket_tx { shift->transactor->websocket(@_) }
  
  sub start {
    my ($self, $tx, $cb) = @_;
  
    # Fork-safety
    $self->_cleanup->server->restart unless ($self->{pid} //= $$) eq $$;
  
    # Non-blocking
    if ($cb) {
      warn "-- Non-blocking request (@{[_url($tx)]})\n" if DEBUG;
      return $self->_start(Mojo::IOLoop->singleton, $tx, $cb);
    }
  
    # Blocking
    warn "-- Blocking request (@{[_url($tx)]})\n" if DEBUG;
    $self->_start($self->ioloop, $tx => sub { shift->ioloop->stop; $tx = shift });
    $self->ioloop->start;
  
    return $tx;
  }
  
  sub websocket {
    my ($self, $cb) = (shift, pop);
    $self->start($self->build_websocket_tx(@_), $cb);
  }
  
  sub _cleanup {
    my $self = shift;
    delete $self->{pid};
    $self->_finish($_, 1) for keys %{$self->{connections} || {}};
    return $self;
  }
  
  sub _connect {
    my ($self, $loop, $peer, $tx, $handle, $cb) = @_;
  
    my $t = $self->transactor;
    my ($proto, $host, $port) = $peer ? $t->peer($tx) : $t->endpoint($tx);
  
    my %options = (timeout => $self->connect_timeout);
    if ($proto eq 'http+unix') { $options{path} = $host }
    else                       { @options{qw(address port)} = ($host, $port) }
    if (my $local = $self->local_address) { $options{local_address} = $local }
    $options{handle} = $handle if $handle;
  
    # SOCKS
    if ($proto eq 'socks') {
      @options{qw(socks_address socks_port)} = @options{qw(address port)};
      ($proto, @options{qw(address port)}) = $t->endpoint($tx);
      my $userinfo = $tx->req->via_proxy(0)->proxy->userinfo;
      @options{qw(socks_user socks_pass)} = split ':', $userinfo if $userinfo;
    }
  
    # TLS
    map { $options{"tls_$_"} = $self->$_ } qw(ca cert key)
      if ($options{tls} = $proto eq 'https');
  
    weaken $self;
    my $id;
    return $id = $loop->client(
      %options => sub {
        my ($loop, $err, $stream) = @_;
  
        # Connection error
        return unless $self;
        return $self->_error($id, $err) if $err;
  
        # Connection established
        $stream->on(timeout => sub { $self->_error($id, 'Inactivity timeout') });
        $stream->on(close => sub { $self && $self->_finish($id, 1) });
        $stream->on(error => sub { $self && $self->_error($id, pop) });
        $stream->on(read => sub { $self->_read($id, pop) });
        $self->$cb($id);
      }
    );
  }
  
  sub _connect_proxy {
    my ($self, $loop, $old, $cb) = @_;
  
    # Start CONNECT request
    return undef unless my $new = $self->transactor->proxy_connect($old);
    return $self->_start(
      ($loop, $new) => sub {
        my ($self, $tx) = @_;
  
        # CONNECT failed
        $old->previous($tx)->req->via_proxy(0);
        my $id = $tx->connection;
        if ($tx->error || !$tx->res->is_success || !$tx->keep_alive) {
          $old->res->error({message => 'Proxy connection failed'});
          $self->_remove($id) if $id;
          return $self->$cb($old);
        }
  
        # Start real transaction without TLS upgrade
        return $self->_start($loop, $old->connection($id), $cb)
          unless $tx->req->url->protocol eq 'https';
  
        # TLS upgrade before starting the real transaction
        my $handle = $loop->stream($id)->steal_handle;
        $self->_remove($id);
        $id = $self->_connect($loop, 0, $old, $handle,
          sub { shift->_start($loop, $old->connection($id), $cb) });
        $self->{connections}{$id} = {cb => $cb, ioloop => $loop, tx => $old};
      }
    );
  }
  
  sub _connected {
    my ($self, $id) = @_;
  
    my $c      = $self->{connections}{$id};
    my $stream = $c->{ioloop}->stream($id)->timeout($self->inactivity_timeout);
    my $tx     = $c->{tx}->connection($id);
    my $handle = $stream->handle;
    unless ($handle->isa('IO::Socket::UNIX')) {
      $tx->local_address($handle->sockhost)->local_port($handle->sockport);
      $tx->remote_address($handle->peerhost)->remote_port($handle->peerport);
    }
  
    weaken $self;
    $tx->on(resume => sub { $self->_write($id) });
    $self->_write($id);
  }
  
  sub _connection {
    my ($self, $loop, $tx, $cb) = @_;
  
    # Reuse connection
    my ($proto, $host, $port) = $self->transactor->endpoint($tx);
    my $id = $tx->connection || $self->_dequeue($loop, "$proto:$host:$port", 1);
    if ($id) {
      warn "-- Reusing connection $id ($proto://$host:$port)\n" if DEBUG;
      @{$self->{connections}{$id}}{qw(cb tx)} = ($cb, $tx);
      $tx->kept_alive(1) unless $tx->connection;
      $self->_connected($id);
      return $id;
    }
  
    # CONNECT request to proxy required
    if (my $id = $self->_connect_proxy($loop, $tx, $cb)) { return $id }
  
    # New connection
    $tx->res->error({message => "Unsupported protocol: $proto"})
      and return $loop->next_tick(sub { $self->$cb($tx) })
      unless $proto eq 'http' || $proto eq 'https' || $proto eq 'http+unix';
    $id = $self->_connect($loop, 1, $tx, undef, \&_connected);
    warn "-- Connect $id ($proto://$host:$port)\n" if DEBUG;
    $self->{connections}{$id} = {cb => $cb, ioloop => $loop, tx => $tx};
  
    return $id;
  }
  
  sub _dequeue {
    my ($self, $loop, $name, $test) = @_;
  
    my $old = $self->{queue}{$loop} ||= [];
    my ($found, @new);
    for my $queued (@$old) {
      push @new, $queued and next if $found || !grep { $_ eq $name } @$queued;
  
      # Search for id/name and sort out corrupted connections if necessary
      next unless my $stream = $loop->stream($queued->[1]);
      $test && $stream->is_readable ? $stream->close : ($found = $queued->[1]);
    }
    @$old = @new;
  
    return $found;
  }
  
  sub _error {
    my ($self, $id, $err) = @_;
    my $tx = $self->{connections}{$id}{tx};
    $tx->res->error({message => $err}) if $tx;
    $self->_finish($id, 1);
  }
  
  sub _finish {
    my ($self, $id, $close) = @_;
  
    # Remove request timeout and finish transaction
    return unless my $c = $self->{connections}{$id};
    $c->{ioloop}->remove($c->{timeout}) if $c->{timeout};
    return $self->_reuse($id, $close) unless my $old = $c->{tx};
  
    # Premature connection close
    my $res = $old->closed->res->finish;
    if ($close && !$res->code && !$res->error) {
      $res->error({message => 'Premature connection close'});
    }
  
    # Always remove connection for WebSockets
    return $self->_remove($id) if $old->is_websocket;
  
    $self->cookie_jar->collect($old);
  
    # Upgrade connection to WebSocket
    if (my $new = $self->transactor->upgrade($old)) {
      weaken $self;
      $new->on(resume => sub { $self->_write($id) });
      $c->{cb}($self, $c->{tx} = $new);
      return $new->client_read($old->res->content->leftovers);
    }
  
    # CONNECT requests always have a follow-up request
    $self->_reuse($id, $close) unless uc $old->req->method eq 'CONNECT';
    $res->error({message => $res->message, code => $res->code}) if $res->is_error;
    $c->{cb}($self, $old) unless $self->_redirect($c, $old);
  }
  
  sub _read {
    my ($self, $id, $chunk) = @_;
  
    # Corrupted connection
    return $self->_remove($id) unless my $tx = $self->{connections}{$id}{tx};
  
    warn term_escape "-- Client <<< Server (@{[_url($tx)]})\n$chunk\n" if DEBUG;
    $tx->client_read($chunk);
    $self->_finish($id) if $tx->is_finished;
  }
  
  sub _redirect {
    my ($self, $c, $old) = @_;
    return undef unless my $new = $self->transactor->redirect($old);
    return undef unless @{$old->redirects} < $self->max_redirects;
    return $self->_start($c->{ioloop}, $new, delete $c->{cb});
  }
  
  sub _remove {
    my ($self, $id) = @_;
    my $c = delete $self->{connections}{$id};
    $self->_dequeue($c->{ioloop}, $id);
    $c->{ioloop}->remove($id);
  }
  
  sub _reuse {
    my ($self, $id, $close) = @_;
  
    # Connection close
    my $c   = $self->{connections}{$id};
    my $tx  = delete $c->{tx};
    my $max = $self->max_connections;
    return $self->_remove($id)
      if $close || !$tx || !$max || !$tx->keep_alive || $tx->error;
  
    # Keep connection alive
    my $queue = $self->{queue}{$c->{ioloop}} ||= [];
    $self->_remove(shift(@$queue)->[1]) while @$queue && @$queue >= $max;
    push @$queue, [join(':', $self->transactor->endpoint($tx)), $id];
  }
  
  sub _start {
    my ($self, $loop, $tx, $cb) = @_;
  
    # Application serve
    my $url = $tx->req->url;
    unless ($url->is_abs) {
      my $base
        = $loop == $self->ioloop ? $self->server->url : $self->server->nb_url;
      $url->scheme($base->scheme)->host($base->host)->port($base->port);
    }
  
    $_->prepare($tx) for $self->proxy, $self->cookie_jar;
    my $max = $self->max_response_size;
    $tx->res->max_message_size($max) if defined $max;
  
    $self->emit(start => $tx);
    return undef unless my $id = $self->_connection($loop, $tx, $cb);
    if (my $timeout = $self->request_timeout) {
      weaken $self;
      $self->{connections}{$id}{timeout}
        = $loop->timer($timeout => sub { $self->_error($id, 'Request timeout') });
    }
  
    return $id;
  }
  
  sub _url { shift->req->url->to_abs }
  
  sub _write {
    my ($self, $id) = @_;
  
    # Protect from resume event recursion
    my $c = $self->{connections}{$id};
    return if !(my $tx = $c->{tx}) || $c->{writing};
    local $c->{writing} = 1;
    my $chunk = $tx->client_write;
    warn term_escape "-- Client >>> Server (@{[_url($tx)]})\n$chunk\n" if DEBUG;
    return unless length $chunk;
    weaken $self;
    $c->{ioloop}->stream($id)->write($chunk => sub { $self->_write($id) });
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojo::UserAgent - Non-blocking I/O HTTP and WebSocket user agent
  
  =head1 SYNOPSIS
  
    use Mojo::UserAgent;
  
    # Fine grained response handling (dies on connection errors)
    my $ua  = Mojo::UserAgent->new;
    my $res = $ua->get('mojolicious.org/perldoc')->result;
    if    ($res->is_success)  { say $res->body }
    elsif ($res->is_error)    { say $res->message }
    elsif ($res->code == 301) { say $res->headers->location }
    else                      { say 'Whatever...' }
  
    # Say hello to the Unicode snowman and include an Accept header
    say $ua->get('www..net?hello=there' => {Accept => '*/*'})->result->body;
  
    # Extract data from HTML and XML resources with CSS selectors
    say $ua->get('www.perl.org')->result->dom->at('title')->text;
  
    # Scrape the latest headlines from a news site
    say $ua->get('blogs.perl.org')
      ->result->dom->find('h2 > a')->map('text')->join("\n");
  
    # IPv6 PUT request with Content-Type header and content
    my $tx = $ua->put('[::1]:3000' => {'Content-Type' => 'text/plain'} => 'Hi!');
  
    # Quick JSON API request with Basic authentication
    my $value = $ua->get('https://sri:t3st@example.com/test.json')->result->json;
  
    # JSON POST (application/json) with TLS certificate authentication
    my $tx = $ua->cert('tls.crt')->key('tls.key')
      ->post('https://example.com' => json => {top => 'secret'});
  
    # Search DuckDuckGo anonymously through Tor
    $ua->proxy->http('socks://127.0.0.1:9050');
    say $ua->get('api.3g2upl4pq6kufc4m.onion/?q=mojolicious&format=json')
      ->result->json('/Abstract');
  
    # GET request via UNIX domain socket "/tmp/myapp.sock" (percent encoded slash)
    say $ua->get('http+unix://%2Ftmp%2Fmyapp.sock/perldoc')->result->body;
  
    # Follow redirects to download Mojolicious from GitHub
    $ua->max_redirects(5)
      ->get('https://www.github.com/kraih/mojo/tarball/master')
      ->result->content->asset->move_to('/home/sri/mojo.tar.gz');
  
    # Form POST (application/x-www-form-urlencoded) with manual exception handling
    my $tx = $ua->post('https://metacpan.org/search' => form => {q => 'mojo'});
    if (my $res = $tx->success) { say $res->body }
    else {
      my $err = $tx->error;
      die "$err->{code} response: $err->{message}" if $err->{code};
      die "Connection error: $err->{message}";
    }
  
    # Non-blocking request
    $ua->get('mojolicious.org' => sub {
      my ($ua, $tx) = @_;
      say $tx->result->dom->at('title')->text;
    });
    Mojo::IOLoop->start unless Mojo::IOLoop->is_running;
  
    # Concurrent non-blocking requests (synchronized with a delay)
    Mojo::IOLoop->delay(
      sub {
        my $delay = shift;
        $ua->get('mojolicious.org' => $delay->begin);
        $ua->get('cpan.org'        => $delay->begin);
      },
      sub {
        my ($delay, $mojo, $cpan) = @_;
        say $mojo->result->dom->at('title')->text;
        say $cpan->result->dom->at('title')->text;
      }
    )->wait;
  
    # WebSocket connection sending and receiving JSON via UNIX domain socket
    $ua->websocket('ws+unix://%2Ftmp%2Fmyapp.sock/echo.json' => sub {
      my ($ua, $tx) = @_;
      say 'WebSocket handshake failed!' and return unless $tx->is_websocket;
      $tx->on(json => sub {
        my ($tx, $hash) = @_;
        say "WebSocket message via JSON: $hash->{msg}";
        $tx->finish;
      });
      $tx->send({json => {msg => 'Hello World!'}});
    });
    Mojo::IOLoop->start unless Mojo::IOLoop->is_running;
  
  =head1 DESCRIPTION
  
  L<Mojo::UserAgent> is a full featured non-blocking I/O HTTP and WebSocket user
  agent, with IPv6, TLS, SNI, IDNA, HTTP/SOCKS5 proxy, UNIX domain socket, Comet
  (long polling), keep-alive, connection pooling, timeout, cookie, multipart, gzip
  compression and multiple event loop support.
  
  All connections will be reset automatically if a new process has been forked,
  this allows multiple processes to share the same L<Mojo::UserAgent> object
  safely.
  
  For better scalability (epoll, kqueue) and to provide non-blocking name
  resolution, SOCKS5 as well as TLS support, the optional modules L<EV> (4.0+),
  L<Net::DNS::Native> (0.15+), L<IO::Socket::Socks> (0.64+) and
  L<IO::Socket::SSL> (1.94+) will be used automatically if possible. Individual
  features can also be disabled with the C<MOJO_NO_NNR>, C<MOJO_NO_SOCKS> and
  C<MOJO_NO_TLS> environment variables.
  
  See L<Mojolicious::Guides::Cookbook/"USER AGENT"> for more.
  
  =head1 EVENTS
  
  L<Mojo::UserAgent> inherits all events from L<Mojo::EventEmitter> and can emit
  the following new ones.
  
  =head2 start
  
    $ua->on(start => sub {
      my ($ua, $tx) = @_;
      ...
    });
  
  Emitted whenever a new transaction is about to start, this includes
  automatically prepared proxy C<CONNECT> requests and followed redirects.
  
    $ua->on(start => sub {
      my ($ua, $tx) = @_;
      $tx->req->headers->header('X-Bender' => 'Bite my shiny metal ass!');
    });
  
  =head1 ATTRIBUTES
  
  L<Mojo::UserAgent> implements the following attributes.
  
  =head2 ca
  
    my $ca = $ua->ca;
    $ua    = $ua->ca('/etc/tls/ca.crt');
  
  Path to TLS certificate authority file used to verify the peer certificate,
  defaults to the value of the C<MOJO_CA_FILE> environment variable. Also
  activates hostname verification.
  
    # Show certificate authorities for debugging
    IO::Socket::SSL::set_defaults(
      SSL_verify_callback => sub { say "Authority: $_[2]" and return $_[0] });
  
  =head2 cert
  
    my $cert = $ua->cert;
    $ua      = $ua->cert('/etc/tls/client.crt');
  
  Path to TLS certificate file, defaults to the value of the C<MOJO_CERT_FILE>
  environment variable.
  
  =head2 connect_timeout
  
    my $timeout = $ua->connect_timeout;
    $ua         = $ua->connect_timeout(5);
  
  Maximum amount of time in seconds establishing a connection may take before
  getting canceled, defaults to the value of the C<MOJO_CONNECT_TIMEOUT>
  environment variable or C<10>.
  
  =head2 cookie_jar
  
    my $cookie_jar = $ua->cookie_jar;
    $ua            = $ua->cookie_jar(Mojo::UserAgent::CookieJar->new);
  
  Cookie jar to use for requests performed by this user agent, defaults to a
  L<Mojo::UserAgent::CookieJar> object.
  
    # Ignore all cookies
    $ua->cookie_jar->ignore(sub { 1 });
  
    # Ignore cookies for public suffixes
    my $ps = IO::Socket::SSL::PublicSuffix->default;
    $ua->cookie_jar->ignore(sub {
      my $cookie = shift;
      return undef unless my $domain = $cookie->domain;
      return ($ps->public_suffix($domain))[0] eq '';
    });
  
    # Add custom cookie to the jar
    $ua->cookie_jar->add(
      Mojo::Cookie::Response->new(
        name   => 'foo',
        value  => 'bar',
        domain => 'mojolicious.org',
        path   => '/perldoc'
      )
    );
  
  =head2 inactivity_timeout
  
    my $timeout = $ua->inactivity_timeout;
    $ua         = $ua->inactivity_timeout(15);
  
  Maximum amount of time in seconds a connection can be inactive before getting
  closed, defaults to the value of the C<MOJO_INACTIVITY_TIMEOUT> environment
  variable or C<20>. Setting the value to C<0> will allow connections to be
  inactive indefinitely.
  
  =head2 ioloop
  
    my $loop = $ua->ioloop;
    $ua      = $ua->ioloop(Mojo::IOLoop->new);
  
  Event loop object to use for blocking I/O operations, defaults to a
  L<Mojo::IOLoop> object.
  
  =head2 key
  
    my $key = $ua->key;
    $ua     = $ua->key('/etc/tls/client.crt');
  
  Path to TLS key file, defaults to the value of the C<MOJO_KEY_FILE> environment
  variable.
  
  =head2 local_address
  
    my $address = $ua->local_address;
    $ua         = $ua->local_address('127.0.0.1');
  
  Local address to bind to.
  
  =head2 max_connections
  
    my $max = $ua->max_connections;
    $ua     = $ua->max_connections(5);
  
  Maximum number of keep-alive connections that the user agent will retain before
  it starts closing the oldest ones, defaults to C<5>. Setting the value to C<0>
  will prevent any connections from being kept alive.
  
  =head2 max_redirects
  
    my $max = $ua->max_redirects;
    $ua     = $ua->max_redirects(3);
  
  Maximum number of redirects the user agent will follow before it fails,
  defaults to the value of the C<MOJO_MAX_REDIRECTS> environment variable or
  C<0>.
  
  =head2 max_response_size
  
    my $max = $ua->max_response_size;
    $ua     = $ua->max_response_size(16777216);
  
  Maximum response size in bytes, defaults to the value of
  L<Mojo::Message::Response/"max_message_size">. Setting the value to C<0> will
  allow responses of indefinite size. Note that increasing this value can also
  drastically increase memory usage, should you for example attempt to parse an
  excessively large response body with the methods L<Mojo::Message/"dom"> or
  L<Mojo::Message/"json">.
  
  =head2 proxy
  
    my $proxy = $ua->proxy;
    $ua       = $ua->proxy(Mojo::UserAgent::Proxy->new);
  
  Proxy manager, defaults to a L<Mojo::UserAgent::Proxy> object.
  
    # Detect proxy servers from environment
    $ua->proxy->detect;
  
    # Manually configure HTTP proxy (using CONNECT for HTTPS/WebSockets)
    $ua->proxy->http('http://127.0.0.1:8080')->https('http://127.0.0.1:8080');
  
    # Manually configure Tor (SOCKS5)
    $ua->proxy->http('socks://127.0.0.1:9050')->https('socks://127.0.0.1:9050');
  
    # Manually configure UNIX domain socket (using CONNECT for HTTPS/WebSockets)
    $ua->proxy->http('http+unix://%2Ftmp%2Fproxy.sock')
      ->https('http+unix://%2Ftmp%2Fproxy.sock');
  
  =head2 request_timeout
  
    my $timeout = $ua->request_timeout;
    $ua         = $ua->request_timeout(5);
  
  Maximum amount of time in seconds establishing a connection, sending the
  request and receiving a whole response may take before getting canceled,
  defaults to the value of the C<MOJO_REQUEST_TIMEOUT> environment variable or
  C<0>. Setting the value to C<0> will allow the user agent to wait indefinitely.
  The timeout will reset for every followed redirect.
  
    # Total limit of 5 seconds, of which 3 seconds may be spent connecting
    $ua->max_redirects(0)->connect_timeout(3)->request_timeout(5);
  
  =head2 server
  
    my $server = $ua->server;
    $ua        = $ua->server(Mojo::UserAgent::Server->new);
  
  Application server relative URLs will be processed with, defaults to a
  L<Mojo::UserAgent::Server> object.
  
    # Mock web service
    $ua->server->app(Mojolicious->new);
    $ua->server->app->routes->get('/time' => sub {
      my $c = shift;
      $c->render(json => {now => time});
    });
    my $time = $ua->get('/time')->result->json->{now};
  
    # Change log level
    $ua->server->app->log->level('fatal');
  
    # Port currently used for processing relative URLs blocking
    say $ua->server->url->port;
  
    # Port currently used for processing relative URLs non-blocking
    say $ua->server->nb_url->port;
  
  =head2 transactor
  
    my $t = $ua->transactor;
    $ua   = $ua->transactor(Mojo::UserAgent::Transactor->new);
  
  Transaction builder, defaults to a L<Mojo::UserAgent::Transactor> object.
  
    # Change name of user agent
    $ua->transactor->name('MyUA 1.0');
  
  =head1 METHODS
  
  L<Mojo::UserAgent> inherits all methods from L<Mojo::EventEmitter> and
  implements the following new ones.
  
  =head2 build_tx
  
    my $tx = $ua->build_tx(GET => 'example.com');
    my $tx = $ua->build_tx(
      PUT => 'http://example.com' => {Accept => '*/*'} => 'Content!');
    my $tx = $ua->build_tx(
      PUT => 'http://example.com' => {Accept => '*/*'} => form => {a => 'b'});
    my $tx = $ua->build_tx(
      PUT => 'http://example.com' => {Accept => '*/*'} => json => {a => 'b'});
  
  Generate L<Mojo::Transaction::HTTP> object with
  L<Mojo::UserAgent::Transactor/"tx">.
  
    # Request with custom cookie
    my $tx = $ua->build_tx(GET => 'https://example.com/account');
    $tx->req->cookies({name => 'user', value => 'sri'});
    $tx = $ua->start($tx);
  
    # Deactivate gzip compression
    my $tx = $ua->build_tx(GET => 'example.com');
    $tx->req->headers->remove('Accept-Encoding');
    $tx = $ua->start($tx);
  
    # Interrupt response by raising an error
    my $tx = $ua->build_tx(GET => 'http://example.com');
    $tx->res->on(progress => sub {
      my $res = shift;
      return unless my $server = $res->headers->server;
      $res->error({message => 'Oh noes, it is IIS!'}) if $server =~ /IIS/;
    });
    $tx = $ua->start($tx);
  
  =head2 build_websocket_tx
  
    my $tx = $ua->build_websocket_tx('ws://example.com');
    my $tx = $ua->build_websocket_tx(
      'ws://example.com' => {DNT => 1} => ['v1.proto']);
  
  Generate L<Mojo::Transaction::HTTP> object with
  L<Mojo::UserAgent::Transactor/"websocket">.
  
    # Custom WebSocket handshake with cookie
    my $tx = $ua->build_websocket_tx('wss://example.com/echo');
    $tx->req->cookies({name => 'user', value => 'sri'});
    $ua->start($tx => sub {
      my ($ua, $tx) = @_;
      say 'WebSocket handshake failed!' and return unless $tx->is_websocket;
      $tx->on(message => sub {
        my ($tx, $msg) = @_;
        say "WebSocket message: $msg";
        $tx->finish;
      });
      $tx->send('Hi!');
    });
    Mojo::IOLoop->start unless Mojo::IOLoop->is_running;
  
  =head2 delete
  
    my $tx = $ua->delete('example.com');
    my $tx = $ua->delete('http://example.com' => {Accept => '*/*'} => 'Content!');
    my $tx = $ua->delete(
      'http://example.com' => {Accept => '*/*'} => form => {a => 'b'});
    my $tx = $ua->delete(
      'http://example.com' => {Accept => '*/*'} => json => {a => 'b'});
  
  Perform blocking C<DELETE> request and return resulting
  L<Mojo::Transaction::HTTP> object, takes the same arguments as
  L<Mojo::UserAgent::Transactor/"tx"> (except for the C<DELETE> method, which is
  implied). You can also append a callback to perform requests non-blocking.
  
    $ua->delete('http://example.com' => json => {a => 'b'} => sub {
      my ($ua, $tx) = @_;
      say $tx->result->body;
    });
    Mojo::IOLoop->start unless Mojo::IOLoop->is_running;
  
  =head2 get
  
    my $tx = $ua->get('example.com');
    my $tx = $ua->get('http://example.com' => {Accept => '*/*'} => 'Content!');
    my $tx = $ua->get(
      'http://example.com' => {Accept => '*/*'} => form => {a => 'b'});
    my $tx = $ua->get(
      'http://example.com' => {Accept => '*/*'} => json => {a => 'b'});
  
  Perform blocking C<GET> request and return resulting L<Mojo::Transaction::HTTP>
  object, takes the same arguments as L<Mojo::UserAgent::Transactor/"tx"> (except
  for the C<GET> method, which is implied). You can also append a callback to
  perform requests non-blocking.
  
    $ua->get('http://example.com' => json => {a => 'b'} => sub {
      my ($ua, $tx) = @_;
      say $tx->result->body;
    });
    Mojo::IOLoop->start unless Mojo::IOLoop->is_running;
  
  =head2 head
  
    my $tx = $ua->head('example.com');
    my $tx = $ua->head('http://example.com' => {Accept => '*/*'} => 'Content!');
    my $tx = $ua->head(
      'http://example.com' => {Accept => '*/*'} => form => {a => 'b'});
    my $tx = $ua->head(
      'http://example.com' => {Accept => '*/*'} => json => {a => 'b'});
  
  Perform blocking C<HEAD> request and return resulting
  L<Mojo::Transaction::HTTP> object, takes the same arguments as
  L<Mojo::UserAgent::Transactor/"tx"> (except for the C<HEAD> method, which is
  implied). You can also append a callback to perform requests non-blocking.
  
    $ua->head('http://example.com' => json => {a => 'b'} => sub {
      my ($ua, $tx) = @_;
      say $tx->result->body;
    });
    Mojo::IOLoop->start unless Mojo::IOLoop->is_running;
  
  =head2 options
  
    my $tx = $ua->options('example.com');
    my $tx = $ua->options('http://example.com' => {Accept => '*/*'} => 'Content!');
    my $tx = $ua->options(
      'http://example.com' => {Accept => '*/*'} => form => {a => 'b'});
    my $tx = $ua->options(
      'http://example.com' => {Accept => '*/*'} => json => {a => 'b'});
  
  Perform blocking C<OPTIONS> request and return resulting
  L<Mojo::Transaction::HTTP> object, takes the same arguments as
  L<Mojo::UserAgent::Transactor/"tx"> (except for the C<OPTIONS> method, which is
  implied). You can also append a callback to perform requests non-blocking.
  
    $ua->options('http://example.com' => json => {a => 'b'} => sub {
      my ($ua, $tx) = @_;
      say $tx->result->body;
    });
    Mojo::IOLoop->start unless Mojo::IOLoop->is_running;
  
  =head2 patch
  
    my $tx = $ua->patch('example.com');
    my $tx = $ua->patch('http://example.com' => {Accept => '*/*'} => 'Content!');
    my $tx = $ua->patch(
      'http://example.com' => {Accept => '*/*'} => form => {a => 'b'});
    my $tx = $ua->patch(
      'http://example.com' => {Accept => '*/*'} => json => {a => 'b'});
  
  Perform blocking C<PATCH> request and return resulting
  L<Mojo::Transaction::HTTP> object, takes the same arguments as
  L<Mojo::UserAgent::Transactor/"tx"> (except for the C<PATCH> method, which is
  implied). You can also append a callback to perform requests non-blocking.
  
    $ua->patch('http://example.com' => json => {a => 'b'} => sub {
      my ($ua, $tx) = @_;
      say $tx->result->body;
    });
    Mojo::IOLoop->start unless Mojo::IOLoop->is_running;
  
  =head2 post
  
    my $tx = $ua->post('example.com');
    my $tx = $ua->post('http://example.com' => {Accept => '*/*'} => 'Content!');
    my $tx = $ua->post(
      'http://example.com' => {Accept => '*/*'} => form => {a => 'b'});
    my $tx = $ua->post(
      'http://example.com' => {Accept => '*/*'} => json => {a => 'b'});
  
  Perform blocking C<POST> request and return resulting
  L<Mojo::Transaction::HTTP> object, takes the same arguments as
  L<Mojo::UserAgent::Transactor/"tx"> (except for the C<POST> method, which is
  implied). You can also append a callback to perform requests non-blocking.
  
    $ua->post('http://example.com' => json => {a => 'b'} => sub {
      my ($ua, $tx) = @_;
      say $tx->result->body;
    });
    Mojo::IOLoop->start unless Mojo::IOLoop->is_running;
  
  =head2 put
  
    my $tx = $ua->put('example.com');
    my $tx = $ua->put('http://example.com' => {Accept => '*/*'} => 'Content!');
    my $tx = $ua->put(
      'http://example.com' => {Accept => '*/*'} => form => {a => 'b'});
    my $tx = $ua->put(
      'http://example.com' => {Accept => '*/*'} => json => {a => 'b'});
  
  Perform blocking C<PUT> request and return resulting L<Mojo::Transaction::HTTP>
  object, takes the same arguments as L<Mojo::UserAgent::Transactor/"tx"> (except
  for the C<PUT> method, which is implied). You can also append a callback to
  perform requests non-blocking.
  
    $ua->put('http://example.com' => json => {a => 'b'} => sub {
      my ($ua, $tx) = @_;
      say $tx->result->body;
    });
    Mojo::IOLoop->start unless Mojo::IOLoop->is_running;
  
  =head2 start
  
    my $tx = $ua->start(Mojo::Transaction::HTTP->new);
  
  Perform blocking request for a custom L<Mojo::Transaction::HTTP> object, which
  can be prepared manually or with L</"build_tx">. You can also append a callback
  to perform requests non-blocking.
  
    my $tx = $ua->build_tx(GET => 'http://example.com');
    $ua->start($tx => sub {
      my ($ua, $tx) = @_;
      say $tx->result->body;
    });
    Mojo::IOLoop->start unless Mojo::IOLoop->is_running;
  
  =head2 websocket
  
    $ua->websocket('ws://example.com' => sub {...});
    $ua->websocket(
      'ws://example.com' => {DNT => 1} => ['v1.proto'] => sub {...});
  
  Open a non-blocking WebSocket connection with transparent handshake, takes the
  same arguments as L<Mojo::UserAgent::Transactor/"websocket">. The callback will
  receive either a L<Mojo::Transaction::WebSocket> or L<Mojo::Transaction::HTTP>
  object, depending on if the handshake was successful.
  
    $ua->websocket('wss://example.com/echo' => ['v1.proto'] => sub {
      my ($ua, $tx) = @_;
      say 'WebSocket handshake failed!' and return unless $tx->is_websocket;
      say 'Subprotocol negotiation failed!' and return unless $tx->protocol;
      $tx->on(finish => sub {
        my ($tx, $code, $reason) = @_;
        say "WebSocket closed with status $code.";
      });
      $tx->on(message => sub {
        my ($tx, $msg) = @_;
        say "WebSocket message: $msg";
        $tx->finish;
      });
      $tx->send('Hi!');
    });
    Mojo::IOLoop->start unless Mojo::IOLoop->is_running;
  
  You can activate C<permessage-deflate> compression by setting the
  C<Sec-WebSocket-Extensions> header, this can result in much better performance,
  but also increases memory usage by up to 300KB per connection.
  
    $ua->websocket('ws://example.com/foo' => {
      'Sec-WebSocket-Extensions' => 'permessage-deflate'
    } => sub {...});
  
  =head1 DEBUGGING
  
  You can set the C<MOJO_USERAGENT_DEBUG> environment variable to get some
  advanced diagnostics information printed to C<STDERR>.
  
    MOJO_USERAGENT_DEBUG=1
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<http://mojolicious.org>.
  
  =cut
MOJO_USERAGENT

$fatpacked{"Mojo/UserAgent/CookieJar.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJO_USERAGENT_COOKIEJAR';
  package Mojo::UserAgent::CookieJar;
  use Mojo::Base -base;
  
  use Mojo::Cookie::Request;
  use Mojo::Path;
  use Scalar::Util 'looks_like_number';
  
  has 'ignore';
  has max_cookie_size => 4096;
  
  sub add {
    my ($self, @cookies) = @_;
  
    my $size = $self->max_cookie_size;
    for my $cookie (@cookies) {
  
      # Convert max age to expires
      my $age = $cookie->max_age;
      $cookie->expires($age <= 0 ? 0 : $age + time) if looks_like_number $age;
  
      # Check cookie size
      next if length($cookie->value // '') > $size;
  
      # Replace cookie
      my $origin = $cookie->origin // '';
      next unless my $domain = lc($cookie->domain // $origin);
      next unless my $path = $cookie->path;
      next unless length(my $name = $cookie->name // '');
      my $jar = $self->{jar}{$domain} ||= [];
      @$jar = (grep({ _compare($_, $path, $name, $origin) } @$jar), $cookie);
    }
  
    return $self;
  }
  
  sub all {
    my $jar = shift->{jar};
    return [map { @{$jar->{$_}} } sort keys %$jar];
  }
  
  sub collect {
    my ($self, $tx) = @_;
  
    my $url = $tx->req->url;
    for my $cookie (@{$tx->res->cookies}) {
  
      # Validate domain
      my $host = lc $url->ihost;
      my $domain = lc($cookie->domain // $cookie->origin($host)->origin);
      if (my $cb = $self->ignore) { next if $cb->($cookie) }
      next if $host ne $domain && ($host !~ /\Q.$domain\E$/ || $host =~ /\.\d+$/);
  
      # Validate path
      my $path = $cookie->path // $url->path->to_dir->to_abs_string;
      $path = Mojo::Path->new($path)->trailing_slash(0)->to_abs_string;
      next unless _path($path, $url->path->to_abs_string);
      $self->add($cookie->path($path));
    }
  }
  
  sub empty { delete shift->{jar} }
  
  sub find {
    my ($self, $url) = @_;
  
    my @found;
    my $domain = my $host = lc $url->ihost;
    my $path = $url->path->to_abs_string;
    while ($domain) {
      next unless my $old = $self->{jar}{$domain};
  
      # Grab cookies
      my $new = $self->{jar}{$domain} = [];
      for my $cookie (@$old) {
        next unless $cookie->domain || $host eq $cookie->origin;
  
        # Check if cookie has expired
        if (defined(my $expires = $cookie->expires)) { next if time > $expires }
        push @$new, $cookie;
  
        # Taste cookie
        next if $cookie->secure && $url->protocol ne 'https';
        next unless _path($cookie->path, $path);
        my $name  = $cookie->name;
        my $value = $cookie->value;
        push @found, Mojo::Cookie::Request->new(name => $name, value => $value);
      }
    }
  
    # Remove another part
    continue { $domain =~ s/^[^.]*\.*// }
  
    return \@found;
  }
  
  sub prepare {
    my ($self, $tx) = @_;
    return unless keys %{$self->{jar}};
    my $req = $tx->req;
    $req->cookies(@{$self->find($req->url)});
  }
  
  sub _compare {
    my ($cookie, $path, $name, $origin) = @_;
    return 1 if $cookie->path ne $path || $cookie->name ne $name;
    return ($cookie->origin // '') ne $origin;
  }
  
  sub _path { $_[0] eq '/' || $_[0] eq $_[1] || index($_[1], "$_[0]/") == 0 }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojo::UserAgent::CookieJar - Cookie jar for HTTP user agents
  
  =head1 SYNOPSIS
  
    use Mojo::UserAgent::CookieJar;
  
    # Add response cookies
    my $jar = Mojo::UserAgent::CookieJar->new;
    $jar->add(
      Mojo::Cookie::Response->new(
        name   => 'foo',
        value  => 'bar',
        domain => 'localhost',
        path   => '/test'
      )
    );
  
    # Find request cookies
    for my $cookie (@{$jar->find(Mojo::URL->new('http://localhost/test'))}) {
      say $cookie->name;
      say $cookie->value;
    }
  
  =head1 DESCRIPTION
  
  L<Mojo::UserAgent::CookieJar> is a minimalistic and relaxed cookie jar used by
  L<Mojo::UserAgent>, based on L<RFC 6265|http://tools.ietf.org/html/rfc6265>.
  
  =head1 ATTRIBUTES
  
  L<Mojo::UserAgent::CookieJar> implements the following attributes.
  
  =head2 ignore
  
    my $ignore = $jar->ignore;
    $jar       = $jar->ignore(sub {...});
  
  A callback used to decide if a cookie should be ignored by L</"collect">.
  
    # Ignore all cookies
    $jar->ignore(sub { 1 });
  
    # Ignore cookies for domains "com", "net" and "org"
    $jar->ignore(sub {
      my $cookie = shift;
      return undef unless my $domain = $cookie->domain;
      return $domain eq 'com' || $domain eq 'net' || $domain eq 'org';
    });
  
  =head2 max_cookie_size
  
    my $size = $jar->max_cookie_size;
    $jar     = $jar->max_cookie_size(4096);
  
  Maximum cookie size in bytes, defaults to C<4096> (4KB).
  
  =head1 METHODS
  
  L<Mojo::UserAgent::CookieJar> inherits all methods from L<Mojo::Base> and
  implements the following new ones.
  
  =head2 add
  
    $jar = $jar->add(@cookies);
  
  Add multiple L<Mojo::Cookie::Response> objects to the jar.
  
  =head2 all
  
    my $cookies = $jar->all;
  
  Return all L<Mojo::Cookie::Response> objects that are currently stored in the
  jar.
  
    # Names of all cookies
    say $_->name for @{$jar->all};
  
  =head2 collect
  
    $jar->collect(Mojo::Transaction::HTTP->new);
  
  Collect response cookies from transaction.
  
  =head2 empty
  
    $jar->empty;
  
  Empty the jar.
  
  =head2 find
  
    my $cookies = $jar->find(Mojo::URL->new);
  
  Find L<Mojo::Cookie::Request> objects in the jar for L<Mojo::URL> object.
  
    # Names of all cookies found
    say $_->name for @{$jar->find(Mojo::URL->new('http://example.com/foo'))};
  
  =head2 prepare
  
    $jar->prepare(Mojo::Transaction::HTTP->new);
  
  Prepare request cookies for transaction.
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<http://mojolicious.org>.
  
  =cut
MOJO_USERAGENT_COOKIEJAR

$fatpacked{"Mojo/UserAgent/Proxy.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJO_USERAGENT_PROXY';
  package Mojo::UserAgent::Proxy;
  use Mojo::Base -base;
  
  use Mojo::URL;
  
  has [qw(http https not)];
  
  sub detect {
    my $self = shift;
    $self->http($ENV{HTTP_PROXY}   || $ENV{http_proxy});
    $self->https($ENV{HTTPS_PROXY} || $ENV{https_proxy});
    return $self->not([split ',', $ENV{NO_PROXY} || $ENV{no_proxy} || '']);
  }
  
  sub is_needed {
    !grep { $_[1] =~ /\Q$_\E$/ } @{$_[0]->not || []};
  }
  
  sub prepare {
    my ($self, $tx) = @_;
  
    $self->detect if $ENV{MOJO_PROXY};
    my $req = $tx->req;
    my $url = $req->url;
    return unless $self->is_needed($url->host);
  
    # HTTP proxy
    my $proto = $url->protocol;
    my $http  = $self->http;
    $req->proxy(Mojo::URL->new($http)) if $http && $proto eq 'http';
  
    # HTTPS proxy
    my $https = $self->https;
    $req->proxy(Mojo::URL->new($https)) if $https && $proto eq 'https';
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojo::UserAgent::Proxy - User agent proxy manager
  
  =head1 SYNOPSIS
  
    use Mojo::UserAgent::Proxy;
  
    my $proxy = Mojo::UserAgent::Proxy->new;
    $proxy->detect;
    say $proxy->http;
  
  =head1 DESCRIPTION
  
  L<Mojo::UserAgent::Proxy> manages proxy servers for L<Mojo::UserAgent>.
  
  =head1 ATTRIBUTES
  
  L<Mojo::UserAgent::Proxy> implements the following attributes.
  
  =head2 http
  
    my $http = $proxy->http;
    $proxy   = $proxy->http('socks://sri:secret@127.0.0.1:8080');
  
  Proxy server to use for HTTP and WebSocket requests.
  
  =head2 https
  
    my $https = $proxy->https;
    $proxy    = $proxy->https('http://sri:secret@127.0.0.1:8080');
  
  Proxy server to use for HTTPS and WebSocket requests.
  
  =head2 not
  
    my $not = $proxy->not;
    $proxy  = $proxy->not(['localhost', 'intranet.mojolicious.org']);
  
  Domains that don't require a proxy server to be used.
  
  =head1 METHODS
  
  L<Mojo::UserAgent::Proxy> inherits all methods from L<Mojo::Base> and
  implements the following new ones.
  
  =head2 detect
  
    $proxy = $proxy->detect;
  
  Check environment variables C<HTTP_PROXY>, C<http_proxy>, C<HTTPS_PROXY>,
  C<https_proxy>, C<NO_PROXY> and C<no_proxy> for proxy information. Automatic
  proxy detection can be enabled with the C<MOJO_PROXY> environment variable.
  
  =head2 is_needed
  
    my $bool = $proxy->is_needed('intranet.example.com');
  
  Check if request for domain would use a proxy server.
  
  =head2 prepare
  
    $proxy->prepare(Mojo::Transaction::HTTP->new);
  
  Prepare proxy server information for transaction.
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<http://mojolicious.org>.
  
  =cut
MOJO_USERAGENT_PROXY

$fatpacked{"Mojo/UserAgent/Server.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJO_USERAGENT_SERVER';
  package Mojo::UserAgent::Server;
  use Mojo::Base -base;
  
  use Mojo::IOLoop;
  use Mojo::Server::Daemon;
  use Scalar::Util 'weaken';
  
  has ioloop => sub { Mojo::IOLoop->singleton };
  
  sub app {
    my ($self, $app) = @_;
  
    # Singleton application
    state $singleton;
    return $singleton = $app ? $app : $singleton unless ref $self;
  
    # Default to singleton application
    return $self->{app} || $singleton unless $app;
    $self->{app} = $app;
    return $self;
  }
  
  sub nb_url { shift->_url(1, @_) }
  
  sub restart { shift->_restart(1) }
  
  sub url { shift->_url(0, @_) }
  
  sub _restart {
    my ($self, $full, $proto) = @_;
    delete @{$self}{qw(nb_port port)} if $full;
  
    $self->{proto} = $proto ||= 'http';
  
    # Blocking
    my $server = $self->{server}
      = Mojo::Server::Daemon->new(ioloop => $self->ioloop, silent => 1);
    weaken $server->app($self->app)->{app};
    my $port = $self->{port} ? ":$self->{port}" : '';
    $self->{port}
      = $server->listen(["$proto://127.0.0.1$port"])->start->ports->[0];
  
    # Non-blocking
    $server = $self->{nb_server} = Mojo::Server::Daemon->new(silent => 1);
    weaken $server->app($self->app)->{app};
    $port = $self->{nb_port} ? ":$self->{nb_port}" : '';
    $self->{nb_port}
      = $server->listen(["$proto://127.0.0.1$port"])->start->ports->[0];
  }
  
  sub _url {
    my ($self, $nb) = (shift, shift);
    $self->_restart(0, @_) if !$self->{server} || @_;
    my $port = $nb ? $self->{nb_port} : $self->{port};
    return Mojo::URL->new("$self->{proto}://127.0.0.1:$port/");
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojo::UserAgent::Server - Application server
  
  =head1 SYNOPSIS
  
    use Mojo::UserAgent::Server;
  
    my $server = Mojo::UserAgent::Server->new;
    say $server->url;
  
  =head1 DESCRIPTION
  
  L<Mojo::UserAgent::Server> is an embedded web server based on
  L<Mojo::Server::Daemon> that processes requests for L<Mojo::UserAgent>.
  
  =head1 ATTRIBUTES
  
  L<Mojo::UserAgent::Server> implements the following attributes.
  
  =head2 ioloop
  
    my $loop = $server->ioloop;
    $server  = $server->ioloop(Mojo::IOLoop->new);
  
  Event loop object to use for I/O operations, defaults to the global
  L<Mojo::IOLoop> singleton.
  
  =head1 METHODS
  
  L<Mojo::UserAgent::Server> inherits all methods from L<Mojo::Base> and
  implements the following new ones.
  
  =head2 app
  
    my $app = Mojo::UserAgent::Server->app;
              Mojo::UserAgent::Server->app(Mojolicious->new);
    my $app = $server->app;
    $server = $server->app(Mojolicious->new);
  
  Application this server handles, instance specific applications override the
  global default.
  
    # Change application behavior
    $server->app->defaults(testing => 'oh yea!');
  
  =head2 nb_url
  
    my $url = $ua->nb_url;
    my $url = $ua->nb_url('http');
    my $url = $ua->nb_url('https');
  
  Get absolute L<Mojo::URL> object for server processing non-blocking requests
  with L</"app"> and switch protocol if necessary.
  
  =head2 restart
  
    $server->restart;
  
  Restart server with new port.
  
  =head2 url
  
    my $url = $ua->url;
    my $url = $ua->url('http');
    my $url = $ua->url('https');
  
  Get absolute L<Mojo::URL> object for server processing blocking requests with
  L</"app"> and switch protocol if necessary.
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<http://mojolicious.org>.
  
  =cut
MOJO_USERAGENT_SERVER

$fatpacked{"Mojo/UserAgent/Transactor.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJO_USERAGENT_TRANSACTOR';
  package Mojo::UserAgent::Transactor;
  use Mojo::Base -base;
  
  use Mojo::Asset::File;
  use Mojo::Asset::Memory;
  use Mojo::Content::MultiPart;
  use Mojo::Content::Single;
  use Mojo::File 'path';
  use Mojo::JSON 'encode_json';
  use Mojo::Parameters;
  use Mojo::Transaction::HTTP;
  use Mojo::Transaction::WebSocket;
  use Mojo::URL;
  use Mojo::Util qw(encode url_escape);
  use Mojo::WebSocket qw(challenge client_handshake);
  
  has generators => sub { {form => \&_form, json => \&_json} };
  has name => 'Mojolicious (Perl)';
  
  sub add_generator { $_[0]->generators->{$_[1]} = $_[2] and return $_[0] }
  
  sub endpoint {
    my ($self, $tx) = @_;
  
    # Basic endpoint
    my $req   = $tx->req;
    my $url   = $req->url;
    my $proto = $url->protocol || 'http';
    my $host  = $url->ihost;
    my $port  = $url->port // ($proto eq 'https' ? 443 : 80);
  
    # Proxy for normal HTTP requests
    my $socks;
    if (my $proxy = $req->proxy) { $socks = $proxy->protocol eq 'socks' }
    return $self->_proxy($tx, $proto, $host, $port)
      if $proto eq 'http' && !$req->is_handshake && !$socks;
  
    return $proto, $host, $port;
  }
  
  sub peer { $_[0]->_proxy($_[1], $_[0]->endpoint($_[1])) }
  
  sub proxy_connect {
    my ($self, $old) = @_;
  
    # Already a CONNECT request
    my $req = $old->req;
    return undef if uc $req->method eq 'CONNECT';
  
    # No proxy
    return undef unless (my $proxy = $req->proxy) && $req->via_proxy;
    return undef if $proxy->protocol eq 'socks';
  
    # WebSocket and/or HTTPS
    my $url = $req->url;
    return undef unless $req->is_handshake || $url->protocol eq 'https';
  
    # CONNECT request (expect a bad response)
    my $new = $self->tx(CONNECT => $url->clone->userinfo(undef));
    $new->req->proxy($proxy);
    $new->res->content->auto_relax(0)->headers->connection('keep-alive');
  
    return $new;
  }
  
  sub redirect {
    my ($self, $old) = @_;
  
    # Commonly used codes
    my $res = $old->res;
    my $code = $res->code // 0;
    return undef unless grep { $_ == $code } 301, 302, 303, 307, 308;
  
    # CONNECT requests cannot be redirected
    my $req = $old->req;
    return undef if uc $req->method eq 'CONNECT';
  
    # Fix location without authority and/or scheme
    return undef
      unless my $location = $res->headers->every_header('Location')->[0];
    $location = Mojo::URL->new($location);
    $location = $location->base($req->url)->to_abs unless $location->is_abs;
    my $proto = $location->protocol;
    return undef if ($proto ne 'http' && $proto ne 'https') || !$location->host;
  
    # Clone request if necessary
    my $new = Mojo::Transaction::HTTP->new;
    if ($code == 307 || $code == 308) {
      return undef unless my $clone = $req->clone;
      $new->req($clone);
    }
    else {
      my $m = uc $req->method;
      my $headers = $new->req->method($code == 303 || $m eq 'POST' ? 'GET' : $m)
        ->content->headers($req->headers->clone)->headers;
      $headers->remove($_) for grep {/^content-/i} @{$headers->names};
    }
    my $headers = $new->req->url($location)->headers;
    $headers->remove($_) for qw(Authorization Cookie Host Referer);
    return $new->previous($old);
  }
  
  sub tx {
    my ($self, $method, $url) = (shift, shift, shift);
  
    # Method and URL
    my $tx  = Mojo::Transaction::HTTP->new;
    my $req = $tx->req->method($method);
    if   (ref $url) { $req->url($url) }
    else            { $req->url->parse($url =~ m!^/|://! ? $url : "http://$url") }
  
    # Headers (we identify ourselves and accept gzip compression)
    my $headers = $req->headers;
    $headers->from_hash(shift) if ref $_[0] eq 'HASH';
    $headers->user_agent($self->name) unless $headers->user_agent;
    $headers->accept_encoding('gzip') unless $headers->accept_encoding;
  
    # Generator
    if (@_ > 1) {
      my $cb = $self->generators->{shift()};
      $self->$cb($tx, @_);
    }
  
    # Body
    elsif (@_) { $req->body(shift) }
  
    return $tx;
  }
  
  sub upgrade {
    my ($self, $tx) = @_;
    my $code = $tx->res->code // 0;
    return undef unless $tx->req->is_handshake && $code == 101;
    my $ws = Mojo::Transaction::WebSocket->new(handshake => $tx, masked => 1);
    return challenge($ws) ? $ws->established(1) : undef;
  }
  
  sub websocket {
    my $self = shift;
  
    # New WebSocket transaction
    my $sub = ref $_[-1] eq 'ARRAY' ? pop : [];
    my $tx = $self->tx(GET => @_);
    my $req = $tx->req;
    $req->headers->sec_websocket_protocol(join ', ', @$sub) if @$sub;
  
    # Handshake protocol
    my $url = $req->url;
    my $proto = $url->protocol // '';
    if    ($proto eq 'ws')      { $url->scheme('http') }
    elsif ($proto eq 'wss')     { $url->scheme('https') }
    elsif ($proto eq 'ws+unix') { $url->scheme('http+unix') }
  
    return client_handshake $tx;
  }
  
  sub _form {
    my ($self, $tx, $form, %options) = @_;
    $options{charset} = 'UTF-8' unless exists $options{charset};
  
    # Check for uploads and force multipart if necessary
    my $req       = $tx->req;
    my $headers   = $req->headers;
    my $multipart = ($headers->content_type // '') =~ m!multipart/form-data!i;
    for my $value (map { ref $_ eq 'ARRAY' ? @$_ : $_ } values %$form) {
      ++$multipart and last if ref $value eq 'HASH';
    }
  
    # Multipart
    if ($multipart) {
      my $parts = $self->_multipart($options{charset}, $form);
      $req->content(
        Mojo::Content::MultiPart->new(headers => $headers, parts => $parts));
      _type($headers, 'multipart/form-data');
      return $tx;
    }
  
    # Query parameters or urlencoded
    my $method = uc $req->method;
    my @form = map { $_ => $form->{$_} } sort keys %$form;
    if ($method eq 'GET' || $method eq 'HEAD') { $req->url->query->merge(@form) }
    else {
      $req->body(
        Mojo::Parameters->new(@form)->charset($options{charset})->to_string);
      _type($headers, 'application/x-www-form-urlencoded');
    }
    return $tx;
  }
  
  sub _json {
    my ($self, $tx, $data) = @_;
    _type($tx->req->body(encode_json $data)->headers, 'application/json');
    return $tx;
  }
  
  sub _multipart {
    my ($self, $charset, $form) = @_;
  
    my @parts;
    for my $name (sort keys %$form) {
      next unless defined(my $values = $form->{$name});
      for my $value (ref $values eq 'ARRAY' ? @$values : ($values)) {
        push @parts, my $part = Mojo::Content::Single->new;
  
        # Upload
        my $filename;
        my $headers = $part->headers;
        if (ref $value eq 'HASH') {
  
          # File
          if (my $file = delete $value->{file}) {
            $file = Mojo::Asset::File->new(path => $file) unless ref $file;
            $part->asset($file);
            $value->{filename} //= path($file->path)->basename
              if $file->isa('Mojo::Asset::File');
          }
  
          # Memory
          elsif (defined(my $content = delete $value->{content})) {
            $part->asset(Mojo::Asset::Memory->new->add_chunk($content));
          }
  
          # Filename and headers
          $filename = url_escape delete $value->{filename} // $name, '"';
          $filename = encode $charset, $filename if $charset;
          $headers->from_hash($value);
        }
  
        # Field
        else {
          $value = encode $charset, $value if $charset;
          $part->asset(Mojo::Asset::Memory->new->add_chunk($value));
        }
  
        # Content-Disposition
        $name = url_escape $name, '"';
        $name = encode $charset, $name if $charset;
        my $disposition = qq{form-data; name="$name"};
        $disposition .= qq{; filename="$filename"} if defined $filename;
        $headers->content_disposition($disposition);
      }
    }
  
    return \@parts;
  }
  
  sub _proxy {
    my ($self, $tx, $proto, $host, $port) = @_;
  
    my $req = $tx->req;
    if ($req->via_proxy && (my $proxy = $req->proxy)) {
      return $proxy->protocol, $proxy->ihost,
        $proxy->port // ($proto eq 'https' ? 443 : 80);
    }
  
    return $proto, $host, $port;
  }
  
  sub _type { $_[0]->content_type($_[1]) unless $_[0]->content_type }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojo::UserAgent::Transactor - User agent transactor
  
  =head1 SYNOPSIS
  
    use Mojo::UserAgent::Transactor;
  
    # GET request with Accept header
    my $t = Mojo::UserAgent::Transactor->new;
    say $t->tx(GET => 'http://example.com' => {Accept => '*/*'})->req->to_string;
  
    # POST request with form-data
    say $t->tx(POST => 'example.com' => form => {a => 'b'})->req->to_string;
  
    # PUT request with JSON data
    say $t->tx(PUT => 'example.com' => json => {a => 'b'})->req->to_string;
  
  =head1 DESCRIPTION
  
  L<Mojo::UserAgent::Transactor> is the transaction building and manipulation
  framework used by L<Mojo::UserAgent>.
  
  =head1 GENERATORS
  
  These content generators are available by default.
  
  =head2 form
  
    $t->tx(POST => 'http://example.com' => form => {a => 'b'});
  
  Generate query string, C<application/x-www-form-urlencoded> or
  C<multipart/form-data> content.
  
  =head2 json
  
    $t->tx(PATCH => 'http://example.com' => json => {a => 'b'});
  
  Generate JSON content with L<Mojo::JSON>.
  
  =head1 ATTRIBUTES
  
  L<Mojo::UserAgent::Transactor> implements the following attributes.
  
  =head2 generators
  
    my $generators = $t->generators;
    $t             = $t->generators({foo => sub {...}});
  
  Registered content generators, by default only C<form> and C<json> are already
  defined.
  
  =head2 name
  
    my $name = $t->name;
    $t       = $t->name('Mojolicious');
  
  Value for C<User-Agent> request header of generated transactions, defaults to
  C<Mojolicious (Perl)>.
  
  =head1 METHODS
  
  L<Mojo::UserAgent::Transactor> inherits all methods from L<Mojo::Base> and
  implements the following new ones.
  
  =head2 add_generator
  
    $t = $t->add_generator(foo => sub {...});
  
  Register a content generator.
  
    $t->add_generator(foo => sub {
      my ($t, $tx, @args) = @_;
      ...
    });
  
  =head2 endpoint
  
    my ($proto, $host, $port) = $t->endpoint(Mojo::Transaction::HTTP->new);
  
  Actual endpoint for transaction.
  
  =head2 peer
  
    my ($proto, $host, $port) = $t->peer(Mojo::Transaction::HTTP->new);
  
  Actual peer for transaction.
  
  =head2 proxy_connect
  
    my $tx = $t->proxy_connect(Mojo::Transaction::HTTP->new);
  
  Build L<Mojo::Transaction::HTTP> proxy C<CONNECT> request for transaction if
  possible.
  
  =head2 redirect
  
    my $tx = $t->redirect(Mojo::Transaction::HTTP->new);
  
  Build L<Mojo::Transaction::HTTP> follow-up request for C<301>, C<302>, C<303>,
  C<307> or C<308> redirect response if possible.
  
  =head2 tx
  
    my $tx = $t->tx(GET  => 'example.com');
    my $tx = $t->tx(POST => 'http://example.com');
    my $tx = $t->tx(GET  => 'http://example.com' => {Accept => '*/*'});
    my $tx = $t->tx(PUT  => 'http://example.com' => 'Content!');
    my $tx = $t->tx(PUT  => 'http://example.com' => form => {a => 'b'});
    my $tx = $t->tx(PUT  => 'http://example.com' => json => {a => 'b'});
    my $tx = $t->tx(
      POST => 'http://example.com' => {Accept => '*/*'} => 'Content!');
    my $tx = $t->tx(
      PUT => 'http://example.com' => {Accept => '*/*'} => form => {a => 'b'});
    my $tx = $t->tx(
      PUT => 'http://example.com' => {Accept => '*/*'} => json => {a => 'b'});
  
  Versatile general purpose L<Mojo::Transaction::HTTP> transaction builder for
  requests, with support for L</"GENERATORS">.
  
    # Generate and inspect custom GET request with DNT header and content
    say $t->tx(GET => 'example.com' => {DNT => 1} => 'Bye!')->req->to_string;
  
    # Stream response content to STDOUT
    my $tx = $t->tx(GET => 'http://example.com');
    $tx->res->content->unsubscribe('read')->on(read => sub { say $_[1] });
  
    # PUT request with content streamed from file
    my $tx = $t->tx(PUT => 'http://example.com');
    $tx->req->content->asset(Mojo::Asset::File->new(path => '/foo.txt'));
  
  The C<json> content generator uses L<Mojo::JSON> for encoding and sets the
  content type to C<application/json>.
  
    # POST request with "application/json" content
    my $tx = $t->tx(
      POST => 'http://example.com' => json => {a => 'b', c => [1, 2, 3]});
  
  The C<form> content generator will automatically use query parameters for
  C<GET> and C<HEAD> requests.
  
    # GET request with query parameters
    my $tx = $t->tx(GET => 'http://example.com' => form => {a => 'b'});
  
  For all other request methods the C<application/x-www-form-urlencoded> content
  type is used.
  
    # POST request with "application/x-www-form-urlencoded" content
    my $tx = $t->tx(
      POST => 'http://example.com' => form => {a => 'b', c => 'd'});
  
  Parameters may be encoded with the C<charset> option.
  
    # PUT request with Shift_JIS encoded form values
    my $tx = $t->tx(
      PUT => 'example.com' => form => {a => 'b'} => charset => 'Shift_JIS');
  
  An array reference can be used for multiple form values sharing the same name.
  
    # POST request with form values sharing the same name
    my $tx = $t->tx(
      POST => 'http://example.com' => form => {a => ['b', 'c', 'd']});
  
  A hash reference with a C<content> or C<file> value can be used to switch to
  the C<multipart/form-data> content type for file uploads.
  
    # POST request with "multipart/form-data" content
    my $tx = $t->tx(
      POST => 'http://example.com' => form => {mytext => {content => 'lala'}});
  
    # POST request with multiple files sharing the same name
    my $tx = $t->tx(POST => 'http://example.com' =>
      form => {mytext => [{content => 'first'}, {content => 'second'}]});
  
  The C<file> value should contain the path to the file you want to upload or an
  asset object, like L<Mojo::Asset::File> or L<Mojo::Asset::Memory>.
  
    # POST request with upload streamed from file
    my $tx = $t->tx(
      POST => 'http://example.com' => form => {mytext => {file => '/foo.txt'}});
  
    # POST request with upload streamed from asset
    my $asset = Mojo::Asset::Memory->new->add_chunk('lalala');
    my $tx    = $t->tx(
      POST => 'http://example.com' => form => {mytext => {file => $asset}});
  
  A C<filename> value will be generated automatically, but can also be set
  manually if necessary. All remaining values in the hash reference get merged
  into the C<multipart/form-data> content as headers.
  
    # POST request with form values and customized upload (filename and header)
    my $tx = $t->tx(POST => 'http://example.com' => form => {
      a      => 'b',
      c      => 'd',
      mytext => {
        content        => 'lalala',
        filename       => 'foo.txt',
        'Content-Type' => 'text/plain'
      }
    });
  
  The C<multipart/form-data> content type can also be enforced by setting the
  C<Content-Type> header manually.
  
    # Force "multipart/form-data"
    my $headers = {'Content-Type' => 'multipart/form-data'};
    my $tx = $t->tx(POST => 'example.com' => $headers => form => {a => 'b'});
  
  =head2 upgrade
  
    my $tx = $t->upgrade(Mojo::Transaction::HTTP->new);
  
  Build L<Mojo::Transaction::WebSocket> follow-up transaction for WebSocket
  handshake if possible.
  
  =head2 websocket
  
    my $tx = $t->websocket('ws://example.com');
    my $tx = $t->websocket('ws://example.com' => {DNT => 1} => ['v1.proto']);
  
  Versatile L<Mojo::Transaction::HTTP> transaction builder for WebSocket
  handshake requests.
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<http://mojolicious.org>.
  
  =cut
MOJO_USERAGENT_TRANSACTOR

$fatpacked{"Mojo/Util.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJO_UTIL';
  package Mojo::Util;
  use Mojo::Base -strict;
  
  use Carp qw(carp croak);
  use Data::Dumper ();
  use Digest::MD5 qw(md5 md5_hex);
  use Digest::SHA qw(hmac_sha1_hex sha1 sha1_hex);
  use Encode 'find_encoding';
  use Exporter 'import';
  use Getopt::Long 'GetOptionsFromArray';
  use IO::Poll qw(POLLIN POLLPRI);
  use List::Util 'min';
  use MIME::Base64 qw(decode_base64 encode_base64);
  use Pod::Usage 'pod2usage';
  use Symbol 'delete_package';
  use Time::HiRes ();
  
  # Check for monotonic clock support
  use constant MONOTONIC =>
    eval { !!Time::HiRes::clock_gettime(Time::HiRes::CLOCK_MONOTONIC()) };
  
  # Punycode bootstring parameters
  use constant {
    PC_BASE         => 36,
    PC_TMIN         => 1,
    PC_TMAX         => 26,
    PC_SKEW         => 38,
    PC_DAMP         => 700,
    PC_INITIAL_BIAS => 72,
    PC_INITIAL_N    => 128
  };
  
  # To generate a new HTML entity table run this command
  # perl examples/entities.pl
  my %ENTITIES;
  for my $line (split "\n", join('', <DATA>)) {
    next unless $line =~ /^(\S+)\s+U\+(\S+)(?:\s+U\+(\S+))?/;
    $ENTITIES{$1} = defined $3 ? (chr(hex $2) . chr(hex $3)) : chr(hex $2);
  }
  close DATA;
  
  # Characters that should be escaped in XML
  my %XML = (
    '&'  => '&amp;',
    '<'  => '&lt;',
    '>'  => '&gt;',
    '"'  => '&quot;',
    '\'' => '&#39;'
  );
  
  # "Sun, 06 Nov 1994 08:49:37 GMT" and "Sunday, 06-Nov-94 08:49:37 GMT"
  my $EXPIRES_RE = qr/(\w+\W+\d+\W+\w+\W+\d+\W+\d+:\d+:\d+\W*\w+)/;
  
  # HTML entities
  my $ENTITY_RE = qr/&(?:\#((?:[0-9]{1,7}|x[0-9a-fA-F]{1,6}));|(\w+[;=]?))/;
  
  # Encoding cache
  my %CACHE;
  
  our @EXPORT_OK = (
    qw(b64_decode b64_encode camelize class_to_file class_to_path decamelize),
    qw(decode deprecated dumper encode extract_usage getopt hmac_sha1_sum),
    qw(html_attr_unescape html_unescape md5_bytes md5_sum monkey_patch),
    qw(punycode_decode punycode_encode quote secure_compare sha1_bytes sha1_sum),
    qw(split_cookie_header split_header steady_time tablify term_escape trim),
    qw(unindent unquote url_escape url_unescape xml_escape xor_encode)
  );
  
  # DEPRECATED!
  push @EXPORT_OK, qw(files slurp spurt);
  
  # Aliases
  monkey_patch(__PACKAGE__, 'b64_decode',    \&decode_base64);
  monkey_patch(__PACKAGE__, 'b64_encode',    \&encode_base64);
  monkey_patch(__PACKAGE__, 'hmac_sha1_sum', \&hmac_sha1_hex);
  monkey_patch(__PACKAGE__, 'md5_bytes',     \&md5);
  monkey_patch(__PACKAGE__, 'md5_sum',       \&md5_hex);
  monkey_patch(__PACKAGE__, 'sha1_bytes',    \&sha1);
  monkey_patch(__PACKAGE__, 'sha1_sum',      \&sha1_hex);
  
  # Use a monotonic clock if possible
  monkey_patch(__PACKAGE__, 'steady_time',
    MONOTONIC
    ? sub () { Time::HiRes::clock_gettime(Time::HiRes::CLOCK_MONOTONIC()) }
    : \&Time::HiRes::time);
  
  sub camelize {
    my $str = shift;
    return $str if $str =~ /^[A-Z]/;
  
    # CamelCase words
    return join '::', map {
      join('', map { ucfirst lc } split '_')
    } split '-', $str;
  }
  
  sub class_to_file {
    my $class = shift;
    $class =~ s/::|'//g;
    $class =~ s/([A-Z])([A-Z]*)/$1 . lc $2/ge;
    return decamelize($class);
  }
  
  sub class_to_path { join '.', join('/', split(/::|'/, shift)), 'pm' }
  
  sub decamelize {
    my $str = shift;
    return $str if $str !~ /^[A-Z]/;
  
    # snake_case words
    return join '-', map {
      join('_', map {lc} grep {length} split /([A-Z]{1}[^A-Z]*)/)
    } split '::', $str;
  }
  
  sub decode {
    my ($encoding, $bytes) = @_;
    return undef
      unless eval { $bytes = _encoding($encoding)->decode("$bytes", 1); 1 };
    return $bytes;
  }
  
  sub deprecated {
    local $Carp::CarpLevel = 1;
    $ENV{MOJO_FATAL_DEPRECATIONS} ? croak @_ : carp @_;
  }
  
  sub dumper {
    Data::Dumper->new([@_])->Indent(1)->Sortkeys(1)->Terse(1)->Useqq(1)->Dump;
  }
  
  sub encode { _encoding($_[0])->encode("$_[1]") }
  
  sub extract_usage {
    my $file = @_ ? "$_[0]" : (caller)[1];
  
    open my $handle, '>', \my $output;
    pod2usage -exitval => 'noexit', -input => $file, -output => $handle;
    $output =~ s/^.*\n|\n$//;
    $output =~ s/\n$//;
  
    return unindent($output);
  }
  
  # DEPRECATED!
  sub files {
    deprecated
      'Mojo::Util::files is DEPRECATED in favor of Mojo::File::list_tree';
    require Mojo::File;
    Mojo::File->new(shift)->list_tree(@_)->map('to_string')->each;
  }
  
  sub getopt {
    my ($array, $opts) = map { ref $_[0] eq 'ARRAY' ? shift : $_ } \@ARGV, [];
    my $save = Getopt::Long::Configure(qw(default no_auto_abbrev no_ignore_case),
      @$opts);
    GetOptionsFromArray $array, @_;
    Getopt::Long::Configure($save);
  }
  
  sub html_attr_unescape { _html(shift, 1) }
  sub html_unescape      { _html(shift, 0) }
  
  # Declared in Mojo::Base to avoid circular require problems
  sub monkey_patch { Mojo::Base::_monkey_patch(@_) }
  
  # Direct translation of RFC 3492
  sub punycode_decode {
    my $input = shift;
    use integer;
  
    my ($n, $i, $bias, @output) = (PC_INITIAL_N, 0, PC_INITIAL_BIAS);
  
    # Consume all code points before the last delimiter
    push @output, split('', $1) if $input =~ s/(.*)\x2d//s;
  
    while (length $input) {
      my ($oldi, $w) = ($i, 1);
  
      # Base to infinity in steps of base
      for (my $k = PC_BASE; 1; $k += PC_BASE) {
        my $digit = ord substr $input, 0, 1, '';
        $digit = $digit < 0x40 ? $digit + (26 - 0x30) : ($digit & 0x1f) - 1;
        $i += $digit * $w;
        my $t = $k - $bias;
        $t = $t < PC_TMIN ? PC_TMIN : $t > PC_TMAX ? PC_TMAX : $t;
        last if $digit < $t;
        $w *= PC_BASE - $t;
      }
  
      $bias = _adapt($i - $oldi, @output + 1, $oldi == 0);
      $n += $i / (@output + 1);
      $i = $i % (@output + 1);
      splice @output, $i++, 0, chr $n;
    }
  
    return join '', @output;
  }
  
  # Direct translation of RFC 3492
  sub punycode_encode {
    my $output = shift;
    use integer;
  
    my ($n, $delta, $bias) = (PC_INITIAL_N, 0, PC_INITIAL_BIAS);
  
    # Extract basic code points
    my @input = map {ord} split '', $output;
    $output =~ s/[^\x00-\x7f]+//gs;
    my $h = my $basic = length $output;
    $output .= "\x2d" if $basic > 0;
  
    for my $m (sort grep { $_ >= PC_INITIAL_N } @input) {
      next if $m < $n;
      $delta += ($m - $n) * ($h + 1);
      $n = $m;
  
      for my $c (@input) {
  
        if ($c < $n) { $delta++ }
        elsif ($c == $n) {
          my $q = $delta;
  
          # Base to infinity in steps of base
          for (my $k = PC_BASE; 1; $k += PC_BASE) {
            my $t = $k - $bias;
            $t = $t < PC_TMIN ? PC_TMIN : $t > PC_TMAX ? PC_TMAX : $t;
            last if $q < $t;
            my $o = $t + (($q - $t) % (PC_BASE - $t));
            $output .= chr $o + ($o < 26 ? 0x61 : 0x30 - 26);
            $q = ($q - $t) / (PC_BASE - $t);
          }
  
          $output .= chr $q + ($q < 26 ? 0x61 : 0x30 - 26);
          $bias = _adapt($delta, $h + 1, $h == $basic);
          $delta = 0;
          $h++;
        }
      }
  
      $delta++;
      $n++;
    }
  
    return $output;
  }
  
  sub quote {
    my $str = shift;
    $str =~ s/(["\\])/\\$1/g;
    return qq{"$str"};
  }
  
  sub secure_compare {
    my ($one, $two) = @_;
    return undef if length $one != length $two;
    my $r = 0;
    $r |= ord(substr $one, $_) ^ ord(substr $two, $_) for 0 .. length($one) - 1;
    return $r == 0;
  }
  
  # DEPRECATED!
  sub slurp {
    deprecated 'Mojo::Util::slurp is DEPRECATED in favor of Mojo::File::slurp';
    require Mojo::File;
    Mojo::File->new(shift)->slurp;
  }
  
  sub split_cookie_header { _header(shift, 1) }
  sub split_header        { _header(shift, 0) }
  
  # DEPRECATED!
  sub spurt {
    deprecated 'Mojo::Util::spurt is DEPRECATED in favor of Mojo::File::spurt';
    require Mojo::File;
    Mojo::File->new($_[1])->spurt($_[0]) and return $_[0];
  }
  
  sub tablify {
    my $rows = shift;
  
    my @spec;
    for my $row (@$rows) {
      for my $i (0 .. $#$row) {
        ($row->[$i] //= '') =~ s/[\r\n]//g;
        my $len = length $row->[$i];
        $spec[$i] = $len if $len >= ($spec[$i] // 0);
      }
    }
  
    my $format = join '  ', map({"\%-${_}s"} @spec[0 .. $#spec - 1]), '%s';
    return join '', map { sprintf "$format\n", @$_ } @$rows;
  }
  
  sub term_escape {
    my $str = shift;
    $str =~ s/([\x00-\x09\x0b-\x1f\x7f\x80-\x9f])/sprintf '\\x%02x', ord $1/ge;
    return $str;
  }
  
  sub trim {
    my $str = shift;
    $str =~ s/^\s+//;
    $str =~ s/\s+$//;
    return $str;
  }
  
  sub unindent {
    my $str = shift;
    my $min = min map { m/^([ \t]*)/; length $1 || () } split "\n", $str;
    $str =~ s/^[ \t]{0,$min}//gm if $min;
    return $str;
  }
  
  sub unquote {
    my $str = shift;
    return $str unless $str =~ s/^"(.*)"$/$1/g;
    $str =~ s/\\\\/\\/g;
    $str =~ s/\\"/"/g;
    return $str;
  }
  
  sub url_escape {
    my ($str, $pattern) = @_;
    if   ($pattern) { $str =~ s/([$pattern])/sprintf '%%%02X', ord $1/ge }
    else            { $str =~ s/([^A-Za-z0-9\-._~])/sprintf '%%%02X', ord $1/ge }
    return $str;
  }
  
  sub url_unescape {
    my $str = shift;
    $str =~ s/%([0-9a-fA-F]{2})/chr hex $1/ge;
    return $str;
  }
  
  sub xml_escape {
    return $_[0] if ref $_[0] && ref $_[0] eq 'Mojo::ByteStream';
    my $str = shift // '';
    $str =~ s/([&<>"'])/$XML{$1}/ge;
    return $str;
  }
  
  sub xor_encode {
    my ($input, $key) = @_;
  
    # Encode with variable key length
    my $len = length $key;
    my $buffer = my $output = '';
    $output .= $buffer ^ $key
      while length($buffer = substr($input, 0, $len, '')) == $len;
    return $output .= $buffer ^ substr($key, 0, length $buffer, '');
  }
  
  sub _adapt {
    my ($delta, $numpoints, $firsttime) = @_;
    use integer;
  
    $delta = $firsttime ? $delta / PC_DAMP : $delta / 2;
    $delta += $delta / $numpoints;
    my $k = 0;
    while ($delta > ((PC_BASE - PC_TMIN) * PC_TMAX) / 2) {
      $delta /= PC_BASE - PC_TMIN;
      $k += PC_BASE;
    }
  
    return $k + (((PC_BASE - PC_TMIN + 1) * $delta) / ($delta + PC_SKEW));
  }
  
  sub _encoding {
    $CACHE{$_[0]} //= find_encoding($_[0]) // croak "Unknown encoding '$_[0]'";
  }
  
  sub _entity {
    my ($point, $name, $attr) = @_;
  
    # Code point
    return chr($point !~ /^x/ ? $point : hex $point) unless defined $name;
  
    # Named character reference
    my $rest = my $last = '';
    while (length $name) {
      return $ENTITIES{$name} . reverse $rest
        if exists $ENTITIES{$name}
        && (!$attr || $name =~ /;$/ || $last !~ /[A-Za-z0-9=]/);
      $rest .= $last = chop $name;
    }
    return '&' . reverse $rest;
  }
  
  # Supported on Perl 5.14+
  sub _global_destruction {
    defined ${^GLOBAL_PHASE} && ${^GLOBAL_PHASE} eq 'DESTRUCT';
  }
  
  sub _header {
    my ($str, $cookie) = @_;
  
    my (@tree, @part);
    while ($str =~ /\G[,;\s]*([^=;, ]+)\s*/gc) {
      push @part, $1, undef;
      my $expires = $cookie && @part > 2 && lc $1 eq 'expires';
  
      # Special "expires" value
      if ($expires && $str =~ /\G=\s*$EXPIRES_RE/gco) { $part[-1] = $1 }
  
      # Quoted value
      elsif ($str =~ /\G=\s*("(?:\\\\|\\"|[^"])*")/gc) { $part[-1] = unquote $1 }
  
      # Unquoted value
      elsif ($str =~ /\G=\s*([^;, ]*)/gc) { $part[-1] = $1 }
  
      # Separator
      next unless $str =~ /\G[;\s]*,\s*/gc;
      push @tree, [@part];
      @part = ();
    }
  
    # Take care of final part
    return [@part ? (@tree, \@part) : @tree];
  }
  
  sub _html {
    my ($str, $attr) = @_;
    $str =~ s/$ENTITY_RE/_entity($1, $2, $attr)/geo;
    return $str;
  }
  
  sub _options {
  
    # Hash or name (one)
    return ref $_[0] eq 'HASH' ? (undef, %{shift()}) : @_ if @_ == 1;
  
    # Name and values (odd)
    return shift, @_ if @_ % 2;
  
    # Name and hash or just values (even)
    return ref $_[1] eq 'HASH' ? (shift, %{shift()}) : (undef, @_);
  }
  
  # This may break in the future, but is worth it for performance
  sub _readable { !!(IO::Poll::_poll(@_[0, 1], my $m = POLLIN | POLLPRI) > 0) }
  
  sub _stash {
    my ($name, $object) = (shift, shift);
  
    # Hash
    return $object->{$name} ||= {} unless @_;
  
    # Get
    return $object->{$name}{$_[0]} unless @_ > 1 || ref $_[0];
  
    # Set
    my $values = ref $_[0] ? $_[0] : {@_};
    @{$object->{$name}}{keys %$values} = values %$values;
  
    return $object;
  }
  
  sub _teardown {
    return unless my $class = shift;
  
    # @ISA has to be cleared first because of circular references
    no strict 'refs';
    @{"${class}::ISA"} = ();
    delete_package $class;
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojo::Util - Portable utility functions
  
  =head1 SYNOPSIS
  
    use Mojo::Util qw(b64_encode url_escape url_unescape);
  
    my $str = 'test=23';
    my $escaped = url_escape $str;
    say url_unescape $escaped;
    say b64_encode $escaped, '';
  
  =head1 DESCRIPTION
  
  L<Mojo::Util> provides portable utility functions for L<Mojo>.
  
  =head1 FUNCTIONS
  
  L<Mojo::Util> implements the following functions, which can be imported
  individually.
  
  =head2 b64_decode
  
    my $bytes = b64_decode $b64;
  
  Base64 decode bytes.
  
  =head2 b64_encode
  
    my $b64 = b64_encode $bytes;
    my $b64 = b64_encode $bytes, "\n";
  
  Base64 encode bytes, the line ending defaults to a newline.
  
  =head2 camelize
  
    my $camelcase = camelize $snakecase;
  
  Convert C<snake_case> string to C<CamelCase> and replace C<-> with C<::>.
  
    # "FooBar"
    camelize 'foo_bar';
  
    # "FooBar::Baz"
    camelize 'foo_bar-baz';
  
    # "FooBar::Baz"
    camelize 'FooBar::Baz';
  
  =head2 class_to_file
  
    my $file = class_to_file 'Foo::Bar';
  
  Convert a class name to a file.
  
    # "foo_bar"
    class_to_file 'Foo::Bar';
  
    # "foobar"
    class_to_file 'FOO::Bar';
  
    # "foo_bar"
    class_to_file 'FooBar';
  
    # "foobar"
    class_to_file 'FOOBar';
  
  =head2 class_to_path
  
    my $path = class_to_path 'Foo::Bar';
  
  Convert class name to path, as used by C<%INC>.
  
    # "Foo/Bar.pm"
    class_to_path 'Foo::Bar';
  
    # "FooBar.pm"
    class_to_path 'FooBar';
  
  =head2 decamelize
  
    my $snakecase = decamelize $camelcase;
  
  Convert C<CamelCase> string to C<snake_case> and replace C<::> with C<->.
  
    # "foo_bar"
    decamelize 'FooBar';
  
    # "foo_bar-baz"
    decamelize 'FooBar::Baz';
  
    # "foo_bar-baz"
    decamelize 'foo_bar-baz';
  
  =head2 decode
  
    my $chars = decode 'UTF-8', $bytes;
  
  Decode bytes to characters, or return C<undef> if decoding failed.
  
  =head2 deprecated
  
    deprecated 'foo is DEPRECATED in favor of bar';
  
  Warn about deprecated feature from perspective of caller. You can also set the
  C<MOJO_FATAL_DEPRECATIONS> environment variable to make them die instead.
  
  =head2 dumper
  
    my $perl = dumper {some => 'data'};
  
  Dump a Perl data structure with L<Data::Dumper>.
  
  =head2 encode
  
    my $bytes = encode 'UTF-8', $chars;
  
  Encode characters to bytes.
  
  =head2 extract_usage
  
    my $usage = extract_usage;
    my $usage = extract_usage '/home/sri/foo.pod';
  
  Extract usage message from the SYNOPSIS section of a file containing POD
  documentation, defaults to using the file this function was called from.
  
    # "Usage: APPLICATION test [OPTIONS]\n"
    extract_usage;
  
    =head1 SYNOPSIS
  
      Usage: APPLICATION test [OPTIONS]
  
    =cut
  
  =head2 getopt
  
    getopt
      'H|headers=s' => \my @headers,
      't|timeout=i' => \my $timeout,
      'v|verbose'   => \my $verbose;
    getopt $array,
      'H|headers=s' => \my @headers,
      't|timeout=i' => \my $timeout,
      'v|verbose'   => \my $verbose;
    getopt $array, ['pass_through'],
      'H|headers=s' => \my @headers,
      't|timeout=i' => \my $timeout,
      'v|verbose'   => \my $verbose;
  
  Extract options from an array reference with L<Getopt::Long>, but without
  changing its global configuration, defaults to using C<@ARGV>. The configuration
  options C<no_auto_abbrev> and C<no_ignore_case> are enabled by default.
  
    # Extract "charset" option
    getopt ['--charset', 'UTF-8'], 'charset=s' => \my $charset;
    say $charset;
  
  =head2 hmac_sha1_sum
  
    my $checksum = hmac_sha1_sum $bytes, 'passw0rd';
  
  Generate HMAC-SHA1 checksum for bytes.
  
    # "11cedfd5ec11adc0ec234466d8a0f2a83736aa68"
    hmac_sha1_sum 'foo', 'passw0rd';
  
  =head2 html_attr_unescape
  
    my $str = html_attr_unescape $escaped;
  
  Same as L</"html_unescape">, but handles special rules from the
  L<HTML Living Standard|https://html.spec.whatwg.org> for HTML attributes.
  
    # "foo=bar&ltest=baz"
    html_attr_unescape 'foo=bar&ltest=baz';
  
    # "foo=bar<est=baz"
    html_attr_unescape 'foo=bar&lt;est=baz';
  
  =head2 html_unescape
  
    my $str = html_unescape $escaped;
  
  Unescape all HTML entities in string.
  
    # "<div>"
    html_unescape '&lt;div&gt;';
  
  =head2 md5_bytes
  
    my $checksum = md5_bytes $bytes;
  
  Generate binary MD5 checksum for bytes.
  
  =head2 md5_sum
  
    my $checksum = md5_sum $bytes;
  
  Generate MD5 checksum for bytes.
  
    # "acbd18db4cc2f85cedef654fccc4a4d8"
    md5_sum 'foo';
  
  =head2 monkey_patch
  
    monkey_patch $package, foo => sub {...};
    monkey_patch $package, foo => sub {...}, bar => sub {...};
  
  Monkey patch functions into package.
  
    monkey_patch 'MyApp',
      one   => sub { say 'One!' },
      two   => sub { say 'Two!' },
      three => sub { say 'Three!' };
  
  =head2 punycode_decode
  
    my $str = punycode_decode $punycode;
  
  Punycode decode string as described in
  L<RFC 3492|http://tools.ietf.org/html/rfc3492>.
  
    # "bcher"
    punycode_decode 'bcher-kva';
  
  =head2 punycode_encode
  
    my $punycode = punycode_encode $str;
  
  Punycode encode string as described in
  L<RFC 3492|http://tools.ietf.org/html/rfc3492>.
  
    # "bcher-kva"
    punycode_encode 'bcher';
  
  =head2 quote
  
    my $quoted = quote $str;
  
  Quote string.
  
  =head2 secure_compare
  
    my $bool = secure_compare $str1, $str2;
  
  Constant time comparison algorithm to prevent timing attacks.
  
  =head2 sha1_bytes
  
    my $checksum = sha1_bytes $bytes;
  
  Generate binary SHA1 checksum for bytes.
  
  =head2 sha1_sum
  
    my $checksum = sha1_sum $bytes;
  
  Generate SHA1 checksum for bytes.
  
    # "0beec7b5ea3f0fdbc95d0dd47f3c5bc275da8a33"
    sha1_sum 'foo';
  
  =head2 split_cookie_header
  
    my $tree = split_cookie_header 'a=b; expires=Thu, 07 Aug 2008 07:07:59 GMT';
  
  Same as L</"split_header">, but handles C<expires> values from
  L<RFC 6265|http://tools.ietf.org/html/rfc6265>.
  
  =head2 split_header
  
     my $tree = split_header 'foo="bar baz"; test=123, yada';
  
  Split HTTP header value into key/value pairs, each comma separated part gets
  its own array reference, and keys without a value get C<undef> assigned.
  
    # "one"
    split_header('one; two="three four", five=six')->[0][0];
  
    # "two"
    split_header('one; two="three four", five=six')->[0][2];
  
    # "three four"
    split_header('one; two="three four", five=six')->[0][3];
  
    # "five"
    split_header('one; two="three four", five=six')->[1][0];
  
    # "six"
    split_header('one; two="three four", five=six')->[1][1];
  
  =head2 steady_time
  
    my $time = steady_time;
  
  High resolution time elapsed from an arbitrary fixed point in the past,
  resilient to time jumps if a monotonic clock is available through
  L<Time::HiRes>.
  
  =head2 tablify
  
    my $table = tablify [['foo', 'bar'], ['baz', 'yada']];
  
  Row-oriented generator for text tables.
  
    # "foo   bar\nyada  yada\nbaz   yada\n"
    tablify [['foo', 'bar'], ['yada', 'yada'], ['baz', 'yada']];
  
  =head2 term_escape
  
    my $escaped = term_escape $str;
  
  Escape all POSIX control characters except for C<\n>.
  
    # "foo\\x09bar\\x0d\n"
    term_escape "foo\tbar\r\n";
  
  =head2 trim
  
    my $trimmed = trim $str;
  
  Trim whitespace characters from both ends of string.
  
    # "foo bar"
    trim '  foo bar  ';
  
  =head2 unindent
  
    my $unindented = unindent $str;
  
  Unindent multi-line string.
  
    # "foo\nbar\nbaz\n"
    unindent "  foo\n  bar\n  baz\n";
  
  =head2 unquote
  
    my $str = unquote $quoted;
  
  Unquote string.
  
  =head2 url_escape
  
    my $escaped = url_escape $str;
    my $escaped = url_escape $str, '^A-Za-z0-9\-._~';
  
  Percent encode unsafe characters in string as described in
  L<RFC 3986|http://tools.ietf.org/html/rfc3986>, the pattern used defaults to
  C<^A-Za-z0-9\-._~>.
  
    # "foo%3Bbar"
    url_escape 'foo;bar';
  
  =head2 url_unescape
  
    my $str = url_unescape $escaped;
  
  Decode percent encoded characters in string as described in
  L<RFC 3986|http://tools.ietf.org/html/rfc3986>.
  
    # "foo;bar"
    url_unescape 'foo%3Bbar';
  
  =head2 xml_escape
  
    my $escaped = xml_escape $str;
  
  Escape unsafe characters C<&>, C<E<lt>>, C<E<gt>>, C<"> and C<'> in string, but
  do not escape L<Mojo::ByteStream> objects.
  
    # "&lt;div&gt;"
    xml_escape '<div>';
  
    # "<div>"
    use Mojo::ByteStream 'b';
    xml_escape b('<div>');
  
  =head2 xor_encode
  
    my $encoded = xor_encode $str, $key;
  
  XOR encode string with variable length key.
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<http://mojolicious.org>.
  
  =cut
  
  __DATA__
  Aacute; U+000C1
  Aacute U+000C1
  aacute; U+000E1
  aacute U+000E1
  Abreve; U+00102
  abreve; U+00103
  ac; U+0223E
  acd; U+0223F
  acE; U+0223E U+00333
  Acirc; U+000C2
  Acirc U+000C2
  acirc; U+000E2
  acirc U+000E2
  acute; U+000B4
  acute U+000B4
  Acy; U+00410
  acy; U+00430
  AElig; U+000C6
  AElig U+000C6
  aelig; U+000E6
  aelig U+000E6
  af; U+02061
  Afr; U+1D504
  afr; U+1D51E
  Agrave; U+000C0
  Agrave U+000C0
  agrave; U+000E0
  agrave U+000E0
  alefsym; U+02135
  aleph; U+02135
  Alpha; U+00391
  alpha; U+003B1
  Amacr; U+00100
  amacr; U+00101
  amalg; U+02A3F
  AMP; U+00026
  AMP U+00026
  amp; U+00026
  amp U+00026
  And; U+02A53
  and; U+02227
  andand; U+02A55
  andd; U+02A5C
  andslope; U+02A58
  andv; U+02A5A
  ang; U+02220
  ange; U+029A4
  angle; U+02220
  angmsd; U+02221
  angmsdaa; U+029A8
  angmsdab; U+029A9
  angmsdac; U+029AA
  angmsdad; U+029AB
  angmsdae; U+029AC
  angmsdaf; U+029AD
  angmsdag; U+029AE
  angmsdah; U+029AF
  angrt; U+0221F
  angrtvb; U+022BE
  angrtvbd; U+0299D
  angsph; U+02222
  angst; U+000C5
  angzarr; U+0237C
  Aogon; U+00104
  aogon; U+00105
  Aopf; U+1D538
  aopf; U+1D552
  ap; U+02248
  apacir; U+02A6F
  apE; U+02A70
  ape; U+0224A
  apid; U+0224B
  apos; U+00027
  ApplyFunction; U+02061
  approx; U+02248
  approxeq; U+0224A
  Aring; U+000C5
  Aring U+000C5
  aring; U+000E5
  aring U+000E5
  Ascr; U+1D49C
  ascr; U+1D4B6
  Assign; U+02254
  ast; U+0002A
  asymp; U+02248
  asympeq; U+0224D
  Atilde; U+000C3
  Atilde U+000C3
  atilde; U+000E3
  atilde U+000E3
  Auml; U+000C4
  Auml U+000C4
  auml; U+000E4
  auml U+000E4
  awconint; U+02233
  awint; U+02A11
  backcong; U+0224C
  backepsilon; U+003F6
  backprime; U+02035
  backsim; U+0223D
  backsimeq; U+022CD
  Backslash; U+02216
  Barv; U+02AE7
  barvee; U+022BD
  Barwed; U+02306
  barwed; U+02305
  barwedge; U+02305
  bbrk; U+023B5
  bbrktbrk; U+023B6
  bcong; U+0224C
  Bcy; U+00411
  bcy; U+00431
  bdquo; U+0201E
  becaus; U+02235
  Because; U+02235
  because; U+02235
  bemptyv; U+029B0
  bepsi; U+003F6
  bernou; U+0212C
  Bernoullis; U+0212C
  Beta; U+00392
  beta; U+003B2
  beth; U+02136
  between; U+0226C
  Bfr; U+1D505
  bfr; U+1D51F
  bigcap; U+022C2
  bigcirc; U+025EF
  bigcup; U+022C3
  bigodot; U+02A00
  bigoplus; U+02A01
  bigotimes; U+02A02
  bigsqcup; U+02A06
  bigstar; U+02605
  bigtriangledown; U+025BD
  bigtriangleup; U+025B3
  biguplus; U+02A04
  bigvee; U+022C1
  bigwedge; U+022C0
  bkarow; U+0290D
  blacklozenge; U+029EB
  blacksquare; U+025AA
  blacktriangle; U+025B4
  blacktriangledown; U+025BE
  blacktriangleleft; U+025C2
  blacktriangleright; U+025B8
  blank; U+02423
  blk12; U+02592
  blk14; U+02591
  blk34; U+02593
  block; U+02588
  bne; U+0003D U+020E5
  bnequiv; U+02261 U+020E5
  bNot; U+02AED
  bnot; U+02310
  Bopf; U+1D539
  bopf; U+1D553
  bot; U+022A5
  bottom; U+022A5
  bowtie; U+022C8
  boxbox; U+029C9
  boxDL; U+02557
  boxDl; U+02556
  boxdL; U+02555
  boxdl; U+02510
  boxDR; U+02554
  boxDr; U+02553
  boxdR; U+02552
  boxdr; U+0250C
  boxH; U+02550
  boxh; U+02500
  boxHD; U+02566
  boxHd; U+02564
  boxhD; U+02565
  boxhd; U+0252C
  boxHU; U+02569
  boxHu; U+02567
  boxhU; U+02568
  boxhu; U+02534
  boxminus; U+0229F
  boxplus; U+0229E
  boxtimes; U+022A0
  boxUL; U+0255D
  boxUl; U+0255C
  boxuL; U+0255B
  boxul; U+02518
  boxUR; U+0255A
  boxUr; U+02559
  boxuR; U+02558
  boxur; U+02514
  boxV; U+02551
  boxv; U+02502
  boxVH; U+0256C
  boxVh; U+0256B
  boxvH; U+0256A
  boxvh; U+0253C
  boxVL; U+02563
  boxVl; U+02562
  boxvL; U+02561
  boxvl; U+02524
  boxVR; U+02560
  boxVr; U+0255F
  boxvR; U+0255E
  boxvr; U+0251C
  bprime; U+02035
  Breve; U+002D8
  breve; U+002D8
  brvbar; U+000A6
  brvbar U+000A6
  Bscr; U+0212C
  bscr; U+1D4B7
  bsemi; U+0204F
  bsim; U+0223D
  bsime; U+022CD
  bsol; U+0005C
  bsolb; U+029C5
  bsolhsub; U+027C8
  bull; U+02022
  bullet; U+02022
  bump; U+0224E
  bumpE; U+02AAE
  bumpe; U+0224F
  Bumpeq; U+0224E
  bumpeq; U+0224F
  Cacute; U+00106
  cacute; U+00107
  Cap; U+022D2
  cap; U+02229
  capand; U+02A44
  capbrcup; U+02A49
  capcap; U+02A4B
  capcup; U+02A47
  capdot; U+02A40
  CapitalDifferentialD; U+02145
  caps; U+02229 U+0FE00
  caret; U+02041
  caron; U+002C7
  Cayleys; U+0212D
  ccaps; U+02A4D
  Ccaron; U+0010C
  ccaron; U+0010D
  Ccedil; U+000C7
  Ccedil U+000C7
  ccedil; U+000E7
  ccedil U+000E7
  Ccirc; U+00108
  ccirc; U+00109
  Cconint; U+02230
  ccups; U+02A4C
  ccupssm; U+02A50
  Cdot; U+0010A
  cdot; U+0010B
  cedil; U+000B8
  cedil U+000B8
  Cedilla; U+000B8
  cemptyv; U+029B2
  cent; U+000A2
  cent U+000A2
  CenterDot; U+000B7
  centerdot; U+000B7
  Cfr; U+0212D
  cfr; U+1D520
  CHcy; U+00427
  chcy; U+00447
  check; U+02713
  checkmark; U+02713
  Chi; U+003A7
  chi; U+003C7
  cir; U+025CB
  circ; U+002C6
  circeq; U+02257
  circlearrowleft; U+021BA
  circlearrowright; U+021BB
  circledast; U+0229B
  circledcirc; U+0229A
  circleddash; U+0229D
  CircleDot; U+02299
  circledR; U+000AE
  circledS; U+024C8
  CircleMinus; U+02296
  CirclePlus; U+02295
  CircleTimes; U+02297
  cirE; U+029C3
  cire; U+02257
  cirfnint; U+02A10
  cirmid; U+02AEF
  cirscir; U+029C2
  ClockwiseContourIntegral; U+02232
  CloseCurlyDoubleQuote; U+0201D
  CloseCurlyQuote; U+02019
  clubs; U+02663
  clubsuit; U+02663
  Colon; U+02237
  colon; U+0003A
  Colone; U+02A74
  colone; U+02254
  coloneq; U+02254
  comma; U+0002C
  commat; U+00040
  comp; U+02201
  compfn; U+02218
  complement; U+02201
  complexes; U+02102
  cong; U+02245
  congdot; U+02A6D
  Congruent; U+02261
  Conint; U+0222F
  conint; U+0222E
  ContourIntegral; U+0222E
  Copf; U+02102
  copf; U+1D554
  coprod; U+02210
  Coproduct; U+02210
  COPY; U+000A9
  COPY U+000A9
  copy; U+000A9
  copy U+000A9
  copysr; U+02117
  CounterClockwiseContourIntegral; U+02233
  crarr; U+021B5
  Cross; U+02A2F
  cross; U+02717
  Cscr; U+1D49E
  cscr; U+1D4B8
  csub; U+02ACF
  csube; U+02AD1
  csup; U+02AD0
  csupe; U+02AD2
  ctdot; U+022EF
  cudarrl; U+02938
  cudarrr; U+02935
  cuepr; U+022DE
  cuesc; U+022DF
  cularr; U+021B6
  cularrp; U+0293D
  Cup; U+022D3
  cup; U+0222A
  cupbrcap; U+02A48
  CupCap; U+0224D
  cupcap; U+02A46
  cupcup; U+02A4A
  cupdot; U+0228D
  cupor; U+02A45
  cups; U+0222A U+0FE00
  curarr; U+021B7
  curarrm; U+0293C
  curlyeqprec; U+022DE
  curlyeqsucc; U+022DF
  curlyvee; U+022CE
  curlywedge; U+022CF
  curren; U+000A4
  curren U+000A4
  curvearrowleft; U+021B6
  curvearrowright; U+021B7
  cuvee; U+022CE
  cuwed; U+022CF
  cwconint; U+02232
  cwint; U+02231
  cylcty; U+0232D
  Dagger; U+02021
  dagger; U+02020
  daleth; U+02138
  Darr; U+021A1
  dArr; U+021D3
  darr; U+02193
  dash; U+02010
  Dashv; U+02AE4
  dashv; U+022A3
  dbkarow; U+0290F
  dblac; U+002DD
  Dcaron; U+0010E
  dcaron; U+0010F
  Dcy; U+00414
  dcy; U+00434
  DD; U+02145
  dd; U+02146
  ddagger; U+02021
  ddarr; U+021CA
  DDotrahd; U+02911
  ddotseq; U+02A77
  deg; U+000B0
  deg U+000B0
  Del; U+02207
  Delta; U+00394
  delta; U+003B4
  demptyv; U+029B1
  dfisht; U+0297F
  Dfr; U+1D507
  dfr; U+1D521
  dHar; U+02965
  dharl; U+021C3
  dharr; U+021C2
  DiacriticalAcute; U+000B4
  DiacriticalDot; U+002D9
  DiacriticalDoubleAcute; U+002DD
  DiacriticalGrave; U+00060
  DiacriticalTilde; U+002DC
  diam; U+022C4
  Diamond; U+022C4
  diamond; U+022C4
  diamondsuit; U+02666
  diams; U+02666
  die; U+000A8
  DifferentialD; U+02146
  digamma; U+003DD
  disin; U+022F2
  div; U+000F7
  divide; U+000F7
  divide U+000F7
  divideontimes; U+022C7
  divonx; U+022C7
  DJcy; U+00402
  djcy; U+00452
  dlcorn; U+0231E
  dlcrop; U+0230D
  dollar; U+00024
  Dopf; U+1D53B
  dopf; U+1D555
  Dot; U+000A8
  dot; U+002D9
  DotDot; U+020DC
  doteq; U+02250
  doteqdot; U+02251
  DotEqual; U+02250
  dotminus; U+02238
  dotplus; U+02214
  dotsquare; U+022A1
  doublebarwedge; U+02306
  DoubleContourIntegral; U+0222F
  DoubleDot; U+000A8
  DoubleDownArrow; U+021D3
  DoubleLeftArrow; U+021D0
  DoubleLeftRightArrow; U+021D4
  DoubleLeftTee; U+02AE4
  DoubleLongLeftArrow; U+027F8
  DoubleLongLeftRightArrow; U+027FA
  DoubleLongRightArrow; U+027F9
  DoubleRightArrow; U+021D2
  DoubleRightTee; U+022A8
  DoubleUpArrow; U+021D1
  DoubleUpDownArrow; U+021D5
  DoubleVerticalBar; U+02225
  DownArrow; U+02193
  Downarrow; U+021D3
  downarrow; U+02193
  DownArrowBar; U+02913
  DownArrowUpArrow; U+021F5
  DownBreve; U+00311
  downdownarrows; U+021CA
  downharpoonleft; U+021C3
  downharpoonright; U+021C2
  DownLeftRightVector; U+02950
  DownLeftTeeVector; U+0295E
  DownLeftVector; U+021BD
  DownLeftVectorBar; U+02956
  DownRightTeeVector; U+0295F
  DownRightVector; U+021C1
  DownRightVectorBar; U+02957
  DownTee; U+022A4
  DownTeeArrow; U+021A7
  drbkarow; U+02910
  drcorn; U+0231F
  drcrop; U+0230C
  Dscr; U+1D49F
  dscr; U+1D4B9
  DScy; U+00405
  dscy; U+00455
  dsol; U+029F6
  Dstrok; U+00110
  dstrok; U+00111
  dtdot; U+022F1
  dtri; U+025BF
  dtrif; U+025BE
  duarr; U+021F5
  duhar; U+0296F
  dwangle; U+029A6
  DZcy; U+0040F
  dzcy; U+0045F
  dzigrarr; U+027FF
  Eacute; U+000C9
  Eacute U+000C9
  eacute; U+000E9
  eacute U+000E9
  easter; U+02A6E
  Ecaron; U+0011A
  ecaron; U+0011B
  ecir; U+02256
  Ecirc; U+000CA
  Ecirc U+000CA
  ecirc; U+000EA
  ecirc U+000EA
  ecolon; U+02255
  Ecy; U+0042D
  ecy; U+0044D
  eDDot; U+02A77
  Edot; U+00116
  eDot; U+02251
  edot; U+00117
  ee; U+02147
  efDot; U+02252
  Efr; U+1D508
  efr; U+1D522
  eg; U+02A9A
  Egrave; U+000C8
  Egrave U+000C8
  egrave; U+000E8
  egrave U+000E8
  egs; U+02A96
  egsdot; U+02A98
  el; U+02A99
  Element; U+02208
  elinters; U+023E7
  ell; U+02113
  els; U+02A95
  elsdot; U+02A97
  Emacr; U+00112
  emacr; U+00113
  empty; U+02205
  emptyset; U+02205
  EmptySmallSquare; U+025FB
  emptyv; U+02205
  EmptyVerySmallSquare; U+025AB
  emsp; U+02003
  emsp13; U+02004
  emsp14; U+02005
  ENG; U+0014A
  eng; U+0014B
  ensp; U+02002
  Eogon; U+00118
  eogon; U+00119
  Eopf; U+1D53C
  eopf; U+1D556
  epar; U+022D5
  eparsl; U+029E3
  eplus; U+02A71
  epsi; U+003B5
  Epsilon; U+00395
  epsilon; U+003B5
  epsiv; U+003F5
  eqcirc; U+02256
  eqcolon; U+02255
  eqsim; U+02242
  eqslantgtr; U+02A96
  eqslantless; U+02A95
  Equal; U+02A75
  equals; U+0003D
  EqualTilde; U+02242
  equest; U+0225F
  Equilibrium; U+021CC
  equiv; U+02261
  equivDD; U+02A78
  eqvparsl; U+029E5
  erarr; U+02971
  erDot; U+02253
  Escr; U+02130
  escr; U+0212F
  esdot; U+02250
  Esim; U+02A73
  esim; U+02242
  Eta; U+00397
  eta; U+003B7
  ETH; U+000D0
  ETH U+000D0
  eth; U+000F0
  eth U+000F0
  Euml; U+000CB
  Euml U+000CB
  euml; U+000EB
  euml U+000EB
  euro; U+020AC
  excl; U+00021
  exist; U+02203
  Exists; U+02203
  expectation; U+02130
  ExponentialE; U+02147
  exponentiale; U+02147
  fallingdotseq; U+02252
  Fcy; U+00424
  fcy; U+00444
  female; U+02640
  ffilig; U+0FB03
  fflig; U+0FB00
  ffllig; U+0FB04
  Ffr; U+1D509
  ffr; U+1D523
  filig; U+0FB01
  FilledSmallSquare; U+025FC
  FilledVerySmallSquare; U+025AA
  fjlig; U+00066 U+0006A
  flat; U+0266D
  fllig; U+0FB02
  fltns; U+025B1
  fnof; U+00192
  Fopf; U+1D53D
  fopf; U+1D557
  ForAll; U+02200
  forall; U+02200
  fork; U+022D4
  forkv; U+02AD9
  Fouriertrf; U+02131
  fpartint; U+02A0D
  frac12; U+000BD
  frac12 U+000BD
  frac13; U+02153
  frac14; U+000BC
  frac14 U+000BC
  frac15; U+02155
  frac16; U+02159
  frac18; U+0215B
  frac23; U+02154
  frac25; U+02156
  frac34; U+000BE
  frac34 U+000BE
  frac35; U+02157
  frac38; U+0215C
  frac45; U+02158
  frac56; U+0215A
  frac58; U+0215D
  frac78; U+0215E
  frasl; U+02044
  frown; U+02322
  Fscr; U+02131
  fscr; U+1D4BB
  gacute; U+001F5
  Gamma; U+00393
  gamma; U+003B3
  Gammad; U+003DC
  gammad; U+003DD
  gap; U+02A86
  Gbreve; U+0011E
  gbreve; U+0011F
  Gcedil; U+00122
  Gcirc; U+0011C
  gcirc; U+0011D
  Gcy; U+00413
  gcy; U+00433
  Gdot; U+00120
  gdot; U+00121
  gE; U+02267
  ge; U+02265
  gEl; U+02A8C
  gel; U+022DB
  geq; U+02265
  geqq; U+02267
  geqslant; U+02A7E
  ges; U+02A7E
  gescc; U+02AA9
  gesdot; U+02A80
  gesdoto; U+02A82
  gesdotol; U+02A84
  gesl; U+022DB U+0FE00
  gesles; U+02A94
  Gfr; U+1D50A
  gfr; U+1D524
  Gg; U+022D9
  gg; U+0226B
  ggg; U+022D9
  gimel; U+02137
  GJcy; U+00403
  gjcy; U+00453
  gl; U+02277
  gla; U+02AA5
  glE; U+02A92
  glj; U+02AA4
  gnap; U+02A8A
  gnapprox; U+02A8A
  gnE; U+02269
  gne; U+02A88
  gneq; U+02A88
  gneqq; U+02269
  gnsim; U+022E7
  Gopf; U+1D53E
  gopf; U+1D558
  grave; U+00060
  GreaterEqual; U+02265
  GreaterEqualLess; U+022DB
  GreaterFullEqual; U+02267
  GreaterGreater; U+02AA2
  GreaterLess; U+02277
  GreaterSlantEqual; U+02A7E
  GreaterTilde; U+02273
  Gscr; U+1D4A2
  gscr; U+0210A
  gsim; U+02273
  gsime; U+02A8E
  gsiml; U+02A90
  GT; U+0003E
  GT U+0003E
  Gt; U+0226B
  gt; U+0003E
  gt U+0003E
  gtcc; U+02AA7
  gtcir; U+02A7A
  gtdot; U+022D7
  gtlPar; U+02995
  gtquest; U+02A7C
  gtrapprox; U+02A86
  gtrarr; U+02978
  gtrdot; U+022D7
  gtreqless; U+022DB
  gtreqqless; U+02A8C
  gtrless; U+02277
  gtrsim; U+02273
  gvertneqq; U+02269 U+0FE00
  gvnE; U+02269 U+0FE00
  Hacek; U+002C7
  hairsp; U+0200A
  half; U+000BD
  hamilt; U+0210B
  HARDcy; U+0042A
  hardcy; U+0044A
  hArr; U+021D4
  harr; U+02194
  harrcir; U+02948
  harrw; U+021AD
  Hat; U+0005E
  hbar; U+0210F
  Hcirc; U+00124
  hcirc; U+00125
  hearts; U+02665
  heartsuit; U+02665
  hellip; U+02026
  hercon; U+022B9
  Hfr; U+0210C
  hfr; U+1D525
  HilbertSpace; U+0210B
  hksearow; U+02925
  hkswarow; U+02926
  hoarr; U+021FF
  homtht; U+0223B
  hookleftarrow; U+021A9
  hookrightarrow; U+021AA
  Hopf; U+0210D
  hopf; U+1D559
  horbar; U+02015
  HorizontalLine; U+02500
  Hscr; U+0210B
  hscr; U+1D4BD
  hslash; U+0210F
  Hstrok; U+00126
  hstrok; U+00127
  HumpDownHump; U+0224E
  HumpEqual; U+0224F
  hybull; U+02043
  hyphen; U+02010
  Iacute; U+000CD
  Iacute U+000CD
  iacute; U+000ED
  iacute U+000ED
  ic; U+02063
  Icirc; U+000CE
  Icirc U+000CE
  icirc; U+000EE
  icirc U+000EE
  Icy; U+00418
  icy; U+00438
  Idot; U+00130
  IEcy; U+00415
  iecy; U+00435
  iexcl; U+000A1
  iexcl U+000A1
  iff; U+021D4
  Ifr; U+02111
  ifr; U+1D526
  Igrave; U+000CC
  Igrave U+000CC
  igrave; U+000EC
  igrave U+000EC
  ii; U+02148
  iiiint; U+02A0C
  iiint; U+0222D
  iinfin; U+029DC
  iiota; U+02129
  IJlig; U+00132
  ijlig; U+00133
  Im; U+02111
  Imacr; U+0012A
  imacr; U+0012B
  image; U+02111
  ImaginaryI; U+02148
  imagline; U+02110
  imagpart; U+02111
  imath; U+00131
  imof; U+022B7
  imped; U+001B5
  Implies; U+021D2
  in; U+02208
  incare; U+02105
  infin; U+0221E
  infintie; U+029DD
  inodot; U+00131
  Int; U+0222C
  int; U+0222B
  intcal; U+022BA
  integers; U+02124
  Integral; U+0222B
  intercal; U+022BA
  Intersection; U+022C2
  intlarhk; U+02A17
  intprod; U+02A3C
  InvisibleComma; U+02063
  InvisibleTimes; U+02062
  IOcy; U+00401
  iocy; U+00451
  Iogon; U+0012E
  iogon; U+0012F
  Iopf; U+1D540
  iopf; U+1D55A
  Iota; U+00399
  iota; U+003B9
  iprod; U+02A3C
  iquest; U+000BF
  iquest U+000BF
  Iscr; U+02110
  iscr; U+1D4BE
  isin; U+02208
  isindot; U+022F5
  isinE; U+022F9
  isins; U+022F4
  isinsv; U+022F3
  isinv; U+02208
  it; U+02062
  Itilde; U+00128
  itilde; U+00129
  Iukcy; U+00406
  iukcy; U+00456
  Iuml; U+000CF
  Iuml U+000CF
  iuml; U+000EF
  iuml U+000EF
  Jcirc; U+00134
  jcirc; U+00135
  Jcy; U+00419
  jcy; U+00439
  Jfr; U+1D50D
  jfr; U+1D527
  jmath; U+00237
  Jopf; U+1D541
  jopf; U+1D55B
  Jscr; U+1D4A5
  jscr; U+1D4BF
  Jsercy; U+00408
  jsercy; U+00458
  Jukcy; U+00404
  jukcy; U+00454
  Kappa; U+0039A
  kappa; U+003BA
  kappav; U+003F0
  Kcedil; U+00136
  kcedil; U+00137
  Kcy; U+0041A
  kcy; U+0043A
  Kfr; U+1D50E
  kfr; U+1D528
  kgreen; U+00138
  KHcy; U+00425
  khcy; U+00445
  KJcy; U+0040C
  kjcy; U+0045C
  Kopf; U+1D542
  kopf; U+1D55C
  Kscr; U+1D4A6
  kscr; U+1D4C0
  lAarr; U+021DA
  Lacute; U+00139
  lacute; U+0013A
  laemptyv; U+029B4
  lagran; U+02112
  Lambda; U+0039B
  lambda; U+003BB
  Lang; U+027EA
  lang; U+027E8
  langd; U+02991
  langle; U+027E8
  lap; U+02A85
  Laplacetrf; U+02112
  laquo; U+000AB
  laquo U+000AB
  Larr; U+0219E
  lArr; U+021D0
  larr; U+02190
  larrb; U+021E4
  larrbfs; U+0291F
  larrfs; U+0291D
  larrhk; U+021A9
  larrlp; U+021AB
  larrpl; U+02939
  larrsim; U+02973
  larrtl; U+021A2
  lat; U+02AAB
  lAtail; U+0291B
  latail; U+02919
  late; U+02AAD
  lates; U+02AAD U+0FE00
  lBarr; U+0290E
  lbarr; U+0290C
  lbbrk; U+02772
  lbrace; U+0007B
  lbrack; U+0005B
  lbrke; U+0298B
  lbrksld; U+0298F
  lbrkslu; U+0298D
  Lcaron; U+0013D
  lcaron; U+0013E
  Lcedil; U+0013B
  lcedil; U+0013C
  lceil; U+02308
  lcub; U+0007B
  Lcy; U+0041B
  lcy; U+0043B
  ldca; U+02936
  ldquo; U+0201C
  ldquor; U+0201E
  ldrdhar; U+02967
  ldrushar; U+0294B
  ldsh; U+021B2
  lE; U+02266
  le; U+02264
  LeftAngleBracket; U+027E8
  LeftArrow; U+02190
  Leftarrow; U+021D0
  leftarrow; U+02190
  LeftArrowBar; U+021E4
  LeftArrowRightArrow; U+021C6
  leftarrowtail; U+021A2
  LeftCeiling; U+02308
  LeftDoubleBracket; U+027E6
  LeftDownTeeVector; U+02961
  LeftDownVector; U+021C3
  LeftDownVectorBar; U+02959
  LeftFloor; U+0230A
  leftharpoondown; U+021BD
  leftharpoonup; U+021BC
  leftleftarrows; U+021C7
  LeftRightArrow; U+02194
  Leftrightarrow; U+021D4
  leftrightarrow; U+02194
  leftrightarrows; U+021C6
  leftrightharpoons; U+021CB
  leftrightsquigarrow; U+021AD
  LeftRightVector; U+0294E
  LeftTee; U+022A3
  LeftTeeArrow; U+021A4
  LeftTeeVector; U+0295A
  leftthreetimes; U+022CB
  LeftTriangle; U+022B2
  LeftTriangleBar; U+029CF
  LeftTriangleEqual; U+022B4
  LeftUpDownVector; U+02951
  LeftUpTeeVector; U+02960
  LeftUpVector; U+021BF
  LeftUpVectorBar; U+02958
  LeftVector; U+021BC
  LeftVectorBar; U+02952
  lEg; U+02A8B
  leg; U+022DA
  leq; U+02264
  leqq; U+02266
  leqslant; U+02A7D
  les; U+02A7D
  lescc; U+02AA8
  lesdot; U+02A7F
  lesdoto; U+02A81
  lesdotor; U+02A83
  lesg; U+022DA U+0FE00
  lesges; U+02A93
  lessapprox; U+02A85
  lessdot; U+022D6
  lesseqgtr; U+022DA
  lesseqqgtr; U+02A8B
  LessEqualGreater; U+022DA
  LessFullEqual; U+02266
  LessGreater; U+02276
  lessgtr; U+02276
  LessLess; U+02AA1
  lesssim; U+02272
  LessSlantEqual; U+02A7D
  LessTilde; U+02272
  lfisht; U+0297C
  lfloor; U+0230A
  Lfr; U+1D50F
  lfr; U+1D529
  lg; U+02276
  lgE; U+02A91
  lHar; U+02962
  lhard; U+021BD
  lharu; U+021BC
  lharul; U+0296A
  lhblk; U+02584
  LJcy; U+00409
  ljcy; U+00459
  Ll; U+022D8
  ll; U+0226A
  llarr; U+021C7
  llcorner; U+0231E
  Lleftarrow; U+021DA
  llhard; U+0296B
  lltri; U+025FA
  Lmidot; U+0013F
  lmidot; U+00140
  lmoust; U+023B0
  lmoustache; U+023B0
  lnap; U+02A89
  lnapprox; U+02A89
  lnE; U+02268
  lne; U+02A87
  lneq; U+02A87
  lneqq; U+02268
  lnsim; U+022E6
  loang; U+027EC
  loarr; U+021FD
  lobrk; U+027E6
  LongLeftArrow; U+027F5
  Longleftarrow; U+027F8
  longleftarrow; U+027F5
  LongLeftRightArrow; U+027F7
  Longleftrightarrow; U+027FA
  longleftrightarrow; U+027F7
  longmapsto; U+027FC
  LongRightArrow; U+027F6
  Longrightarrow; U+027F9
  longrightarrow; U+027F6
  looparrowleft; U+021AB
  looparrowright; U+021AC
  lopar; U+02985
  Lopf; U+1D543
  lopf; U+1D55D
  loplus; U+02A2D
  lotimes; U+02A34
  lowast; U+02217
  lowbar; U+0005F
  LowerLeftArrow; U+02199
  LowerRightArrow; U+02198
  loz; U+025CA
  lozenge; U+025CA
  lozf; U+029EB
  lpar; U+00028
  lparlt; U+02993
  lrarr; U+021C6
  lrcorner; U+0231F
  lrhar; U+021CB
  lrhard; U+0296D
  lrm; U+0200E
  lrtri; U+022BF
  lsaquo; U+02039
  Lscr; U+02112
  lscr; U+1D4C1
  Lsh; U+021B0
  lsh; U+021B0
  lsim; U+02272
  lsime; U+02A8D
  lsimg; U+02A8F
  lsqb; U+0005B
  lsquo; U+02018
  lsquor; U+0201A
  Lstrok; U+00141
  lstrok; U+00142
  LT; U+0003C
  LT U+0003C
  Lt; U+0226A
  lt; U+0003C
  lt U+0003C
  ltcc; U+02AA6
  ltcir; U+02A79
  ltdot; U+022D6
  lthree; U+022CB
  ltimes; U+022C9
  ltlarr; U+02976
  ltquest; U+02A7B
  ltri; U+025C3
  ltrie; U+022B4
  ltrif; U+025C2
  ltrPar; U+02996
  lurdshar; U+0294A
  luruhar; U+02966
  lvertneqq; U+02268 U+0FE00
  lvnE; U+02268 U+0FE00
  macr; U+000AF
  macr U+000AF
  male; U+02642
  malt; U+02720
  maltese; U+02720
  Map; U+02905
  map; U+021A6
  mapsto; U+021A6
  mapstodown; U+021A7
  mapstoleft; U+021A4
  mapstoup; U+021A5
  marker; U+025AE
  mcomma; U+02A29
  Mcy; U+0041C
  mcy; U+0043C
  mdash; U+02014
  mDDot; U+0223A
  measuredangle; U+02221
  MediumSpace; U+0205F
  Mellintrf; U+02133
  Mfr; U+1D510
  mfr; U+1D52A
  mho; U+02127
  micro; U+000B5
  micro U+000B5
  mid; U+02223
  midast; U+0002A
  midcir; U+02AF0
  middot; U+000B7
  middot U+000B7
  minus; U+02212
  minusb; U+0229F
  minusd; U+02238
  minusdu; U+02A2A
  MinusPlus; U+02213
  mlcp; U+02ADB
  mldr; U+02026
  mnplus; U+02213
  models; U+022A7
  Mopf; U+1D544
  mopf; U+1D55E
  mp; U+02213
  Mscr; U+02133
  mscr; U+1D4C2
  mstpos; U+0223E
  Mu; U+0039C
  mu; U+003BC
  multimap; U+022B8
  mumap; U+022B8
  nabla; U+02207
  Nacute; U+00143
  nacute; U+00144
  nang; U+02220 U+020D2
  nap; U+02249
  napE; U+02A70 U+00338
  napid; U+0224B U+00338
  napos; U+00149
  napprox; U+02249
  natur; U+0266E
  natural; U+0266E
  naturals; U+02115
  nbsp; U+000A0
  nbsp U+000A0
  nbump; U+0224E U+00338
  nbumpe; U+0224F U+00338
  ncap; U+02A43
  Ncaron; U+00147
  ncaron; U+00148
  Ncedil; U+00145
  ncedil; U+00146
  ncong; U+02247
  ncongdot; U+02A6D U+00338
  ncup; U+02A42
  Ncy; U+0041D
  ncy; U+0043D
  ndash; U+02013
  ne; U+02260
  nearhk; U+02924
  neArr; U+021D7
  nearr; U+02197
  nearrow; U+02197
  nedot; U+02250 U+00338
  NegativeMediumSpace; U+0200B
  NegativeThickSpace; U+0200B
  NegativeThinSpace; U+0200B
  NegativeVeryThinSpace; U+0200B
  nequiv; U+02262
  nesear; U+02928
  nesim; U+02242 U+00338
  NestedGreaterGreater; U+0226B
  NestedLessLess; U+0226A
  NewLine; U+0000A
  nexist; U+02204
  nexists; U+02204
  Nfr; U+1D511
  nfr; U+1D52B
  ngE; U+02267 U+00338
  nge; U+02271
  ngeq; U+02271
  ngeqq; U+02267 U+00338
  ngeqslant; U+02A7E U+00338
  nges; U+02A7E U+00338
  nGg; U+022D9 U+00338
  ngsim; U+02275
  nGt; U+0226B U+020D2
  ngt; U+0226F
  ngtr; U+0226F
  nGtv; U+0226B U+00338
  nhArr; U+021CE
  nharr; U+021AE
  nhpar; U+02AF2
  ni; U+0220B
  nis; U+022FC
  nisd; U+022FA
  niv; U+0220B
  NJcy; U+0040A
  njcy; U+0045A
  nlArr; U+021CD
  nlarr; U+0219A
  nldr; U+02025
  nlE; U+02266 U+00338
  nle; U+02270
  nLeftarrow; U+021CD
  nleftarrow; U+0219A
  nLeftrightarrow; U+021CE
  nleftrightarrow; U+021AE
  nleq; U+02270
  nleqq; U+02266 U+00338
  nleqslant; U+02A7D U+00338
  nles; U+02A7D U+00338
  nless; U+0226E
  nLl; U+022D8 U+00338
  nlsim; U+02274
  nLt; U+0226A U+020D2
  nlt; U+0226E
  nltri; U+022EA
  nltrie; U+022EC
  nLtv; U+0226A U+00338
  nmid; U+02224
  NoBreak; U+02060
  NonBreakingSpace; U+000A0
  Nopf; U+02115
  nopf; U+1D55F
  Not; U+02AEC
  not; U+000AC
  not U+000AC
  NotCongruent; U+02262
  NotCupCap; U+0226D
  NotDoubleVerticalBar; U+02226
  NotElement; U+02209
  NotEqual; U+02260
  NotEqualTilde; U+02242 U+00338
  NotExists; U+02204
  NotGreater; U+0226F
  NotGreaterEqual; U+02271
  NotGreaterFullEqual; U+02267 U+00338
  NotGreaterGreater; U+0226B U+00338
  NotGreaterLess; U+02279
  NotGreaterSlantEqual; U+02A7E U+00338
  NotGreaterTilde; U+02275
  NotHumpDownHump; U+0224E U+00338
  NotHumpEqual; U+0224F U+00338
  notin; U+02209
  notindot; U+022F5 U+00338
  notinE; U+022F9 U+00338
  notinva; U+02209
  notinvb; U+022F7
  notinvc; U+022F6
  NotLeftTriangle; U+022EA
  NotLeftTriangleBar; U+029CF U+00338
  NotLeftTriangleEqual; U+022EC
  NotLess; U+0226E
  NotLessEqual; U+02270
  NotLessGreater; U+02278
  NotLessLess; U+0226A U+00338
  NotLessSlantEqual; U+02A7D U+00338
  NotLessTilde; U+02274
  NotNestedGreaterGreater; U+02AA2 U+00338
  NotNestedLessLess; U+02AA1 U+00338
  notni; U+0220C
  notniva; U+0220C
  notnivb; U+022FE
  notnivc; U+022FD
  NotPrecedes; U+02280
  NotPrecedesEqual; U+02AAF U+00338
  NotPrecedesSlantEqual; U+022E0
  NotReverseElement; U+0220C
  NotRightTriangle; U+022EB
  NotRightTriangleBar; U+029D0 U+00338
  NotRightTriangleEqual; U+022ED
  NotSquareSubset; U+0228F U+00338
  NotSquareSubsetEqual; U+022E2
  NotSquareSuperset; U+02290 U+00338
  NotSquareSupersetEqual; U+022E3
  NotSubset; U+02282 U+020D2
  NotSubsetEqual; U+02288
  NotSucceeds; U+02281
  NotSucceedsEqual; U+02AB0 U+00338
  NotSucceedsSlantEqual; U+022E1
  NotSucceedsTilde; U+0227F U+00338
  NotSuperset; U+02283 U+020D2
  NotSupersetEqual; U+02289
  NotTilde; U+02241
  NotTildeEqual; U+02244
  NotTildeFullEqual; U+02247
  NotTildeTilde; U+02249
  NotVerticalBar; U+02224
  npar; U+02226
  nparallel; U+02226
  nparsl; U+02AFD U+020E5
  npart; U+02202 U+00338
  npolint; U+02A14
  npr; U+02280
  nprcue; U+022E0
  npre; U+02AAF U+00338
  nprec; U+02280
  npreceq; U+02AAF U+00338
  nrArr; U+021CF
  nrarr; U+0219B
  nrarrc; U+02933 U+00338
  nrarrw; U+0219D U+00338
  nRightarrow; U+021CF
  nrightarrow; U+0219B
  nrtri; U+022EB
  nrtrie; U+022ED
  nsc; U+02281
  nsccue; U+022E1
  nsce; U+02AB0 U+00338
  Nscr; U+1D4A9
  nscr; U+1D4C3
  nshortmid; U+02224
  nshortparallel; U+02226
  nsim; U+02241
  nsime; U+02244
  nsimeq; U+02244
  nsmid; U+02224
  nspar; U+02226
  nsqsube; U+022E2
  nsqsupe; U+022E3
  nsub; U+02284
  nsubE; U+02AC5 U+00338
  nsube; U+02288
  nsubset; U+02282 U+020D2
  nsubseteq; U+02288
  nsubseteqq; U+02AC5 U+00338
  nsucc; U+02281
  nsucceq; U+02AB0 U+00338
  nsup; U+02285
  nsupE; U+02AC6 U+00338
  nsupe; U+02289
  nsupset; U+02283 U+020D2
  nsupseteq; U+02289
  nsupseteqq; U+02AC6 U+00338
  ntgl; U+02279
  Ntilde; U+000D1
  Ntilde U+000D1
  ntilde; U+000F1
  ntilde U+000F1
  ntlg; U+02278
  ntriangleleft; U+022EA
  ntrianglelefteq; U+022EC
  ntriangleright; U+022EB
  ntrianglerighteq; U+022ED
  Nu; U+0039D
  nu; U+003BD
  num; U+00023
  numero; U+02116
  numsp; U+02007
  nvap; U+0224D U+020D2
  nVDash; U+022AF
  nVdash; U+022AE
  nvDash; U+022AD
  nvdash; U+022AC
  nvge; U+02265 U+020D2
  nvgt; U+0003E U+020D2
  nvHarr; U+02904
  nvinfin; U+029DE
  nvlArr; U+02902
  nvle; U+02264 U+020D2
  nvlt; U+0003C U+020D2
  nvltrie; U+022B4 U+020D2
  nvrArr; U+02903
  nvrtrie; U+022B5 U+020D2
  nvsim; U+0223C U+020D2
  nwarhk; U+02923
  nwArr; U+021D6
  nwarr; U+02196
  nwarrow; U+02196
  nwnear; U+02927
  Oacute; U+000D3
  Oacute U+000D3
  oacute; U+000F3
  oacute U+000F3
  oast; U+0229B
  ocir; U+0229A
  Ocirc; U+000D4
  Ocirc U+000D4
  ocirc; U+000F4
  ocirc U+000F4
  Ocy; U+0041E
  ocy; U+0043E
  odash; U+0229D
  Odblac; U+00150
  odblac; U+00151
  odiv; U+02A38
  odot; U+02299
  odsold; U+029BC
  OElig; U+00152
  oelig; U+00153
  ofcir; U+029BF
  Ofr; U+1D512
  ofr; U+1D52C
  ogon; U+002DB
  Ograve; U+000D2
  Ograve U+000D2
  ograve; U+000F2
  ograve U+000F2
  ogt; U+029C1
  ohbar; U+029B5
  ohm; U+003A9
  oint; U+0222E
  olarr; U+021BA
  olcir; U+029BE
  olcross; U+029BB
  oline; U+0203E
  olt; U+029C0
  Omacr; U+0014C
  omacr; U+0014D
  Omega; U+003A9
  omega; U+003C9
  Omicron; U+0039F
  omicron; U+003BF
  omid; U+029B6
  ominus; U+02296
  Oopf; U+1D546
  oopf; U+1D560
  opar; U+029B7
  OpenCurlyDoubleQuote; U+0201C
  OpenCurlyQuote; U+02018
  operp; U+029B9
  oplus; U+02295
  Or; U+02A54
  or; U+02228
  orarr; U+021BB
  ord; U+02A5D
  order; U+02134
  orderof; U+02134
  ordf; U+000AA
  ordf U+000AA
  ordm; U+000BA
  ordm U+000BA
  origof; U+022B6
  oror; U+02A56
  orslope; U+02A57
  orv; U+02A5B
  oS; U+024C8
  Oscr; U+1D4AA
  oscr; U+02134
  Oslash; U+000D8
  Oslash U+000D8
  oslash; U+000F8
  oslash U+000F8
  osol; U+02298
  Otilde; U+000D5
  Otilde U+000D5
  otilde; U+000F5
  otilde U+000F5
  Otimes; U+02A37
  otimes; U+02297
  otimesas; U+02A36
  Ouml; U+000D6
  Ouml U+000D6
  ouml; U+000F6
  ouml U+000F6
  ovbar; U+0233D
  OverBar; U+0203E
  OverBrace; U+023DE
  OverBracket; U+023B4
  OverParenthesis; U+023DC
  par; U+02225
  para; U+000B6
  para U+000B6
  parallel; U+02225
  parsim; U+02AF3
  parsl; U+02AFD
  part; U+02202
  PartialD; U+02202
  Pcy; U+0041F
  pcy; U+0043F
  percnt; U+00025
  period; U+0002E
  permil; U+02030
  perp; U+022A5
  pertenk; U+02031
  Pfr; U+1D513
  pfr; U+1D52D
  Phi; U+003A6
  phi; U+003C6
  phiv; U+003D5
  phmmat; U+02133
  phone; U+0260E
  Pi; U+003A0
  pi; U+003C0
  pitchfork; U+022D4
  piv; U+003D6
  planck; U+0210F
  planckh; U+0210E
  plankv; U+0210F
  plus; U+0002B
  plusacir; U+02A23
  plusb; U+0229E
  pluscir; U+02A22
  plusdo; U+02214
  plusdu; U+02A25
  pluse; U+02A72
  PlusMinus; U+000B1
  plusmn; U+000B1
  plusmn U+000B1
  plussim; U+02A26
  plustwo; U+02A27
  pm; U+000B1
  Poincareplane; U+0210C
  pointint; U+02A15
  Popf; U+02119
  popf; U+1D561
  pound; U+000A3
  pound U+000A3
  Pr; U+02ABB
  pr; U+0227A
  prap; U+02AB7
  prcue; U+0227C
  prE; U+02AB3
  pre; U+02AAF
  prec; U+0227A
  precapprox; U+02AB7
  preccurlyeq; U+0227C
  Precedes; U+0227A
  PrecedesEqual; U+02AAF
  PrecedesSlantEqual; U+0227C
  PrecedesTilde; U+0227E
  preceq; U+02AAF
  precnapprox; U+02AB9
  precneqq; U+02AB5
  precnsim; U+022E8
  precsim; U+0227E
  Prime; U+02033
  prime; U+02032
  primes; U+02119
  prnap; U+02AB9
  prnE; U+02AB5
  prnsim; U+022E8
  prod; U+0220F
  Product; U+0220F
  profalar; U+0232E
  profline; U+02312
  profsurf; U+02313
  prop; U+0221D
  Proportion; U+02237
  Proportional; U+0221D
  propto; U+0221D
  prsim; U+0227E
  prurel; U+022B0
  Pscr; U+1D4AB
  pscr; U+1D4C5
  Psi; U+003A8
  psi; U+003C8
  puncsp; U+02008
  Qfr; U+1D514
  qfr; U+1D52E
  qint; U+02A0C
  Qopf; U+0211A
  qopf; U+1D562
  qprime; U+02057
  Qscr; U+1D4AC
  qscr; U+1D4C6
  quaternions; U+0210D
  quatint; U+02A16
  quest; U+0003F
  questeq; U+0225F
  QUOT; U+00022
  QUOT U+00022
  quot; U+00022
  quot U+00022
  rAarr; U+021DB
  race; U+0223D U+00331
  Racute; U+00154
  racute; U+00155
  radic; U+0221A
  raemptyv; U+029B3
  Rang; U+027EB
  rang; U+027E9
  rangd; U+02992
  range; U+029A5
  rangle; U+027E9
  raquo; U+000BB
  raquo U+000BB
  Rarr; U+021A0
  rArr; U+021D2
  rarr; U+02192
  rarrap; U+02975
  rarrb; U+021E5
  rarrbfs; U+02920
  rarrc; U+02933
  rarrfs; U+0291E
  rarrhk; U+021AA
  rarrlp; U+021AC
  rarrpl; U+02945
  rarrsim; U+02974
  Rarrtl; U+02916
  rarrtl; U+021A3
  rarrw; U+0219D
  rAtail; U+0291C
  ratail; U+0291A
  ratio; U+02236
  rationals; U+0211A
  RBarr; U+02910
  rBarr; U+0290F
  rbarr; U+0290D
  rbbrk; U+02773
  rbrace; U+0007D
  rbrack; U+0005D
  rbrke; U+0298C
  rbrksld; U+0298E
  rbrkslu; U+02990
  Rcaron; U+00158
  rcaron; U+00159
  Rcedil; U+00156
  rcedil; U+00157
  rceil; U+02309
  rcub; U+0007D
  Rcy; U+00420
  rcy; U+00440
  rdca; U+02937
  rdldhar; U+02969
  rdquo; U+0201D
  rdquor; U+0201D
  rdsh; U+021B3
  Re; U+0211C
  real; U+0211C
  realine; U+0211B
  realpart; U+0211C
  reals; U+0211D
  rect; U+025AD
  REG; U+000AE
  REG U+000AE
  reg; U+000AE
  reg U+000AE
  ReverseElement; U+0220B
  ReverseEquilibrium; U+021CB
  ReverseUpEquilibrium; U+0296F
  rfisht; U+0297D
  rfloor; U+0230B
  Rfr; U+0211C
  rfr; U+1D52F
  rHar; U+02964
  rhard; U+021C1
  rharu; U+021C0
  rharul; U+0296C
  Rho; U+003A1
  rho; U+003C1
  rhov; U+003F1
  RightAngleBracket; U+027E9
  RightArrow; U+02192
  Rightarrow; U+021D2
  rightarrow; U+02192
  RightArrowBar; U+021E5
  RightArrowLeftArrow; U+021C4
  rightarrowtail; U+021A3
  RightCeiling; U+02309
  RightDoubleBracket; U+027E7
  RightDownTeeVector; U+0295D
  RightDownVector; U+021C2
  RightDownVectorBar; U+02955
  RightFloor; U+0230B
  rightharpoondown; U+021C1
  rightharpoonup; U+021C0
  rightleftarrows; U+021C4
  rightleftharpoons; U+021CC
  rightrightarrows; U+021C9
  rightsquigarrow; U+0219D
  RightTee; U+022A2
  RightTeeArrow; U+021A6
  RightTeeVector; U+0295B
  rightthreetimes; U+022CC
  RightTriangle; U+022B3
  RightTriangleBar; U+029D0
  RightTriangleEqual; U+022B5
  RightUpDownVector; U+0294F
  RightUpTeeVector; U+0295C
  RightUpVector; U+021BE
  RightUpVectorBar; U+02954
  RightVector; U+021C0
  RightVectorBar; U+02953
  ring; U+002DA
  risingdotseq; U+02253
  rlarr; U+021C4
  rlhar; U+021CC
  rlm; U+0200F
  rmoust; U+023B1
  rmoustache; U+023B1
  rnmid; U+02AEE
  roang; U+027ED
  roarr; U+021FE
  robrk; U+027E7
  ropar; U+02986
  Ropf; U+0211D
  ropf; U+1D563
  roplus; U+02A2E
  rotimes; U+02A35
  RoundImplies; U+02970
  rpar; U+00029
  rpargt; U+02994
  rppolint; U+02A12
  rrarr; U+021C9
  Rrightarrow; U+021DB
  rsaquo; U+0203A
  Rscr; U+0211B
  rscr; U+1D4C7
  Rsh; U+021B1
  rsh; U+021B1
  rsqb; U+0005D
  rsquo; U+02019
  rsquor; U+02019
  rthree; U+022CC
  rtimes; U+022CA
  rtri; U+025B9
  rtrie; U+022B5
  rtrif; U+025B8
  rtriltri; U+029CE
  RuleDelayed; U+029F4
  ruluhar; U+02968
  rx; U+0211E
  Sacute; U+0015A
  sacute; U+0015B
  sbquo; U+0201A
  Sc; U+02ABC
  sc; U+0227B
  scap; U+02AB8
  Scaron; U+00160
  scaron; U+00161
  sccue; U+0227D
  scE; U+02AB4
  sce; U+02AB0
  Scedil; U+0015E
  scedil; U+0015F
  Scirc; U+0015C
  scirc; U+0015D
  scnap; U+02ABA
  scnE; U+02AB6
  scnsim; U+022E9
  scpolint; U+02A13
  scsim; U+0227F
  Scy; U+00421
  scy; U+00441
  sdot; U+022C5
  sdotb; U+022A1
  sdote; U+02A66
  searhk; U+02925
  seArr; U+021D8
  searr; U+02198
  searrow; U+02198
  sect; U+000A7
  sect U+000A7
  semi; U+0003B
  seswar; U+02929
  setminus; U+02216
  setmn; U+02216
  sext; U+02736
  Sfr; U+1D516
  sfr; U+1D530
  sfrown; U+02322
  sharp; U+0266F
  SHCHcy; U+00429
  shchcy; U+00449
  SHcy; U+00428
  shcy; U+00448
  ShortDownArrow; U+02193
  ShortLeftArrow; U+02190
  shortmid; U+02223
  shortparallel; U+02225
  ShortRightArrow; U+02192
  ShortUpArrow; U+02191
  shy; U+000AD
  shy U+000AD
  Sigma; U+003A3
  sigma; U+003C3
  sigmaf; U+003C2
  sigmav; U+003C2
  sim; U+0223C
  simdot; U+02A6A
  sime; U+02243
  simeq; U+02243
  simg; U+02A9E
  simgE; U+02AA0
  siml; U+02A9D
  simlE; U+02A9F
  simne; U+02246
  simplus; U+02A24
  simrarr; U+02972
  slarr; U+02190
  SmallCircle; U+02218
  smallsetminus; U+02216
  smashp; U+02A33
  smeparsl; U+029E4
  smid; U+02223
  smile; U+02323
  smt; U+02AAA
  smte; U+02AAC
  smtes; U+02AAC U+0FE00
  SOFTcy; U+0042C
  softcy; U+0044C
  sol; U+0002F
  solb; U+029C4
  solbar; U+0233F
  Sopf; U+1D54A
  sopf; U+1D564
  spades; U+02660
  spadesuit; U+02660
  spar; U+02225
  sqcap; U+02293
  sqcaps; U+02293 U+0FE00
  sqcup; U+02294
  sqcups; U+02294 U+0FE00
  Sqrt; U+0221A
  sqsub; U+0228F
  sqsube; U+02291
  sqsubset; U+0228F
  sqsubseteq; U+02291
  sqsup; U+02290
  sqsupe; U+02292
  sqsupset; U+02290
  sqsupseteq; U+02292
  squ; U+025A1
  Square; U+025A1
  square; U+025A1
  SquareIntersection; U+02293
  SquareSubset; U+0228F
  SquareSubsetEqual; U+02291
  SquareSuperset; U+02290
  SquareSupersetEqual; U+02292
  SquareUnion; U+02294
  squarf; U+025AA
  squf; U+025AA
  srarr; U+02192
  Sscr; U+1D4AE
  sscr; U+1D4C8
  ssetmn; U+02216
  ssmile; U+02323
  sstarf; U+022C6
  Star; U+022C6
  star; U+02606
  starf; U+02605
  straightepsilon; U+003F5
  straightphi; U+003D5
  strns; U+000AF
  Sub; U+022D0
  sub; U+02282
  subdot; U+02ABD
  subE; U+02AC5
  sube; U+02286
  subedot; U+02AC3
  submult; U+02AC1
  subnE; U+02ACB
  subne; U+0228A
  subplus; U+02ABF
  subrarr; U+02979
  Subset; U+022D0
  subset; U+02282
  subseteq; U+02286
  subseteqq; U+02AC5
  SubsetEqual; U+02286
  subsetneq; U+0228A
  subsetneqq; U+02ACB
  subsim; U+02AC7
  subsub; U+02AD5
  subsup; U+02AD3
  succ; U+0227B
  succapprox; U+02AB8
  succcurlyeq; U+0227D
  Succeeds; U+0227B
  SucceedsEqual; U+02AB0
  SucceedsSlantEqual; U+0227D
  SucceedsTilde; U+0227F
  succeq; U+02AB0
  succnapprox; U+02ABA
  succneqq; U+02AB6
  succnsim; U+022E9
  succsim; U+0227F
  SuchThat; U+0220B
  Sum; U+02211
  sum; U+02211
  sung; U+0266A
  Sup; U+022D1
  sup; U+02283
  sup1; U+000B9
  sup1 U+000B9
  sup2; U+000B2
  sup2 U+000B2
  sup3; U+000B3
  sup3 U+000B3
  supdot; U+02ABE
  supdsub; U+02AD8
  supE; U+02AC6
  supe; U+02287
  supedot; U+02AC4
  Superset; U+02283
  SupersetEqual; U+02287
  suphsol; U+027C9
  suphsub; U+02AD7
  suplarr; U+0297B
  supmult; U+02AC2
  supnE; U+02ACC
  supne; U+0228B
  supplus; U+02AC0
  Supset; U+022D1
  supset; U+02283
  supseteq; U+02287
  supseteqq; U+02AC6
  supsetneq; U+0228B
  supsetneqq; U+02ACC
  supsim; U+02AC8
  supsub; U+02AD4
  supsup; U+02AD6
  swarhk; U+02926
  swArr; U+021D9
  swarr; U+02199
  swarrow; U+02199
  swnwar; U+0292A
  szlig; U+000DF
  szlig U+000DF
  Tab; U+00009
  target; U+02316
  Tau; U+003A4
  tau; U+003C4
  tbrk; U+023B4
  Tcaron; U+00164
  tcaron; U+00165
  Tcedil; U+00162
  tcedil; U+00163
  Tcy; U+00422
  tcy; U+00442
  tdot; U+020DB
  telrec; U+02315
  Tfr; U+1D517
  tfr; U+1D531
  there4; U+02234
  Therefore; U+02234
  therefore; U+02234
  Theta; U+00398
  theta; U+003B8
  thetasym; U+003D1
  thetav; U+003D1
  thickapprox; U+02248
  thicksim; U+0223C
  ThickSpace; U+0205F U+0200A
  thinsp; U+02009
  ThinSpace; U+02009
  thkap; U+02248
  thksim; U+0223C
  THORN; U+000DE
  THORN U+000DE
  thorn; U+000FE
  thorn U+000FE
  Tilde; U+0223C
  tilde; U+002DC
  TildeEqual; U+02243
  TildeFullEqual; U+02245
  TildeTilde; U+02248
  times; U+000D7
  times U+000D7
  timesb; U+022A0
  timesbar; U+02A31
  timesd; U+02A30
  tint; U+0222D
  toea; U+02928
  top; U+022A4
  topbot; U+02336
  topcir; U+02AF1
  Topf; U+1D54B
  topf; U+1D565
  topfork; U+02ADA
  tosa; U+02929
  tprime; U+02034
  TRADE; U+02122
  trade; U+02122
  triangle; U+025B5
  triangledown; U+025BF
  triangleleft; U+025C3
  trianglelefteq; U+022B4
  triangleq; U+0225C
  triangleright; U+025B9
  trianglerighteq; U+022B5
  tridot; U+025EC
  trie; U+0225C
  triminus; U+02A3A
  TripleDot; U+020DB
  triplus; U+02A39
  trisb; U+029CD
  tritime; U+02A3B
  trpezium; U+023E2
  Tscr; U+1D4AF
  tscr; U+1D4C9
  TScy; U+00426
  tscy; U+00446
  TSHcy; U+0040B
  tshcy; U+0045B
  Tstrok; U+00166
  tstrok; U+00167
  twixt; U+0226C
  twoheadleftarrow; U+0219E
  twoheadrightarrow; U+021A0
  Uacute; U+000DA
  Uacute U+000DA
  uacute; U+000FA
  uacute U+000FA
  Uarr; U+0219F
  uArr; U+021D1
  uarr; U+02191
  Uarrocir; U+02949
  Ubrcy; U+0040E
  ubrcy; U+0045E
  Ubreve; U+0016C
  ubreve; U+0016D
  Ucirc; U+000DB
  Ucirc U+000DB
  ucirc; U+000FB
  ucirc U+000FB
  Ucy; U+00423
  ucy; U+00443
  udarr; U+021C5
  Udblac; U+00170
  udblac; U+00171
  udhar; U+0296E
  ufisht; U+0297E
  Ufr; U+1D518
  ufr; U+1D532
  Ugrave; U+000D9
  Ugrave U+000D9
  ugrave; U+000F9
  ugrave U+000F9
  uHar; U+02963
  uharl; U+021BF
  uharr; U+021BE
  uhblk; U+02580
  ulcorn; U+0231C
  ulcorner; U+0231C
  ulcrop; U+0230F
  ultri; U+025F8
  Umacr; U+0016A
  umacr; U+0016B
  uml; U+000A8
  uml U+000A8
  UnderBar; U+0005F
  UnderBrace; U+023DF
  UnderBracket; U+023B5
  UnderParenthesis; U+023DD
  Union; U+022C3
  UnionPlus; U+0228E
  Uogon; U+00172
  uogon; U+00173
  Uopf; U+1D54C
  uopf; U+1D566
  UpArrow; U+02191
  Uparrow; U+021D1
  uparrow; U+02191
  UpArrowBar; U+02912
  UpArrowDownArrow; U+021C5
  UpDownArrow; U+02195
  Updownarrow; U+021D5
  updownarrow; U+02195
  UpEquilibrium; U+0296E
  upharpoonleft; U+021BF
  upharpoonright; U+021BE
  uplus; U+0228E
  UpperLeftArrow; U+02196
  UpperRightArrow; U+02197
  Upsi; U+003D2
  upsi; U+003C5
  upsih; U+003D2
  Upsilon; U+003A5
  upsilon; U+003C5
  UpTee; U+022A5
  UpTeeArrow; U+021A5
  upuparrows; U+021C8
  urcorn; U+0231D
  urcorner; U+0231D
  urcrop; U+0230E
  Uring; U+0016E
  uring; U+0016F
  urtri; U+025F9
  Uscr; U+1D4B0
  uscr; U+1D4CA
  utdot; U+022F0
  Utilde; U+00168
  utilde; U+00169
  utri; U+025B5
  utrif; U+025B4
  uuarr; U+021C8
  Uuml; U+000DC
  Uuml U+000DC
  uuml; U+000FC
  uuml U+000FC
  uwangle; U+029A7
  vangrt; U+0299C
  varepsilon; U+003F5
  varkappa; U+003F0
  varnothing; U+02205
  varphi; U+003D5
  varpi; U+003D6
  varpropto; U+0221D
  vArr; U+021D5
  varr; U+02195
  varrho; U+003F1
  varsigma; U+003C2
  varsubsetneq; U+0228A U+0FE00
  varsubsetneqq; U+02ACB U+0FE00
  varsupsetneq; U+0228B U+0FE00
  varsupsetneqq; U+02ACC U+0FE00
  vartheta; U+003D1
  vartriangleleft; U+022B2
  vartriangleright; U+022B3
  Vbar; U+02AEB
  vBar; U+02AE8
  vBarv; U+02AE9
  Vcy; U+00412
  vcy; U+00432
  VDash; U+022AB
  Vdash; U+022A9
  vDash; U+022A8
  vdash; U+022A2
  Vdashl; U+02AE6
  Vee; U+022C1
  vee; U+02228
  veebar; U+022BB
  veeeq; U+0225A
  vellip; U+022EE
  Verbar; U+02016
  verbar; U+0007C
  Vert; U+02016
  vert; U+0007C
  VerticalBar; U+02223
  VerticalLine; U+0007C
  VerticalSeparator; U+02758
  VerticalTilde; U+02240
  VeryThinSpace; U+0200A
  Vfr; U+1D519
  vfr; U+1D533
  vltri; U+022B2
  vnsub; U+02282 U+020D2
  vnsup; U+02283 U+020D2
  Vopf; U+1D54D
  vopf; U+1D567
  vprop; U+0221D
  vrtri; U+022B3
  Vscr; U+1D4B1
  vscr; U+1D4CB
  vsubnE; U+02ACB U+0FE00
  vsubne; U+0228A U+0FE00
  vsupnE; U+02ACC U+0FE00
  vsupne; U+0228B U+0FE00
  Vvdash; U+022AA
  vzigzag; U+0299A
  Wcirc; U+00174
  wcirc; U+00175
  wedbar; U+02A5F
  Wedge; U+022C0
  wedge; U+02227
  wedgeq; U+02259
  weierp; U+02118
  Wfr; U+1D51A
  wfr; U+1D534
  Wopf; U+1D54E
  wopf; U+1D568
  wp; U+02118
  wr; U+02240
  wreath; U+02240
  Wscr; U+1D4B2
  wscr; U+1D4CC
  xcap; U+022C2
  xcirc; U+025EF
  xcup; U+022C3
  xdtri; U+025BD
  Xfr; U+1D51B
  xfr; U+1D535
  xhArr; U+027FA
  xharr; U+027F7
  Xi; U+0039E
  xi; U+003BE
  xlArr; U+027F8
  xlarr; U+027F5
  xmap; U+027FC
  xnis; U+022FB
  xodot; U+02A00
  Xopf; U+1D54F
  xopf; U+1D569
  xoplus; U+02A01
  xotime; U+02A02
  xrArr; U+027F9
  xrarr; U+027F6
  Xscr; U+1D4B3
  xscr; U+1D4CD
  xsqcup; U+02A06
  xuplus; U+02A04
  xutri; U+025B3
  xvee; U+022C1
  xwedge; U+022C0
  Yacute; U+000DD
  Yacute U+000DD
  yacute; U+000FD
  yacute U+000FD
  YAcy; U+0042F
  yacy; U+0044F
  Ycirc; U+00176
  ycirc; U+00177
  Ycy; U+0042B
  ycy; U+0044B
  yen; U+000A5
  yen U+000A5
  Yfr; U+1D51C
  yfr; U+1D536
  YIcy; U+00407
  yicy; U+00457
  Yopf; U+1D550
  yopf; U+1D56A
  Yscr; U+1D4B4
  yscr; U+1D4CE
  YUcy; U+0042E
  yucy; U+0044E
  Yuml; U+00178
  yuml; U+000FF
  yuml U+000FF
  Zacute; U+00179
  zacute; U+0017A
  Zcaron; U+0017D
  zcaron; U+0017E
  Zcy; U+00417
  zcy; U+00437
  Zdot; U+0017B
  zdot; U+0017C
  zeetrf; U+02128
  ZeroWidthSpace; U+0200B
  Zeta; U+00396
  zeta; U+003B6
  Zfr; U+02128
  zfr; U+1D537
  ZHcy; U+00416
  zhcy; U+00436
  zigrarr; U+021DD
  Zopf; U+02124
  zopf; U+1D56B
  Zscr; U+1D4B5
  zscr; U+1D4CF
  zwj; U+0200D
  zwnj; U+0200C
MOJO_UTIL

$fatpacked{"Mojo/WebSocket.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJO_WEBSOCKET';
  package Mojo::WebSocket;
  use Mojo::Base -strict;
  
  use Config;
  use Exporter 'import';
  use Mojo::Util qw(b64_encode dumper sha1_bytes xor_encode);
  
  use constant DEBUG => $ENV{MOJO_WEBSOCKET_DEBUG} || 0;
  
  # Unique value from RFC 6455
  use constant GUID => '258EAFA5-E914-47DA-95CA-C5AB0DC85B11';
  
  # Perl with support for quads
  use constant MODERN =>
    (($Config{use64bitint} // '') eq 'define' || $Config{longsize} >= 8);
  
  # Opcodes
  use constant {
    WS_CONTINUATION => 0x0,
    WS_TEXT         => 0x1,
    WS_BINARY       => 0x2,
    WS_CLOSE        => 0x8,
    WS_PING         => 0x9,
    WS_PONG         => 0xa
  };
  
  our @EXPORT_OK = (
    qw(WS_BINARY WS_CLOSE WS_CONTINUATION WS_PING WS_PONG WS_TEXT),
    qw(build_frame challenge client_handshake parse_frame server_handshake)
  );
  
  sub build_frame {
    my ($masked, $fin, $rsv1, $rsv2, $rsv3, $op, $payload) = @_;
    warn "-- Building frame ($fin, $rsv1, $rsv2, $rsv3, $op)\n" if DEBUG;
  
    # Head
    my $head = $op + ($fin ? 128 : 0);
    $head |= 0b01000000 if $rsv1;
    $head |= 0b00100000 if $rsv2;
    $head |= 0b00010000 if $rsv3;
    my $frame = pack 'C', $head;
  
    # Small payload
    my $len = length $payload;
    if ($len < 126) {
      warn "-- Small payload ($len)\n@{[dumper $payload]}" if DEBUG;
      $frame .= pack 'C', $masked ? ($len | 128) : $len;
    }
  
    # Extended payload (16-bit)
    elsif ($len < 65536) {
      warn "-- Extended 16-bit payload ($len)\n@{[dumper $payload]}" if DEBUG;
      $frame .= pack 'Cn', $masked ? (126 | 128) : 126, $len;
    }
  
    # Extended payload (64-bit with 32-bit fallback)
    else {
      warn "-- Extended 64-bit payload ($len)\n@{[dumper $payload]}" if DEBUG;
      $frame .= pack 'C', $masked ? (127 | 128) : 127;
      $frame .= MODERN ? pack('Q>', $len) : pack('NN', 0, $len & 0xffffffff);
    }
  
    # Mask payload
    if ($masked) {
      my $mask = pack 'N', int(rand 9 x 7);
      $payload = $mask . xor_encode($payload, $mask x 128);
    }
  
    return $frame . $payload;
  }
  
  sub challenge {
    my $tx = shift;
  
    # "permessage-deflate" extension
    my $headers = $tx->res->headers;
    $tx->compressed(1)
      if ($headers->sec_websocket_extensions // '') =~ /permessage-deflate/;
  
    return _challenge($tx->req->headers->sec_websocket_key) eq
      $headers->sec_websocket_accept;
  }
  
  sub client_handshake {
    my $tx = shift;
  
    my $headers = $tx->req->headers;
    $headers->upgrade('websocket')      unless $headers->upgrade;
    $headers->connection('Upgrade')     unless $headers->connection;
    $headers->sec_websocket_version(13) unless $headers->sec_websocket_version;
  
    # Generate 16 byte WebSocket challenge
    my $challenge = b64_encode sprintf('%16u', int(rand 9 x 16)), '';
    $headers->sec_websocket_key($challenge) unless $headers->sec_websocket_key;
  
    return $tx;
  }
  
  sub parse_frame {
    my ($buffer, $max) = @_;
  
    # Head
    return undef unless length $$buffer >= 2;
    my ($first, $second) = unpack 'C*', substr($$buffer, 0, 2);
  
    # FIN
    my $fin = ($first & 0b10000000) == 0b10000000 ? 1 : 0;
  
    # RSV1-3
    my $rsv1 = ($first & 0b01000000) == 0b01000000 ? 1 : 0;
    my $rsv2 = ($first & 0b00100000) == 0b00100000 ? 1 : 0;
    my $rsv3 = ($first & 0b00010000) == 0b00010000 ? 1 : 0;
  
    # Opcode
    my $op = $first & 0b00001111;
    warn "-- Parsing frame ($fin, $rsv1, $rsv2, $rsv3, $op)\n" if DEBUG;
  
    # Small payload
    my ($hlen, $len) = (2, $second & 0b01111111);
    if ($len < 126) { warn "-- Small payload ($len)\n" if DEBUG }
  
    # Extended payload (16-bit)
    elsif ($len == 126) {
      return undef unless length $$buffer > 4;
      $hlen = 4;
      $len = unpack 'n', substr($$buffer, 2, 2);
      warn "-- Extended 16-bit payload ($len)\n" if DEBUG;
    }
  
    # Extended payload (64-bit with 32-bit fallback)
    elsif ($len == 127) {
      return undef unless length $$buffer > 10;
      $hlen = 10;
      my $ext = substr $$buffer, 2, 8;
      $len = MODERN ? unpack('Q>', $ext) : unpack('N', substr($ext, 4, 4));
      warn "-- Extended 64-bit payload ($len)\n" if DEBUG;
    }
  
    # Check message size
    return 1 if $len > $max;
  
    # Check if whole packet has arrived
    $len += 4 if my $masked = $second & 0b10000000;
    return undef if length $$buffer < ($hlen + $len);
    substr $$buffer, 0, $hlen, '';
  
    # Payload
    my $payload = $len ? substr($$buffer, 0, $len, '') : '';
    $payload = xor_encode($payload, substr($payload, 0, 4, '') x 128) if $masked;
    warn dumper $payload if DEBUG;
  
    return [$fin, $rsv1, $rsv2, $rsv3, $op, $payload];
  }
  
  sub server_handshake {
    my $tx = shift;
  
    my $headers = $tx->res->headers;
    $headers->upgrade('websocket')->connection('Upgrade');
    $headers->sec_websocket_accept(
      _challenge($tx->req->headers->sec_websocket_key));
  
    return $tx;
  }
  
  sub _challenge { b64_encode(sha1_bytes(($_[0] || '') . GUID), '') }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojo::WebSocket - The WebSocket protocol
  
  =head1 SYNOPSIS
  
    use Mojo::WebSocket qw(WS_TEXT build_frame parse_frame);
  
    my $bytes = build_frame 0, 1, 0, 0, 0, WS_TEXT, 'Hello World!';
    my $frame = parse_frame \$bytes, 262144;
  
  =head1 DESCRIPTION
  
  L<Mojo::WebSocket> implements the WebSocket protocol as described in
  L<RFC 6455|http://tools.ietf.org/html/rfc6455>. Note that 64-bit frames require
  a Perl with support for quads or they are limited to 32-bit.
  
  =head1 FUNCTIONS
  
  L<Mojo::WebSocket> implements the following functions, which can be imported
  individually.
  
  =head2 build_frame
  
    my $bytes = build_frame $masked, $fin, $rsv1, $rsv2, $rsv3, $op, $payload;
  
  Build WebSocket frame.
  
    # Masked binary frame with FIN bit and payload
    say build_frame 1, 1, 0, 0, 0, WS_BINARY, 'Hello World!';
  
    # Text frame with payload but without FIN bit
    say build_frame 0, 0, 0, 0, 0, WS_TEXT, 'Hello ';
  
    # Continuation frame with FIN bit and payload
    say build_frame 0, 1, 0, 0, 0, WS_CONTINUATION, 'World!';
  
    # Close frame with FIN bit and without payload
    say build_frame 0, 1, 0, 0, 0, WS_CLOSE, '';
  
    # Ping frame with FIN bit and payload
    say build_frame 0, 1, 0, 0, 0, WS_PING, 'Test 123';
  
    # Pong frame with FIN bit and payload
    say build_frame 0, 1, 0, 0, 0, WS_PONG, 'Test 123';
  
  =head2 challenge
  
    my $bool = challenge Mojo::Transaction::WebSocket->new;
  
  Check WebSocket handshake challenge.
  
  =head2 client_handshake
  
    my $tx = client_handshake Mojo::Transaction::HTTP->new;
  
  Perform WebSocket handshake client-side.
  
  =head2 parse_frame
  
    my $frame = parse_frame \$bytes, $limit;
  
  Parse WebSocket frame.
  
    # Parse single frame and remove it from buffer
    my $frame = parse_frame \$buffer, 262144;
    say "FIN: $frame->[0]";
    say "RSV1: $frame->[1]";
    say "RSV2: $frame->[2]";
    say "RSV3: $frame->[3]";
    say "Opcode: $frame->[4]";
    say "Payload: $frame->[5]";
  
  =head2 server_handshake
  
    my $tx = server_handshake Mojo::Transaction::HTTP->new;
  
  Perform WebSocket handshake server-side.
  
  =head1 CONSTANTS
  
  L<Mojo::WebSocket> implements the following constants, which can be imported
  individually.
  
  =head2 WS_BINARY
  
  Opcode for C<Binary> frames.
  
  =head2 WS_CLOSE
  
  Opcode for C<Close> frames.
  
  =head2 WS_CONTINUATION
  
  Opcode for C<Continuation> frames.
  
  =head2 WS_PING
  
  Opcode for C<Ping> frames.
  
  =head2 WS_PONG
  
  Opcode for C<Pong> frames.
  
  =head2 WS_TEXT
  
  Opcode for C<Text> frames.
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<http://mojolicious.org>.
  
  =cut
MOJO_WEBSOCKET

$fatpacked{"Mojolicious.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJOLICIOUS';
  package Mojolicious;
  use Mojo::Base 'Mojo';
  
  # "Fry: Shut up and take my money!"
  use Carp ();
  use Mojo::Exception;
  use Mojo::Log;
  use Mojo::Util;
  use Mojolicious::Commands;
  use Mojolicious::Controller;
  use Mojolicious::Plugins;
  use Mojolicious::Renderer;
  use Mojolicious::Routes;
  use Mojolicious::Sessions;
  use Mojolicious::Static;
  use Mojolicious::Types;
  use Mojolicious::Validator;
  use Scalar::Util ();
  use Time::HiRes  ();
  
  has commands => sub {
    my $commands = Mojolicious::Commands->new(app => shift);
    Scalar::Util::weaken $commands->{app};
    return $commands;
  };
  has controller_class => 'Mojolicious::Controller';
  has log              => sub {
    my $self = shift;
  
    # Check if we have a log directory that is writable
    my $log  = Mojo::Log->new;
    my $home = $self->home;
    my $mode = $self->mode;
    $log->path($home->child('log', "$mode.log"))
      if -d $home->child('log') && -w _;
  
    # Reduced log output outside of development mode
    return $mode eq 'development' ? $log : $log->level('info');
  };
  has 'max_request_size';
  has mode => sub { $ENV{MOJO_MODE} || $ENV{PLACK_ENV} || 'development' };
  has moniker  => sub { Mojo::Util::decamelize ref shift };
  has plugins  => sub { Mojolicious::Plugins->new };
  has renderer => sub { Mojolicious::Renderer->new };
  has routes   => sub { Mojolicious::Routes->new };
  has secrets  => sub {
    my $self = shift;
  
    # Warn developers about insecure default
    $self->log->debug('Your secret passphrase needs to be changed');
  
    # Default to moniker
    return [$self->moniker];
  };
  has sessions  => sub { Mojolicious::Sessions->new };
  has static    => sub { Mojolicious::Static->new };
  has types     => sub { Mojolicious::Types->new };
  has validator => sub { Mojolicious::Validator->new };
  
  our $CODENAME = 'Doughnut';
  our $VERSION  = '7.30';
  
  sub AUTOLOAD {
    my $self = shift;
  
    my ($package, $method) = our $AUTOLOAD =~ /^(.+)::(.+)$/;
    Carp::croak "Undefined subroutine &${package}::$method called"
      unless Scalar::Util::blessed $self && $self->isa(__PACKAGE__);
  
    # Call helper with fresh controller
    Carp::croak qq{Can't locate object method "$method" via package "$package"}
      unless my $helper = $self->renderer->get_helper($method);
    return $self->build_controller->$helper(@_);
  }
  
  sub build_controller {
    my ($self, $tx) = @_;
    $tx ||= $self->build_tx;
  
    # Embedded application
    my $stash = {};
    if (my $sub = $tx->can('stash')) { ($stash, $tx) = ($tx->$sub, $tx->tx) }
  
    # Build default controller
    my $defaults = $self->defaults;
    @$stash{keys %$defaults} = values %$defaults;
    my $c
      = $self->controller_class->new(app => $self, stash => $stash, tx => $tx);
    Scalar::Util::weaken $c->{app};
  
    return $c;
  }
  
  sub build_tx {
    my $self = shift;
  
    my $tx  = Mojo::Transaction::HTTP->new;
    my $max = $self->max_request_size;
    $tx->req->max_message_size($max) if defined $max;
    $self->plugins->emit_hook(after_build_tx => $tx, $self);
  
    return $tx;
  }
  
  sub defaults { Mojo::Util::_stash(defaults => @_) }
  
  sub dispatch {
    my ($self, $c) = @_;
  
    my $plugins = $self->plugins->emit_hook(before_dispatch => $c);
  
    # Try to find a static file
    my $tx = $c->tx;
    $self->static->dispatch($c) and $plugins->emit_hook(after_static => $c)
      unless $tx->res->code;
  
    # Start timer (ignore static files)
    my $stash = $c->stash;
    unless ($stash->{'mojo.static'} || $stash->{'mojo.started'}) {
      my $req    = $c->req;
      my $method = $req->method;
      my $path   = $req->url->path->to_abs_string;
      $self->log->debug(qq{$method "$path"});
      $stash->{'mojo.started'} = [Time::HiRes::gettimeofday];
    }
  
    # Routes
    $plugins->emit_hook(before_routes => $c);
    $c->helpers->reply->not_found
      unless $tx->res->code || $self->routes->dispatch($c) || $tx->res->code;
  }
  
  sub handler {
    my $self = shift;
  
    # Dispatcher has to be last in the chain
    ++$self->{dispatch}
      and $self->hook(around_action   => sub { $_[2]($_[1]) })
      and $self->hook(around_dispatch => sub { $_[1]->app->dispatch($_[1]) })
      unless $self->{dispatch};
  
    # Process with chain
    my $c = $self->build_controller(@_);
    Scalar::Util::weaken $c->{tx};
    $self->plugins->emit_chain(around_dispatch => $c);
  
    # Delayed response
    $self->log->debug('Nothing has been rendered, expecting delayed response')
      unless $c->stash->{'mojo.rendered'};
  }
  
  sub helper { shift->renderer->add_helper(@_) }
  
  sub hook { shift->plugins->on(@_) }
  
  sub new {
    my $self = shift->SUPER::new(@_);
  
    my $home = $self->home;
    push @{$self->renderer->paths}, $home->child('templates');
    push @{$self->static->paths},   $home->child('public');
  
    # Default to controller and application namespace
    my $r = $self->routes->namespaces(["@{[ref $self]}::Controller", ref $self]);
  
    # Hide controller attributes/methods
    $r->hide(qw(app continue cookie every_cookie every_param));
    $r->hide(qw(every_signed_cookie finish flash helpers match on param));
    $r->hide(qw(redirect_to render render_later render_maybe render_to_string));
    $r->hide(qw(rendered req res respond_to send session signed_cookie stash));
    $r->hide(qw(tx url_for validation write write_chunk));
  
    $self->plugin($_)
      for qw(HeaderCondition DefaultHelpers TagHelpers EPLRenderer EPRenderer);
  
    # Exception handling should be first in chain
    $self->hook(around_dispatch => \&_exception);
  
    $self->startup;
  
    return $self;
  }
  
  sub plugin {
    my $self = shift;
    $self->plugins->register_plugin(shift, $self, @_);
  }
  
  sub start {
    my $self = shift;
    $_->warmup for $self->static, $self->renderer;
    return $self->commands->run(@_ ? @_ : @ARGV);
  }
  
  sub startup { }
  
  sub _exception {
    my ($next, $c) = @_;
    local $SIG{__DIE__}
      = sub { ref $_[0] ? CORE::die $_[0] : Mojo::Exception->throw(shift) };
    $c->helpers->reply->exception($@) unless eval { $next->(); 1 };
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojolicious - Real-time web framework
  
  =head1 SYNOPSIS
  
    # Application
    package MyApp;
    use Mojo::Base 'Mojolicious';
  
    # Route
    sub startup {
      my $self = shift;
      $self->routes->get('/hello')->to('foo#hello');
    }
  
    # Controller
    package MyApp::Controller::Foo;
    use Mojo::Base 'Mojolicious::Controller';
  
    # Action
    sub hello {
      my $self = shift;
      $self->render(text => 'Hello World!');
    }
  
  =head1 DESCRIPTION
  
  An amazing real-time web framework built on top of the powerful L<Mojo> web
  development toolkit. With support for RESTful routes, plugins, commands,
  Perl-ish templates, content negotiation, session management, form validation,
  testing framework, static file server, C<CGI>/C<PSGI> detection, first class
  Unicode support and much more for you to discover.
  
  Take a look at our excellent documentation in L<Mojolicious::Guides>!
  
  =head1 HOOKS
  
  L<Mojolicious> will emit the following hooks in the listed order.
  
  =head2 after_build_tx
  
  Emitted right after the transaction is built and before the HTTP request gets
  parsed.
  
    $app->hook(after_build_tx => sub {
      my ($tx, $app) = @_;
      ...
    });
  
  This is a very powerful hook and should not be used lightly, it makes some
  rather advanced features such as upload progress bars possible. Note that this
  hook will not work for embedded applications, because only the host application
  gets to build transactions. (Passed the transaction and application object)
  
  =head2 around_dispatch
  
  Emitted right after a new request has been received and wraps around the whole
  dispatch process, so you have to manually forward to the next hook if you want
  to continue the chain. Default exception handling with
  L<Mojolicious::Plugin::DefaultHelpers/"reply-E<gt>exception"> is the first hook
  in the chain and a call to L</"dispatch"> the last, yours will be in between.
  
    $app->hook(around_dispatch => sub {
      my ($next, $c) = @_;
      ...
      $next->();
      ...
    });
  
  This is a very powerful hook and should not be used lightly, it allows you to,
  for example, customize application-wide exception handling, consider it the
  sledgehammer in your toolbox. (Passed a callback leading to the next hook and
  the default controller object)
  
  =head2 before_dispatch
  
  Emitted right before the static file server and router start their work.
  
    $app->hook(before_dispatch => sub {
      my $c = shift;
      ...
    });
  
  Very useful for rewriting incoming requests and other preprocessing tasks.
  (Passed the default controller object)
  
  =head2 after_static
  
  Emitted after a static file response has been generated by the static file
  server.
  
    $app->hook(after_static => sub {
      my $c = shift;
      ...
    });
  
  Mostly used for post-processing static file responses. (Passed the default
  controller object)
  
  =head2 before_routes
  
  Emitted after the static file server determined if a static file should be
  served and before the router starts its work.
  
    $app->hook(before_routes => sub {
      my $c = shift;
      ...
    });
  
  Mostly used for custom dispatchers and collecting metrics. (Passed the default
  controller object)
  
  =head2 around_action
  
  Emitted right before an action gets executed and wraps around it, so you have to
  manually forward to the next hook if you want to continue the chain. Default
  action dispatching is the last hook in the chain, yours will run before it.
  
    $app->hook(around_action => sub {
      my ($next, $c, $action, $last) = @_;
      ...
      return $next->();
    });
  
  This is a very powerful hook and should not be used lightly, it allows you for
  example to pass additional arguments to actions or handle return values
  differently. Note that this hook can trigger more than once for the same
  request if there are nested routes. (Passed a callback leading to the next hook,
  the current controller object, the action callback and a flag indicating if this
  action is an endpoint)
  
  =head2 before_render
  
  Emitted before content is generated by the renderer. Note that this hook can
  trigger out of order due to its dynamic nature, and with embedded applications
  will only work for the application that is rendering.
  
    $app->hook(before_render => sub {
      my ($c, $args) = @_;
      ...
    });
  
  Mostly used for pre-processing arguments passed to the renderer. (Passed the
  current controller object and the render arguments)
  
  =head2 after_render
  
  Emitted after content has been generated by the renderer that will be assigned
  to the response. Note that this hook can trigger out of order due to its
  dynamic nature, and with embedded applications will only work for the
  application that is rendering.
  
    $app->hook(after_render => sub {
      my ($c, $output, $format) = @_;
      ...
    });
  
  Mostly used for post-processing dynamically generated content. (Passed the
  current controller object, a reference to the content and the format)
  
  =head2 after_dispatch
  
  Emitted in reverse order after a response has been generated. Note that this
  hook can trigger out of order due to its dynamic nature, and with embedded
  applications will only work for the application that is generating the response.
  
    $app->hook(after_dispatch => sub {
      my $c = shift;
      ...
    });
  
  Useful for rewriting outgoing responses and other post-processing tasks.
  (Passed the current controller object)
  
  =head1 ATTRIBUTES
  
  L<Mojolicious> inherits all attributes from L<Mojo> and implements the
  following new ones.
  
  =head2 commands
  
    my $commands = $app->commands;
    $app         = $app->commands(Mojolicious::Commands->new);
  
  Command line interface for your application, defaults to a
  L<Mojolicious::Commands> object.
  
    # Add another namespace to load commands from
    push @{$app->commands->namespaces}, 'MyApp::Command';
  
  =head2 controller_class
  
    my $class = $app->controller_class;
    $app      = $app->controller_class('Mojolicious::Controller');
  
  Class to be used for the default controller, defaults to
  L<Mojolicious::Controller>. Note that this class needs to have already been
  loaded before the first request arrives.
  
  =head2 log
  
    my $log = $app->log;
    $app    = $app->log(Mojo::Log->new);
  
  The logging layer of your application, defaults to a L<Mojo::Log> object. The
  level will default to C<debug> if the L</mode> is C<development>, or C<info>
  otherwise. All messages will be written to C<STDERR>, or a C<log/$mode.log> file
  if a C<log> directory exists.
  
    # Log debug message
    $app->log->debug('It works');
  
  =head2 max_request_size
  
    my $max = $app->max_request_size;
    $app    = $app->max_request_size(16777216);
  
  Maximum request size in bytes, defaults to the value of
  L<Mojo::Message/"max_message_size">. Setting the value to C<0> will allow
  requests of indefinite size. Note that increasing this value can also
  drastically increase memory usage, should you for example attempt to parse an
  excessively large request body with the methods L<Mojo::Message/"dom"> or
  L<Mojo::Message/"json">.
  
  =head2 mode
  
    my $mode = $app->mode;
    $app     = $app->mode('production');
  
  The operating mode for your application, defaults to a value from the
  C<MOJO_MODE> and C<PLACK_ENV> environment variables or C<development>.
  
  =head2 moniker
  
    my $moniker = $app->moniker;
    $app        = $app->moniker('foo_bar');
  
  Moniker of this application, often used as default filename for configuration
  files and the like, defaults to decamelizing the application class with
  L<Mojo::Util/"decamelize">.
  
  =head2 plugins
  
    my $plugins = $app->plugins;
    $app        = $app->plugins(Mojolicious::Plugins->new);
  
  The plugin manager, defaults to a L<Mojolicious::Plugins> object. See the
  L</"plugin"> method below if you want to load a plugin.
  
    # Add another namespace to load plugins from
    push @{$app->plugins->namespaces}, 'MyApp::Plugin';
  
  =head2 renderer
  
    my $renderer = $app->renderer;
    $app         = $app->renderer(Mojolicious::Renderer->new);
  
  Used to render content, defaults to a L<Mojolicious::Renderer> object. For more
  information about how to generate content see
  L<Mojolicious::Guides::Rendering>.
  
    # Add another "templates" directory
    push @{$app->renderer->paths}, '/home/sri/templates';
  
    # Add another "templates" directory with higher precedence
    unshift @{$app->renderer->paths}, '/home/sri/themes/blue/templates';
  
    # Add another class with templates in DATA section
    push @{$app->renderer->classes}, 'Mojolicious::Plugin::Fun';
  
  =head2 routes
  
    my $routes = $app->routes;
    $app       = $app->routes(Mojolicious::Routes->new);
  
  The router, defaults to a L<Mojolicious::Routes> object. You use this in your
  startup method to define the url endpoints for your application.
  
    # Add routes
    my $r = $app->routes;
    $r->get('/foo/bar')->to('test#foo', title => 'Hello Mojo!');
    $r->post('/baz')->to('test#baz');
  
    # Add another namespace to load controllers from
    push @{$app->routes->namespaces}, 'MyApp::MyController';
  
  =head2 secrets
  
    my $secrets = $app->secrets;
    $app        = $app->secrets([$bytes]);
  
  Secret passphrases used for signed cookies and the like, defaults to the
  L</"moniker"> of this application, which is not very secure, so you should
  change it!!! As long as you are using the insecure default there will be debug
  messages in the log file reminding you to change your passphrase. Only the
  first passphrase is used to create new signatures, but all of them for
  verification. So you can increase security without invalidating all your
  existing signed cookies by rotating passphrases, just add new ones to the front
  and remove old ones from the back.
  
    # Rotate passphrases
    $app->secrets(['new_passw0rd', 'old_passw0rd', 'very_old_passw0rd']);
  
  =head2 sessions
  
    my $sessions = $app->sessions;
    $app         = $app->sessions(Mojolicious::Sessions->new);
  
  Signed cookie based session manager, defaults to a L<Mojolicious::Sessions>
  object. You can usually leave this alone, see
  L<Mojolicious::Controller/"session"> for more information about working with
  session data.
  
    # Change name of cookie used for all sessions
    $app->sessions->cookie_name('mysession');
  
  =head2 static
  
    my $static = $app->static;
    $app       = $app->static(Mojolicious::Static->new);
  
  For serving static files from your C<public> directories, defaults to a
  L<Mojolicious::Static> object.
  
    # Add another "public" directory
    push @{$app->static->paths}, '/home/sri/public';
  
    # Add another "public" directory with higher precedence
    unshift @{$app->static->paths}, '/home/sri/themes/blue/public';
  
    # Add another class with static files in DATA section
    push @{$app->static->classes}, 'Mojolicious::Plugin::Fun';
  
  =head2 types
  
    my $types = $app->types;
    $app      = $app->types(Mojolicious::Types->new);
  
  Responsible for connecting file extensions with MIME types, defaults to a
  L<Mojolicious::Types> object.
  
    # Add custom MIME type
    $app->types->type(twt => 'text/tweet');
  
  =head2 validator
  
    my $validator = $app->validator;
    $app          = $app->validator(Mojolicious::Validator->new);
  
  Validate values, defaults to a L<Mojolicious::Validator> object.
  
    # Add validation check
    $app->validator->add_check(foo => sub {
      my ($validation, $name, $value) = @_;
      return $value ne 'foo';
    });
  
    # Add validation filter
    $app->validator->add_filter(quotemeta => sub {
      my ($validation, $name, $value) = @_;
      return quotemeta $value;
    });
  
  =head1 METHODS
  
  L<Mojolicious> inherits all methods from L<Mojo> and implements the following
  new ones.
  
  =head2 build_controller
  
    my $c = $app->build_controller;
    my $c = $app->build_controller(Mojo::Transaction::HTTP->new);
    my $c = $app->build_controller(Mojolicious::Controller->new);
  
  Build default controller object with L</"controller_class">.
  
    # Render template from application
    my $foo = $app->build_controller->render_to_string(template => 'foo');
  
  =head2 build_tx
  
    my $tx = $app->build_tx;
  
  Build L<Mojo::Transaction::HTTP> object and emit L</"after_build_tx"> hook.
  
  =head2 defaults
  
    my $hash = $app->defaults;
    my $foo  = $app->defaults('foo');
    $app     = $app->defaults({foo => 'bar', baz => 23});
    $app     = $app->defaults(foo => 'bar', baz => 23);
  
  Default values for L<Mojolicious::Controller/"stash">, assigned for every new
  request.
  
    # Remove value
    my $foo = delete $app->defaults->{foo};
  
    # Assign multiple values at once
    $app->defaults(foo => 'test', bar => 23);
  
  =head2 dispatch
  
    $app->dispatch(Mojolicious::Controller->new);
  
  The heart of every L<Mojolicious> application, calls the L</"static"> and
  L</"routes"> dispatchers for every request and passes them a
  L<Mojolicious::Controller> object.
  
  =head2 handler
  
    $app->handler(Mojo::Transaction::HTTP->new);
    $app->handler(Mojolicious::Controller->new);
  
  Sets up the default controller and emits the L</"around_dispatch"> hook for
  every request.
  
  =head2 helper
  
    $app->helper(foo => sub {...});
  
  Add or replace a helper that will be available as a method of the controller
  object and the application object, as well as a function in C<ep> templates. For
  a full list of helpers that are available by default see
  L<Mojolicious::Plugin::DefaultHelpers> and L<Mojolicious::Plugin::TagHelpers>.
  
    # Helper
    $app->helper(cache => sub { state $cache = {} });
  
    # Application
    $app->cache->{foo} = 'bar';
    my $result = $app->cache->{foo};
  
    # Controller
    $c->cache->{foo} = 'bar';
    my $result = $c->cache->{foo};
  
    # Template
    % cache->{foo} = 'bar';
    %= cache->{foo}
  
  =head2 hook
  
    $app->hook(after_dispatch => sub {...});
  
  Extend L<Mojolicious> with hooks, which allow code to be shared with all
  requests indiscriminately, for a full list of available hooks see L</"HOOKS">.
  
    # Dispatchers will not run if there's already a response code defined
    $app->hook(before_dispatch => sub {
      my $c = shift;
      $c->render(text => 'Skipped static file server and router!')
        if $c->req->url->path->to_route =~ /do_not_dispatch/;
    });
  
  =head2 new
  
    my $app = Mojolicious->new;
    my $app = Mojolicious->new(moniker => 'foo_bar');
    my $app = Mojolicious->new({moniker => 'foo_bar'});
  
  Construct a new L<Mojolicious> application and call L</"startup">. Will
  automatically detect your home directory. Also sets up the renderer, static file
  server, a default set of plugins and an L</"around_dispatch"> hook with the
  default exception handling.
  
  =head2 plugin
  
    $app->plugin('some_thing');
    $app->plugin('some_thing', foo => 23);
    $app->plugin('some_thing', {foo => 23});
    $app->plugin('SomeThing');
    $app->plugin('SomeThing', foo => 23);
    $app->plugin('SomeThing', {foo => 23});
    $app->plugin('MyApp::Plugin::SomeThing');
    $app->plugin('MyApp::Plugin::SomeThing', foo => 23);
    $app->plugin('MyApp::Plugin::SomeThing', {foo => 23});
  
  Load a plugin, for a full list of example plugins included in the
  L<Mojolicious> distribution see L<Mojolicious::Plugins/"PLUGINS">.
  
  =head2 start
  
    $app->start;
    $app->start(@ARGV);
  
  Start the command line interface for your application. For a full list of
  commands that are available by default see L<Mojolicious::Commands/"COMMANDS">.
  Note that the options C<-h>/C<--help>, C<--home> and C<-m>/C<--mode>, which are
  shared by all commands, will be parsed from C<@ARGV> during compile time.
  
    # Always start daemon
    $app->start('daemon', '-l', 'http://*:8080');
  
  =head2 startup
  
    $app->startup;
  
  This is your main hook into the application, it will be called at application
  startup. Meant to be overloaded in a subclass.
  
    sub startup {
      my $self = shift;
      ...
    }
  
  =head1 AUTOLOAD
  
  In addition to the L</"ATTRIBUTES"> and L</"METHODS"> above you can also call
  helpers on L<Mojolicious> objects. This includes all helpers from
  L<Mojolicious::Plugin::DefaultHelpers> and L<Mojolicious::Plugin::TagHelpers>.
  Note that application helpers are always called with a new default controller
  object, so they can't depend on or change controller state, which includes
  request, response and stash.
  
    # Call helper
    say $app->dumper({foo => 'bar'});
  
    # Longer version
    say $app->build_controller->helpers->dumper({foo => 'bar'});
  
  =head1 BUNDLED FILES
  
  The L<Mojolicious> distribution includes a few files with different licenses
  that have been bundled for internal use.
  
  =head2 Mojolicious Artwork
  
    Copyright (C) 2010-2017, Sebastian Riedel.
  
  Licensed under the CC-SA License, Version 4.0
  L<http://creativecommons.org/licenses/by-sa/4.0>.
  
  =head2 jQuery
  
    Copyright (C) jQuery Foundation.
  
  Licensed under the MIT License, L<http://creativecommons.org/licenses/MIT>.
  
  =head2 prettify.js
  
    Copyright (C) 2006, 2013 Google Inc..
  
  Licensed under the Apache License, Version 2.0
  L<http://www.apache.org/licenses/LICENSE-2.0>.
  
  =head1 CODE NAMES
  
  Every major release of L<Mojolicious> has a code name, these are the ones that
  have been used in the past.
  
  7.0, C<Doughnut> (U+1F369)
  
  6.0, C<Clinking Beer Mugs> (U+1F37B)
  
  5.0, C<Tiger Face> (U+1F42F)
  
  4.0, C<Top Hat> (U+1F3A9)
  
  3.0, C<Rainbow> (U+1F308)
  
  2.0, C<Leaf Fluttering In Wind> (U+1F343)
  
  1.4, C<Smiling Face With Sunglasses> (U+1F60E)
  
  1.3, C<Tropical Drink> (U+1F379)
  
  1.1, C<Smiling Cat Face With Heart-Shaped Eyes> (U+1F63B)
  
  1.0, C<Snowflake> (U+2744)
  
  =head1 SPONSORS
  
  Some of the work on this distribution has been sponsored by
  L<The Perl Foundation|http://www.perlfoundation.org>, thank you!
  
  =head1 PROJECT FOUNDER
  
  Sebastian Riedel, C<sri@cpan.org>
  
  =head1 CORE DEVELOPERS
  
  Current members of the core team in alphabetical order:
  
  =over 2
  
  Jan Henning Thorsen, C<jhthorsen@cpan.org>
  
  Joel Berger, C<jberger@cpan.org>
  
  Marcus Ramberg, C<mramberg@cpan.org>
  
  =back
  
  The following members of the core team are currently on hiatus:
  
  =over 2
  
  Abhijit Menon-Sen, C<ams@cpan.org>
  
  Glen Hinkle, C<tempire@cpan.org>
  
  =back
  
  =head1 CREDITS
  
  In alphabetical order:
  
  =over 2
  
  Adam Kennedy
  
  Adriano Ferreira
  
  Al Newkirk
  
  Alex Efros
  
  Alex Salimon
  
  Alexey Likhatskiy
  
  Anatoly Sharifulin
  
  Andre Parker
  
  Andre Vieth
  
  Andreas Jaekel
  
  Andreas Koenig
  
  Andrew Fresh
  
  Andrew Nugged
  
  Andrey Khozov
  
  Andrey Kuzmin
  
  Andy Grundman
  
  Aristotle Pagaltzis
  
  Ashley Dev
  
  Ask Bjoern Hansen
  
  Audrey Tang
  
  Ben Tyler
  
  Ben van Staveren
  
  Benjamin Erhart
  
  Bernhard Graf
  
  Breno G. de Oliveira
  
  Brian Duggan
  
  Brian Medley
  
  Burak Gursoy
  
  Ch Lamprecht
  
  Charlie Brady
  
  Chas. J. Owens IV
  
  Christian Hansen
  
  chromatic
  
  Curt Tilmes
  
  Dan Book
  
  Daniel Kimsey
  
  Danijel Tasov
  
  Danny Thomas
  
  David Davis
  
  David Webb
  
  Diego Kuperman
  
  Dmitriy Shalashov
  
  Dmitry Konstantinov
  
  Dominik Jarmulowicz
  
  Dominique Dumont
  
  Douglas Christopher Wilson
  
  Eugen Konkov
  
  Eugene Toropov
  
  Gisle Aas
  
  Graham Barr
  
  Graham Knop
  
  Henry Tang
  
  Hideki Yamamura
  
  Hiroki Toyokawa
  
  Ian Goodacre
  
  Ilya Chesnokov
  
  James Duncan
  
  Jan Jona Javorsek
  
  Jan Schmidt
  
  Jaroslav Muhin
  
  Jesse Vincent
  
  Johannes Plunien
  
  John Kingsley
  
  Jonathan Yu
  
  Josh Leder
  
  Kazuhiro Shibuya
  
  Kevin Old
  
  Kitamura Akatsuki
  
  Klaus S. Madsen
  
  Knut Arne Bjorndal
  
  Lars Balker Rasmussen
  
  Lee Johnson
  
  Leon Brocard
  
  Magnus Holm
  
  Maik Fischer
  
  Mark Fowler
  
  Mark Grimes
  
  Mark Stosberg
  
  Marty Tennison
  
  Matt S Trout
  
  Matthew Lineen
  
  Maksym Komar
  
  Maxim Vuets
  
  Michael Gregorowicz
  
  Michael Harris
  
  Mike Magowan
  
  Mirko Westermeier
  
  Mons Anderson
  
  Moritz Lenz
  
  Neil Watkiss
  
  Nic Sandfield
  
  Nils Diewald
  
  Oleg Zhelo
  
  Olivier Mengue
  
  Pascal Gaudette
  
  Paul Evans
  
  Paul Tomlin
  
  Pavel Shaydo
  
  Pedro Melo
  
  Peter Edwards
  
  Pierre-Yves Ritschard
  
  Piotr Roszatycki
  
  Quentin Carbonneaux
  
  Rafal Pocztarski
  
  Randal Schwartz
  
  Richard Elberger
  
  Rick Delaney
  
  Robert Hicks
  
  Robin Lee
  
  Roland Lammel
  
  Roy Storey
  
  Ryan Jendoubi
  
  Salvador Fandino
  
  Sascha Kiefer
  
  Scott Wiersdorf
  
  Sergey Zasenko
  
  Simon Bertrang
  
  Simone Tampieri
  
  Shu Cho
  
  Skye Shaw
  
  Stanis Trendelenburg
  
  Steffen Ullrich
  
  Stephan Kulow
  
  Stephane Este-Gracias
  
  Steve Atkins
  
  Tatsuhiko Miyagawa
  
  Terrence Brannon
  
  Tianon Gravi
  
  Tomas Znamenacek
  
  Tudor Constantin
  
  Ulrich Habel
  
  Ulrich Kautz
  
  Uwe Voelker
  
  Viacheslav Tykhanovskyi
  
  Victor Engmark
  
  Viliam Pucik
  
  Wes Cravens
  
  Yaroslav Korshak
  
  Yuki Kimoto
  
  Zak B. Elep
  
  Zoffix Znet
  
  =back
  
  =head1 COPYRIGHT AND LICENSE
  
  Copyright (C) 2008-2017, Sebastian Riedel and others.
  
  This program is free software, you can redistribute it and/or modify it under
  the terms of the Artistic License version 2.0.
  
  =head1 SEE ALSO
  
  L<https://github.com/kraih/mojo>, L<Mojolicious::Guides>,
  L<http://mojolicious.org>.
  
  =cut
MOJOLICIOUS

$fatpacked{"Mojolicious/Command.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJOLICIOUS_COMMAND';
  package Mojolicious::Command;
  use Mojo::Base -base;
  
  use Carp 'croak';
  use Mojo::File 'path';
  use Mojo::Loader 'data_section';
  use Mojo::Server;
  use Mojo::Template;
  use Mojo::Util 'deprecated';
  
  has app => sub { Mojo::Server->new->build_app('Mojo::HelloWorld') };
  has description => 'No description';
  has 'quiet';
  has usage => "Usage: APPLICATION\n";
  
  sub chmod_file {
    my ($self, $path, $mod) = @_;
    chmod $mod, $path or croak qq{Can't chmod file "$path": $!};
    return $self->_loud("  [chmod] $path " . sprintf('%lo', $mod));
  }
  
  sub chmod_rel_file { $_[0]->chmod_file($_[0]->rel_file($_[1]), $_[2]) }
  
  sub create_dir {
    my ($self, $path) = @_;
    return $self->_loud("  [exist] $path") if -d $path;
    path($path)->make_path;
    return $self->_loud("  [mkdir] $path");
  }
  
  sub create_rel_dir { $_[0]->create_dir($_[0]->rel_file($_[1])) }
  
  sub extract_usage { Mojo::Util::extract_usage((caller)[1]) }
  
  sub help { print shift->usage }
  
  # DEPRECATED!
  sub rel_dir {
    deprecated 'Mojolicious::Command::rel_dir is DEPRECATED'
      . ' in favor of Mojolicious::Command::rel_file';
    path->child(split('/', pop))->to_string;
  }
  
  sub rel_file { path->child(split('/', pop)) }
  
  sub render_data {
    my ($self, $name) = (shift, shift);
    Mojo::Template->new->name("template $name from DATA section")
      ->render(data_section(ref $self, $name), @_);
  }
  
  sub render_to_file {
    my ($self, $data, $path) = (shift, shift, shift);
    return $self->write_file($path, $self->render_data($data, @_));
  }
  
  sub render_to_rel_file {
    my $self = shift;
    $self->render_to_file(shift, $self->rel_file(shift), @_);
  }
  
  sub run { croak 'Method "run" not implemented by subclass' }
  
  sub write_file {
    my ($self, $path, $data) = @_;
    return $self->_loud("  [exist] $path") if -f $path;
    $self->create_dir(path($path)->dirname);
    path($path)->spurt($data);
    return $self->_loud("  [write] $path");
  }
  
  sub write_rel_file { $_[0]->write_file($_[0]->rel_file($_[1]), $_[2]) }
  
  sub _loud {
    my ($self, $msg) = @_;
    say $msg unless $self->quiet;
    return $self;
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojolicious::Command - Command base class
  
  =head1 SYNOPSIS
  
    # Lowercase command name
    package Mojolicious::Command::mycommand;
    use Mojo::Base 'Mojolicious::Command';
  
    # Short description
    has description => 'My first Mojo command';
  
    # Usage message from SYNOPSIS
    has usage => sub { shift->extract_usage };
  
    sub run {
      my ($self, @args) = @_;
  
      # Magic here! :)
    }
  
    1;
  
    =head1 SYNOPSIS
  
      Usage: APPLICATION mycommand [OPTIONS]
  
      Options:
        -s, --something   Does something
  
    =cut
  
  =head1 DESCRIPTION
  
  L<Mojolicious::Command> is an abstract base class for L<Mojolicious> commands.
  
  See L<Mojolicious::Commands/"COMMANDS"> for a list of commands that are
  available by default.
  
  =head1 ATTRIBUTES
  
  L<Mojolicious::Command> implements the following attributes.
  
  =head2 app
  
    my $app  = $command->app;
    $command = $command->app(Mojolicious->new);
  
  Application for command, defaults to a L<Mojo::HelloWorld> object.
  
    # Introspect
    say "Template path: $_" for @{$command->app->renderer->paths};
  
  =head2 description
  
    my $description = $command->description;
    $command        = $command->description('Foo');
  
  Short description of command, used for the command list.
  
  =head2 quiet
  
    my $bool = $command->quiet;
    $command = $command->quiet($bool);
  
  Limited command output.
  
  =head2 usage
  
    my $usage = $command->usage;
    $command  = $command->usage('Foo');
  
  Usage information for command, used for the help screen.
  
  =head1 METHODS
  
  L<Mojolicious::Command> inherits all methods from L<Mojo::Base> and implements
  the following new ones.
  
  =head2 chmod_file
  
    $command = $command->chmod_file('/home/sri/foo.txt', 0644);
  
  Change mode of a file.
  
  =head2 chmod_rel_file
  
    $command = $command->chmod_rel_file('foo/foo.txt', 0644);
  
  Portably change mode of a file relative to the current working directory.
  
  =head2 create_dir
  
    $command = $command->create_dir('/home/sri/foo/bar');
  
  Create a directory.
  
  =head2 create_rel_dir
  
    $command = $command->create_rel_dir('foo/bar/baz');
  
  Portably create a directory relative to the current working directory.
  
  =head2 extract_usage
  
    my $usage = $command->extract_usage;
  
  Extract usage message from the SYNOPSIS section of the file this method was
  called from with L<Mojo::Util/"extract_usage">.
  
  =head2 help
  
    $command->help;
  
  Print usage information for command.
  
  =head2 rel_file
  
    my $path = $command->rel_file('foo/bar.txt');
  
  Return a L<Mojo::File> object relative to the current working directory.
  
  =head2 render_data
  
    my $data = $command->render_data('foo_bar');
    my $data = $command->render_data('foo_bar', @args);
  
  Render a template from the C<DATA> section of the command class with
  L<Mojo::Loader> and L<Mojo::Template>.
  
  =head2 render_to_file
  
    $command = $command->render_to_file('foo_bar', '/home/sri/foo.txt');
    $command = $command->render_to_file('foo_bar', '/home/sri/foo.txt', @args);
  
  Render a template from the C<DATA> section of the command class with
  L<Mojo::Template> to a file and create directory if necessary.
  
  =head2 render_to_rel_file
  
    $command = $command->render_to_rel_file('foo_bar', 'foo/bar.txt');
    $command = $command->render_to_rel_file('foo_bar', 'foo/bar.txt', @args);
  
  Portably render a template from the C<DATA> section of the command class with
  L<Mojo::Template> to a file relative to the current working directory and
  create directory if necessary.
  
  =head2 run
  
    $command->run;
    $command->run(@ARGV);
  
  Run command. Meant to be overloaded in a subclass.
  
  =head2 write_file
  
    $command = $command->write_file('/home/sri/foo.txt', 'Hello World!');
  
  Write text to a file and create directory if necessary.
  
  =head2 write_rel_file
  
    $command = $command->write_rel_file('foo/bar.txt', 'Hello World!');
  
  Portably write text to a file relative to the current working directory and
  create directory if necessary.
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<http://mojolicious.org>.
  
  =cut
MOJOLICIOUS_COMMAND

$fatpacked{"Mojolicious/Command/cgi.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJOLICIOUS_COMMAND_CGI';
  package Mojolicious::Command::cgi;
  use Mojo::Base 'Mojolicious::Command';
  
  use Mojo::Server::CGI;
  use Mojo::Util 'getopt';
  
  has description => 'Start application with CGI';
  has usage => sub { shift->extract_usage };
  
  sub run {
    my ($self, @args) = @_;
    getopt \@args, nph => \(my $nph = 0);
    Mojo::Server::CGI->new(app => $self->app, nph => $nph)->run;
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojolicious::Command::cgi - CGI command
  
  =head1 SYNOPSIS
  
    Usage: APPLICATION cgi [OPTIONS]
  
      ./myapp.pl cgi
  
    Options:
      -h, --help          Show this summary of available options
          --home <path>   Path to home directory of your application, defaults to
                          the value of MOJO_HOME or auto-detection
      -m, --mode <name>   Operating mode for your application, defaults to the
                          value of MOJO_MODE/PLACK_ENV or "development"
          --nph           Enable non-parsed-header mode
  
  =head1 DESCRIPTION
  
  L<Mojolicious::Command::cgi> starts applications with the L<Mojo::Server::CGI>
  backend.
  
  This is a core command, that means it is always enabled and its code a good
  example for learning to build new commands, you're welcome to fork it.
  
  See L<Mojolicious::Commands/"COMMANDS"> for a list of commands that are
  available by default.
  
  =head1 ATTRIBUTES
  
  L<Mojolicious::Command::cgi> inherits all attributes from
  L<Mojolicious::Command> and implements the following new ones.
  
  =head2 description
  
    my $description = $cgi->description;
    $cgi            = $cgi->description('Foo');
  
  Short description of this command, used for the command list.
  
  =head2 usage
  
    my $usage = $cgi->usage;
    $cgi      = $cgi->usage('Foo');
  
  Usage information for this command, used for the help screen.
  
  =head1 METHODS
  
  L<Mojolicious::Command::cgi> inherits all methods from L<Mojolicious::Command>
  and implements the following new ones.
  
  =head2 run
  
    $cgi->run(@ARGV);
  
  Run this command.
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<http://mojolicious.org>.
  
  =cut
MOJOLICIOUS_COMMAND_CGI

$fatpacked{"Mojolicious/Command/cpanify.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJOLICIOUS_COMMAND_CPANIFY';
  package Mojolicious::Command::cpanify;
  use Mojo::Base 'Mojolicious::Command';
  
  use Mojo::File 'path';
  use Mojo::Util 'getopt';
  
  has description => 'Upload distribution to CPAN';
  has usage => sub { shift->extract_usage };
  
  sub run {
    my ($self, @args) = @_;
  
    getopt \@args,
      'p|password=s' => \(my $password = ''),
      'u|user=s'     => \(my $user     = '');
    die $self->usage unless my $file = shift @args;
  
    my $tx = $self->app->ua->tap(sub { $_->proxy->detect })->post(
      "https://$user:$password\@pause.perl.org/pause/authenquery" => form => {
        HIDDENNAME                        => $user,
        CAN_MULTIPART                     => 1,
        pause99_add_uri_upload            => path($file)->basename,
        SUBMIT_pause99_add_uri_httpupload => ' Upload this file from my disk ',
        pause99_add_uri_uri               => '',
        pause99_add_uri_httpupload        => {file => $file},
      }
    );
  
    unless ($tx->success) {
      my $code = $tx->res->code // 0;
      my $msg = $tx->error->{message};
      if    ($code == 401) { $msg = 'Wrong username or password.' }
      elsif ($code == 409) { $msg = 'File already exists on CPAN.' }
      die qq{Problem uploading file "$file": $msg\n};
    }
  
    say 'Upload successful!';
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojolicious::Command::cpanify - CPAN-ify command
  
  =head1 SYNOPSIS
  
    Usage: APPLICATION cpanify [OPTIONS] [FILE]
  
      mojo cpanify -u sri -p secr3t Mojolicious-Plugin-MyPlugin-0.01.tar.gz
  
    Options:
      -h, --help                  Show this summary of available options
      -p, --password <password>   PAUSE password
      -u, --user <name>           PAUSE username
  
  =head1 DESCRIPTION
  
  L<Mojolicious::Command::cpanify> uploads files to CPAN.
  
  This is a core command, that means it is always enabled and its code a good
  example for learning to build new commands, you're welcome to fork it.
  
  See L<Mojolicious::Commands/"COMMANDS"> for a list of commands that are
  available by default.
  
  =head1 ATTRIBUTES
  
  L<Mojolicious::Command::cpanify> inherits all attributes from
  L<Mojolicious::Command> and implements the following new ones.
  
  =head2 description
  
    my $description = $cpanify->description;
    $cpanify        = $cpanify->description('Foo');
  
  Short description of this command, used for the command list.
  
  =head2 usage
  
    my $usage = $cpanify->usage;
    $cpanify  = $cpanify->usage('Foo');
  
  Usage information for this command, used for the help screen.
  
  =head1 METHODS
  
  L<Mojolicious::Command::cpanify> inherits all methods from
  L<Mojolicious::Command> and implements the following new ones.
  
  =head2 run
  
    $cpanify->run(@ARGV);
  
  Run this command.
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<http://mojolicious.org>.
  
  =cut
MOJOLICIOUS_COMMAND_CPANIFY

$fatpacked{"Mojolicious/Command/daemon.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJOLICIOUS_COMMAND_DAEMON';
  package Mojolicious::Command::daemon;
  use Mojo::Base 'Mojolicious::Command';
  
  use Mojo::Server::Daemon;
  use Mojo::Util 'getopt';
  
  has description => 'Start application with HTTP and WebSocket server';
  has usage => sub { shift->extract_usage };
  
  sub run {
    my ($self, @args) = @_;
  
    my $daemon = Mojo::Server::Daemon->new(app => $self->app);
    getopt \@args,
      'b|backlog=i'            => sub { $daemon->backlog($_[1]) },
      'c|clients=i'            => sub { $daemon->max_clients($_[1]) },
      'i|inactivity-timeout=i' => sub { $daemon->inactivity_timeout($_[1]) },
      'l|listen=s'   => \my @listen,
      'p|proxy'      => sub { $daemon->reverse_proxy(1) },
      'r|requests=i' => sub { $daemon->max_requests($_[1]) };
  
    $daemon->listen(\@listen) if @listen;
    $daemon->run;
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojolicious::Command::daemon - Daemon command
  
  =head1 SYNOPSIS
  
    Usage: APPLICATION daemon [OPTIONS]
  
      ./myapp.pl daemon
      ./myapp.pl daemon -m production -l http://*:8080
      ./myapp.pl daemon -l http://127.0.0.1:8080 -l https://[::]:8081
      ./myapp.pl daemon -l 'https://*:443?cert=./server.crt&key=./server.key'
      ./myapp.pl daemon -l http+unix://%2Ftmp%2Fmyapp.sock
  
    Options:
      -b, --backlog <size>                 Listen backlog size, defaults to
                                           SOMAXCONN
      -c, --clients <number>               Maximum number of concurrent
                                           connections, defaults to 1000
      -h, --help                           Show this summary of available options
          --home <path>                    Path to home directory of your
                                           application, defaults to the value of
                                           MOJO_HOME or auto-detection
      -i, --inactivity-timeout <seconds>   Inactivity timeout, defaults to the
                                           value of MOJO_INACTIVITY_TIMEOUT or 15
      -l, --listen <location>              One or more locations you want to
                                           listen on, defaults to the value of
                                           MOJO_LISTEN or "http://*:3000"
      -m, --mode <name>                    Operating mode for your application,
                                           defaults to the value of
                                           MOJO_MODE/PLACK_ENV or "development"
      -p, --proxy                          Activate reverse proxy support,
                                           defaults to the value of
                                           MOJO_REVERSE_PROXY
      -r, --requests <number>              Maximum number of requests per
                                           keep-alive connection, defaults to 100
  
  =head1 DESCRIPTION
  
  L<Mojolicious::Command::daemon> starts applications with the
  L<Mojo::Server::Daemon> backend.
  
  This is a core command, that means it is always enabled and its code a good
  example for learning to build new commands, you're welcome to fork it.
  
  See L<Mojolicious::Commands/"COMMANDS"> for a list of commands that are
  available by default.
  
  =head1 ATTRIBUTES
  
  L<Mojolicious::Command::daemon> inherits all attributes from
  L<Mojolicious::Command> and implements the following new ones.
  
  =head2 description
  
    my $description = $daemon->description;
    $daemon         = $daemon->description('Foo');
  
  Short description of this command, used for the command list.
  
  =head2 usage
  
    my $usage = $daemon->usage;
    $daemon   = $daemon->usage('Foo');
  
  Usage information for this command, used for the help screen.
  
  =head1 METHODS
  
  L<Mojolicious::Command::daemon> inherits all methods from
  L<Mojolicious::Command> and implements the following new ones.
  
  =head2 run
  
    $daemon->run(@ARGV);
  
  Run this command.
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<http://mojolicious.org>.
  
  =cut
MOJOLICIOUS_COMMAND_DAEMON

$fatpacked{"Mojolicious/Command/eval.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJOLICIOUS_COMMAND_EVAL';
  package Mojolicious::Command::eval;
  use Mojo::Base 'Mojolicious::Command';
  
  use Mojo::Util 'getopt';
  
  has description => 'Run code against application';
  has usage => sub { shift->extract_usage };
  
  sub run {
    my ($self, @args) = @_;
  
    getopt \@args, 'v|verbose' => \my $v1, 'V' => \my $v2;
    my $code = shift @args || '';
  
    # Run code against application
    my $app = $self->app;
    no warnings;
    my $result = eval "package main; sub app; local *app = sub { \$app }; $code";
    return $@ ? die $@ : $result unless defined $result && ($v1 || $v2);
    $v2 ? print($app->dumper($result)) : say $result;
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojolicious::Command::eval - Eval command
  
  =head1 SYNOPSIS
  
    Usage: APPLICATION eval [OPTIONS] CODE
  
      ./myapp.pl eval 'say app->ua->get("/")->result->body'
      ./myapp.pl eval 'say for sort keys %{app->renderer->helpers}'
      ./myapp.pl eval -v 'app->home'
      ./myapp.pl eval -V 'app->renderer->paths'
  
    Options:
      -h, --help          Show this summary of available options
          --home <path>   Path to home directory of your application, defaults to
                          the value of MOJO_HOME or auto-detection
      -m, --mode <name>   Operating mode for your application, defaults to the
                          value of MOJO_MODE/PLACK_ENV or "development"
      -v, --verbose       Print return value to STDOUT
      -V                  Print returned data structure to STDOUT
  
  =head1 DESCRIPTION
  
  L<Mojolicious::Command::eval> runs code against applications.
  
  This is a core command, that means it is always enabled and its code a good
  example for learning to build new commands, you're welcome to fork it.
  
  See L<Mojolicious::Commands/"COMMANDS"> for a list of commands that are
  available by default.
  
  =head1 ATTRIBUTES
  
  L<Mojolicious::Command::eval> inherits all attributes from
  L<Mojolicious::Command> and implements the following new ones.
  
  =head2 description
  
    my $description = $eval->description;
    $eval           = $eval->description('Foo');
  
  Short description of this command, used for the command list.
  
  =head2 usage
  
    my $usage = $eval->usage;
    $eval     = $eval->usage('Foo');
  
  Usage information for this command, used for the help screen.
  
  =head1 METHODS
  
  L<Mojolicious::Command::eval> inherits all methods from L<Mojolicious::Command>
  and implements the following new ones.
  
  =head2 run
  
    $eval->run(@ARGV);
  
  Run this command.
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<http://mojolicious.org>.
  
  =cut
MOJOLICIOUS_COMMAND_EVAL

$fatpacked{"Mojolicious/Command/generate.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJOLICIOUS_COMMAND_GENERATE';
  package Mojolicious::Command::generate;
  use Mojo::Base 'Mojolicious::Commands';
  
  has description => 'Generate files and directories from templates';
  has hint        => <<EOF;
  
  See 'APPLICATION generate help GENERATOR' for more information on a specific
  generator.
  EOF
  has message    => sub { shift->extract_usage . "\nGenerators:\n" };
  has namespaces => sub { ['Mojolicious::Command::generate'] };
  
  sub help { shift->run(@_) }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojolicious::Command::generate - Generator command
  
  =head1 SYNOPSIS
  
    Usage: APPLICATION generate GENERATOR [OPTIONS]
  
      mojo generate app
      mojo generate lite_app
  
  =head1 DESCRIPTION
  
  L<Mojolicious::Command::generate> lists available generators.
  
  This is a core command, that means it is always enabled and its code a good
  example for learning to build new commands, you're welcome to fork it.
  
  See L<Mojolicious::Commands/"COMMANDS"> for a list of commands that are
  available by default.
  
  =head1 ATTRIBUTES
  
  L<Mojolicious::Command::generate> inherits all attributes from
  L<Mojolicious::Commands> and implements the following new ones.
  
  =head2 description
  
    my $description = $generator->description;
    $generator      = $generator->description('Foo');
  
  Short description of this command, used for the command list.
  
  =head2 hint
  
    my $hint   = $generator->hint;
    $generator = $generator->hint('Foo');
  
  Short hint shown after listing available generator commands.
  
  =head2 message
  
    my $msg    = $generator->message;
    $generator = $generator->message('Bar');
  
  Short usage message shown before listing available generator commands.
  
  =head2 namespaces
  
    my $namespaces = $generator->namespaces;
    $generator     = $generator->namespaces(['MyApp::Command::generate']);
  
  Namespaces to search for available generator commands, defaults to
  L<Mojolicious::Command::generate>.
  
  =head1 METHODS
  
  L<Mojolicious::Command::generate> inherits all methods from
  L<Mojolicious::Commands> and implements the following new ones.
  
  =head2 help
  
    $generator->help('app');
  
  Print usage information for generator command.
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<http://mojolicious.org>.
  
  =cut
MOJOLICIOUS_COMMAND_GENERATE

$fatpacked{"Mojolicious/Command/generate/app.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJOLICIOUS_COMMAND_GENERATE_APP';
  package Mojolicious::Command::generate::app;
  use Mojo::Base 'Mojolicious::Command';
  
  use Mojo::Util qw(class_to_file class_to_path);
  
  has description => 'Generate Mojolicious application directory structure';
  has usage => sub { shift->extract_usage };
  
  sub run {
    my ($self, $class) = @_;
    $class ||= 'MyApp';
  
    # Prevent bad applications
    die <<EOF unless $class =~ /^[A-Z](?:\w|::)+$/;
  Your application name has to be a well formed (CamelCase) Perl module name
  like "MyApp".
  EOF
  
    # Script
    my $name = class_to_file $class;
    $self->render_to_rel_file('mojo', "$name/script/$name", $class);
    $self->chmod_rel_file("$name/script/$name", 0744);
  
    # Application class
    my $app = class_to_path $class;
    $self->render_to_rel_file('appclass', "$name/lib/$app", $class);
  
    # Config file
    $self->render_to_rel_file('config', "$name/$name.conf");
  
    # Controller
    my $controller = "${class}::Controller::Example";
    my $path       = class_to_path $controller;
    $self->render_to_rel_file('controller', "$name/lib/$path", $controller);
  
    # Test
    $self->render_to_rel_file('test', "$name/t/basic.t", $class);
  
    # Static file
    $self->render_to_rel_file('static', "$name/public/index.html");
  
    # Templates
    $self->render_to_rel_file('layout',
      "$name/templates/layouts/default.html.ep");
    $self->render_to_rel_file('welcome',
      "$name/templates/example/welcome.html.ep");
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojolicious::Command::generate::app - App generator command
  
  =head1 SYNOPSIS
  
    Usage: APPLICATION generate app [OPTIONS] [NAME]
  
      mojo generate app
      mojo generate app TestApp
  
    Options:
      -h, --help   Show this summary of available options
  
  =head1 DESCRIPTION
  
  L<Mojolicious::Command::generate::app> generates application directory
  structures for fully functional L<Mojolicious> applications.
  
  This is a core command, that means it is always enabled and its code a good
  example for learning to build new commands, you're welcome to fork it.
  
  See L<Mojolicious::Commands/"COMMANDS"> for a list of commands that are
  available by default.
  
  =head1 ATTRIBUTES
  
  L<Mojolicious::Command::generate::app> inherits all attributes from
  L<Mojolicious::Command> and implements the following new ones.
  
  =head2 description
  
    my $description = $app->description;
    $app            = $app->description('Foo');
  
  Short description of this command, used for the command list.
  
  =head2 usage
  
    my $usage = $app->usage;
    $app      = $app->usage('Foo');
  
  Usage information for this command, used for the help screen.
  
  =head1 METHODS
  
  L<Mojolicious::Command::generate::app> inherits all methods from
  L<Mojolicious::Command> and implements the following new ones.
  
  =head2 run
  
    $app->run(@ARGV);
  
  Run this command.
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<http://mojolicious.org>.
  
  =cut
  
  __DATA__
  
  @@ mojo
  % my $class = shift;
  #!/usr/bin/env perl
  
  use strict;
  use warnings;
  
  use FindBin;
  BEGIN { unshift @INC, "$FindBin::Bin/../lib" }
  use Mojolicious::Commands;
  
  # Start command line interface for application
  Mojolicious::Commands->start_app('<%= $class %>');
  
  @@ appclass
  % my $class = shift;
  package <%= $class %>;
  use Mojo::Base 'Mojolicious';
  
  # This method will run once at server start
  sub startup {
    my $self = shift;
  
    # Load configuration from hash returned by "my_app.conf"
    my $config = $self->plugin('Config');
  
    # Documentation browser under "/perldoc"
    $self->plugin('PODRenderer') if $config->{perldoc};
  
    # Router
    my $r = $self->routes;
  
    # Normal route to controller
    $r->get('/')->to('example#welcome');
  }
  
  1;
  
  @@ controller
  % my $class = shift;
  package <%= $class %>;
  use Mojo::Base 'Mojolicious::Controller';
  
  # This action will render a template
  sub welcome {
    my $self = shift;
  
    # Render template "example/welcome.html.ep" with message
    $self->render(msg => 'Welcome to the Mojolicious real-time web framework!');
  }
  
  1;
  
  @@ static
  <!DOCTYPE html>
  <html>
    <head>
      <title>Welcome to the Mojolicious real-time web framework!</title>
    </head>
    <body>
      <h2>Welcome to the Mojolicious real-time web framework!</h2>
      This is the static document "public/index.html",
      <a href="/">click here</a> to get back to the start.
    </body>
  </html>
  
  @@ test
  % my $class = shift;
  use Mojo::Base -strict;
  
  use Test::More;
  use Test::Mojo;
  
  my $t = Test::Mojo->new('<%= $class %>');
  $t->get_ok('/')->status_is(200)->content_like(qr/Mojolicious/i);
  
  done_testing();
  
  @@ layout
  <!DOCTYPE html>
  <html>
    <head><title><%%= title %></title></head>
    <body><%%= content %></body>
  </html>
  
  @@ welcome
  %% layout 'default';
  %% title 'Welcome';
  <h2><%%= $msg %></h2>
  <p>
    This page was generated from the template "templates/example/welcome.html.ep"
    and the layout "templates/layouts/default.html.ep",
    <%%= link_to 'click here' => url_for %> to reload the page or
    <%%= link_to 'here' => '/index.html' %> to move forward to a static page.
    %% if (config 'perldoc') {
      To learn more, you can also browse through the documentation
      <%%= link_to 'here' => '/perldoc' %>.
    %% }
  </p>
  
  @@ config
  % use Mojo::Util qw(sha1_sum steady_time);
  {
    perldoc => 1,
    secrets => ['<%= sha1_sum $$ . steady_time . rand  %>']
  }
MOJOLICIOUS_COMMAND_GENERATE_APP

$fatpacked{"Mojolicious/Command/generate/lite_app.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJOLICIOUS_COMMAND_GENERATE_LITE_APP';
  package Mojolicious::Command::generate::lite_app;
  use Mojo::Base 'Mojolicious::Command';
  
  has description => 'Generate Mojolicious::Lite application';
  has usage => sub { shift->extract_usage };
  
  sub run {
    my ($self, $name) = @_;
    $name ||= 'myapp.pl';
    $self->render_to_rel_file('liteapp', $name);
    $self->chmod_rel_file($name, 0744);
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojolicious::Command::generate::lite_app - Lite app generator command
  
  =head1 SYNOPSIS
  
    Usage: APPLICATION generate lite_app [OPTIONS] [NAME]
  
      mojo generate lite_app
      mojo generate lite_app foo.pl
  
    Options:
      -h, --help   Show this summary of available options
  
  =head1 DESCRIPTION
  
  L<Mojolicious::Command::generate::lite_app> generate fully functional
  L<Mojolicious::Lite> applications.
  
  This is a core command, that means it is always enabled and its code a good
  example for learning to build new commands, you're welcome to fork it.
  
  See L<Mojolicious::Commands/"COMMANDS"> for a list of commands that are
  available by default.
  
  =head1 ATTRIBUTES
  
  L<Mojolicious::Command::generate::lite_app> inherits all attributes from
  L<Mojolicious::Command> and implements the following new ones.
  
  =head2 description
  
    my $description = $app->description;
    $app            = $app->description('Foo');
  
  Short description of this command, used for the command list.
  
  =head2 usage
  
    my $usage = $app->usage;
    $app      = $app->usage('Foo');
  
  Usage information for this command, used for the help screen.
  
  =head1 METHODS
  
  L<Mojolicious::Command::generate::lite_app> inherits all methods from
  L<Mojolicious::Command> and implements the following new ones.
  
  =head2 run
  
    $app->run(@ARGV);
  
  Run this command.
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<http://mojolicious.org>.
  
  =cut
  
  __DATA__
  
  @@ liteapp
  #!/usr/bin/env perl
  use Mojolicious::Lite;
  
  # Documentation browser under "/perldoc"
  plugin 'PODRenderer';
  
  get '/' => sub {
    my $c = shift;
    $c->render(template => 'index');
  };
  
  app->start;
  <% %>__DATA__
  
  <% %>@@ index.html.ep
  %% layout 'default';
  %% title 'Welcome';
  <h1>Welcome to the Mojolicious real-time web framework!</h1>
  To learn more, you can browse through the documentation
  <%%= link_to 'here' => '/perldoc' %>.
  
  <% %>@@ layouts/default.html.ep
  <!DOCTYPE html>
  <html>
    <head><title><%%= title %></title></head>
    <body><%%= content %></body>
  </html>
MOJOLICIOUS_COMMAND_GENERATE_LITE_APP

$fatpacked{"Mojolicious/Command/generate/makefile.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJOLICIOUS_COMMAND_GENERATE_MAKEFILE';
  package Mojolicious::Command::generate::makefile;
  use Mojo::Base 'Mojolicious::Command';
  
  use Mojolicious;
  
  has description => 'Generate "Makefile.PL"';
  has usage => sub { shift->extract_usage };
  
  sub run { shift->render_to_rel_file('makefile', 'Makefile.PL') }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojolicious::Command::generate::makefile - Makefile generator command
  
  =head1 SYNOPSIS
  
    Usage: APPLICATION generate makefile [OPTIONS]
  
      mojo generate makefile
  
    Options:
      -h, --help   Show this summary of available options
  
  =head1 DESCRIPTION
  
  L<Mojolicious::Command::generate::makefile> generates C<Makefile.PL> files for
  applications.
  
  This is a core command, that means it is always enabled and its code a good
  example for learning to build new commands, you're welcome to fork it.
  
  See L<Mojolicious::Commands/"COMMANDS"> for a list of commands that are
  available by default.
  
  =head1 ATTRIBUTES
  
  L<Mojolicious::Command::generate::makefile> inherits all attributes from
  L<Mojolicious::Command> and implements the following new ones.
  
  =head2 description
  
    my $description = $makefile->description;
    $makefile       = $makefile->description('Foo');
  
  Short description of this command, used for the command list.
  
  =head2 usage
  
    my $usage = $makefile->usage;
    $makefile = $makefile->usage('Foo');
  
  Usage information for this command, used for the help screen.
  
  =head1 METHODS
  
  L<Mojolicious::Command::generate::makefile> inherits all methods from
  L<Mojolicious::Command> and implements the following new ones.
  
  =head2 run
  
    $makefile->run(@ARGV);
  
  Run this command.
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<http://mojolicious.org>.
  
  =cut
  
  __DATA__
  
  @@ makefile
  use strict;
  use warnings;
  
  use ExtUtils::MakeMaker;
  
  WriteMakefile(
    VERSION   => '0.01',
    PREREQ_PM => {'Mojolicious' => '<%= $Mojolicious::VERSION %>'},
    test      => {TESTS => 't/*.t'}
  );
MOJOLICIOUS_COMMAND_GENERATE_MAKEFILE

$fatpacked{"Mojolicious/Command/generate/plugin.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJOLICIOUS_COMMAND_GENERATE_PLUGIN';
  package Mojolicious::Command::generate::plugin;
  use Mojo::Base 'Mojolicious::Command';
  
  use Mojo::Util qw(camelize class_to_path);
  use Mojolicious;
  
  has description => 'Generate Mojolicious plugin directory structure';
  has usage => sub { shift->extract_usage };
  
  sub run {
    my ($self, $name) = @_;
    $name ||= 'MyPlugin';
  
    # Class
    my $class = $name =~ /^[a-z]/ ? camelize $name : $name;
    $class = "Mojolicious::Plugin::$class";
    my $app = class_to_path $class;
    my $dir = join '-', split('::', $class);
    $self->render_to_rel_file('class', "$dir/lib/$app", $class, $name);
  
    # Test
    $self->render_to_rel_file('test', "$dir/t/basic.t", $name);
  
    # Makefile
    $self->render_to_rel_file('makefile', "$dir/Makefile.PL", $class, $app);
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojolicious::Command::generate::plugin - Plugin generator command
  
  =head1 SYNOPSIS
  
    Usage: APPLICATION generate plugin [OPTIONS] [NAME]
  
      mojo generate plugin
      mojo generate plugin TestPlugin
  
    Options:
      -h, --help   Show this summary of available options
  
  =head1 DESCRIPTION
  
  L<Mojolicious::Command::generate::plugin> generates directory structures for
  fully functional L<Mojolicious> plugins.
  
  This is a core command, that means it is always enabled and its code a good
  example for learning to build new commands, you're welcome to fork it.
  
  See L<Mojolicious::Commands/"COMMANDS"> for a list of commands that are
  available by default.
  
  =head1 ATTRIBUTES
  
  L<Mojolicious::Command::generate::plugin> inherits all attributes from
  L<Mojolicious::Command> and implements the following new ones.
  
  =head2 description
  
    my $description = $plugin->description;
    $plugin         = $plugin->description('Foo');
  
  Short description of this command, used for the command list.
  
  =head2 usage
  
    my $usage = $plugin->usage;
    $plugin   = $plugin->usage('Foo');
  
  Usage information for this command, used for the help screen.
  
  =head1 METHODS
  
  L<Mojolicious::Command::generate::plugin> inherits all methods from
  L<Mojolicious::Command> and implements the following new ones.
  
  =head2 run
  
    $plugin->run(@ARGV);
  
  Run this command.
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<http://mojolicious.org>.
  
  =cut
  
  __DATA__
  
  @@ class
  % my ($class, $name) = @_;
  package <%= $class %>;
  use Mojo::Base 'Mojolicious::Plugin';
  
  our $VERSION = '0.01';
  
  sub register {
    my ($self, $app) = @_;
  }
  
  1;
  <% %>__END__
  
  <% %>=encoding utf8
  
  <% %>=head1 NAME
  
  <%= $class %> - Mojolicious Plugin
  
  <% %>=head1 SYNOPSIS
  
    # Mojolicious
    $self->plugin('<%= $name %>');
  
    # Mojolicious::Lite
    plugin '<%= $name %>';
  
  <% %>=head1 DESCRIPTION
  
  L<<%= $class %>> is a L<Mojolicious> plugin.
  
  <% %>=head1 METHODS
  
  L<<%= $class %>> inherits all methods from
  L<Mojolicious::Plugin> and implements the following new ones.
  
  <% %>=head2 register
  
    $plugin->register(Mojolicious->new);
  
  Register plugin in L<Mojolicious> application.
  
  <% %>=head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<http://mojolicious.org>.
  
  <% %>=cut
  
  @@ test
  % my $name = shift;
  use Mojo::Base -strict;
  
  use Test::More;
  use Mojolicious::Lite;
  use Test::Mojo;
  
  plugin '<%= $name %>';
  
  get '/' => sub {
    my $c = shift;
    $c->render(text => 'Hello Mojo!');
  };
  
  my $t = Test::Mojo->new;
  $t->get_ok('/')->status_is(200)->content_is('Hello Mojo!');
  
  done_testing();
  
  @@ makefile
  % my ($class, $path) = @_;
  use strict;
  use warnings;
  
  use ExtUtils::MakeMaker;
  
  WriteMakefile(
    NAME         => '<%= $class %>',
    VERSION_FROM => 'lib/<%= $path %>',
    AUTHOR       => 'A Good Programmer <nospam@cpan.org>',
    PREREQ_PM    => {'Mojolicious' => '<%= $Mojolicious::VERSION %>'},
    test         => {TESTS => 't/*.t'}
  );
MOJOLICIOUS_COMMAND_GENERATE_PLUGIN

$fatpacked{"Mojolicious/Command/get.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJOLICIOUS_COMMAND_GET';
  package Mojolicious::Command::get;
  use Mojo::Base 'Mojolicious::Command';
  
  use Mojo::DOM;
  use Mojo::IOLoop;
  use Mojo::JSON qw(encode_json j);
  use Mojo::JSON::Pointer;
  use Mojo::UserAgent;
  use Mojo::Util qw(decode encode getopt);
  use Scalar::Util 'weaken';
  
  has description => 'Perform HTTP request';
  has usage => sub { shift->extract_usage };
  
  sub run {
    my ($self, @args) = @_;
  
    my $ua = Mojo::UserAgent->new(ioloop => Mojo::IOLoop->singleton);
    getopt \@args,
      'C|charset=s'            => \my $charset,
      'c|content=s'            => \(my $content = ''),
      'H|header=s'             => \my @headers,
      'i|inactivity-timeout=i' => sub { $ua->inactivity_timeout($_[1]) },
      'M|method=s'             => \(my $method = 'GET'),
      'o|connect-timeout=i'    => sub { $ua->connect_timeout($_[1]) },
      'r|redirect'             => \my $redirect,
      'S|response-size=i'      => sub { $ua->max_response_size($_[1]) },
      'v|verbose'              => \my $verbose;
  
    @args = map { decode 'UTF-8', $_ } @args;
    die $self->usage unless my $url = shift @args;
    my $selector = shift @args;
  
    # Parse header pairs
    my %headers = map { /^\s*([^:]+)\s*:\s*(.*+)$/ ? ($1, $2) : () } @headers;
  
    # Detect proxy for absolute URLs
    $url !~ m!^/! ? $ua->proxy->detect : $ua->server->app($self->app);
    $ua->max_redirects(10) if $redirect;
  
    my $buffer = '';
    $ua->on(
      start => sub {
        my ($ua, $tx) = @_;
  
        # Verbose
        weaken $tx;
        $tx->res->content->on(
          body => sub { warn _header($tx->req), _header($tx->res) })
          if $verbose;
  
        # Stream content (ignore redirects)
        $tx->res->content->unsubscribe('read')->on(
          read => sub {
            return if $redirect && $tx->res->is_redirect;
            defined $selector ? ($buffer .= pop) : print pop;
          }
        );
      }
    );
  
    # Switch to verbose for HEAD requests
    $verbose = 1 if $method eq 'HEAD';
    STDOUT->autoflush(1);
    my $tx = $ua->start($ua->build_tx($method, $url, \%headers, $content));
    my $res = $tx->result;
  
    # JSON Pointer
    return unless defined $selector;
    return _json($buffer, $selector) if !length $selector || $selector =~ m!^/!;
  
    # Selector
    $charset //= $res->content->charset || $res->default_charset;
    _select($buffer, $selector, $charset, @args);
  }
  
  sub _header { $_[0]->build_start_line, $_[0]->headers->to_string, "\n\n" }
  
  sub _json {
    return unless my $data = j(shift);
    return unless defined($data = Mojo::JSON::Pointer->new($data)->get(shift));
    return _say($data) unless ref $data eq 'HASH' || ref $data eq 'ARRAY';
    say encode_json($data);
  }
  
  sub _say { length && say encode('UTF-8', $_) for @_ }
  
  sub _select {
    my ($buffer, $selector, $charset, @args) = @_;
  
    # Keep a strong reference to the root
    $buffer = decode($charset, $buffer) // $buffer if $charset;
    my $dom     = Mojo::DOM->new($buffer);
    my $results = $dom->find($selector);
  
    while (defined(my $command = shift @args)) {
  
      # Number
      ($results = $results->slice($command)) and next if $command =~ /^\d+$/;
  
      # Text
      return _say($results->map('text')->each) if $command eq 'text';
  
      # All text
      return _say($results->map('all_text')->each) if $command eq 'all';
  
      # Attribute
      return _say($results->map(attr => $args[0] // '')->each)
        if $command eq 'attr';
  
      # Unknown
      die qq{Unknown command "$command".\n};
    }
  
    _say($results->each);
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojolicious::Command::get - Get command
  
  =head1 SYNOPSIS
  
    Usage: APPLICATION get [OPTIONS] URL [SELECTOR|JSON-POINTER] [COMMANDS]
  
      ./myapp.pl get /
      ./myapp.pl get -H 'Accept: text/html' /hello.html 'head > title' text
      ./myapp.pl get //sri:secr3t@/secrets.json /1/content
      mojo get mojolicious.org
      mojo get -v -r -o 25 -i 50 google.com
      mojo get -v -H 'Host: mojolicious.org' -H 'Accept: */*' mojolicious.org
      mojo get -M POST -H 'Content-Type: text/trololo' -c 'trololo' perl.org
      mojo get mojolicious.org 'head > title' text
      mojo get mojolicious.org .footer all
      mojo get mojolicious.org a attr href
      mojo get mojolicious.org '*' attr id
      mojo get mojolicious.org 'h1, h2, h3' 3 text
      mojo get https://api.metacpan.org/v0/author/SRI /name
      mojo get -H 'Host: example.com' http+unix://%2Ftmp%2Fmyapp.sock/index.html
  
    Options:
      -C, --charset <charset>              Charset of HTML/XML content, defaults
                                           to auto-detection
      -c, --content <content>              Content to send with request
      -H, --header <name:value>            Additional HTTP header
      -h, --help                           Show this summary of available options
          --home <path>                    Path to home directory of your
                                           application, defaults to the value of
                                           MOJO_HOME or auto-detection
      -i, --inactivity-timeout <seconds>   Inactivity timeout, defaults to the
                                           value of MOJO_INACTIVITY_TIMEOUT or 20
      -M, --method <method>                HTTP method to use, defaults to "GET"
      -m, --mode <name>                    Operating mode for your application,
                                           defaults to the value of
                                           MOJO_MODE/PLACK_ENV or "development"
      -o, --connect-timeout <seconds>      Connect timeout, defaults to the value
                                           of MOJO_CONNECT_TIMEOUT or 10
      -r, --redirect                       Follow up to 10 redirects
      -S, --response-size <size>           Maximum response size in bytes,
                                           defaults to 2147483648 (2GB)
      -v, --verbose                        Print request and response headers to
                                           STDERR
  
  =head1 DESCRIPTION
  
  L<Mojolicious::Command::get> is a command line interface for
  L<Mojo::UserAgent>.
  
  This is a core command, that means it is always enabled and its code a good
  example for learning to build new commands, you're welcome to fork it.
  
  See L<Mojolicious::Commands/"COMMANDS"> for a list of commands that are
  available by default.
  
  =head1 ATTRIBUTES
  
  L<Mojolicious::Command::get> performs requests to remote hosts or local
  applications.
  
  =head2 description
  
    my $description = $get->description;
    $get            = $get->description('Foo');
  
  Short description of this command, used for the command list.
  
  =head2 usage
  
    my $usage = $get->usage;
    $get      = $get->usage('Foo');
  
  Usage information for this command, used for the help screen.
  
  =head1 METHODS
  
  L<Mojolicious::Command::get> inherits all methods from L<Mojolicious::Command>
  and implements the following new ones.
  
  =head2 run
  
    $get->run(@ARGV);
  
  Run this command.
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<http://mojolicious.org>.
  
  =cut
MOJOLICIOUS_COMMAND_GET

$fatpacked{"Mojolicious/Command/inflate.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJOLICIOUS_COMMAND_INFLATE';
  package Mojolicious::Command::inflate;
  use Mojo::Base 'Mojolicious::Command';
  
  use Mojo::Loader qw(data_section file_is_binary);
  use Mojo::Util 'encode';
  
  has description => 'Inflate embedded files to real files';
  has usage => sub { shift->extract_usage };
  
  sub run {
    my $self = shift;
  
    # Find all embedded files
    my %all;
    my $app = $self->app;
    for my $class (@{$app->renderer->classes}, @{$app->static->classes}) {
      for my $name (keys %{data_section $class}) {
        my $data = data_section $class, $name;
        $data = encode 'UTF-8', $data unless file_is_binary $class, $name;
        $all{$name} = $data;
      }
    }
  
    # Turn them into real files
    for my $name (grep {/\.\w+$/} keys %all) {
      my $prefix = $name =~ /\.\w+\.\w+$/ ? 'templates' : 'public';
      $self->write_file($self->rel_file("$prefix/$name"), $all{$name});
    }
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojolicious::Command::inflate - Inflate command
  
  =head1 SYNOPSIS
  
    Usage: APPLICATION inflate [OPTIONS]
  
      ./myapp.pl inflate
  
    Options:
      -h, --help          Show this summary of available options
          --home <path>   Path to home directory of your application, defaults to
                          the value of MOJO_HOME or auto-detection
      -m, --mode <name>   Operating mode for your application, defaults to the
                          value of MOJO_MODE/PLACK_ENV or "development"
  
  =head1 DESCRIPTION
  
  L<Mojolicious::Command::inflate> turns templates and static files embedded in
  the C<DATA> sections of your application into real files.
  
  This is a core command, that means it is always enabled and its code a good
  example for learning to build new commands, you're welcome to fork it.
  
  See L<Mojolicious::Commands/"COMMANDS"> for a list of commands that are
  available by default.
  
  =head1 ATTRIBUTES
  
  L<Mojolicious::Command::inflate> inherits all attributes from
  L<Mojolicious::Command> and implements the following new ones.
  
  =head2 description
  
    my $description = $inflate->description;
    $inflate        = $inflate->description('Foo');
  
  Short description of this command, used for the command list.
  
  =head2 usage
  
    my $usage = $inflate->usage;
    $inflate  = $inflate->usage('Foo');
  
  Usage information for this command, used for the help screen.
  
  =head1 METHODS
  
  L<Mojolicious::Command::inflate> inherits all methods from
  L<Mojolicious::Command> and implements the following new ones.
  
  =head2 run
  
    $inflate->run(@ARGV);
  
  Run this command.
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<http://mojolicious.org>.
  
  =cut
MOJOLICIOUS_COMMAND_INFLATE

$fatpacked{"Mojolicious/Command/prefork.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJOLICIOUS_COMMAND_PREFORK';
  package Mojolicious::Command::prefork;
  use Mojo::Base 'Mojolicious::Command';
  
  use Mojo::Server::Prefork;
  use Mojo::Util 'getopt';
  
  has description =>
    'Start application with pre-forking HTTP and WebSocket server';
  has usage => sub { shift->extract_usage };
  
  sub run {
    my ($self, @args) = @_;
  
    my $prefork = Mojo::Server::Prefork->new(app => $self->app);
    getopt \@args,
      'a|accepts=i'            => sub { $prefork->accepts($_[1]) },
      'b|backlog=i'            => sub { $prefork->backlog($_[1]) },
      'c|clients=i'            => sub { $prefork->max_clients($_[1]) },
      'G|graceful-timeout=i'   => sub { $prefork->graceful_timeout($_[1]) },
      'I|heartbeat-interval=i' => sub { $prefork->heartbeat_interval($_[1]) },
      'H|heartbeat-timeout=i'  => sub { $prefork->heartbeat_timeout($_[1]) },
      'i|inactivity-timeout=i' => sub { $prefork->inactivity_timeout($_[1]) },
      'l|listen=s'   => \my @listen,
      'P|pid-file=s' => sub { $prefork->pid_file($_[1]) },
      'p|proxy'      => sub { $prefork->reverse_proxy(1) },
      'r|requests=i' => sub { $prefork->max_requests($_[1]) },
      'w|workers=i'  => sub { $prefork->workers($_[1]) };
  
    $prefork->listen(\@listen) if @listen;
    $prefork->run;
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojolicious::Command::prefork - Pre-fork command
  
  =head1 SYNOPSIS
  
    Usage: APPLICATION prefork [OPTIONS]
  
      ./myapp.pl prefork
      ./myapp.pl prefork -m production -l http://*:8080
      ./myapp.pl prefork -l http://127.0.0.1:8080 -l https://[::]:8081
      ./myapp.pl prefork -l 'https://*:443?cert=./server.crt&key=./server.key'
      ./myapp.pl prefork -l http+unix://%2Ftmp%2Fmyapp.sock
  
    Options:
      -a, --accepts <number>               Number of connections for workers to
                                           accept, defaults to 10000
      -b, --backlog <size>                 Listen backlog size, defaults to
                                           SOMAXCONN
      -c, --clients <number>               Maximum number of concurrent
                                           connections, defaults to 1000
      -G, --graceful-timeout <seconds>     Graceful timeout, defaults to 20.
      -I, --heartbeat-interval <seconds>   Heartbeat interval, defaults to 5
      -H, --heartbeat-timeout <seconds>    Heartbeat timeout, defaults to 20
      -h, --help                           Show this summary of available options
          --home <path>                    Path to home directory of your
                                           application, defaults to the value of
                                           MOJO_HOME or auto-detection
      -i, --inactivity-timeout <seconds>   Inactivity timeout, defaults to the
                                           value of MOJO_INACTIVITY_TIMEOUT or 15
      -l, --listen <location>              One or more locations you want to
                                           listen on, defaults to the value of
                                           MOJO_LISTEN or "http://*:3000"
      -m, --mode <name>                    Operating mode for your application,
                                           defaults to the value of
                                           MOJO_MODE/PLACK_ENV or "development"
      -P, --pid-file <path>                Path to process id file, defaults to
                                           "prefork.pid" in a temporary diretory
      -p, --proxy                          Activate reverse proxy support,
                                           defaults to the value of
                                           MOJO_REVERSE_PROXY
      -r, --requests <number>              Maximum number of requests per
                                           keep-alive connection, defaults to 100
      -w, --workers <number>               Number of workers, defaults to 4
  
  =head1 DESCRIPTION
  
  L<Mojolicious::Command::prefork> starts applications with the
  L<Mojo::Server::Prefork> backend.
  
  This is a core command, that means it is always enabled and its code a good
  example for learning to build new commands, you're welcome to fork it.
  
  See L<Mojolicious::Commands/"COMMANDS"> for a list of commands that are
  available by default.
  
  =head1 ATTRIBUTES
  
  L<Mojolicious::Command::prefork> inherits all attributes from
  L<Mojolicious::Command> and implements the following new ones.
  
  =head2 description
  
    my $description = $prefork->description;
    $prefork        = $prefork->description('Foo');
  
  Short description of this command, used for the command list.
  
  =head2 usage
  
    my $usage = $prefork->usage;
    $prefork  = $prefork->usage('Foo');
  
  Usage information for this command, used for the help screen.
  
  =head1 METHODS
  
  L<Mojolicious::Command::prefork> inherits all methods from
  L<Mojolicious::Command> and implements the following new ones.
  
  =head2 run
  
    $prefork->run(@ARGV);
  
  Run this command.
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<http://mojolicious.org>.
  
  =cut
MOJOLICIOUS_COMMAND_PREFORK

$fatpacked{"Mojolicious/Command/psgi.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJOLICIOUS_COMMAND_PSGI';
  package Mojolicious::Command::psgi;
  use Mojo::Base 'Mojolicious::Command';
  
  use Mojo::Server::PSGI;
  
  has description => 'Start application with PSGI';
  has usage => sub { shift->extract_usage };
  
  sub run { Mojo::Server::PSGI->new(app => shift->app)->to_psgi_app }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojolicious::Command::psgi - PSGI command
  
  =head1 SYNOPSIS
  
    Usage: APPLICATION psgi [OPTIONS]
  
      ./myapp.pl psgi
  
    Options:
      -h, --help          Show this summary of available options
          --home <path>   Path to home directory of your application, defaults to
                          the value of MOJO_HOME or auto-detection
      -m, --mode <name>   Operating mode for your application, defaults to the
                          value of MOJO_MODE/PLACK_ENV or "development"
  
  =head1 DESCRIPTION
  
  L<Mojolicious::Command::psgi> starts applications with the L<Mojo::Server::PSGI>
  backend.
  
  This is a core command, that means it is always enabled and its code a good
  example for learning to build new commands, you're welcome to fork it.
  
  See L<Mojolicious::Commands/"COMMANDS"> for a list of commands that are
  available by default.
  
  =head1 ATTRIBUTES
  
  L<Mojolicious::Command::psgi> inherits all attributes from
  L<Mojolicious::Command> and implements the following new ones.
  
  =head2 description
  
    my $description = $psgi->description;
    $psgi           = $psgi->description('Foo');
  
  Short description of this command, used for the command list.
  
  =head2 usage
  
    my $usage = $psgi->usage;
    $psgi     = $psgi->usage('Foo');
  
  Usage information for this command, used for the help screen.
  
  =head1 METHODS
  
  L<Mojolicious::Command::psgi> inherits all methods from L<Mojolicious::Command>
  and implements the following new ones.
  
  =head2 run
  
    my $app = $psgi->run;
  
  Run this command.
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<http://mojolicious.org>.
  
  =cut
MOJOLICIOUS_COMMAND_PSGI

$fatpacked{"Mojolicious/Command/routes.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJOLICIOUS_COMMAND_ROUTES';
  package Mojolicious::Command::routes;
  use Mojo::Base 'Mojolicious::Command';
  
  use re 'regexp_pattern';
  use Mojo::Util qw(encode getopt tablify);
  
  has description => 'Show available routes';
  has usage => sub { shift->extract_usage };
  
  sub run {
    my ($self, @args) = @_;
  
    getopt \@args, 'v|verbose' => \my $verbose;
  
    my $rows = [];
    _walk($_, 0, $rows, $verbose) for @{$self->app->routes->children};
    print encode('UTF-8', tablify($rows));
  }
  
  sub _walk {
    my ($route, $depth, $rows, $verbose) = @_;
  
    # Pattern
    my $prefix = '';
    if (my $i = $depth * 2) { $prefix .= ' ' x $i . '+' }
    push @$rows, my $row = [$prefix . ($route->pattern->unparsed || '/')];
  
    # Flags
    my @flags;
    push @flags, @{$route->over || []} ? 'C' : '.';
    push @flags, (my $partial = $route->partial) ? 'D' : '.';
    push @flags, $route->inline       ? 'U' : '.';
    push @flags, $route->is_websocket ? 'W' : '.';
    push @$row, join('', @flags) if $verbose;
  
    # Methods
    my $via = $route->via;
    push @$row, !$via ? '*' : uc join ',', @$via;
  
    # Name
    my $name = $route->name;
    push @$row, $route->has_custom_name ? qq{"$name"} : $name;
  
    # Regex (verbose)
    my $pattern = $route->pattern;
    $pattern->match('/', $route->is_endpoint && !$partial);
    push @$row, (regexp_pattern $pattern->regex)[0] if $verbose;
  
    $depth++;
    _walk($_, $depth, $rows, $verbose) for @{$route->children};
    $depth--;
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojolicious::Command::routes - Routes command
  
  =head1 SYNOPSIS
  
    Usage: APPLICATION routes [OPTIONS]
  
      ./myapp.pl routes
      ./myapp.pl routes -v
  
    Options:
      -h, --help          Show this summary of available options
          --home <path>   Path to home directory of your application, defaults to
                          the value of MOJO_HOME or auto-detection
      -m, --mode <name>   Operating mode for your application, defaults to the
                          value of MOJO_MODE/PLACK_ENV or "development"
      -v, --verbose       Print additional details about routes, flags indicate
                          C=Conditions, D=Detour, U=Under and W=WebSocket
  
  =head1 DESCRIPTION
  
  L<Mojolicious::Command::routes> lists all your application routes.
  
  This is a core command, that means it is always enabled and its code a good
  example for learning to build new commands, you're welcome to fork it.
  
  See L<Mojolicious::Commands/"COMMANDS"> for a list of commands that are
  available by default.
  
  =head1 ATTRIBUTES
  
  L<Mojolicious::Command::routes> inherits all attributes from
  L<Mojolicious::Command> and implements the following new ones.
  
  =head2 description
  
    my $description = $routes->description;
    $routes         = $routes->description('Foo');
  
  Short description of this command, used for the command list.
  
  =head2 usage
  
    my $usage = $routes->usage;
    $routes   = $routes->usage('Foo');
  
  Usage information for this command, used for the help screen.
  
  =head1 METHODS
  
  L<Mojolicious::Command::routes> inherits all methods from
  L<Mojolicious::Command> and implements the following new ones.
  
  =head2 run
  
    $routes->run(@ARGV);
  
  Run this command.
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<http://mojolicious.org>.
  
  =cut
MOJOLICIOUS_COMMAND_ROUTES

$fatpacked{"Mojolicious/Command/test.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJOLICIOUS_COMMAND_TEST';
  package Mojolicious::Command::test;
  use Mojo::Base 'Mojolicious::Command';
  
  use Mojo::Util 'getopt';
  
  has description => 'Run tests';
  has usage => sub { shift->extract_usage };
  
  sub run {
    my ($self, @args) = @_;
  
    getopt \@args, 'v|verbose' => \$ENV{HARNESS_VERBOSE};
  
    if (!@args && (my $tests = $self->app->home->child('t'))) {
      die "Can't find test directory.\n" unless -d $tests;
      @args = $tests->list_tree->grep(qr/\.t$/)->map('to_string')->each;
      say qq{Running tests from "$tests".};
    }
  
    $ENV{HARNESS_OPTIONS} //= 'c';
    require Test::Harness;
    local $Test::Harness::switches = '';
    Test::Harness::runtests(sort @args);
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojolicious::Command::test - Test command
  
  =head1 SYNOPSIS
  
    Usage: APPLICATION test [OPTIONS] [TESTS]
  
      ./myapp.pl test
      ./myapp.pl test t/foo.t
      ./myapp.pl test -v t/foo/*.t
  
    Options:
      -h, --help      Show this summary of available options
      -v, --verbose   Print verbose debug information to STDERR
  
  =head1 DESCRIPTION
  
  L<Mojolicious::Command::test> runs application tests from the C<t> directory.
  
  This is a core command, that means it is always enabled and its code a good
  example for learning to build new commands, you're welcome to fork it.
  
  See L<Mojolicious::Commands/"COMMANDS"> for a list of commands that are
  available by default.
  
  =head1 ATTRIBUTES
  
  L<Mojolicious::Command::test> inherits all attributes from
  L<Mojolicious::Command> and implements the following new ones.
  
  =head2 description
  
    my $description = $test->description;
    $test           = $test->description('Foo');
  
  Short description of this command, used for the command list.
  
  =head2 usage
  
    my $usage = $test->usage;
    $test     = $test->usage('Foo');
  
  Usage information for this command, used for the help screen.
  
  =head1 METHODS
  
  L<Mojolicious::Command::test> inherits all methods from L<Mojolicious::Command>
  and implements the following new ones.
  
  =head2 run
  
    $test->run(@ARGV);
  
  Run this command.
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<http://mojolicious.org>.
  
  =cut
MOJOLICIOUS_COMMAND_TEST

$fatpacked{"Mojolicious/Command/version.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJOLICIOUS_COMMAND_VERSION';
  package Mojolicious::Command::version;
  use Mojo::Base 'Mojolicious::Command';
  
  use Mojo::IOLoop::Client;
  use Mojo::IOLoop::TLS;
  use Mojolicious;
  
  has description => 'Show versions of available modules';
  has usage => sub { shift->extract_usage };
  
  sub run {
    my $self = shift;
  
    my $ev = eval 'use Mojo::Reactor::EV; 1' ? $EV::VERSION : 'n/a';
    my $socks
      = Mojo::IOLoop::Client->can_socks ? $IO::Socket::Socks::VERSION : 'n/a';
    my $tls = Mojo::IOLoop::TLS->can_tls    ? $IO::Socket::SSL::VERSION  : 'n/a';
    my $nnr = Mojo::IOLoop::Client->can_nnr ? $Net::DNS::Native::VERSION : 'n/a';
  
    print <<EOF;
  CORE
    Perl        ($^V, $^O)
    Mojolicious ($Mojolicious::VERSION, $Mojolicious::CODENAME)
  
  OPTIONAL
    EV 4.0+                 ($ev)
    IO::Socket::Socks 0.64+ ($socks)
    IO::Socket::SSL 1.94+   ($tls)
    Net::DNS::Native 0.15+  ($nnr)
  
  EOF
  
    # Check latest version on CPAN
    my $latest = eval {
      $self->app->ua->max_redirects(10)->tap(sub { $_->proxy->detect })
        ->get('api.metacpan.org/v0/release/Mojolicious')->result->json->{version};
    } or return;
  
    my $msg = 'This version is up to date, have fun!';
    $msg = 'Thanks for testing a development release, you are awesome!'
      if $latest < $Mojolicious::VERSION;
    $msg = "You might want to update your Mojolicious to $latest!"
      if $latest > $Mojolicious::VERSION;
    say $msg;
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojolicious::Command::version - Version command
  
  =head1 SYNOPSIS
  
    Usage: APPLICATION version [OPTIONS]
  
      mojo version
  
    Options:
      -h, --help   Show this summary of available options
  
  =head1 DESCRIPTION
  
  L<Mojolicious::Command::version> shows version information for available core
  and optional modules.
  
  This is a core command, that means it is always enabled and its code a good
  example for learning to build new commands, you're welcome to fork it.
  
  See L<Mojolicious::Commands/"COMMANDS"> for a list of commands that are
  available by default.
  
  =head1 ATTRIBUTES
  
  L<Mojolicious::Command::version> inherits all attributes from
  L<Mojolicious::Command> and implements the following new ones.
  
  =head2 description
  
    my $description = $v->description;
    $v              = $v->description('Foo');
  
  Short description of this command, used for the command list.
  
  =head2 usage
  
    my $usage = $v->usage;
    $v        = $v->usage('Foo');
  
  Usage information for this command, used for the help screen.
  
  =head1 METHODS
  
  L<Mojolicious::Command::version> inherits all methods from
  L<Mojolicious::Command> and implements the following new ones.
  
  =head2 run
  
    $v->run(@ARGV);
  
  Run this command.
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<http://mojolicious.org>.
  
  =cut
MOJOLICIOUS_COMMAND_VERSION

$fatpacked{"Mojolicious/Commands.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJOLICIOUS_COMMANDS';
  package Mojolicious::Commands;
  use Mojo::Base 'Mojolicious::Command';
  
  use Mojo::Loader qw(find_modules find_packages load_class);
  use Mojo::Server;
  use Mojo::Util qw(getopt tablify);
  
  has hint => <<EOF;
  
  See 'APPLICATION help COMMAND' for more information on a specific command.
  EOF
  has message    => sub { shift->extract_usage . "\nCommands:\n" };
  has namespaces => sub { ['Mojolicious::Command'] };
  
  sub detect {
  
    # PSGI (Plack only for now)
    return 'psgi' if defined $ENV{PLACK_ENV};
  
    # CGI
    return 'cgi' if defined $ENV{PATH_INFO} || defined $ENV{GATEWAY_INTERFACE};
  
    # Nothing
    return undef;
  }
  
  sub run {
    my ($self, $name, @args) = @_;
  
    # Application loader
    return $self->app if defined $ENV{MOJO_APP_LOADER};
  
    # Try to detect environment
    if (!$ENV{MOJO_NO_DETECT} && (my $env = $self->detect)) { $name = $env }
  
    # Run command
    if ($name && $name =~ /^\w+$/ && ($name ne 'help' || $args[0])) {
  
      # Help
      $name = shift @args if my $help = $name eq 'help';
      $help = $ENV{MOJO_HELP} ||= $help;
  
      # Remove options shared by all commands before loading the command
      _args(\@args);
      my $module;
      $module = _command("${_}::$name", 1) and last for @{$self->namespaces};
  
      # Unknown command
      die qq{Unknown command "$name", maybe you need to install it?\n}
        unless $module;
  
      # Run command
      my $command = $module->new(app => $self->app);
      return $help ? $command->help(@args) : $command->run(@args);
    }
  
    # Hide list for tests
    return 1 if $ENV{HARNESS_ACTIVE};
  
    # Find all available commands
    my %all;
    for my $ns (@{$self->namespaces}) {
      $all{substr $_, length "${ns}::"} //= $_->new->description
        for grep { _command($_) } find_modules($ns), find_packages($ns);
    }
  
    my @rows = map { [" $_", $all{$_}] } sort keys %all;
    return print $self->message, tablify(\@rows), $self->hint;
  }
  
  sub start_app { shift; Mojo::Server->new->build_app(shift)->start(@_) }
  
  # Command line options for MOJO_HELP, MOJO_HOME and MOJO_MODE
  sub _args {
    getopt shift, ['pass_through'],
      'h|help'   => \$ENV{MOJO_HELP},
      'home=s'   => \$ENV{MOJO_HOME},
      'm|mode=s' => \$ENV{MOJO_MODE}
      unless __PACKAGE__->detect;
  }
  
  # Do not remove options from @ARGV
  BEGIN { _args([@ARGV]) }
  
  sub _command {
    my ($module, $fatal) = @_;
    return $module->isa('Mojolicious::Command') ? $module : undef
      unless my $e = load_class $module;
    $fatal && ref $e ? die $e : return undef;
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojolicious::Commands - Command line interface
  
  =head1 SYNOPSIS
  
    Usage: APPLICATION COMMAND [OPTIONS]
  
      mojo version
      mojo generate lite_app
      ./myapp.pl daemon -m production -l http://*:8080
      ./myapp.pl get /foo
      ./myapp.pl routes -v
  
    Tip: CGI and PSGI environments can be automatically detected very often and
         work without commands.
  
    Options (for all commands):
      -h, --help          Get more information on a specific command
          --home <path>   Path to home directory of your application, defaults to
                          the value of MOJO_HOME or auto-detection
      -m, --mode <name>   Operating mode for your application, defaults to the
                          value of MOJO_MODE/PLACK_ENV or "development"
  
  =head1 DESCRIPTION
  
  L<Mojolicious::Commands> is the interactive command line interface for the
  L<Mojolicious> framework. It will automatically detect available commands in
  the C<Mojolicious::Command> namespace.
  
  =head1 COMMANDS
  
  These commands are available by default.
  
  =head2 cgi
  
    $ ./myapp.pl cgi
  
  Use L<Mojolicious::Command::cgi> to start application with CGI backend, usually
  auto detected.
  
  =head2 cpanify
  
    $ mojo cpanify -u sri -p secr3t Mojolicious-Plugin-Fun-0.1.tar.gz
  
  Use L<Mojolicious::Command::cpanify> for uploading files to CPAN.
  
  =head2 daemon
  
    $ ./myapp.pl daemon
  
  Use L<Mojolicious::Command::daemon> to start application with standalone HTTP
  and WebSocket server.
  
  =head2 eval
  
    $ ./myapp.pl eval 'say app->home'
  
  Use L<Mojolicious::Command::eval> to run code against application.
  
  =head2 generate
  
    $ mojo generate
    $ mojo generate help
    $ ./myapp.pl generate help
  
  List available generator commands with short descriptions.
  
    $ mojo generate help <generator>
    $ ./myapp.pl generate help <generator>
  
  List available options for generator command with short descriptions.
  
  =head2 generate app
  
    $ mojo generate app <AppName>
  
  Use L<Mojolicious::Command::generate::app> to generate application directory
  structure for a fully functional L<Mojolicious> application.
  
  =head2 generate lite_app
  
    $ mojo generate lite_app
  
  Use L<Mojolicious::Command::generate::lite_app> to generate a fully functional
  L<Mojolicious::Lite> application.
  
  =head2 generate makefile
  
    $ mojo generate makefile
    $ ./myapp.pl generate makefile
  
  Use L<Mojolicious::Command::generate::makefile> to generate C<Makefile.PL> file
  for application.
  
  =head2 generate plugin
  
    $ mojo generate plugin <PluginName>
  
  Use L<Mojolicious::Command::generate::plugin> to generate directory structure
  for a fully functional L<Mojolicious> plugin.
  
  =head2 get
  
    $ mojo get http://mojolicious.org
    $ ./myapp.pl get /foo
  
  Use L<Mojolicious::Command::get> to perform requests to remote host or local
  application.
  
  =head2 help
  
    $ mojo
    $ mojo help
    $ ./myapp.pl help
  
  List available commands with short descriptions.
  
    $ mojo help <command>
    $ ./myapp.pl help <command>
  
  List available options for the command with short descriptions.
  
  =head2 inflate
  
    $ ./myapp.pl inflate
  
  Use L<Mojolicious::Command::inflate> to turn templates and static files
  embedded in the C<DATA> sections of your application into real files.
  
  =head2 prefork
  
    $ ./myapp.pl prefork
  
  Use L<Mojolicious::Command::prefork> to start application with standalone
  pre-forking HTTP and WebSocket server.
  
  =head2 psgi
  
    $ ./myapp.pl psgi
  
  Use L<Mojolicious::Command::psgi> to start application with PSGI backend,
  usually auto detected.
  
  =head2 routes
  
    $ ./myapp.pl routes
  
  Use L<Mojolicious::Command::routes> to list application routes.
  
  =head2 test
  
    $ ./myapp.pl test
    $ ./myapp.pl test t/fun.t
  
  Use L<Mojolicious::Command::test> to run application tests from the C<t>
  directory.
  
  =head2 version
  
    $ mojo version
    $ ./myapp.pl version
  
  Use L<Mojolicious::Command::version> to show version information for available
  core and optional modules, very useful for debugging.
  
  =head1 ATTRIBUTES
  
  L<Mojolicious::Commands> inherits all attributes from L<Mojolicious::Command>
  and implements the following new ones.
  
  =head2 hint
  
    my $hint  = $commands->hint;
    $commands = $commands->hint('Foo');
  
  Short hint shown after listing available commands.
  
  =head2 message
  
    my $msg   = $commands->message;
    $commands = $commands->message('Hello World!');
  
  Short usage message shown before listing available commands.
  
  =head2 namespaces
  
    my $namespaces = $commands->namespaces;
    $commands      = $commands->namespaces(['MyApp::Command']);
  
  Namespaces to load commands from, defaults to C<Mojolicious::Command>.
  
    # Add another namespace to load commands from
    push @{$commands->namespaces}, 'MyApp::Command';
  
  =head1 METHODS
  
  L<Mojolicious::Commands> inherits all methods from L<Mojolicious::Command> and
  implements the following new ones.
  
  =head2 detect
  
    my $env = $commands->detect;
  
  Try to detect environment, or return C<undef> if none could be detected.
  
  =head2 run
  
    $commands->run;
    $commands->run(@ARGV);
  
  Load and run commands. Automatic deployment environment detection can be
  disabled with the C<MOJO_NO_DETECT> environment variable.
  
  =head2 start_app
  
    Mojolicious::Commands->start_app('MyApp');
    Mojolicious::Commands->start_app(MyApp => @ARGV);
  
  Load application from class and start the command line interface for it. Note
  that the options C<-h>/C<--help>, C<--home> and C<-m>/C<--mode>, which are
  shared by all commands, will be parsed from C<@ARGV> during compile time.
  
    # Always start daemon for application
    Mojolicious::Commands->start_app('MyApp', 'daemon', '-l', 'http://*:8080');
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<http://mojolicious.org>.
  
  =cut
MOJOLICIOUS_COMMANDS

$fatpacked{"Mojolicious/Controller.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJOLICIOUS_CONTROLLER';
  package Mojolicious::Controller;
  use Mojo::Base -base;
  
  # No imports, for security reasons!
  use Carp ();
  use Mojo::ByteStream;
  use Mojo::URL;
  use Mojo::Util;
  use Mojolicious::Routes::Match;
  use Scalar::Util ();
  use Time::HiRes  ();
  
  has [qw(app tx)];
  has match =>
    sub { Mojolicious::Routes::Match->new(root => shift->app->routes) };
  
  # Reserved stash values
  my %RESERVED = map { $_ => 1 } (
    qw(action app cb controller data extends format handler inline json layout),
    qw(namespace path status template text variant)
  );
  
  sub AUTOLOAD {
    my $self = shift;
  
    my ($package, $method) = our $AUTOLOAD =~ /^(.+)::(.+)$/;
    Carp::croak "Undefined subroutine &${package}::$method called"
      unless Scalar::Util::blessed $self && $self->isa(__PACKAGE__);
  
    # Call helper with current controller
    Carp::croak qq{Can't locate object method "$method" via package "$package"}
      unless my $helper = $self->app->renderer->get_helper($method);
    return $self->$helper(@_);
  }
  
  sub continue { $_[0]->app->routes->continue($_[0]) }
  
  sub cookie {
    my ($self, $name) = (shift, shift);
  
    # Response cookie
    if (@_) {
  
      # Cookie too big
      my $cookie = {name => $name, value => shift, %{shift || {}}};
      $self->app->log->error(qq{Cookie "$name" is bigger than 4096 bytes})
        if length $cookie->{value} > 4096;
  
      $self->res->cookies($cookie);
      return $self;
    }
  
    # Request cookies
    return undef unless my $cookie = $self->req->cookie($name);
    return $cookie->value;
  }
  
  sub every_cookie {
    [map { $_->value } @{shift->req->every_cookie(shift)}];
  }
  
  sub every_param {
    my ($self, $name) = @_;
  
    # Captured unreserved values
    my $captures = $self->stash->{'mojo.captures'} ||= {};
    if (!$RESERVED{$name} && exists $captures->{$name}) {
      my $value = $captures->{$name};
      return ref $value eq 'ARRAY' ? $value : [$value];
    }
  
    # Uploads or param values
    my $req     = $self->req;
    my $uploads = $req->every_upload($name);
    return @$uploads ? $uploads : $req->every_param($name);
  }
  
  sub every_signed_cookie {
    my ($self, $name) = @_;
  
    my $secrets = $self->app->secrets;
    my @results;
    for my $value (@{$self->every_cookie($name)}) {
  
      # Check signature with rotating secrets
      if ($value =~ s/--([^\-]+)$//) {
        my $signature = $1;
  
        my $valid;
        for my $secret (@$secrets) {
          my $check = Mojo::Util::hmac_sha1_sum($value, $secret);
          ++$valid and last if Mojo::Util::secure_compare($signature, $check);
        }
        if ($valid) { push @results, $value }
  
        else { $self->app->log->debug(qq{Cookie "$name" has a bad signature}) }
      }
  
      else { $self->app->log->debug(qq{Cookie "$name" is not signed}) }
    }
  
    return \@results;
  }
  
  sub finish {
    my $self = shift;
  
    # WebSocket
    my $tx = $self->tx || Carp::croak 'Connection already closed';
    $tx->finish(@_) and return $tx->established ? $self : $self->rendered(101)
      if $tx->is_websocket;
  
    # Chunked stream
    return @_ ? $self->write_chunk(@_)->write_chunk('') : $self->write_chunk('')
      if $tx->res->content->is_chunked;
  
    # Normal stream
    return @_ ? $self->write(@_)->write('') : $self->write('');
  }
  
  sub flash {
    my $self = shift;
  
    # Check old flash
    my $session = $self->session;
    return $session->{flash} ? $session->{flash}{$_[0]} : undef
      if @_ == 1 && !ref $_[0];
  
    # Initialize new flash and merge values
    my $values = ref $_[0] ? $_[0] : {@_};
    @{$session->{new_flash} ||= {}}{keys %$values} = values %$values;
  
    return $self;
  }
  
  sub helpers { $_[0]->app->renderer->get_helper('')->($_[0]) }
  
  sub on {
    my ($self, $name, $cb) = @_;
    my $tx = $self->tx || Carp::croak 'Connection already closed';
    $self->rendered(101) if $tx->is_websocket && !$tx->established;
    return $tx->on($name => sub { shift; $self->$cb(@_) });
  }
  
  sub param {
    my ($self, $name) = (shift, shift);
    return $self->every_param($name)->[-1] unless @_;
    $self->stash->{'mojo.captures'}{$name} = @_ > 1 ? [@_] : $_[0];
    return $self;
  }
  
  sub redirect_to {
    my $self = shift;
  
    # Don't override 3xx status
    my $res = $self->res;
    $res->headers->location($self->url_for(@_));
    return $self->rendered($res->is_redirect ? () : 302);
  }
  
  sub render {
    my $self = shift;
  
    # Template may be first argument
    my ($template, $args) = (@_ % 2 ? shift : undef, {@_});
    $args->{template} = $template if $template;
    my $app     = $self->app;
    my $plugins = $app->plugins->emit_hook(before_render => $self, $args);
    my $maybe   = delete $args->{'mojo.maybe'};
  
    my $ts = $args->{'mojo.string'};
    my ($output, $format) = $app->renderer->render($self, $args);
  
    # Maybe no 404
    return defined $output ? Mojo::ByteStream->new($output) : undef if $ts;
    return $maybe ? undef : !$self->helpers->reply->not_found
      unless defined $output;
  
    $plugins->emit_hook(after_render => $self, \$output, $format);
    my $headers = $self->res->body($output)->headers;
    $headers->content_type($app->types->type($format) || 'text/plain')
      unless $headers->content_type;
    return !!$self->rendered($self->stash->{status});
  }
  
  sub render_later { shift->stash('mojo.rendered' => 1) }
  
  sub render_maybe { shift->render(@_, 'mojo.maybe' => 1) }
  
  sub render_to_string { shift->render(@_, 'mojo.string' => 1) }
  
  sub rendered {
    my ($self, $status) = @_;
  
    # Make sure we have a status
    my $res = $self->res;
    $res->code($status || 200) if $status || !$res->code;
  
    # Finish transaction
    my $stash = $self->stash;
    if (!$stash->{'mojo.finished'} && ++$stash->{'mojo.finished'}) {
  
      # Disable auto rendering and stop timer
      my $app = $self->render_later->app;
      if (my $started = delete $stash->{'mojo.started'}) {
        my $elapsed
          = Time::HiRes::tv_interval($started, [Time::HiRes::gettimeofday()]);
        my $rps  = $elapsed == 0 ? '??' : sprintf '%.3f', 1 / $elapsed;
        my $code = $res->code;
        my $msg  = $res->message || $res->default_message($code);
        $app->log->debug("$code $msg (${elapsed}s, $rps/s)");
      }
  
      $app->plugins->emit_hook_reverse(after_dispatch => $self);
      $app->sessions->store($self);
    }
    $self->tx->resume;
    return $self;
  }
  
  sub req { (shift->tx || Carp::croak 'Connection already closed')->req }
  sub res { (shift->tx || Carp::croak 'Connection already closed')->res }
  
  sub respond_to {
    my ($self, $args) = (shift, ref $_[0] ? $_[0] : {@_});
  
    # Find target
    my $target;
    my $renderer = $self->app->renderer;
    my @formats  = @{$renderer->accepts($self)};
    for my $format (@formats ? @formats : ($renderer->default_format)) {
      next unless $target = $args->{$format};
      $self->stash->{format} = $format;
      last;
    }
  
    # Fallback
    unless ($target) {
      return $self->rendered(204) unless $target = $args->{any};
      delete $self->stash->{format};
    }
  
    # Dispatch
    ref $target eq 'CODE' ? $target->($self) : $self->render(%$target);
  
    return $self;
  }
  
  sub send {
    my ($self, $msg, $cb) = @_;
    my $tx = $self->tx || Carp::croak 'Connection already closed';
    Carp::croak 'No WebSocket connection to send message to'
      unless $tx->is_websocket;
    $tx->send($msg, $cb ? sub { shift; $self->$cb(@_) } : ());
    return $tx->established ? $self : $self->rendered(101);
  }
  
  sub session {
    my $self = shift;
  
    my $stash = $self->stash;
    $self->app->sessions->load($self)
      unless exists $stash->{'mojo.active_session'};
  
    # Hash
    my $session = $stash->{'mojo.session'} ||= {};
    return $session unless @_;
  
    # Get
    return $session->{$_[0]} unless @_ > 1 || ref $_[0];
  
    # Set
    my $values = ref $_[0] ? $_[0] : {@_};
    @$session{keys %$values} = values %$values;
  
    return $self;
  }
  
  sub signed_cookie {
    my ($self, $name, $value, $options) = @_;
  
    # Request cookie
    return $self->every_signed_cookie($name)->[-1] unless defined $value;
  
    # Response cookie
    my $checksum = Mojo::Util::hmac_sha1_sum($value, $self->app->secrets->[0]);
    return $self->cookie($name, "$value--$checksum", $options);
  }
  
  sub stash { Mojo::Util::_stash(stash => @_) }
  
  sub url_for {
    my ($self, $target) = (shift, shift // '');
  
    # Absolute URL
    return $target if Scalar::Util::blessed $target && $target->isa('Mojo::URL');
    return Mojo::URL->new($target) if $target =~ m!^(?:[^:/?#]+:|//|#)!;
  
    # Base
    my $url  = Mojo::URL->new;
    my $req  = $self->req;
    my $base = $url->base($req->url->base->clone)->base->userinfo(undef);
  
    # Relative URL
    my $path = $url->path;
    if ($target =~ m!^/!) {
      if (defined(my $prefix = $self->stash->{path})) {
        my $real = $req->url->path->to_route;
        $real =~ s!/?\Q$prefix\E$!$target!;
        $target = $real;
      }
      $url->parse($target);
    }
  
    # Route
    else {
      my $generated = $self->match->path_for($target, @_);
      $path->parse($generated->{path}) if $generated->{path};
      $base->scheme($base->protocol eq 'https' ? 'wss' : 'ws')
        if $generated->{websocket};
    }
  
    # Make path absolute
    my $base_path = $base->path;
    unshift @{$path->parts}, @{$base_path->parts};
    $base_path->parts([])->trailing_slash(0);
  
    return $url;
  }
  
  sub validation {
    my $self = shift;
  
    my $stash = $self->stash;
    return $stash->{'mojo.validation'} if $stash->{'mojo.validation'};
  
    my $req    = $self->req;
    my $token  = $self->session->{csrf_token};
    my $header = $req->headers->header('X-CSRF-Token');
    my $hash   = $req->params->to_hash;
    $hash->{csrf_token} //= $header if $token && $header;
    $hash->{$_} = $req->every_upload($_) for map { $_->name } @{$req->uploads};
    my $validation = $self->app->validator->validation->input($hash);
    return $stash->{'mojo.validation'} = $validation->csrf_token($token);
  }
  
  sub write {
    my ($self, $chunk, $cb) = @_;
    $self->res->content->write($chunk, $cb ? sub { shift; $self->$cb(@_) } : ());
    return $self->rendered;
  }
  
  sub write_chunk {
    my ($self, $chunk, $cb) = @_;
    my $content = $self->res->content;
    $content->write_chunk($chunk, $cb ? sub { shift; $self->$cb(@_) } : ());
    return $self->rendered;
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojolicious::Controller - Controller base class
  
  =head1 SYNOPSIS
  
    # Controller
    package MyApp::Controller::Foo;
    use Mojo::Base 'Mojolicious::Controller';
  
    # Action
    sub bar {
      my $self = shift;
      my $name = $self->param('name');
      $self->res->headers->cache_control('max-age=1, no-cache');
      $self->render(json => {hello => $name});
    }
  
  =head1 DESCRIPTION
  
  L<Mojolicious::Controller> is the base class for your L<Mojolicious>
  controllers. It is also the default controller class unless you set
  L<Mojolicious/"controller_class">.
  
  =head1 ATTRIBUTES
  
  L<Mojolicious::Controller> inherits all attributes from L<Mojo::Base> and
  implements the following new ones.
  
  =head2 app
  
    my $app = $c->app;
    $c      = $c->app(Mojolicious->new);
  
  A reference back to the application that dispatched to this controller, usually
  a L<Mojolicious> object.
  
    # Use application logger
    $c->app->log->debug('Hello Mojo');
  
    # Generate path
    my $path = $c->app->home->child('templates', 'foo', 'bar.html.ep');
  
  =head2 match
  
    my $m = $c->match;
    $c    = $c->match(Mojolicious::Routes::Match->new);
  
  Router results for the current request, defaults to a
  L<Mojolicious::Routes::Match> object.
  
    # Introspect
    my $name   = $c->match->endpoint->name;
    my $foo    = $c->match->endpoint->pattern->defaults->{foo};
    my $action = $c->match->stack->[-1]{action};
  
  =head2 tx
  
    my $tx = $c->tx;
    $c     = $c->tx(Mojo::Transaction::HTTP->new);
  
  The transaction that is currently being processed, usually a
  L<Mojo::Transaction::HTTP> or L<Mojo::Transaction::WebSocket> object. Note that
  this reference is usually weakened, so the object needs to be referenced
  elsewhere as well when you're performing non-blocking operations and the
  underlying connection might get closed early.
  
    # Check peer information
    my $address = $c->tx->remote_address;
    my $port    = $c->tx->remote_port;
  
    # Increase size limit for WebSocket messages to 16MB
    $c->tx->max_websocket_size(16777216) if $c->tx->is_websocket;
  
    # Perform non-blocking operation without knowing the connection status
    my $tx = $c->tx;
    Mojo::IOLoop->timer(2 => sub {
      $c->app->log->debug($tx->is_finished ? 'Finished' : 'In progress');
    });
  
  =head1 METHODS
  
  L<Mojolicious::Controller> inherits all methods from L<Mojo::Base> and
  implements the following new ones.
  
  =head2 continue
  
    $c->continue;
  
  Continue dispatch chain from an intermediate destination with
  L<Mojolicious::Routes/"continue">.
  
  =head2 cookie
  
    my $value = $c->cookie('foo');
    $c        = $c->cookie(foo => 'bar');
    $c        = $c->cookie(foo => 'bar', {path => '/'});
  
  Access request cookie values and create new response cookies. If there are
  multiple values sharing the same name, and you want to access more than just
  the last one, you can use L</"every_cookie">.
  
    # Create response cookie with domain and expiration date
    $c->cookie(user => 'sri', {domain => 'example.com', expires => time + 60});
  
    # Create secure response cookie
    $c->cookie(secret => 'I <3 Mojolicious', {secure => 1, httponly => 1});
  
  =head2 every_cookie
  
    my $values = $c->every_cookie('foo');
  
  Similar to L</"cookie">, but returns all request cookie values sharing the same
  name as an array reference.
  
    $ Get first cookie value
    my $first = $c->every_cookie('foo')->[0];
  
  =head2 every_param
  
    my $values = $c->every_param('foo');
  
  Similar to L</"param">, but returns all values sharing the same name as an
  array reference.
  
    # Get first value
    my $first = $c->every_param('foo')->[0];
  
  =head2 every_signed_cookie
  
    my $values = $c->every_signed_cookie('foo');
  
  Similar to L</"signed_cookie">, but returns all signed request cookie values
  sharing the same name as an array reference.
  
    # Get first signed cookie value
    my $first = $c->every_signed_cookie('foo')->[0];
  
  =head2 finish
  
    $c = $c->finish;
    $c = $c->finish(1000);
    $c = $c->finish(1003 => 'Cannot accept data!');
    $c = $c->finish('Bye!');
  
  Close WebSocket connection or long poll stream gracefully. This method will
  automatically respond to WebSocket handshake requests with a C<101> response
  status, to establish the WebSocket connection.
  
  =head2 flash
  
    my $foo = $c->flash('foo');
    $c      = $c->flash({foo => 'bar'});
    $c      = $c->flash(foo => 'bar');
  
  Data storage persistent only for the next request, stored in the L</"session">.
  
    # Show message after redirect
    $c->flash(message => 'User created successfully!');
    $c->redirect_to('show_user', id => 23);
  
  =head2 helpers
  
    my $helpers = $c->helpers;
  
  Return a proxy object containing the current controller object and on which
  helpers provided by L</"app"> can be called. This includes all helpers from
  L<Mojolicious::Plugin::DefaultHelpers> and L<Mojolicious::Plugin::TagHelpers>.
  
    # Make sure to use the "title" helper and not the controller method
    $c->helpers->title('Welcome!');
  
    # Use a nested helper instead of the "reply" controller method
    $c->helpers->reply->not_found;
  
  =head2 on
  
    my $cb = $c->on(finish => sub {...});
  
  Subscribe to events of L</"tx">, which is usually a L<Mojo::Transaction::HTTP>
  or L<Mojo::Transaction::WebSocket> object. This method will automatically
  respond to WebSocket handshake requests with a C<101> response status, to
  establish the WebSocket connection.
  
    # Do something after the transaction has been finished
    $c->on(finish => sub {
      my $c = shift;
      $c->app->log->debug('All data has been sent');
    });
  
    # Receive WebSocket message
    $c->on(message => sub {
      my ($c, $msg) = @_;
      $c->app->log->debug("Message: $msg");
    });
  
    # Receive JSON object via WebSocket message
    $c->on(json => sub {
      my ($c, $hash) = @_;
      $c->app->log->debug("Test: $hash->{test}");
    });
  
    # Receive WebSocket "Binary" message
    $c->on(binary => sub {
      my ($c, $bytes) = @_;
      my $len = length $bytes;
      $c->app->log->debug("Received $len bytes");
    });
  
  =head2 param
  
    my $value = $c->param('foo');
    $c        = $c->param(foo => 'ba;r');
    $c        = $c->param(foo => 'ba;r', 'baz');
    $c        = $c->param(foo => ['ba;r', 'baz']);
  
  Access route placeholder values that are not reserved stash values, file
  uploads as well as C<GET> and C<POST> parameters extracted from the query
  string and C<application/x-www-form-urlencoded> or C<multipart/form-data>
  message body, in that order. If there are multiple values sharing the same
  name, and you want to access more than just the last one, you can use
  L</"every_param">. Parts of the request body need to be loaded into memory to
  parse C<POST> parameters, so you have to make sure it is not excessively large.
  There's a 16MB limit for requests by default.
  
    # Get first value
    my $first = $c->every_param('foo')->[0];
  
  For more control you can also access request information directly.
  
    # Only GET parameters
    my $foo = $c->req->query_params->param('foo');
  
    # Only POST parameters
    my $foo = $c->req->body_params->param('foo');
  
    # Only GET and POST parameters
    my $foo = $c->req->param('foo');
  
    # Only file uploads
    my $foo = $c->req->upload('foo');
  
  =head2 redirect_to
  
    $c = $c->redirect_to('named', foo => 'bar');
    $c = $c->redirect_to('named', {foo => 'bar'});
    $c = $c->redirect_to('/index.html');
    $c = $c->redirect_to('http://example.com/index.html');
  
  Prepare a C<302> (if the status code is not already C<3xx>) redirect response
  with C<Location> header, takes the same arguments as L</"url_for">.
  
    # Moved Permanently
    $c->res->code(301);
    $c->redirect_to('some_route');
  
    # Temporary Redirect
    $c->res->code(307);
    $c->redirect_to('some_route');
  
  =head2 render
  
    my $bool = $c->render;
    my $bool = $c->render(foo => 'bar', baz => 23);
    my $bool = $c->render(template => 'foo/index');
    my $bool = $c->render(template => 'index', format => 'html');
    my $bool = $c->render(data => $bytes);
    my $bool = $c->render(text => 'Hello!');
    my $bool = $c->render(json => {foo => 'bar'});
    my $bool = $c->render(handler => 'something');
    my $bool = $c->render('foo/index');
  
  Render content with L<Mojolicious/"renderer"> and emit hooks
  L<Mojolicious/"before_render"> as well as L<Mojolicious/"after_render">, or
  call L<Mojolicious::Plugin::DefaultHelpers/"reply-E<gt>not_found"> if no
  response could be generated, all additional key/value pairs get merged into the
  L</"stash">.
  
    # Render characters
    $c->render(text => 'I  Mojolicious!');
  
    # Render characters (alternative)
    $c->stash(text => 'I  Mojolicious!')->render;
  
    # Render binary data
    use Mojo::JSON 'encode_json';
    $c->render(data => encode_json({test => 'I  Mojolicious!'}));
  
    # Render JSON
    $c->render(json => {test => 'I  Mojolicious!'});
  
    # Render inline template
    $c->render(inline => '<%= 1 + 1 %>');
  
    # Render template "foo/bar.html.ep"
    $c->render(template => 'foo/bar', format => 'html', handler => 'ep');
  
    # Render template "test.*.*" with arbitrary values "foo" and "bar"
    $c->render(template => 'test', foo => 'test', bar => 23);
  
    # Render template "test.xml.*"
    $c->render(template => 'test', format => 'xml');
  
    # Render template "test.xml.*" (alternative)
    $c->render('test', format => 'xml');
  
  =head2 render_later
  
    $c = $c->render_later;
  
  Disable automatic rendering to delay response generation, only necessary if
  automatic rendering would result in a response.
  
    # Delayed rendering
    $c->render_later;
    Mojo::IOLoop->timer(2 => sub {
      $c->render(text => 'Delayed by 2 seconds!');
    });
  
  =head2 render_maybe
  
    my $bool = $c->render_maybe;
    my $bool = $c->render_maybe(foo => 'bar', baz => 23);
    my $bool = $c->render_maybe('foo/index', format => 'html');
  
  Try to render content, but do not call
  L<Mojolicious::Plugin::DefaultHelpers/"reply-E<gt>not_found"> if no response
  could be generated, takes the same arguments as L</"render">.
  
    # Render template "index_local" only if it exists
    $c->render_maybe('index_local') or $c->render('index');
  
  =head2 render_to_string
  
    my $output = $c->render_to_string('foo/index', format => 'pdf');
  
  Try to render content and return it wrapped in a L<Mojo::ByteStream> object or
  return C<undef>, all arguments get localized automatically and are only
  available during this render operation, takes the same arguments as
  L</"render">.
  
    # Render inline template
    my $two = $c->render_to_string(inline => '<%= 1 + 1 %>');
  
  =head2 rendered
  
    $c = $c->rendered;
    $c = $c->rendered(302);
  
  Finalize response and emit hook L<Mojolicious/"after_dispatch">, defaults to
  using a C<200> response code.
  
    # Custom response
    $c->res->headers->content_type('text/plain');
    $c->res->body('Hello World!');
    $c->rendered(200);
  
  =head2 req
  
    my $req = $c->req;
  
  Get L<Mojo::Message::Request> object from L</"tx">.
  
    # Longer version
    my $req = $c->tx->req;
  
    # Extract request information
    my $method = $c->req->method;
    my $url    = $c->req->url->to_abs;
    my $info   = $c->req->url->to_abs->userinfo;
    my $host   = $c->req->url->to_abs->host;
    my $agent  = $c->req->headers->user_agent;
    my $custom = $c->req->headers->header('Custom-Header');
    my $bytes  = $c->req->body;
    my $str    = $c->req->text;
    my $hash   = $c->req->params->to_hash;
    my $all    = $c->req->uploads;
    my $value  = $c->req->json;
    my $foo    = $c->req->json('/23/foo');
    my $dom    = $c->req->dom;
    my $bar    = $c->req->dom('div.bar')->first->text;
  
  =head2 res
  
    my $res = $c->res;
  
  Get L<Mojo::Message::Response> object from L</"tx">.
  
    # Longer version
    my $res = $c->tx->res;
  
    # Force file download by setting a response header
    $c->res->headers->content_disposition('attachment; filename=foo.png;');
  
    # Use a custom response header
    $c->res->headers->header('Custom-Header' => 'whatever');
  
    # Make sure response is cached correctly
    $c->res->headers->cache_control('public, max-age=300');
    $c->res->headers->append(Vary => 'Accept-Encoding');
  
  =head2 respond_to
  
    $c = $c->respond_to(
      json => {json => {message => 'Welcome!'}},
      html => {template => 'welcome'},
      any  => sub {...}
    );
  
  Automatically select best possible representation for resource from C<Accept>
  request header, C<format> stash value or C<format> C<GET>/C<POST> parameter,
  defaults to L<Mojolicious::Renderer/"default_format"> or rendering an empty
  C<204> response. Each representation can be handled with a callback or a hash
  reference containing arguments to be passed to L</"render">. Since browsers
  often don't really know what they actually want, unspecific C<Accept> request
  headers with more than one MIME type will be ignored, unless the
  C<X-Requested-With> header is set to the value C<XMLHttpRequest>.
  
    # Everything else than "json" and "xml" gets a 204 response
    $c->respond_to(
      json => sub { $c->render(json => {just => 'works'}) },
      xml  => {text => '<just>works</just>'},
      any  => {data => '', status => 204}
    );
  
  For more advanced negotiation logic you can also use the helper
  L<Mojolicious::Plugin::DefaultHelpers/"accepts">.
  
  =head2 send
  
    $c = $c->send({binary => $bytes});
    $c = $c->send({text   => $bytes});
    $c = $c->send({json   => {test => [1, 2, 3]}});
    $c = $c->send([$fin, $rsv1, $rsv2, $rsv3, $op, $payload]);
    $c = $c->send($chars);
    $c = $c->send($chars => sub {...});
  
  Send message or frame non-blocking via WebSocket, the optional drain callback
  will be executed once all data has been written. This method will automatically
  respond to WebSocket handshake requests with a C<101> response status, to
  establish the WebSocket connection.
  
    # Send "Text" message
    $c->send('I  Mojolicious!');
  
    # Send JSON object as "Text" message
    $c->send({json => {test => 'I  Mojolicious!'}});
  
    # Send JSON object as "Binary" message
    use Mojo::JSON 'encode_json';
    $c->send({binary => encode_json({test => 'I  Mojolicious!'})});
  
    # Send "Ping" frame
    use Mojo::WebSocket 'WS_PING';
    $c->send([1, 0, 0, 0, WS_PING, 'Hello World!']);
  
    # Make sure the first message has been written before continuing
    $c->send('First message!' => sub {
      my $c = shift;
      $c->send('Second message!');
    });
  
  For mostly idle WebSockets you might also want to increase the inactivity
  timeout with L<Mojolicious::Plugin::DefaultHelpers/"inactivity_timeout">, which
  usually defaults to C<15> seconds.
  
    # Increase inactivity timeout for connection to 300 seconds
    $c->inactivity_timeout(300);
  
  =head2 session
  
    my $session = $c->session;
    my $foo     = $c->session('foo');
    $c          = $c->session({foo => 'bar'});
    $c          = $c->session(foo => 'bar');
  
  Persistent data storage for the next few requests, all session data gets
  serialized with L<Mojo::JSON> and stored Base64 encoded in HMAC-SHA1 signed
  cookies, to prevent tampering. Note that cookies usually have a C<4096> byte
  (4KB) limit, depending on browser.
  
    # Manipulate session
    $c->session->{foo} = 'bar';
    my $foo = $c->session->{foo};
    delete $c->session->{foo};
  
    # Expiration date in seconds from now (persists between requests)
    $c->session(expiration => 604800);
  
    # Expiration date as absolute epoch time (only valid for one request)
    $c->session(expires => time + 604800);
  
    # Delete whole session by setting an expiration date in the past
    $c->session(expires => 1);
  
  =head2 signed_cookie
  
    my $value = $c->signed_cookie('foo');
    $c        = $c->signed_cookie(foo => 'bar');
    $c        = $c->signed_cookie(foo => 'bar', {path => '/'});
  
  Access signed request cookie values and create new signed response cookies. If
  there are multiple values sharing the same name, and you want to access more
  than just the last one, you can use L</"every_signed_cookie">. Cookies are
  cryptographically signed with HMAC-SHA1, to prevent tampering, and the ones
  failing signature verification will be automatically discarded.
  
  =head2 stash
  
    my $hash = $c->stash;
    my $foo  = $c->stash('foo');
    $c       = $c->stash({foo => 'bar', baz => 23});
    $c       = $c->stash(foo => 'bar', baz => 23);
  
  Non-persistent data storage and exchange for the current request, application
  wide default values can be set with L<Mojolicious/"defaults">. Some stash
  values have a special meaning and are reserved, the full list is currently
  C<action>, C<app>, C<cb>, C<controller>, C<data>, C<extends>, C<format>,
  C<handler>, C<inline>, C<json>, C<layout>, C<namespace>, C<path>, C<status>,
  C<template>, C<text> and C<variant>. Note that all stash values with a
  C<mojo.*> prefix are reserved for internal use.
  
    # Remove value
    my $foo = delete $c->stash->{foo};
  
    # Assign multiple values at once
    $c->stash(foo => 'test', bar => 23);
  
  =head2 url_for
  
    my $url = $c->url_for;
    my $url = $c->url_for(name => 'sebastian');
    my $url = $c->url_for({name => 'sebastian'});
    my $url = $c->url_for('test', name => 'sebastian');
    my $url = $c->url_for('test', {name => 'sebastian'});
    my $url = $c->url_for('/index.html');
    my $url = $c->url_for('//example.com/index.html');
    my $url = $c->url_for('http://example.com/index.html');
    my $url = $c->url_for('mailto:sri@example.com');
    my $url = $c->url_for('#whatever');
  
  Generate a portable L<Mojo::URL> object with base for a path, URL or route.
  
    # "http://127.0.0.1:3000/index.html" if application was started with Morbo
    $c->url_for('/index.html')->to_abs;
  
    # "https://127.0.0.1:443/index.html" if application was started with Morbo
    $c->url_for('/index.html')->to_abs->scheme('https')->port(443);
  
    # "/index.html?foo=bar" if application is deployed under "/"
    $c->url_for('/index.html')->query(foo => 'bar');
  
    # "/myapp/index.html?foo=bar" if application is deployed under "/myapp"
    $c->url_for('/index.html')->query(foo => 'bar');
  
  You can also use the helper L<Mojolicious::Plugin::DefaultHelpers/"url_with">
  to inherit query parameters from the current request.
  
    # "/list?q=mojo&page=2" if current request was for "/list?q=mojo&page=1"
    $c->url_with->query([page => 2]);
  
  =head2 validation
  
    my $validation = $c->validation;
  
  Get L<Mojolicious::Validator::Validation> object for current request to
  validate file uploads as well as C<GET> and C<POST> parameters extracted from
  the query string and C<application/x-www-form-urlencoded> or
  C<multipart/form-data> message body. Parts of the request body need to be loaded
  into memory to parse C<POST> parameters, so you have to make sure it is not
  excessively large. There's a 16MB limit for requests by default.
  
    # Validate GET/POST parameter
    my $validation = $c->validation;
    $validation->required('title', 'trim')->size(3, 50);
    my $title = $validation->param('title');
  
    # Validate file upload
    my $validation = $c->validation;
    $validation->required('tarball')->upload->size(1, 1048576);
    my $tarball = $validation->param('tarball');
  
  =head2 write
  
    $c = $c->write;
    $c = $c->write('');
    $c = $c->write($bytes);
    $c = $c->write($bytes => sub {...});
  
  Write dynamic content non-blocking, the optional drain callback will be executed
  once all data has been written. Calling this method without a chunk of data
  will finalize the response headers and allow for dynamic content to be written
  later.
  
    # Keep connection alive (with Content-Length header)
    $c->res->headers->content_length(6);
    $c->write('Hel' => sub {
      my $c = shift;
      $c->write('lo!');
    });
  
    # Close connection when finished (without Content-Length header)
    $c->write('Hel' => sub {
      my $c = shift;
      $c->write('lo!' => sub {
        my $c = shift;
        $c->finish;
      });
    });
  
  You can call L</"finish"> or write an empty chunk of data at any time to end
  the stream.
  
    HTTP/1.1 200 OK
    Date: Sat, 13 Sep 2014 16:48:29 GMT
    Content-Length: 6
    Server: Mojolicious (Perl)
  
    Hello!
  
    HTTP/1.1 200 OK
    Connection: close
    Date: Sat, 13 Sep 2014 16:48:29 GMT
    Server: Mojolicious (Perl)
  
    Hello!
  
  For Comet (long polling) you might also want to increase the inactivity timeout
  with L<Mojolicious::Plugin::DefaultHelpers/"inactivity_timeout">, which usually
  defaults to C<15> seconds.
  
    # Increase inactivity timeout for connection to 300 seconds
    $c->inactivity_timeout(300);
  
  =head2 write_chunk
  
    $c = $c->write_chunk;
    $c = $c->write_chunk('');
    $c = $c->write_chunk($bytes);
    $c = $c->write_chunk($bytes => sub {...});
  
  Write dynamic content non-blocking with chunked transfer encoding, the optional
  drain callback will be executed once all data has been written. Calling this
  method without a chunk of data will finalize the response headers and allow for
  dynamic content to be written later.
  
    # Make sure previous chunk has been written before continuing
    $c->write_chunk('H' => sub {
      my $c = shift;
      $c->write_chunk('ell' => sub {
        my $c = shift;
        $c->finish('o!');
      });
    });
  
  You can call L</"finish"> or write an empty chunk of data at any time to end
  the stream.
  
    HTTP/1.1 200 OK
    Date: Sat, 13 Sep 2014 16:48:29 GMT
    Transfer-Encoding: chunked
    Server: Mojolicious (Perl)
  
    1
    H
    3
    ell
    2
    o!
    0
  
  =head1 AUTOLOAD
  
  In addition to the L</"ATTRIBUTES"> and L</"METHODS"> above you can also call
  helpers provided by L</"app"> on L<Mojolicious::Controller> objects. This
  includes all helpers from L<Mojolicious::Plugin::DefaultHelpers> and
  L<Mojolicious::Plugin::TagHelpers>.
  
    # Call helpers
    $c->layout('green');
    $c->title('Welcome!');
  
    # Longer version
    $c->helpers->layout('green');
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<http://mojolicious.org>.
  
  =cut
MOJOLICIOUS_CONTROLLER

$fatpacked{"Mojolicious/Lite.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJOLICIOUS_LITE';
  package Mojolicious::Lite;
  use Mojo::Base 'Mojolicious';
  
  # "Bender: Bite my shiny metal ass!"
  use Mojo::File 'path';
  use Mojo::UserAgent::Server;
  use Mojo::Util 'monkey_patch';
  
  sub import {
  
    # Remember executable for later
    $ENV{MOJO_EXE} ||= (caller)[1];
  
    # Reuse home directory if possible
    local $ENV{MOJO_HOME} = path($ENV{MOJO_EXE})->dirname->to_string
      unless $ENV{MOJO_HOME};
  
    # Initialize application class
    my $caller = caller;
    no strict 'refs';
    push @{"${caller}::ISA"}, 'Mojo';
  
    # Generate moniker based on filename
    my $moniker = path($ENV{MOJO_EXE})->basename('.pl', '.pm', '.t');
    my $app = shift->new(moniker => $moniker);
  
    # Initialize routes without namespaces
    my $routes = $app->routes->namespaces([]);
    $app->static->classes->[0] = $app->renderer->classes->[0] = $caller;
  
    # The Mojolicious::Lite DSL
    my $root = $routes;
    for my $name (qw(any get options patch post put websocket)) {
      monkey_patch $caller, $name, sub { $routes->$name(@_) };
    }
    monkey_patch($caller, $_, sub {$app}) for qw(new app);
    monkey_patch $caller, del => sub { $routes->delete(@_) };
    monkey_patch $caller, group => sub (&) {
      (my $old, $root) = ($root, $routes);
      shift->();
      ($routes, $root) = ($root, $old);
    };
    monkey_patch $caller,
      helper => sub { $app->helper(@_) },
      hook   => sub { $app->hook(@_) },
      plugin => sub { $app->plugin(@_) },
      under  => sub { $routes = $root->under(@_) };
  
    # Make sure there's a default application for testing
    Mojo::UserAgent::Server->app($app) unless Mojo::UserAgent::Server->app;
  
    # Lite apps are strict!
    Mojo::Base->import(-strict);
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojolicious::Lite - Micro real-time web framework
  
  =head1 SYNOPSIS
  
    # Automatically enables "strict", "warnings", "utf8" and Perl 5.10 features
    use Mojolicious::Lite;
  
    # Route with placeholder
    get '/:foo' => sub {
      my $c   = shift;
      my $foo = $c->param('foo');
      $c->render(text => "Hello from $foo.");
    };
  
    # Start the Mojolicious command system
    app->start;
  
  =head1 DESCRIPTION
  
  L<Mojolicious::Lite> is a tiny domain specific language built around
  L<Mojolicious>, made up of only about a dozen Perl functions.
  
  See L<Mojolicious::Guides::Tutorial> for more!
  
  =head1 GROWING
  
  While L<Mojolicious::Guides::Growing> will give you a detailed introduction to
  growing a L<Mojolicious::Lite> prototype into a well-structured L<Mojolicious>
  application, here we have collected a few snippets that illustrate very well
  just how similar both of them are.
  
  =head2 Routes
  
  The functions L</"get">, L</"post"> and friends all have equivalent methods.
  
    # Mojolicious::Lite
    get '/foo' => sub {
      my $c = shift;
      $c->render(text => 'Hello World!');
    };
  
    # Mojolicious
    sub startup {
      my $self = shift;
  
      my $routes = $self->routes;
      $routes->get('/foo' => sub {
        my $c = shift;
        $c->render(text => 'Hello World!');
      });
    }
  
  =head2 Application
  
  The application object you can access with the function L</"app"> is the first
  argument passed to the C<startup> method.
  
    # Mojolicious::Lite
    app->max_request_size(16777216);
  
    # Mojolicious
    sub startup {
      my $self = shift;
      $self->max_request_size(16777216);
    }
  
  =head2 Plugins
  
  Instead of the L</"plugin"> function you just use the method
  L<Mojolicious/"plugin">.
  
    # Mojolicious::Lite
    plugin 'Config';
  
    # Mojolicious
    sub startup {
      my $self = shift;
      $self->plugin('Config');
    }
  
  =head2 Helpers
  
  Similar to plugins, instead of the L</"helper"> function you just use the method
  L<Mojolicious/"helper">.
  
    # Mojolicious::Lite
    helper two => sub {
      my $c = shift;
      return 1 + 1;
    };
  
    # Mojolicious
    sub startup {
      my $self = shift;
      $self->helper(two => sub {
        my $c = shift;
        return 1 + 1;
      });
    }
  
  =head2 Under
  
  Instead of sequential function calls, we can use methods to build a tree with
  nested routes, that much better illustrates how routes work internally.
  
    # Mojolicious::Lite
    under '/foo';
    get '/bar' => sub {...};
  
    # Mojolicious
    sub startup {
      my $self = shift;
  
      my $routes = $self->routes;
      my $foo = $routes->under('/foo');
      $foo->get('/bar' => sub {...});
    }
  
  =head1 FUNCTIONS
  
  L<Mojolicious::Lite> implements the following functions, which are
  automatically exported.
  
  =head2 any
  
    my $route = any '/:foo' => sub {...};
    my $route = any '/:foo' => sub {...} => 'name';
    my $route = any '/:foo' => {foo => 'bar'} => sub {...};
    my $route = any '/:foo' => [foo => qr/\w+/] => sub {...};
    my $route = any ['GET', 'POST'] => '/:foo' => sub {...};
    my $route = any ['GET', 'POST'] => '/:foo' => [foo => qr/\w+/] => sub {...};
    my $route = any
      ['GET', 'POST'] => '/:foo' => (agent => qr/Firefox/) => sub {...};
  
  Generate route with L<Mojolicious::Routes::Route/"any">, matching any of the
  listed HTTP request methods or all. See L<Mojolicious::Guides::Tutorial> and
  L<Mojolicious::Guides::Routing> for more information.
  
  =head2 app
  
    my $app = app;
  
  Returns the L<Mojolicious::Lite> application object, which is a subclass of
  L<Mojolicious>.
  
    # Use all the available attributes and methods
    app->log->level('error');
    app->defaults(foo => 'bar');
  
  =head2 del
  
    my $route = del '/:foo' => sub {...};
    my $route = del '/:foo' => sub {...} => 'name';
    my $route = del '/:foo' => {foo => 'bar'} => sub {...};
    my $route = del '/:foo' => [foo => qr/\w+/] => sub {...};
    my $route = del '/:foo' => (agent => qr/Firefox/) => sub {...};
  
  Generate route with L<Mojolicious::Routes::Route/"delete">, matching only
  C<DELETE> requests. See L<Mojolicious::Guides::Tutorial> and
  L<Mojolicious::Guides::Routing> for more information.
  
  =head2 get
  
    my $route = get '/:foo' => sub {...};
    my $route = get '/:foo' => sub {...} => 'name';
    my $route = get '/:foo' => {foo => 'bar'} => sub {...};
    my $route = get '/:foo' => [foo => qr/\w+/] => sub {...};
    my $route = get '/:foo' => (agent => qr/Firefox/) => sub {...};
  
  Generate route with L<Mojolicious::Routes::Route/"get">, matching only C<GET>
  requests. See L<Mojolicious::Guides::Tutorial> and
  L<Mojolicious::Guides::Routing> for more information.
  
  =head2 group
  
    group {...};
  
  Start a new route group.
  
  =head2 helper
  
    helper foo => sub {...};
  
  Add a new helper with L<Mojolicious/"helper">.
  
  =head2 hook
  
    hook after_dispatch => sub {...};
  
  Share code with L<Mojolicious/"hook">.
  
  =head2 options
  
    my $route = options '/:foo' => sub {...};
    my $route = options '/:foo' => sub {...} => 'name';
    my $route = options '/:foo' => {foo => 'bar'} => sub {...};
    my $route = options '/:foo' => [foo => qr/\w+/] => sub {...};
    my $route = options '/:foo' => (agent => qr/Firefox/) => sub {...};
  
  Generate route with L<Mojolicious::Routes::Route/"options">, matching only
  C<OPTIONS> requests. See L<Mojolicious::Guides::Tutorial> and
  L<Mojolicious::Guides::Routing> for more information.
  
  =head2 patch
  
    my $route = patch '/:foo' => sub {...};
    my $route = patch '/:foo' => sub {...} => 'name';
    my $route = patch '/:foo' => {foo => 'bar'} => sub {...};
    my $route = patch '/:foo' => [foo => qr/\w+/] => sub {...};
    my $route = patch '/:foo' => (agent => qr/Firefox/) => sub {...};
  
  Generate route with L<Mojolicious::Routes::Route/"patch">, matching only
  C<PATCH> requests. See L<Mojolicious::Guides::Tutorial> and
  L<Mojolicious::Guides::Routing> for more information.
  
  =head2 plugin
  
    plugin SomePlugin => {foo => 23};
  
  Load a plugin with L<Mojolicious/"plugin">.
  
  =head2 post
  
    my $route = post '/:foo' => sub {...};
    my $route = post '/:foo' => sub {...} => 'name';
    my $route = post '/:foo' => {foo => 'bar'} => sub {...};
    my $route = post '/:foo' => [foo => qr/\w+/] => sub {...};
    my $route = post '/:foo' => (agent => qr/Firefox/) => sub {...};
  
  Generate route with L<Mojolicious::Routes::Route/"post">, matching only C<POST>
  requests. See L<Mojolicious::Guides::Tutorial> and
  L<Mojolicious::Guides::Routing> for more information.
  
  =head2 put
  
    my $route = put '/:foo' => sub {...};
    my $route = put '/:foo' => sub {...} => 'name';
    my $route = put '/:foo' => {foo => 'bar'} => sub {...};
    my $route = put '/:foo' => [foo => qr/\w+/] => sub {...};
    my $route = put '/:foo' => (agent => qr/Firefox/) => sub {...};
  
  Generate route with L<Mojolicious::Routes::Route/"put">, matching only C<PUT>
  requests. See L<Mojolicious::Guides::Tutorial> and
  L<Mojolicious::Guides::Routing> for more information.
  
  =head2 under
  
    my $route = under sub {...};
    my $route = under '/:foo' => sub {...};
    my $route = under '/:foo' => {foo => 'bar'};
    my $route = under '/:foo' => [foo => qr/\w+/];
    my $route = under '/:foo' => (agent => qr/Firefox/);
    my $route = under [format => 0];
  
  Generate nested route with L<Mojolicious::Routes::Route/"under">, to which all
  following routes are automatically appended. See
  L<Mojolicious::Guides::Tutorial> and L<Mojolicious::Guides::Routing> for more
  information.
  
  =head2 websocket
  
    my $route = websocket '/:foo' => sub {...};
    my $route = websocket '/:foo' => sub {...} => 'name';
    my $route = websocket '/:foo' => {foo => 'bar'} => sub {...};
    my $route = websocket '/:foo' => [foo => qr/\w+/] => sub {...};
    my $route = websocket '/:foo' => (agent => qr/Firefox/) => sub {...};
  
  Generate route with L<Mojolicious::Routes::Route/"websocket">, matching only
  WebSocket handshakes. See L<Mojolicious::Guides::Tutorial> and
  L<Mojolicious::Guides::Routing> for more information.
  
  =head1 ATTRIBUTES
  
  L<Mojolicious::Lite> inherits all attributes from L<Mojolicious>.
  
  =head1 METHODS
  
  L<Mojolicious::Lite> inherits all methods from L<Mojolicious>.
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<http://mojolicious.org>.
  
  =cut
MOJOLICIOUS_LITE

$fatpacked{"Mojolicious/Plugin.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJOLICIOUS_PLUGIN';
  package Mojolicious::Plugin;
  use Mojo::Base -base;
  
  use Carp 'croak';
  
  sub register { croak 'Method "register" not implemented by subclass' }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojolicious::Plugin - Plugin base class
  
  =head1 SYNOPSIS
  
    # CamelCase plugin name
    package Mojolicious::Plugin::MyPlugin;
    use Mojo::Base 'Mojolicious::Plugin';
  
    sub register {
      my ($self, $app, $conf) = @_;
  
      # Magic here! :)
    }
  
  =head1 DESCRIPTION
  
  L<Mojolicious::Plugin> is an abstract base class for L<Mojolicious> plugins.
  
  See L<Mojolicious::Plugins/"PLUGINS"> for a list of plugins that are available
  by default.
  
  =head1 METHODS
  
  L<Mojolicious::Plugin> inherits all methods from L<Mojo::Base> and implements
  the following new ones.
  
  =head2 register
  
    $plugin->register(Mojolicious->new);
    $plugin->register(Mojolicious->new, {foo => 'bar'});
  
  This method will be called by L<Mojolicious::Plugins> at startup time. Meant to
  be overloaded in a subclass.
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<http://mojolicious.org>.
  
  =cut
MOJOLICIOUS_PLUGIN

$fatpacked{"Mojolicious/Plugin/Config.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJOLICIOUS_PLUGIN_CONFIG';
  package Mojolicious::Plugin::Config;
  use Mojo::Base 'Mojolicious::Plugin';
  
  use Mojo::File 'path';
  use Mojo::Util 'decode';
  
  sub load { $_[0]->parse(decode('UTF-8', path($_[1])->slurp), @_[1, 2, 3]) }
  
  sub parse {
    my ($self, $content, $file, $conf, $app) = @_;
  
    # Run Perl code in sandbox
    my $config = eval 'package Mojolicious::Plugin::Config::Sandbox; no warnings;'
      . "sub app; local *app = sub { \$app }; use Mojo::Base -strict; $content";
    die qq{Can't load configuration from file "$file": $@} if $@;
    die qq{Configuration file "$file" did not return a hash reference.\n}
      unless ref $config eq 'HASH';
  
    return $config;
  }
  
  sub register {
    my ($self, $app, $conf) = @_;
  
    # Override
    return $app->config if $app->config->{config_override};
  
    # Config file
    my $file = $conf->{file} || $ENV{MOJO_CONFIG};
    $file ||= $app->moniker . '.' . ($conf->{ext} || 'conf');
  
    # Mode specific config file
    my $mode = $file =~ /^(.*)\.([^.]+)$/ ? join('.', $1, $app->mode, $2) : '';
  
    my $home = $app->home;
    $file = $home->child($file) unless path($file)->is_abs;
    $mode = $home->child($mode) if $mode && !path($mode)->is_abs;
    $mode = undef unless $mode && -e $mode;
  
    # Read config file
    my $config = {};
    if (-e $file) { $config = $self->load($file, $conf, $app) }
  
    # Check for default and mode specific config file
    elsif (!$conf->{default} && !$mode) {
      die qq{Configuration file "$file" missing, maybe you need to create it?\n};
    }
  
    # Merge everything
    $config = {%$config, %{$self->load($mode, $conf, $app)}} if $mode;
    $config = {%{$conf->{default}}, %$config} if $conf->{default};
    return $app->defaults(config => $app->config)->config($config)->config;
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojolicious::Plugin::Config - Perl-ish configuration plugin
  
  =head1 SYNOPSIS
  
    # myapp.conf (it's just Perl returning a hash)
    {
      # Just a value
      foo => "bar",
  
      # Nested data structures are fine too
      baz => [''],
  
      # You have full access to the application
      music_dir => app->home->child('music')
    };
  
    # Mojolicious
    my $config = $app->plugin('Config');
    say $config->{foo};
  
    # Mojolicious::Lite
    my $config = plugin 'Config';
    say $config->{foo};
  
    # foo.html.ep
    %= $config->{foo}
  
    # The configuration is available application-wide
    my $config = app->config;
    say $config->{foo};
  
    # Everything can be customized with options
    my $config = plugin Config => {file => '/etc/myapp.stuff'};
  
  =head1 DESCRIPTION
  
  L<Mojolicious::Plugin::Config> is a Perl-ish configuration plugin.
  
  The application object can be accessed via C<$app> or the C<app> function,
  L<strict>, L<warnings>, L<utf8> and Perl 5.10 L<features|feature> are
  automatically enabled. A default configuration filename in the application home
  directory will be generated from the value of L<Mojolicious/"moniker">
  (C<$moniker.conf>). You can extend the normal configuration file
  C<$moniker.conf> with C<mode> specific ones like C<$moniker.$mode.conf>, which
  will be detected automatically.
  
  If the configuration value C<config_override> has been set in L<Mojo/"config">
  when this plugin is loaded, it will not do anything.
  
  The code of this plugin is a good example for learning to build new plugins,
  you're welcome to fork it.
  
  See L<Mojolicious::Plugins/"PLUGINS"> for a list of plugins that are available
  by default.
  
  =head1 OPTIONS
  
  L<Mojolicious::Plugin::Config> supports the following options.
  
  =head2 default
  
    # Mojolicious::Lite
    plugin Config => {default => {foo => 'bar'}};
  
  Default configuration, making configuration files optional.
  
  =head2 ext
  
    # Mojolicious::Lite
    plugin Config => {ext => 'stuff'};
  
  File extension for generated configuration filenames, defaults to C<conf>.
  
  =head2 file
  
    # Mojolicious::Lite
    plugin Config => {file => 'myapp.conf'};
    plugin Config => {file => '/etc/foo.stuff'};
  
  Path to configuration file, absolute or relative to the application home
  directory, defaults to the value of the C<MOJO_CONFIG> environment variable or
  C<$moniker.conf> in the application home directory.
  
  =head1 METHODS
  
  L<Mojolicious::Plugin::Config> inherits all methods from L<Mojolicious::Plugin>
  and implements the following new ones.
  
  =head2 load
  
    $plugin->load($file, $conf, $app);
  
  Loads configuration file and passes the content to L</"parse">.
  
    sub load {
      my ($self, $file, $conf, $app) = @_;
      ...
      return $self->parse($content, $file, $conf, $app);
    }
  
  =head2 parse
  
    $plugin->parse($content, $file, $conf, $app);
  
  Parse configuration file.
  
    sub parse {
      my ($self, $content, $file, $conf, $app) = @_;
      ...
      return $hash;
    }
  
  =head2 register
  
    my $config = $plugin->register(Mojolicious->new);
    my $config = $plugin->register(Mojolicious->new, {file => '/etc/app.conf'});
  
  Register plugin in L<Mojolicious> application and merge configuration.
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<http://mojolicious.org>.
  
  =cut
MOJOLICIOUS_PLUGIN_CONFIG

$fatpacked{"Mojolicious/Plugin/DefaultHelpers.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJOLICIOUS_PLUGIN_DEFAULTHELPERS';
  package Mojolicious::Plugin::DefaultHelpers;
  use Mojo::Base 'Mojolicious::Plugin';
  
  use Mojo::ByteStream;
  use Mojo::Collection;
  use Mojo::Exception;
  use Mojo::IOLoop;
  use Mojo::Util qw(dumper hmac_sha1_sum steady_time);
  use Scalar::Util 'blessed';
  
  sub register {
    my ($self, $app) = @_;
  
    # Controller alias helpers
    for my $name (qw(app flash param stash session url_for validation)) {
      $app->helper($name => sub { shift->$name(@_) });
    }
  
    # Stash key shortcuts (should not generate log messages)
    for my $name (qw(extends layout title)) {
      $app->helper($name => sub { shift->stash($name, @_) });
    }
  
    $app->helper(accepts => sub { $_[0]->app->renderer->accepts(@_) });
    $app->helper(b       => sub { shift; Mojo::ByteStream->new(@_) });
    $app->helper(c       => sub { shift; Mojo::Collection->new(@_) });
    $app->helper(config  => sub { shift->app->config(@_) });
  
    $app->helper(content      => sub { _content(0, 0, @_) });
    $app->helper(content_for  => sub { _content(1, 0, @_) });
    $app->helper(content_with => sub { _content(0, 1, @_) });
  
    $app->helper($_ => $self->can("_$_"))
      for qw(csrf_token current_route delay inactivity_timeout is_fresh url_with);
  
    $app->helper(dumper => sub { shift; dumper @_ });
    $app->helper(include => sub { shift->render_to_string(@_) });
  
    $app->helper("reply.$_" => $self->can("_$_")) for qw(asset static);
  
    $app->helper('reply.exception' => sub { _development('exception', @_) });
    $app->helper('reply.not_found' => sub { _development('not_found', @_) });
  
    $app->helper(ua => sub { shift->app->ua });
  }
  
  sub _asset {
    my $c = shift;
    $c->app->static->serve_asset($c, @_);
    $c->rendered;
  }
  
  sub _block { ref $_[0] eq 'CODE' ? $_[0]() : $_[0] }
  
  sub _content {
    my ($append, $replace, $c, $name, $content) = @_;
    $name ||= 'content';
  
    my $hash = $c->stash->{'mojo.content'} ||= {};
    if (defined $content) {
      if ($append) { $hash->{$name} .= _block($content) }
      if ($replace) { $hash->{$name} = _block($content) }
      else          { $hash->{$name} //= _block($content) }
    }
  
    return Mojo::ByteStream->new($hash->{$name} // '');
  }
  
  sub _csrf_token {
    my $c = shift;
    return $c->session->{csrf_token}
      ||= hmac_sha1_sum($$ . steady_time . rand, $c->app->secrets->[0]);
  }
  
  sub _current_route {
    return '' unless my $route = shift->match->endpoint;
    return @_ ? $route->name eq shift : $route->name;
  }
  
  sub _delay {
    my $c     = shift;
    my $tx    = $c->render_later->tx;
    my $delay = Mojo::IOLoop->delay(@_);
    $delay->catch(sub { $c->helpers->reply->exception(pop) and undef $tx })->wait;
  }
  
  sub _development {
    my ($page, $c, $e) = @_;
  
    my $app = $c->app;
    $app->log->error($e = _exception($e) ? $e : Mojo::Exception->new($e)->inspect)
      if $page eq 'exception';
  
    # Filtered stash snapshot
    my $stash = $c->stash;
    my %snapshot = map { $_ => $stash->{$_} }
      grep { !/^mojo\./ and defined $stash->{$_} } keys %$stash;
  
    # Render with fallbacks
    my $mode     = $app->mode;
    my $renderer = $app->renderer;
    my $options  = {
      exception => $page eq 'exception' ? $e : undef,
      format => $stash->{format} || $renderer->default_format,
      handler  => undef,
      snapshot => \%snapshot,
      status   => $page eq 'exception' ? 500 : 404,
      template => "$page.$mode"
    };
    my $bundled = 'mojo/' . ($mode eq 'development' ? 'debug' : $page);
    return $c if _fallbacks($c, $options, $page, $bundled);
    _fallbacks($c, {%$options, format => 'html'}, $page, $bundled);
    return $c;
  }
  
  sub _exception { blessed $_[0] && $_[0]->isa('Mojo::Exception') }
  
  sub _fallbacks {
    my ($c, $options, $template, $bundled) = @_;
  
    # Mode specific template
    return 1 if $c->render_maybe(%$options);
  
    # Normal template
    return 1 if $c->render_maybe(%$options, template => $template);
  
    # Inline template
    my $stash = $c->stash;
    return undef unless $stash->{format} eq 'html';
    delete @$stash{qw(extends layout)};
    return $c->render_maybe($bundled, %$options, handler => 'ep');
  }
  
  sub _inactivity_timeout {
    my ($c, $timeout) = @_;
    my $stream = Mojo::IOLoop->stream($c->tx->connection // '');
    $stream->timeout($timeout) if $stream;
    return $c;
  }
  
  sub _is_fresh {
    my ($c, %options) = @_;
    return $c->app->static->is_fresh($c, \%options);
  }
  
  sub _static {
    my ($c, $file) = @_;
    return !!$c->rendered if $c->app->static->serve($c, $file);
    $c->app->log->debug(qq{Static file "$file" not found});
    return !$c->helpers->reply->not_found;
  }
  
  sub _url_with {
    my $c = shift;
    return $c->url_for(@_)->query($c->req->url->query->clone);
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojolicious::Plugin::DefaultHelpers - Default helpers plugin
  
  =head1 SYNOPSIS
  
    # Mojolicious
    $app->plugin('DefaultHelpers');
  
    # Mojolicious::Lite
    plugin 'DefaultHelpers';
  
  =head1 DESCRIPTION
  
  L<Mojolicious::Plugin::DefaultHelpers> is a collection of helpers for
  L<Mojolicious>.
  
  This is a core plugin, that means it is always enabled and its code a good
  example for learning to build new plugins, you're welcome to fork it.
  
  See L<Mojolicious::Plugins/"PLUGINS"> for a list of plugins that are available
  by default.
  
  =head1 HELPERS
  
  L<Mojolicious::Plugin::DefaultHelpers> implements the following helpers.
  
  =head2 accepts
  
    my $formats = $c->accepts;
    my $format  = $c->accepts('html', 'json', 'txt');
  
  Select best possible representation for resource from C<Accept> request header,
  C<format> stash value or C<format> C<GET>/C<POST> parameter with
  L<Mojolicious::Renderer/"accepts">, defaults to returning the first extension
  if no preference could be detected.
  
    # Check if JSON is acceptable
    $c->render(json => {hello => 'world'}) if $c->accepts('json');
  
    # Check if JSON was specifically requested
    $c->render(json => {hello => 'world'}) if $c->accepts('', 'json');
  
    # Unsupported representation
    $c->render(data => '', status => 204)
      unless my $format = $c->accepts('html', 'json');
  
    # Detected representations to select from
    my @formats = @{$c->accepts};
  
  =head2 app
  
    %= app->secrets->[0]
  
  Alias for L<Mojolicious::Controller/"app">.
  
  =head2 b
  
    %= b('test 123')->b64_encode
  
  Turn string into a L<Mojo::ByteStream> object.
  
  =head2 c
  
    %= c('a', 'b', 'c')->shuffle->join
  
  Turn list into a L<Mojo::Collection> object.
  
  =head2 config
  
    %= config 'something'
  
  Alias for L<Mojo/"config">.
  
  =head2 content
  
    %= content foo => begin
      test
    % end
    %= content bar => 'Hello World!'
    %= content 'foo'
    %= content 'bar'
    %= content
  
  Store partial rendered content in a named buffer and retrieve it later,
  defaults to retrieving the named buffer C<content>, which is used by the
  renderer for the C<layout> and C<extends> features. New content will be ignored
  if the named buffer is already in use.
  
  =head2 content_for
  
    % content_for foo => begin
      test
    % end
    %= content_for 'foo'
  
  Same as L</"content">, but appends content to named buffers if they are already
  in use.
  
    % content_for message => begin
      Hello
    % end
    % content_for message => begin
      world!
    % end
    %= content 'message'
  
  =head2 content_with
  
    % content_with foo => begin
      test
    % end
    %= content_with 'foo'
  
  Same as L</"content">, but replaces content of named buffers if they are
  already in use.
  
    % content message => begin
      world!
    % end
    % content_with message => begin
      Hello <%= content 'message' %>
    % end
    %= content 'message'
  
  =head2 csrf_token
  
    %= csrf_token
  
  Get CSRF token from L</"session">, and generate one if none exists.
  
  =head2 current_route
  
    % if (current_route 'login') {
      Welcome to Mojolicious!
    % }
    %= current_route
  
  Check or get name of current route.
  
  =head2 delay
  
    $c->delay(sub {...}, sub {...});
  
  Disable automatic rendering and use L<Mojo::IOLoop/"delay"> to manage callbacks
  and control the flow of events, which can help you avoid deep nested closures
  that often result from continuation-passing style. Also keeps a reference to
  L<Mojolicious::Controller/"tx"> in case the underlying connection gets closed
  early, and calls L</"reply-E<gt>exception"> if an exception gets thrown in one
  of the steps, breaking the chain.
  
    # Longer version
    $c->render_later;
    my $tx    = $c->tx;
    my $delay = Mojo::IOLoop->delay(sub {...}, sub {...});
    $delay->catch(sub { $c->reply->exception(pop) and undef $tx })->wait;
  
    # Non-blocking request
    $c->delay(
      sub {
        my $delay = shift;
        $c->ua->get('http://mojolicious.org' => $delay->begin);
      },
      sub {
        my ($delay, $tx) = @_;
        $c->render(json => {title => $tx->result->dom->at('title')->text});
      }
    );
  
  =head2 dumper
  
    %= dumper {some => 'data'}
  
  Dump a Perl data structure with L<Mojo::Util/"dumper">, very useful for
  debugging.
  
  =head2 extends
  
    % extends 'blue';
    % extends 'blue', title => 'Blue!';
  
  Set C<extends> stash value, all additional key/value pairs get merged into the
  L</"stash">.
  
  =head2 flash
  
    %= flash 'foo'
  
  Alias for L<Mojolicious::Controller/"flash">.
  
  =head2 inactivity_timeout
  
    $c = $c->inactivity_timeout(3600);
  
  Use L<Mojo::IOLoop/"stream"> to find the current connection and increase
  timeout if possible.
  
    # Longer version
    Mojo::IOLoop->stream($c->tx->connection)->timeout(3600);
  
  =head2 include
  
    %= include 'menubar'
    %= include 'menubar', format => 'txt'
  
  Alias for L<Mojolicious::Controller/"render_to_string">.
  
  =head2 is_fresh
  
    my $bool = $c->is_fresh;
    my $bool = $c->is_fresh(etag => 'abc');
    my $bool = $c->is_fresh(last_modified => $epoch);
  
  Check freshness of request by comparing the C<If-None-Match> and
  C<If-Modified-Since> request headers to the C<ETag> and C<Last-Modified>
  response headers with L<Mojolicious::Static/"is_fresh">.
  
    # Add ETag/Last-Modified headers and check freshness before rendering
    $c->is_fresh(etag => 'abc', last_modified => 1424985708)
      ? $c->rendered(304)
      : $c->render(text => 'I  Mojolicious!');
  
  =head2 layout
  
    % layout 'green';
    % layout 'green', title => 'Green!';
  
  Set C<layout> stash value, all additional key/value pairs get merged into the
  L</"stash">.
  
  =head2 param
  
    %= param 'foo'
  
  Alias for L<Mojolicious::Controller/"param">.
  
  =head2 reply->asset
  
    $c->reply->asset(Mojo::Asset::File->new);
  
  Reply with a L<Mojo::Asset::File> or L<Mojo::Asset::Memory> object using
  L<Mojolicious::Static/"serve_asset">, and perform content negotiation with
  C<Range>, C<If-Modified-Since> and C<If-None-Match> headers.
  
    # Serve asset with custom modification time
    my $asset = Mojo::Asset::Memory->new;
    $asset->add_chunk('Hello World!')->mtime(784111777);
    $c->res->headers->content_type('text/plain');
    $c->reply->asset($asset);
  
    # Serve static file if it exists
    if (my $asset = $c->app->static->file('images/logo.png')) {
      $c->res->headers->content_type('image/png');
      $c->reply->asset($asset);
    }
  
  =head2 reply->exception
  
    $c = $c->reply->exception('Oops!');
    $c = $c->reply->exception(Mojo::Exception->new);
  
  Render the exception template C<exception.$mode.$format.*> or
  C<exception.$format.*> and set the response status code to C<500>. Also sets
  the stash values C<exception> to a L<Mojo::Exception> object and C<snapshot> to
  a copy of the L</"stash"> for use in the templates.
  
  =head2 reply->not_found
  
    $c = $c->reply->not_found;
  
  Render the not found template C<not_found.$mode.$format.*> or
  C<not_found.$format.*> and set the response status code to C<404>. Also sets
  the stash value C<snapshot> to a copy of the L</"stash"> for use in the
  templates.
  
  =head2 reply->static
  
    my $bool = $c->reply->static('images/logo.png');
    my $bool = $c->reply->static('../lib/MyApp.pm');
  
  Reply with a static file using L<Mojolicious/"static">, usually from the
  C<public> directories or C<DATA> sections of your application. Note that this
  helper uses a relative path, but does not protect from traversing to parent
  directories.
  
    # Serve file with a custom content type
    $c->res->headers->content_type('application/myapp');
    $c->reply->static('foo.txt');
  
  =head2 session
  
    %= session 'foo'
  
  Alias for L<Mojolicious::Controller/"session">.
  
  =head2 stash
  
    %= stash 'foo'
    % stash foo => 'bar';
  
  Alias for L<Mojolicious::Controller/"stash">.
  
    %= stash('name') // 'Somebody'
  
  =head2 title
  
    %= title
    % title 'Welcome!';
    % title 'Welcome!', foo => 'bar';
  
  Get or set C<title> stash value, all additional key/value pairs get merged into
  the L</"stash">.
  
  =head2 ua
  
    %= ua->get('mojolicious.org')->result->dom->at('title')->text
  
  Alias for L<Mojo/"ua">.
  
  =head2 url_for
  
    %= url_for 'named', controller => 'bar', action => 'baz'
  
  Alias for L<Mojolicious::Controller/"url_for">.
  
    %= url_for('/index.html')->query(foo => 'bar')
  
  =head2 url_with
  
    %= url_with 'named', controller => 'bar', action => 'baz'
  
  Does the same as L</"url_for">, but inherits query parameters from the current
  request.
  
    %= url_with->query([page => 2])
  
  =head2 validation
  
    %= validation->param('foo')
  
  Alias for L<Mojolicious::Controller/"validation">.
  
  =head1 METHODS
  
  L<Mojolicious::Plugin::DefaultHelpers> inherits all methods from
  L<Mojolicious::Plugin> and implements the following new ones.
  
  =head2 register
  
    $plugin->register(Mojolicious->new);
  
  Register helpers in L<Mojolicious> application.
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<http://mojolicious.org>.
  
  =cut
MOJOLICIOUS_PLUGIN_DEFAULTHELPERS

$fatpacked{"Mojolicious/Plugin/EPLRenderer.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJOLICIOUS_PLUGIN_EPLRENDERER';
  package Mojolicious::Plugin::EPLRenderer;
  use Mojo::Base 'Mojolicious::Plugin';
  
  use Mojo::Template;
  use Mojo::Util qw(encode md5_sum);
  
  sub register {
    my ($self, $app) = @_;
    $app->renderer->add_handler(
      epl => sub { _render(@_, Mojo::Template->new, $_[1]) });
  }
  
  sub _render {
    my ($renderer, $c, $output, $options, $mt, @args) = @_;
  
    # Cached
    if ($mt->compiled) {
      $c->app->log->debug("Rendering cached @{[$mt->name]}");
      $$output = $mt->process(@args);
    }
  
    # Not cached
    else {
      my $inline = $options->{inline};
      my $name = defined $inline ? md5_sum encode('UTF-8', $inline) : undef;
      return unless defined($name //= $renderer->template_name($options));
  
      # Inline
      if (defined $inline) {
        $c->app->log->debug(qq{Rendering inline template "$name"});
        $$output = $mt->name(qq{inline template "$name"})->render($inline, @args);
      }
  
      # File
      else {
        if (my $encoding = $renderer->encoding) { $mt->encoding($encoding) }
  
        # Try template
        if (defined(my $path = $renderer->template_path($options))) {
          $c->app->log->debug(qq{Rendering template "$name"});
          $$output = $mt->name(qq{template "$name"})->render_file($path, @args);
        }
  
        # Try DATA section
        elsif (defined(my $d = $renderer->get_data_template($options))) {
          $c->app->log->debug(qq{Rendering template "$name" from DATA section});
          $$output = $mt->name(qq{template "$name" from DATA section})
            ->render($d, @args);
        }
  
        # No template
        else { $c->app->log->debug(qq{Template "$name" not found}) }
      }
    }
  
    # Exception
    die $$output if ref $$output;
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojolicious::Plugin::EPLRenderer - Embedded Perl Lite renderer plugin
  
  =head1 SYNOPSIS
  
    # Mojolicious
    $app->plugin('EPLRenderer');
  
    # Mojolicious::Lite
    plugin 'EPLRenderer';
  
  =head1 DESCRIPTION
  
  L<Mojolicious::Plugin::EPLRenderer> is a renderer for C<epl> templates, which
  are pretty much just raw L<Mojo::Template>.
  
  This is a core plugin, that means it is always enabled and its code a good
  example for learning to build new plugins, you're welcome to fork it.
  
  See L<Mojolicious::Plugins/"PLUGINS"> for a list of plugins that are available
  by default.
  
  =head1 METHODS
  
  L<Mojolicious::Plugin::EPLRenderer> inherits all methods from
  L<Mojolicious::Plugin> and implements the following new ones.
  
  =head2 register
  
    $plugin->register(Mojolicious->new);
  
  Register renderer in L<Mojolicious> application.
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<http://mojolicious.org>.
  
  =cut
MOJOLICIOUS_PLUGIN_EPLRENDERER

$fatpacked{"Mojolicious/Plugin/EPRenderer.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJOLICIOUS_PLUGIN_EPRENDERER';
  package Mojolicious::Plugin::EPRenderer;
  use Mojo::Base 'Mojolicious::Plugin::EPLRenderer';
  
  use Mojo::Template;
  use Mojo::Util qw(encode md5_sum monkey_patch);
  
  sub DESTROY { Mojo::Util::_teardown(shift->{namespace}) }
  
  sub register {
    my ($self, $app, $conf) = @_;
  
    # Auto escape by default to prevent XSS attacks
    my $ep = {auto_escape => 1, %{$conf->{template} || {}}, vars => 1};
    my $ns = $self->{namespace} = $ep->{namespace}
      //= 'Mojo::Template::Sandbox::' . md5_sum "$self";
  
    # Make "$self" and "$c" available in templates
    $ep->{prepend} = 'my $self = my $c = _C;' . ($ep->{prepend} // '');
  
    # Add "ep" handler and make it the default
    $app->renderer->default_handler('ep')->add_handler(
      $conf->{name} || 'ep' => sub {
        my ($renderer, $c, $output, $options) = @_;
  
        my $name = $options->{inline} // $renderer->template_name($options);
        return unless defined $name;
        my $key = md5_sum encode 'UTF-8', $name;
  
        my $cache = $renderer->cache;
        my $mt    = $cache->get($key);
        $cache->set($key => $mt = Mojo::Template->new($ep)) unless $mt;
  
        # Export helpers only once
        ++$self->{helpers} and _helpers($ns, $renderer->helpers)
          unless $self->{helpers};
  
        # Make current controller available and render with "epl" handler
        no strict 'refs';
        no warnings 'redefine';
        local *{"${ns}::_C"} = sub {$c};
        Mojolicious::Plugin::EPLRenderer::_render($renderer, $c, $output,
          $options, $mt, $c->stash);
      }
    );
  }
  
  sub _helpers {
    my ($class, $helpers) = @_;
    for my $method (grep {/^\w+$/} keys %$helpers) {
      my $sub = $helpers->{$method};
      monkey_patch $class, $method, sub { $class->_C->$sub(@_) };
    }
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojolicious::Plugin::EPRenderer - Embedded Perl renderer plugin
  
  =head1 SYNOPSIS
  
    # Mojolicious
    $app->plugin('EPRenderer');
    $app->plugin(EPRenderer => {name => 'foo'});
    $app->plugin(EPRenderer => {name => 'bar', template => {line_start => '.'}});
  
    # Mojolicious::Lite
    plugin 'EPRenderer';
    plugin EPRenderer => {name => 'foo'};
    plugin EPRenderer => {name => 'bar', template => {line_start => '.'}};
  
  =head1 DESCRIPTION
  
  L<Mojolicious::Plugin::EPRenderer> is a renderer for Embedded Perl templates.
  For more information see L<Mojolicious::Guides::Rendering/"Embedded Perl">.
  
  This is a core plugin, that means it is always enabled and its code a good
  example for learning to build new plugins, you're welcome to fork it.
  
  See L<Mojolicious::Plugins/"PLUGINS"> for a list of plugins that are available
  by default.
  
  =head1 OPTIONS
  
  L<Mojolicious::Plugin::EPRenderer> supports the following options.
  
  =head2 name
  
    # Mojolicious::Lite
    plugin EPRenderer => {name => 'foo'};
  
  Handler name, defaults to C<ep>.
  
  =head2 template
  
    # Mojolicious::Lite
    plugin EPRenderer => {template => {line_start => '.'}};
  
  Attribute values passed to L<Mojo::Template> object used to render templates.
  
  =head1 METHODS
  
  L<Mojolicious::Plugin::EPRenderer> inherits all methods from
  L<Mojolicious::Plugin::EPLRenderer> and implements the following new ones.
  
  =head2 register
  
    $plugin->register(Mojolicious->new);
    $plugin->register(Mojolicious->new, {name => 'foo'});
  
  Register renderer in L<Mojolicious> application.
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<http://mojolicious.org>.
  
  =cut
MOJOLICIOUS_PLUGIN_EPRENDERER

$fatpacked{"Mojolicious/Plugin/HeaderCondition.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJOLICIOUS_PLUGIN_HEADERCONDITION';
  package Mojolicious::Plugin::HeaderCondition;
  use Mojo::Base 'Mojolicious::Plugin';
  
  sub register {
    my ($self, $app) = @_;
  
    $app->routes->add_condition(headers => \&_headers);
    $app->routes->add_condition(
      agent => sub { _headers(@_[0 .. 2], {'User-Agent' => $_[3]}) });
    $app->routes->add_condition(
      host => sub { _check($_[1]->req->url->to_abs->host, $_[3]) });
  }
  
  sub _check {
    my ($value, $pattern) = @_;
    return 1
      if $value && $pattern && ref $pattern eq 'Regexp' && $value =~ $pattern;
    return $value && defined $pattern && $pattern eq $value;
  }
  
  sub _headers {
    my ($route, $c, $captures, $patterns) = @_;
    return undef unless $patterns && ref $patterns eq 'HASH' && keys %$patterns;
  
    # All headers need to match
    my $headers = $c->req->headers;
    _check($headers->header($_), $patterns->{$_}) || return undef
      for keys %$patterns;
    return 1;
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojolicious::Plugin::HeaderCondition - Header condition plugin
  
  =head1 SYNOPSIS
  
    # Mojolicious
    $app->plugin('HeaderCondition');
    $app->routes->get('/:controller/:action')
      ->over(headers => {Referer => qr/example\.com/});
  
    # Mojolicious::Lite
    plugin 'HeaderCondition';
    get '/' => (headers => {Referer => qr/example\.com/}) => sub {...};
  
    # All headers need to match
    $app->routes->get('/:controller/:action')->over(headers => {
      'X-Secret-Header' => 'Foo',
      Referer => qr/example\.com/
    });
  
    # The "agent" condition is a shortcut for the "User-Agent" header
    get '/' => (agent => qr/Firefox/) => sub {...};
  
    # The "host" condition is a shortcut for the detected host
    get '/' => (host => qr/mojolicious\.org/) => sub {...};
  
  =head1 DESCRIPTION
  
  L<Mojolicious::Plugin::HeaderCondition> is a route condition for header-based
  routes.
  
  This is a core plugin, that means it is always enabled and its code a good
  example for learning to build new plugins, you're welcome to fork it.
  
  See L<Mojolicious::Plugins/"PLUGINS"> for a list of plugins that are available
  by default.
  
  =head1 METHODS
  
  L<Mojolicious::Plugin::HeaderCondition> inherits all methods from
  L<Mojolicious::Plugin> and implements the following new ones.
  
  =head2 register
  
    $plugin->register(Mojolicious->new);
  
  Register conditions in L<Mojolicious> application.
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<http://mojolicious.org>.
  
  =cut
MOJOLICIOUS_PLUGIN_HEADERCONDITION

$fatpacked{"Mojolicious/Plugin/JSONConfig.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJOLICIOUS_PLUGIN_JSONCONFIG';
  package Mojolicious::Plugin::JSONConfig;
  use Mojo::Base 'Mojolicious::Plugin::Config';
  
  use Mojo::JSON 'from_json';
  use Mojo::Template;
  
  sub parse {
    my ($self, $content, $file, $conf, $app) = @_;
  
    my $config = eval { from_json $self->render($content, $file, $conf, $app) };
    die qq{Can't parse config "$file": $@} if $@;
    die qq{Invalid config "$file"} unless ref $config eq 'HASH';
  
    return $config;
  }
  
  sub register { shift->SUPER::register(shift, {ext => 'json', %{shift()}}) }
  
  sub render {
    my ($self, $content, $file, $conf, $app) = @_;
  
    # Application instance and helper
    my $prepend = q[no strict 'refs'; no warnings 'redefine';];
    $prepend .= q[my $app = shift; sub app; local *app = sub { $app };];
    $prepend .= q[use Mojo::Base -strict; no warnings 'ambiguous';];
  
    my $mt = Mojo::Template->new($conf->{template} || {})->name($file);
    my $output = $mt->prepend($prepend . $mt->prepend)->render($content, $app);
    return ref $output ? die $output : $output;
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojolicious::Plugin::JSONConfig - JSON configuration plugin
  
  =head1 SYNOPSIS
  
    # myapp.json (it's just JSON with embedded Perl)
    {
      %# Just a value
      "foo": "bar",
  
      %# Nested data structures are fine too
      "baz": [""],
  
      %# You have full access to the application
      "music_dir": "<%= app->home->child('music') %>"
    }
  
    # Mojolicious
    my $config = $app->plugin('JSONConfig');
    say $config->{foo};
  
    # Mojolicious::Lite
    my $config = plugin 'JSONConfig';
    say $config->{foo};
  
    # foo.html.ep
    %= $config->{foo}
  
    # The configuration is available application-wide
    my $config = app->config;
    say $config->{foo};
  
    # Everything can be customized with options
    my $config = plugin JSONConfig => {file => '/etc/myapp.conf'};
  
  =head1 DESCRIPTION
  
  L<Mojolicious::Plugin::JSONConfig> is a JSON configuration plugin that
  preprocesses its input with L<Mojo::Template>.
  
  The application object can be accessed via C<$app> or the C<app> function. A
  default configuration filename in the application home directory will be
  generated from the value of L<Mojolicious/"moniker"> (C<$moniker.json>). You can
  extend the normal configuration file C<$moniker.json> with C<mode> specific ones
  like C<$moniker.$mode.json>, which will be detected automatically.
  
  If the configuration value C<config_override> has been set in L<Mojo/"config">
  when this plugin is loaded, it will not do anything.
  
  The code of this plugin is a good example for learning to build new plugins,
  you're welcome to fork it.
  
  See L<Mojolicious::Plugins/"PLUGINS"> for a list of plugins that are available
  by default.
  
  =head1 OPTIONS
  
  L<Mojolicious::Plugin::JSONConfig> inherits all options from
  L<Mojolicious::Plugin::Config> and supports the following new ones.
  
  =head2 template
  
    # Mojolicious::Lite
    plugin JSONConfig => {template => {line_start => '.'}};
  
  Attribute values passed to L<Mojo::Template> object used to preprocess
  configuration files.
  
  =head1 METHODS
  
  L<Mojolicious::Plugin::JSONConfig> inherits all methods from
  L<Mojolicious::Plugin::Config> and implements the following new ones.
  
  =head2 parse
  
    $plugin->parse($content, $file, $conf, $app);
  
  Process content with L</"render"> and parse it with L<Mojo::JSON>.
  
    sub parse {
      my ($self, $content, $file, $conf, $app) = @_;
      ...
      $content = $self->render($content, $file, $conf, $app);
      ...
      return $hash;
    }
  
  =head2 register
  
    my $config = $plugin->register(Mojolicious->new);
    my $config = $plugin->register(Mojolicious->new, {file => '/etc/foo.conf'});
  
  Register plugin in L<Mojolicious> application and merge configuration.
  
  =head2 render
  
    $plugin->render($content, $file, $conf, $app);
  
  Process configuration file with L<Mojo::Template>.
  
    sub render {
      my ($self, $content, $file, $conf, $app) = @_;
      ...
      return $content;
    }
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<http://mojolicious.org>.
  
  =cut
MOJOLICIOUS_PLUGIN_JSONCONFIG

$fatpacked{"Mojolicious/Plugin/Mount.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJOLICIOUS_PLUGIN_MOUNT';
  package Mojolicious::Plugin::Mount;
  use Mojo::Base 'Mojolicious::Plugin';
  
  use Mojo::Server;
  
  sub register {
    my ($self, $app, $conf) = @_;
  
    my $path  = (keys %$conf)[0];
    my $embed = Mojo::Server->new->load_app($conf->{$path});
    $embed->secrets($app->secrets);
  
    # Extract host
    my $host;
    ($host, $path) = ($1 ? qr/^(?:.*\.)?\Q$2\E$/i : qr/^\Q$2\E$/i, $3)
      if $path =~ m!^(\*\.)?([^/]+)(/.*)?$!;
  
    my $route = $app->routes->route($path)->detour(app => $embed);
    return $host ? $route->over(host => $host) : $route;
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojolicious::Plugin::Mount - Application mount plugin
  
  =head1 SYNOPSIS
  
    # Mojolicious
    my $route = $app->plugin(Mount => {'/prefix' => '/home/sri/myapp.pl'});
  
    # Mojolicious::Lite
    my $route = plugin Mount => {'/prefix' => '/home/sri/myapp.pl'};
  
    # Adjust the generated route and mounted application
    my $example = plugin Mount => {'/example' => '/home/sri/example.pl'};
    $example->to(message => 'It works great!');
    my $app = $example->pattern->defaults->{app};
    $app->config(foo => 'bar');
    $app->log(app->log);
  
    # Mount application with host
    plugin Mount => {'example.com' => '/home/sri/myapp.pl'};
  
    # Host and path
    plugin Mount => {'example.com/myapp' => '/home/sri/myapp.pl'};
  
    # Or even hosts with wildcard subdomains
    plugin Mount => {'*.example.com/myapp' => '/home/sri/myapp.pl'};
  
  =head1 DESCRIPTION
  
  L<Mojolicious::Plugin::Mount> is a plugin that allows you to mount whole
  L<Mojolicious> applications.
  
  The code of this plugin is a good example for learning to build new plugins,
  you're welcome to fork it.
  
  See L<Mojolicious::Plugins/"PLUGINS"> for a list of plugins that are available
  by default.
  
  =head1 METHODS
  
  L<Mojolicious::Plugin::Mount> inherits all methods from L<Mojolicious::Plugin>
  and implements the following new ones.
  
  =head2 register
  
    my $route = $plugin->register(Mojolicious->new, {'/foo' => '/some/app.pl'});
  
  Mount L<Mojolicious> application and return the generated route, which is
  usually a L<Mojolicious::Routes::Route> object.
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<http://mojolicious.org>.
  
  =cut
MOJOLICIOUS_PLUGIN_MOUNT

$fatpacked{"Mojolicious/Plugin/PODRenderer.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJOLICIOUS_PLUGIN_PODRENDERER';
  package Mojolicious::Plugin::PODRenderer;
  use Mojo::Base 'Mojolicious::Plugin';
  
  use Mojo::Asset::File;
  use Mojo::ByteStream;
  use Mojo::DOM;
  use Mojo::File 'path';
  use Mojo::URL;
  use Pod::Simple::XHTML;
  use Pod::Simple::Search;
  
  sub register {
    my ($self, $app, $conf) = @_;
  
    my $preprocess = $conf->{preprocess} || 'ep';
    $app->renderer->add_handler(
      $conf->{name} || 'pod' => sub {
        my ($renderer, $c, $output, $options) = @_;
        $renderer->handlers->{$preprocess}($renderer, $c, $output, $options);
        $$output = _pod_to_html($$output) if defined $$output;
      }
    );
  
    $app->helper(
      pod_to_html => sub { shift; Mojo::ByteStream->new(_pod_to_html(@_)) });
  
    # Perldoc browser
    return undef if $conf->{no_perldoc};
    my $defaults = {module => 'Mojolicious/Guides', format => 'html'};
    return $app->routes->any(
      '/perldoc/:module' => $defaults => [module => qr/[^.]+/] => \&_perldoc);
  }
  
  sub _indentation {
    (sort map {/^(\s+)/} @{shift()})[0];
  }
  
  sub _html {
    my ($c, $src) = @_;
  
    # Rewrite links
    my $dom     = Mojo::DOM->new(_pod_to_html($src));
    my $perldoc = $c->url_for('/perldoc/');
    $_->{href} =~ s!^https://metacpan\.org/pod/!$perldoc!
      and $_->{href} =~ s!::!/!gi
      for $dom->find('a[href]')->map('attr')->each;
  
    # Rewrite code blocks for syntax highlighting and correct indentation
    for my $e ($dom->find('pre > code')->each) {
      my $str = $e->content;
      next if $str =~ /^\s*(?:\$|Usage:)\s+/m || $str !~ /[\$\@\%]\w|-&gt;\w/m;
      my $attrs = $e->attr;
      my $class = $attrs->{class};
      $attrs->{class} = defined $class ? "$class prettyprint" : 'prettyprint';
    }
  
    # Rewrite headers
    my $toc = Mojo::URL->new->fragment('toc');
    my @parts;
    for my $e ($dom->find('h1, h2, h3, h4')->each) {
  
      push @parts, [] if $e->tag eq 'h1' || !@parts;
      my $link = Mojo::URL->new->fragment($e->{id});
      push @{$parts[-1]}, my $text = $e->all_text, $link;
      my $permalink = $c->link_to('#' => $link, class => 'permalink');
      $e->content($permalink . $c->link_to($text => $toc));
    }
  
    # Try to find a title
    my $title = 'Perldoc';
    $dom->find('h1 + p')->first(sub { $title = shift->text });
  
    # Combine everything to a proper response
    $c->content_for(perldoc => "$dom");
    $c->render('mojo/perldoc', title => $title, parts => \@parts);
  }
  
  sub _perldoc {
    my $c = shift;
  
    # Find module or redirect to CPAN
    my $module = join '::', split('/', $c->param('module'));
    my $path
      = Pod::Simple::Search->new->find($module, map { $_, "$_/pods" } @INC);
    return $c->redirect_to("https://metacpan.org/pod/$module")
      unless $path && -r $path;
  
    my $src = path($path)->slurp;
    $c->respond_to(txt => {data => $src}, html => sub { _html($c, $src) });
  }
  
  sub _pod_to_html {
    return '' unless defined(my $pod = ref $_[0] eq 'CODE' ? shift->() : shift);
  
    my $parser = Pod::Simple::XHTML->new;
    $parser->perldoc_url_prefix('https://metacpan.org/pod/');
    $parser->$_('') for qw(html_header html_footer);
    $parser->strip_verbatim_indent(\&_indentation);
    $parser->output_string(\(my $output));
    return $@ unless eval { $parser->parse_string_document("$pod"); 1 };
  
    return $output;
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojolicious::Plugin::PODRenderer - POD renderer plugin
  
  =head1 SYNOPSIS
  
    # Mojolicious (with documentation browser under "/perldoc")
    my $route = $app->plugin('PODRenderer');
    my $route = $app->plugin(PODRenderer => {name => 'foo'});
    my $route = $app->plugin(PODRenderer => {preprocess => 'epl'});
  
    # Mojolicious::Lite (with documentation browser under "/perldoc")
    my $route = plugin 'PODRenderer';
    my $route = plugin PODRenderer => {name => 'foo'};
    my $route = plugin PODRenderer => {preprocess => 'epl'};
  
    # Without documentation browser
    plugin PODRenderer => {no_perldoc => 1};
  
    # foo.html.ep
    %= pod_to_html "=head1 TEST\n\nC<123>"
  
    # foo.html.pod
    =head1 <%= uc 'test' %>
  
  =head1 DESCRIPTION
  
  L<Mojolicious::Plugin::PODRenderer> is a renderer for true Perl hackers, rawr!
  
  The code of this plugin is a good example for learning to build new plugins,
  you're welcome to fork it.
  
  See L<Mojolicious::Plugins/"PLUGINS"> for a list of plugins that are available
  by default.
  
  =head1 OPTIONS
  
  L<Mojolicious::Plugin::PODRenderer> supports the following options.
  
  =head2 name
  
    # Mojolicious::Lite
    plugin PODRenderer => {name => 'foo'};
  
  Handler name, defaults to C<pod>.
  
  =head2 no_perldoc
  
    # Mojolicious::Lite
    plugin PODRenderer => {no_perldoc => 1};
  
  Disable L<Mojolicious::Guides> documentation browser that will otherwise be
  available under C</perldoc>.
  
  =head2 preprocess
  
    # Mojolicious::Lite
    plugin PODRenderer => {preprocess => 'epl'};
  
  Name of handler used to preprocess POD, defaults to C<ep>.
  
  =head1 HELPERS
  
  L<Mojolicious::Plugin::PODRenderer> implements the following helpers.
  
  =head2 pod_to_html
  
    %= pod_to_html '=head2 lalala'
    <%= pod_to_html begin %>=head2 lalala<% end %>
  
  Render POD to HTML without preprocessing.
  
  =head1 METHODS
  
  L<Mojolicious::Plugin::PODRenderer> inherits all methods from
  L<Mojolicious::Plugin> and implements the following new ones.
  
  =head2 register
  
    my $route = $plugin->register(Mojolicious->new);
    my $route = $plugin->register(Mojolicious->new, {name => 'foo'});
  
  Register renderer and helper in L<Mojolicious> application.
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<http://mojolicious.org>.
  
  =cut
MOJOLICIOUS_PLUGIN_PODRENDERER

$fatpacked{"Mojolicious/Plugin/TagHelpers.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJOLICIOUS_PLUGIN_TAGHELPERS';
  package Mojolicious::Plugin::TagHelpers;
  use Mojo::Base 'Mojolicious::Plugin';
  
  use Mojo::ByteStream;
  use Mojo::DOM::HTML;
  use Scalar::Util 'blessed';
  
  sub register {
    my ($self, $app) = @_;
  
    # Text field variations
    my @time = qw(date month time week);
    for my $name (@time, qw(color email number range search tel text url)) {
      $app->helper("${name}_field" => sub { _input(@_, type => $name) });
    }
    $app->helper(datetime_field => sub { _input(@_, type => 'datetime-local') });
  
    my @helpers = (
      qw(csrf_field form_for hidden_field javascript label_for link_to),
      qw(select_field stylesheet submit_button tag_with_error text_area)
    );
    $app->helper($_ => __PACKAGE__->can("_$_")) for @helpers;
  
    $app->helper(button_to => sub { _button_to(0, @_) });
    $app->helper(check_box => sub { _input(@_, type => 'checkbox') });
    $app->helper(csrf_button_to => sub { _button_to(1, @_) });
    $app->helper(file_field => sub { _empty_field('file', @_) });
    $app->helper(image => sub { _tag('img', src => shift->url_for(shift), @_) });
    $app->helper(input_tag      => sub { _input(@_) });
    $app->helper(password_field => sub { _empty_field('password', @_) });
    $app->helper(radio_button   => sub { _input(@_, type => 'radio') });
  
    # "t" is just a shortcut for the "tag" helper
    $app->helper($_ => sub { shift; _tag(@_) }) for qw(t tag);
  }
  
  sub _button_to {
    my ($csrf, $c, $text) = (shift, shift, shift);
    my $prefix = $csrf ? _csrf_field($c) : '';
    return _form_for($c, @_, sub { $prefix . _submit_button($c, $text) });
  }
  
  sub _csrf_field {
    my $c = shift;
    return _hidden_field($c, csrf_token => $c->helpers->csrf_token, @_);
  }
  
  sub _empty_field {
    my ($type, $c, $name) = (shift, shift, shift);
    return _validation($c, $name, 'input', name => $name, @_, type => $type);
  }
  
  sub _form_for {
    my ($c, @url) = (shift, shift);
    push @url, shift if ref $_[0] eq 'HASH';
  
    # Method detection
    my $r      = $c->app->routes->lookup($url[0]);
    my $method = $r ? $r->suggested_method : 'GET';
    my @post   = $method ne 'GET' ? (method => 'POST') : ();
  
    my $url = $c->url_for(@url);
    $url->query({_method => $method}) if @post && $method ne 'POST';
    return _tag('form', action => $url, @post, @_);
  }
  
  sub _hidden_field {
    my ($c, $name, $value) = (shift, shift, shift);
    return _tag('input', name => $name, value => $value, @_, type => 'hidden');
  }
  
  sub _input {
    my ($c, $name) = (shift, shift);
    my %attrs = @_ % 2 ? (value => shift, @_) : @_;
  
    if (my @values = @{$c->every_param($name)}) {
  
      # Checkbox or radiobutton
      my $type = $attrs{type} || '';
      if ($type eq 'checkbox' || $type eq 'radio') {
        delete $attrs{checked} if @values;
        my $value = $attrs{value} // 'on';
        $attrs{checked} = undef if grep { $_ eq $value } @values;
      }
  
      # Others
      else { $attrs{value} = $values[-1] }
    }
  
    return _validation($c, $name, 'input', name => $name, %attrs);
  }
  
  sub _javascript {
    my $c = shift;
    my $content
      = ref $_[-1] eq 'CODE' ? "//<![CDATA[\n" . pop->() . "\n//]]>" : '';
    my @src = @_ % 2 ? (src => $c->url_for(shift)) : ();
    return _tag('script', @src, @_, sub {$content});
  }
  
  sub _label_for {
    my ($c, $name) = (shift, shift);
    my $content = ref $_[-1] eq 'CODE' ? pop : shift;
    return _validation($c, $name, 'label', for => $name, @_, $content);
  }
  
  sub _link_to {
    my ($c, $content) = (shift, shift);
    my @url = ($content);
  
    # Content
    unless (ref $_[-1] eq 'CODE') {
      @url = (shift);
      push @_, $content;
    }
  
    # Captures
    push @url, shift if ref $_[0] eq 'HASH';
  
    return _tag('a', href => $c->url_for(@url), @_);
  }
  
  sub _option {
    my ($values, $pair) = @_;
  
    $pair = [$pair => $pair] unless ref $pair eq 'ARRAY';
    my %attrs = (value => $pair->[1], @$pair[2 .. $#$pair]);
    delete $attrs{selected} if keys %$values;
    $attrs{selected} = undef if $values->{$pair->[1]};
  
    return _tag('option', %attrs, $pair->[0]);
  }
  
  sub _select_field {
    my ($c, $name, $options, %attrs) = (shift, shift, shift, @_);
  
    my %values = map { $_ => 1 } @{$c->every_param($name)};
  
    my $groups = '';
    for my $group (@$options) {
  
      # "optgroup" tag
      if (blessed $group && $group->isa('Mojo::Collection')) {
        my ($label, $values, %attrs) = @$group;
        my $content = join '', map { _option(\%values, $_) } @$values;
        $groups .= _tag('optgroup', label => $label, %attrs, sub {$content});
      }
  
      # "option" tag
      else { $groups .= _option(\%values, $group) }
    }
  
    return _validation($c, $name, 'select', name => $name, %attrs, sub {$groups});
  }
  
  sub _stylesheet {
    my $c = shift;
    my $content
      = ref $_[-1] eq 'CODE' ? "/*<![CDATA[*/\n" . pop->() . "\n/*]]>*/" : '';
    return _tag('style', @_, sub {$content}) unless @_ % 2;
    return _tag('link', rel => 'stylesheet', href => $c->url_for(shift), @_);
  }
  
  sub _submit_button {
    my ($c, $value) = (shift, shift // 'Ok');
    return _tag('input', value => $value, @_, type => 'submit');
  }
  
  sub _tag {
    my $tree = ['tag', shift, undef, undef];
  
    # Content
    if (ref $_[-1] eq 'CODE') { push @$tree, ['raw', pop->()] }
    elsif (@_ % 2) { push @$tree, ['text', pop] }
  
    # Attributes
    my $attrs = $tree->[2] = {@_};
    if (ref $attrs->{data} eq 'HASH' && (my $data = delete $attrs->{data})) {
      @$attrs{map { y/_/-/; lc "data-$_" } keys %$data} = values %$data;
    }
  
    return Mojo::ByteStream->new(Mojo::DOM::HTML::_render($tree));
  }
  
  sub _tag_with_error {
    my ($c, $tag) = (shift, shift);
    my ($content, %attrs) = (@_ % 2 ? pop : undef, @_);
    $attrs{class} .= $attrs{class} ? ' field-with-error' : 'field-with-error';
    return _tag($tag, %attrs, defined $content ? $content : ());
  }
  
  sub _text_area {
    my ($c, $name) = (shift, shift);
  
    my $cb = ref $_[-1] eq 'CODE' ? pop : undef;
    my $content = @_ % 2 ? shift : undef;
    $content = $c->param($name) // $content // $cb // '';
  
    return _validation($c, $name, 'textarea', name => $name, @_, $content);
  }
  
  sub _validation {
    my ($c, $name) = (shift, shift);
    return _tag(@_) unless $c->validation->has_error($name);
    return $c->helpers->tag_with_error(@_);
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojolicious::Plugin::TagHelpers - Tag helpers plugin
  
  =head1 SYNOPSIS
  
    # Mojolicious
    $app->plugin('TagHelpers');
  
    # Mojolicious::Lite
    plugin 'TagHelpers';
  
  =head1 DESCRIPTION
  
  L<Mojolicious::Plugin::TagHelpers> is a collection of HTML tag helpers for
  L<Mojolicious>, based on the
  L<HTML Living Standard|https://html.spec.whatwg.org>.
  
  Most form helpers can automatically pick up previous input values and will show
  them as default. You can also use
  L<Mojolicious::Plugin::DefaultHelpers/"param"> to set them manually and let
  necessary attributes always be generated automatically.
  
    % param country => 'germany' unless param 'country';
    <%= radio_button country => 'germany' %> Germany
    <%= radio_button country => 'france'  %> France
    <%= radio_button country => 'uk'      %> UK
  
  For fields that failed validation with L<Mojolicious::Controller/"validation">
  the C<field-with-error> class will be automatically added through
  L</"tag_with_error">, to make styling with CSS easier.
  
    <input class="field-with-error" name="age" type="text" value="250">
  
  This is a core plugin, that means it is always enabled and its code a good
  example for learning how to build new plugins, you're welcome to fork it.
  
  See L<Mojolicious::Plugins/"PLUGINS"> for a list of plugins that are available
  by default.
  
  =head1 HELPERS
  
  L<Mojolicious::Plugin::TagHelpers> implements the following helpers.
  
  =head2 button_to
  
    %= button_to Test => 'some_get_route'
    %= button_to Test => some_get_route => {id => 23} => (class => 'menu')
    %= button_to Test => 'http://example.com/test' => (class => 'menu')
    %= button_to Remove => 'some_delete_route'
  
  Generate portable C<form> tag with L</"form_for">, containing a single button.
  
    <form action="/path/to/get/route">
      <input type="submit" value="Test">
    </form>
    <form action="/path/to/get/route/23" class="menu">
      <input type="submit" value="Test">
    </form>
    <form action="http://example.com/test" class="menu">
      <input type="submit" value="Test">
    </form>
    <form action="/path/to/delete/route?_method=DELETE" method="POST">
      <input type="submit" value="Remove">
    </form>
  
  =head2 check_box
  
    %= check_box 'employed'
    %= check_box employed => 1
    %= check_box employed => 1, checked => undef, id => 'foo'
  
  Generate C<input> tag of type C<checkbox>. Previous input values will
  automatically get picked up and shown as default.
  
    <input name="employed" type="checkbox">
    <input name="employed" type="checkbox" value="1">
    <input checked id="foo" name="employed" type="checkbox" value="1">
  
  =head2 color_field
  
    %= color_field 'background'
    %= color_field background => '#ffffff'
    %= color_field background => '#ffffff', id => 'foo'
  
  Generate C<input> tag of type C<color>. Previous input values will
  automatically get picked up and shown as default.
  
    <input name="background" type="color">
    <input name="background" type="color" value="#ffffff">
    <input id="foo" name="background" type="color" value="#ffffff">
  
  =head2 csrf_button_to
  
    %= csrf_button_to Remove => 'some_delete_route'
  
  Same as L</"button_to">, but also includes a L</"csrf_field">.
  
    <form action="/path/to/delete/route?_method=DELETE" method="POST">
      <input name="csrf_token" type="hidden" value="fa6a08...">
      <input type="submit" value="Remove">
    </form>
  
  =head2 csrf_field
  
    %= csrf_field
  
  Generate C<input> tag of type C<hidden> with
  L<Mojolicious::Plugin::DefaultHelpers/"csrf_token">.
  
    <input name="csrf_token" type="hidden" value="fa6a08...">
  
  =head2 date_field
  
    %= date_field 'end'
    %= date_field end => '2012-12-21'
    %= date_field end => '2012-12-21', id => 'foo'
  
  Generate C<input> tag of type C<date>. Previous input values will automatically
  get picked up and shown as default.
  
    <input name="end" type="date">
    <input name="end" type="date" value="2012-12-21">
    <input id="foo" name="end" type="date" value="2012-12-21">
  
  =head2 datetime_field
  
    %= datetime_field 'end'
    %= datetime_field end => '2012-12-21T23:59:59'
    %= datetime_field end => '2012-12-21T23:59:59', id => 'foo'
  
  Generate C<input> tag of type C<datetime-local>. Previous input values will
  automatically get picked up and shown as default.
  
    <input name="end" type="datetime-local">
    <input name="end" type="datetime-local" value="2012-12-21T23:59:59">
    <input id="foo" name="end" type="datetime-local" value="2012-12-21T23:59:59">
  
  =head2 email_field
  
    %= email_field 'notify'
    %= email_field notify => 'nospam@example.com'
    %= email_field notify => 'nospam@example.com', id => 'foo'
  
  Generate C<input> tag of type C<email>. Previous input values will
  automatically get picked up and shown as default.
  
    <input name="notify" type="email">
    <input name="notify" type="email" value="nospam@example.com">
    <input id="foo" name="notify" type="email" value="nospam@example.com">
  
  =head2 file_field
  
    %= file_field 'avatar'
    %= file_field 'avatar', id => 'foo'
  
  Generate C<input> tag of type C<file>.
  
    <input name="avatar" type="file">
    <input id="foo" name="avatar" type="file">
  
  =head2 form_for
  
    %= form_for login => begin
      %= text_field 'first_name'
      %= submit_button
    % end
    %= form_for login => {format => 'txt'} => (method => 'POST') => begin
      %= text_field 'first_name'
      %= submit_button
    % end
    %= form_for '/login' => (enctype => 'multipart/form-data') => begin
      %= text_field 'first_name', disabled => 'disabled'
      %= submit_button
    % end
    %= form_for 'http://example.com/login' => (method => 'POST') => begin
      %= text_field 'first_name'
      %= submit_button
    % end
    %= form_for some_delete_route => begin
      %= submit_button 'Remove'
    % end
  
  Generate portable C<form> tag with L<Mojolicious::Controller/"url_for">. For
  routes that do not allow C<GET>, a C<method> attribute with the value C<POST>
  will be automatically added. And for methods other than C<GET> or C<POST>, an
  C<_method> query parameter will be added as well.
  
    <form action="/path/to/login">
      <input name="first_name" type="text">
      <input type="submit" value="Ok">
    </form>
    <form action="/path/to/login.txt" method="POST">
      <input name="first_name" type="text">
      <input type="submit" value="Ok">
    </form>
    <form action="/path/to/login" enctype="multipart/form-data">
      <input disabled="disabled" name="first_name" type="text">
      <input type="submit" value="Ok">
    </form>
    <form action="http://example.com/login" method="POST">
      <input name="first_name" type="text">
      <input type="submit" value="Ok">
    </form>
    <form action="/path/to/delete/route?_method=DELETE" method="POST">
      <input type="submit" value="Remove">
    </form>
  
  =head2 hidden_field
  
    %= hidden_field foo => 'bar'
    %= hidden_field foo => 'bar', id => 'bar'
  
  Generate C<input> tag of type C<hidden>.
  
    <input name="foo" type="hidden" value="bar">
    <input id="bar" name="foo" type="hidden" value="bar">
  
  =head2 image
  
    %= image '/images/foo.png'
    %= image '/images/foo.png', alt => 'Foo'
  
  Generate portable C<img> tag.
  
    <img src="/path/to/images/foo.png">
    <img alt="Foo" src="/path/to/images/foo.png">
  
  =head2 input_tag
  
    %= input_tag 'first_name'
    %= input_tag first_name => 'Default'
    %= input_tag 'employed', type => 'checkbox'
  
  Generate C<input> tag. Previous input values will automatically get picked up
  and shown as default.
  
    <input name="first_name">
    <input name="first_name" value="Default">
    <input name="employed" type="checkbox">
  
  =head2 javascript
  
    %= javascript '/script.js'
    %= javascript begin
      var a = 'b';
    % end
  
  Generate portable C<script> tag for JavaScript asset.
  
    <script src="/path/to/script.js"></script>
    <script><![CDATA[
      var a = 'b';
    ]]></script>
  
  =head2 label_for
  
    %= label_for first_name => 'First name'
    %= label_for first_name => 'First name', class => 'user'
    %= label_for first_name => begin
      First name
    % end
    %= label_for first_name => (class => 'user') => begin
      First name
    % end
  
  Generate C<label> tag.
  
    <label for="first_name">First name</label>
    <label class="user" for="first_name">First name</label>
    <label for="first_name">
      First name
    </label>
    <label class="user" for="first_name">
      First name
    </label>
  
  =head2 link_to
  
    %= link_to Home => 'index'
    %= link_to Home => 'index' => {format => 'txt'} => (class => 'menu')
    %= link_to index => {format => 'txt'} => (class => 'menu') => begin
      Home
    % end
    %= link_to Contact => 'mailto:sri@example.com'
    <%= link_to index => begin %>Home<% end %>
    <%= link_to '/file.txt' => begin %>File<% end %>
    <%= link_to 'http://mojolicious.org' => begin %>Mojolicious<% end %>
    <%= link_to url_for->query(foo => 'bar')->to_abs => begin %>Retry<% end %>
  
  Generate portable C<a> tag with L<Mojolicious::Controller/"url_for">, defaults
  to using the capitalized link target as content.
  
    <a href="/path/to/index">Home</a>
    <a class="menu" href="/path/to/index.txt">Home</a>
    <a class="menu" href="/path/to/index.txt">
      Home
    </a>
    <a href="mailto:sri@example.com">Contact</a>
    <a href="/path/to/index">Home</a>
    <a href="/path/to/file.txt">File</a>
    <a href="http://mojolicious.org">Mojolicious</a>
    <a href="http://127.0.0.1:3000/current/path?foo=bar">Retry</a>
  
  =head2 month_field
  
    %= month_field 'vacation'
    %= month_field vacation => '2012-12'
    %= month_field vacation => '2012-12', id => 'foo'
  
  Generate C<input> tag of type C<month>. Previous input values will
  automatically get picked up and shown as default.
  
    <input name="vacation" type="month">
    <input name="vacation" type="month" value="2012-12">
    <input id="foo" name="vacation" type="month" value="2012-12">
  
  =head2 number_field
  
    %= number_field 'age'
    %= number_field age => 25
    %= number_field age => 25, id => 'foo', min => 0, max => 200
  
  Generate C<input> tag of type C<number>. Previous input values will
  automatically get picked up and shown as default.
  
    <input name="age" type="number">
    <input name="age" type="number" value="25">
    <input id="foo" max="200" min="0" name="age" type="number" value="25">
  
  =head2 password_field
  
    %= password_field 'pass'
    %= password_field 'pass', id => 'foo'
  
  Generate C<input> tag of type C<password>.
  
    <input name="pass" type="password">
    <input id="foo" name="pass" type="password">
  
  =head2 radio_button
  
    %= radio_button 'test'
    %= radio_button country => 'germany'
    %= radio_button country => 'germany', checked => undef, id => 'foo'
  
  Generate C<input> tag of type C<radio>. Previous input values will
  automatically get picked up and shown as default.
  
    <input name="test" type="radio">
    <input name="country" type="radio" value="germany">
    <input checked id="foo" name="country" type="radio" value="germany">
  
  =head2 range_field
  
    %= range_field 'age'
    %= range_field age => 25
    %= range_field age => 25, id => 'foo', min => 0, max => 200
  
  Generate C<input> tag of type C<range>. Previous input values will
  automatically get picked up and shown as default.
  
    <input name="age" type="range">
    <input name="age" type="range" value="25">
    <input id="foo" max="200" min="200" name="age" type="range" value="25">
  
  =head2 search_field
  
    %= search_field 'q'
    %= search_field q => 'perl'
    %= search_field q => 'perl', id => 'foo'
  
  Generate C<input> tag of type C<search>. Previous input values will
  automatically get picked up and shown as default.
  
    <input name="q" type="search">
    <input name="q" type="search" value="perl">
    <input id="foo" name="q" type="search" value="perl">
  
  =head2 select_field
  
    %= select_field country => ['de', 'en']
    %= select_field country => [[Germany => 'de'], 'en'], id => 'eu'
    %= select_field country => [[Germany => 'de', selected => 'selected'], 'en']
    %= select_field country => [c(EU => [[Germany => 'de'], 'en'], id => 'eu')]
    %= select_field country => [c(EU => ['de', 'en']), c(Asia => ['cn', 'jp'])]
  
  Generate C<select> and C<option> tags from array references and C<optgroup>
  tags from L<Mojo::Collection> objects. Previous input values will automatically
  get picked up and shown as default.
  
    <select name="country">
      <option value="de">de</option>
      <option value="en">en</option>
    </select>
    <select id="eu" name="country">
      <option value="de">Germany</option>
      <option value="en">en</option>
    </select>
    <select name="country">
      <option selected="selected" value="de">Germany</option>
      <option value="en">en</option>
    </select>
    <select name="country">
      <optgroup id="eu" label="EU">
        <option value="de">Germany</option>
        <option value="en">en</option>
      </optgroup>
    </select>
    <select name="country">
      <optgroup label="EU">
        <option value="de">de</option>
        <option value="en">en</option>
      </optgroup>
      <optgroup label="Asia">
        <option value="cn">cn</option>
        <option value="jp">jp</option>
      </optgroup>
    </select>
  
  =head2 stylesheet
  
    %= stylesheet '/foo.css'
    %= stylesheet begin
      body {color: #000}
    % end
  
  Generate portable C<style> or C<link> tag for CSS asset.
  
    <link href="/path/to/foo.css" rel="stylesheet">
    <style><![CDATA[
      body {color: #000}
    ]]></style>
  
  =head2 submit_button
  
    %= submit_button
    %= submit_button 'Ok!', id => 'foo'
  
  Generate C<input> tag of type C<submit>.
  
    <input type="submit" value="Ok">
    <input id="foo" type="submit" value="Ok!">
  
  =head2 t
  
    %= t div => 'test & 123'
  
  Alias for L</"tag">.
  
    <div>test &amp; 123</div>
  
  =head2 tag
  
    %= tag 'br'
    %= tag 'div'
    %= tag 'div', id => 'foo', hidden => undef
    %= tag div => 'test & 123'
    %= tag div => (id => 'foo') => 'test & 123'
    %= tag div => (data => {my_id => 1, Name => 'test'}) => 'test & 123'
    %= tag div => begin
      test & 123
    % end
    <%= tag div => (id => 'foo') => begin %>test & 123<% end %>
  
  HTML tag generator, the C<data> attribute may contain a hash reference with
  key/value pairs to generate attributes from.
  
    <br>
    <div></div>
    <div id="foo" hidden></div>
    <div>test &amp; 123</div>
    <div id="foo">test &amp; 123</div>
    <div data-my-id="1" data-name="test">test &amp; 123</div>
    <div>
      test & 123
    </div>
    <div id="foo">test & 123</div>
  
  Very useful for reuse in more specific tag helpers.
  
    my $output = $c->tag('meta');
    my $output = $c->tag('meta', charset => 'UTF-8');
    my $output = $c->tag(div => '<p>This will be escaped</p>');
    my $output = $c->tag(div => sub { '<p>This will not be escaped</p>' });
  
  Results are automatically wrapped in L<Mojo::ByteStream> objects to prevent
  accidental double escaping in C<ep> templates.
  
  =head2 tag_with_error
  
    %= tag_with_error 'input', class => 'foo'
  
  Same as L</"tag">, but adds the class C<field-with-error>.
  
    <input class="foo field-with-error">
  
  =head2 tel_field
  
    %= tel_field 'work'
    %= tel_field work => '123456789'
    %= tel_field work => '123456789', id => 'foo'
  
  Generate C<input> tag of type C<tel>. Previous input values will automatically
  get picked up and shown as default.
  
    <input name="work" type="tel">
    <input name="work" type="tel" value="123456789">
    <input id="foo" name="work" type="tel" value="123456789">
  
  =head2 text_area
  
    %= text_area 'story'
    %= text_area 'story', cols => 40
    %= text_area story => 'Default', cols => 40
    %= text_area story => (cols => 40) => begin
      Default
    % end
  
  Generate C<textarea> tag. Previous input values will automatically get picked
  up and shown as default.
  
    <textarea name="story"></textarea>
    <textarea cols="40" name="story"></textarea>
    <textarea cols="40" name="story">Default</textarea>
    <textarea cols="40" name="story">
      Default
    </textarea>
  
  =head2 text_field
  
    %= text_field 'first_name'
    %= text_field first_name => 'Default'
    %= text_field first_name => 'Default', class => 'user'
  
  Generate C<input> tag of type C<text>. Previous input values will automatically
  get picked up and shown as default.
  
    <input name="first_name" type="text">
    <input name="first_name" type="text" value="Default">
    <input class="user" name="first_name" type="text" value="Default">
  
  =head2 time_field
  
    %= time_field 'start'
    %= time_field start => '23:59:59'
    %= time_field start => '23:59:59', id => 'foo'
  
  Generate C<input> tag of type C<time>. Previous input values will automatically
  get picked up and shown as default.
  
    <input name="start" type="time">
    <input name="start" type="time" value="23:59:59">
    <input id="foo" name="start" type="time" value="23:59:59">
  
  =head2 url_field
  
    %= url_field 'address'
    %= url_field address => 'http://mojolicious.org'
    %= url_field address => 'http://mojolicious.org', id => 'foo'
  
  Generate C<input> tag of type C<url>. Previous input values will automatically
  get picked up and shown as default.
  
    <input name="address" type="url">
    <input name="address" type="url" value="http://mojolicious.org">
    <input id="foo" name="address" type="url" value="http://mojolicious.org">
  
  =head2 week_field
  
    %= week_field 'vacation'
    %= week_field vacation => '2012-W17'
    %= week_field vacation => '2012-W17', id => 'foo'
  
  Generate C<input> tag of type C<week>. Previous input values will automatically
  get picked up and shown as default.
  
    <input name="vacation" type="week">
    <input name="vacation" type="week" value="2012-W17">
    <input id="foo" name="vacation" type="week" value="2012-W17">
  
  =head1 METHODS
  
  L<Mojolicious::Plugin::TagHelpers> inherits all methods from
  L<Mojolicious::Plugin> and implements the following new ones.
  
  =head2 register
  
    $plugin->register(Mojolicious->new);
  
  Register helpers in L<Mojolicious> application.
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<http://mojolicious.org>.
  
  =cut
MOJOLICIOUS_PLUGIN_TAGHELPERS

$fatpacked{"Mojolicious/Plugins.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJOLICIOUS_PLUGINS';
  package Mojolicious::Plugins;
  use Mojo::Base 'Mojo::EventEmitter';
  
  use Mojo::Loader 'load_class';
  use Mojo::Util 'camelize';
  
  has namespaces => sub { ['Mojolicious::Plugin'] };
  
  sub emit_chain {
    my ($self, $name, @args) = @_;
  
    my $wrapper;
    for my $cb (reverse @{$self->subscribers($name)}) {
      my $next = $wrapper;
      $wrapper = sub { $cb->($next, @args) };
    }
  
    !$wrapper ? return : return $wrapper->();
  }
  
  sub emit_hook {
    my $self = shift;
    for my $cb (@{$self->subscribers(shift)}) { $cb->(@_) }
    return $self;
  }
  
  sub emit_hook_reverse {
    my $self = shift;
    for my $cb (reverse @{$self->subscribers(shift)}) { $cb->(@_) }
    return $self;
  }
  
  sub load_plugin {
    my ($self, $name) = @_;
  
    # Try all namespaces and full module name
    my $suffix = $name =~ /^[a-z]/ ? camelize $name : $name;
    my @classes = map {"${_}::$suffix"} @{$self->namespaces};
    for my $class (@classes, $name) { return $class->new if _load($class) }
  
    # Not found
    die qq{Plugin "$name" missing, maybe you need to install it?\n};
  }
  
  sub register_plugin {
    shift->load_plugin(shift)->register(shift, ref $_[0] ? $_[0] : {@_});
  }
  
  sub _load {
    my $module = shift;
    return $module->isa('Mojolicious::Plugin') unless my $e = load_class $module;
    ref $e ? die $e : return undef;
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojolicious::Plugins - Plugin manager
  
  =head1 SYNOPSIS
  
    use Mojolicious::Plugins;
  
    my $plugins = Mojolicious::Plugins->new;
    push @{$plugins->namespaces}, 'MyApp::Plugin';
  
  =head1 DESCRIPTION
  
  L<Mojolicious::Plugins> is the plugin manager of L<Mojolicious>.
  
  =head1 PLUGINS
  
  The following plugins are included in the L<Mojolicious> distribution as
  examples.
  
  =over 2
  
  =item L<Mojolicious::Plugin::Config>
  
  Perl-ish configuration files.
  
  =item L<Mojolicious::Plugin::DefaultHelpers>
  
  General purpose helper collection, loaded automatically.
  
  =item L<Mojolicious::Plugin::EPLRenderer>
  
  Renderer for plain embedded Perl templates, loaded automatically.
  
  =item L<Mojolicious::Plugin::EPRenderer>
  
  Renderer for more sophisticated embedded Perl templates, loaded automatically.
  
  =item L<Mojolicious::Plugin::HeaderCondition>
  
  Route condition for all kinds of headers, loaded automatically.
  
  =item L<Mojolicious::Plugin::JSONConfig>
  
  JSON configuration files.
  
  =item L<Mojolicious::Plugin::Mount>
  
  Mount whole L<Mojolicious> applications.
  
  =item L<Mojolicious::Plugin::PODRenderer>
  
  Renderer for turning POD into HTML and documentation browser for
  L<Mojolicious::Guides>.
  
  =item L<Mojolicious::Plugin::TagHelpers>
  
  Template specific helper collection, loaded automatically.
  
  =back
  
  =head1 EVENTS
  
  L<Mojolicious::Plugins> inherits all events from L<Mojo::EventEmitter>.
  
  =head1 ATTRIBUTES
  
  L<Mojolicious::Plugins> implements the following attributes.
  
  =head2 namespaces
  
    my $namespaces = $plugins->namespaces;
    $plugins       = $plugins->namespaces(['Mojolicious::Plugin']);
  
  Namespaces to load plugins from, defaults to L<Mojolicious::Plugin>.
  
    # Add another namespace to load plugins from
    push @{$plugins->namespaces}, 'MyApp::Plugin';
  
  =head1 METHODS
  
  L<Mojolicious::Plugins> inherits all methods from L<Mojo::EventEmitter> and
  implements the following new ones.
  
  =head2 emit_chain
  
    $plugins->emit_chain('foo');
    $plugins->emit_chain(foo => 123);
  
  Emit events as chained hooks.
  
  =head2 emit_hook
  
    $plugins = $plugins->emit_hook('foo');
    $plugins = $plugins->emit_hook(foo => 123);
  
  Emit events as hooks.
  
  =head2 emit_hook_reverse
  
    $plugins = $plugins->emit_hook_reverse('foo');
    $plugins = $plugins->emit_hook_reverse(foo => 123);
  
  Emit events as hooks in reverse order.
  
  =head2 load_plugin
  
    my $plugin = $plugins->load_plugin('some_thing');
    my $plugin = $plugins->load_plugin('SomeThing');
    my $plugin = $plugins->load_plugin('MyApp::Plugin::SomeThing');
  
  Load a plugin from the configured namespaces or by full module name.
  
  =head2 register_plugin
  
    $plugins->register_plugin('some_thing', Mojolicious->new);
    $plugins->register_plugin('some_thing', Mojolicious->new, foo => 23);
    $plugins->register_plugin('some_thing', Mojolicious->new, {foo => 23});
    $plugins->register_plugin('SomeThing', Mojolicious->new);
    $plugins->register_plugin('SomeThing', Mojolicious->new, foo => 23);
    $plugins->register_plugin('SomeThing', Mojolicious->new, {foo => 23});
    $plugins->register_plugin('MyApp::Plugin::SomeThing', Mojolicious->new);
    $plugins->register_plugin(
      'MyApp::Plugin::SomeThing', Mojolicious->new, foo => 23);
    $plugins->register_plugin(
      'MyApp::Plugin::SomeThing', Mojolicious->new, {foo => 23});
  
  Load a plugin from the configured namespaces or by full module name and run
  C<register>, optional arguments are passed through.
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<http://mojolicious.org>.
  
  =cut
MOJOLICIOUS_PLUGINS

$fatpacked{"Mojolicious/Renderer.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJOLICIOUS_RENDERER';
  package Mojolicious::Renderer;
  use Mojo::Base -base;
  
  use Mojo::Cache;
  use Mojo::File 'path';
  use Mojo::JSON 'encode_json';
  use Mojo::Home;
  use Mojo::Loader 'data_section';
  use Mojo::Util qw(decamelize encode md5_sum monkey_patch);
  
  has cache   => sub { Mojo::Cache->new };
  has classes => sub { ['main'] };
  has default_format => 'html';
  has 'default_handler';
  has encoding => 'UTF-8';
  has [qw(handlers helpers)] => sub { {} };
  has paths => sub { [] };
  
  # Bundled templates
  my $TEMPLATES = Mojo::Home->new(Mojo::Home->new->mojo_lib_dir)
    ->child('Mojolicious', 'resources', 'templates');
  
  sub DESTROY { Mojo::Util::_teardown($_) for @{shift->{namespaces}} }
  
  sub accepts {
    my ($self, $c) = (shift, shift);
  
    # List representations
    my $req = $c->req;
    my @exts = @{$c->app->types->detect($req->headers->accept, $req->is_xhr)};
    if (!@exts && (my $format = $c->stash->{format} || $req->param('format'))) {
      push @exts, $format;
    }
    return \@exts unless @_;
  
    # Find best representation
    for my $ext (@exts) { $ext eq $_ and return $ext for @_ }
    return @exts ? undef : shift;
  }
  
  sub add_handler { $_[0]->handlers->{$_[1]} = $_[2] and return $_[0] }
  
  sub add_helper {
    my ($self, $name, $cb) = @_;
    $self->helpers->{$name} = $cb;
    delete $self->{proxy};
    return $self;
  }
  
  sub get_data_template {
    my ($self, $options) = @_;
    return undef unless my $template = $self->template_name($options);
    return data_section $self->{index}{$template}, $template;
  }
  
  sub get_helper {
    my ($self, $name) = @_;
  
    if (my $h = $self->{proxy}{$name} || $self->helpers->{$name}) { return $h }
  
    my $found;
    my $class = 'Mojolicious::Renderer::Helpers::' . md5_sum "$name:$self";
    my $re = length $name ? qr/^(\Q$name\E\.([^.]+))/ : qr/^(([^.]+))/;
    for my $key (keys %{$self->helpers}) {
      $key =~ $re ? ($found, my $method) = (1, $2) : next;
      my $sub = $self->get_helper($1);
      monkey_patch $class, $method => sub { ${shift()}->$sub(@_) };
    }
  
    $found ? push @{$self->{namespaces}}, $class : return undef;
    return $self->{proxy}{$name} = sub { bless \(my $dummy = shift), $class };
  }
  
  sub render {
    my ($self, $c, $args) = @_;
  
    # Localize "extends" and "layout" to allow argument overrides
    my $stash = $c->stash;
    local $stash->{layout}  = $stash->{layout}  if exists $stash->{layout};
    local $stash->{extends} = $stash->{extends} if exists $stash->{extends};
  
    # Rendering to string
    local @{$stash}{keys %$args} if my $string = delete $args->{'mojo.string'};
    delete @{$stash}{qw(layout extends)} if $string;
  
    # All other arguments just become part of the stash
    @$stash{keys %$args} = values %$args;
  
    my $options = {
      encoding => $self->encoding,
      handler  => $stash->{handler},
      template => delete $stash->{template},
      variant  => $stash->{variant}
    };
    my $inline = $options->{inline} = delete $stash->{inline};
    $options->{handler} //= $self->default_handler if defined $inline;
    $options->{format} = $stash->{format} || $self->default_format;
  
    # Data
    return delete $stash->{data}, $options->{format} if defined $stash->{data};
  
    # Text
    return _maybe($options->{encoding}, delete $stash->{text}), $options->{format}
      if defined $stash->{text};
  
    # JSON
    return encode_json(delete $stash->{json}), 'json' if exists $stash->{json};
  
    # Template or templateless handler
    $options->{template} //= $self->template_for($c);
    return () unless $self->_render_template($c, \my $output, $options);
  
    # Inheritance
    my $content = $stash->{'mojo.content'} ||= {};
    local $content->{content} = $output =~ /\S/ ? $output : undef
      if $stash->{extends} || $stash->{layout};
    while ((my $next = _next($stash)) && !defined $inline) {
      @$options{qw(handler template)} = ($stash->{handler}, $next);
      $options->{format} = $stash->{format} || $self->default_format;
      if ($self->_render_template($c, \my $tmp, $options)) { $output = $tmp }
      $content->{content} //= $output if $output =~ /\S/;
    }
  
    return $string ? $output : _maybe($options->{encoding}, $output),
      $options->{format};
  }
  
  sub template_for {
    my ($self, $c) = @_;
  
    # Normal default template
    my $stash = $c->stash;
    my ($controller, $action) = @$stash{qw(controller action)};
    return join '/', split('-', decamelize $controller), $action
      if $controller && $action;
  
    # Try the route name if we don't have controller and action
    return undef unless my $route = $c->match->endpoint;
    return $route->name;
  }
  
  sub template_handler {
    my ($self, $options) = @_;
    return undef unless my $file = $self->template_name($options);
    return $self->default_handler unless my $handlers = $self->{templates}{$file};
    return $handlers->[0];
  }
  
  sub template_name {
    my ($self, $options) = @_;
  
    return undef unless defined(my $template = $options->{template});
    return undef unless my $format = $options->{format};
    $template .= ".$format";
  
    $self->warmup unless $self->{templates};
  
    # Variants
    my $handler = $options->{handler};
    if (defined(my $variant = $options->{variant})) {
      $variant = "$template+$variant";
      my $handlers = $self->{templates}{$variant} // [];
      $template = $variant
        if @$handlers && !defined $handler || grep { $_ eq $handler } @$handlers;
    }
  
    return defined $handler ? "$template.$handler" : $template;
  }
  
  sub template_path {
    my ($self, $options) = @_;
    return undef unless my $name = $self->template_name($options);
    my @parts = split '/', $name;
    -r and return $_
      for map { path($_, @parts)->to_string } @{$self->paths}, $TEMPLATES;
    return undef;
  }
  
  sub warmup {
    my $self = shift;
  
    my ($index, $templates) = @$self{qw(index templates)} = ({}, {});
  
    # Handlers for templates
    for my $path (@{$self->paths}, $TEMPLATES) {
      s/\.(\w+)$// and push @{$templates->{$_}}, $1
        for path($path)->list_tree->map(sub { join '/', @{$_->to_rel($path)} })
        ->each;
    }
  
    # Handlers and classes for DATA templates
    for my $class (reverse @{$self->classes}) {
      $index->{$_} = $class for my @keys = sort keys %{data_section $class};
      s/\.(\w+)$// and unshift @{$templates->{$_}}, $1 for reverse @keys;
    }
  }
  
  sub _maybe { $_[0] ? encode @_ : $_[1] }
  
  sub _next {
    my $stash = shift;
    return delete $stash->{extends} if $stash->{extends};
    return undef unless my $layout = delete $stash->{layout};
    return join '/', 'layouts', $layout;
  }
  
  sub _render_template {
    my ($self, $c, $output, $options) = @_;
  
    my $handler = $options->{handler} ||= $self->template_handler($options);
    return undef unless $handler;
    $c->app->log->error(qq{No handler for "$handler" available}) and return undef
      unless my $renderer = $self->handlers->{$handler};
  
    $renderer->($self, $c, $output, $options);
    return 1 if defined $$output;
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojolicious::Renderer - Generate dynamic content
  
  =head1 SYNOPSIS
  
    use Mojolicious::Renderer;
  
    my $renderer = Mojolicious::Renderer->new;
    push @{$renderer->classes}, 'MyApp::Controller::Foo';
    push @{$renderer->paths}, '/home/sri/templates';
  
  =head1 DESCRIPTION
  
  L<Mojolicious::Renderer> is the standard L<Mojolicious> renderer.
  
  See L<Mojolicious::Guides::Rendering> for more.
  
  =head1 ATTRIBUTES
  
  L<Mojolicious::Renderer> implements the following attributes.
  
  =head2 cache
  
    my $cache = $renderer->cache;
    $renderer = $renderer->cache(Mojo::Cache->new);
  
  Renderer cache, defaults to a L<Mojo::Cache> object.
  
  =head2 classes
  
    my $classes = $renderer->classes;
    $renderer   = $renderer->classes(['main']);
  
  Classes to use for finding templates in C<DATA> sections with L<Mojo::Loader>,
  first one has the highest precedence, defaults to C<main>. Only files with
  exactly two extensions will be used, like C<index.html.ep>. Note that for
  templates to be detected, these classes need to have already been loaded and
  added before L</"warmup"> is called, which usually happens automatically during
  application startup.
  
    # Add another class with templates in DATA section
    push @{$renderer->classes}, 'Mojolicious::Plugin::Fun';
  
    # Add another class with templates in DATA section and higher precedence
    unshift @{$renderer->classes}, 'Mojolicious::Plugin::MoreFun';
  
  =head2 default_format
  
    my $default = $renderer->default_format;
    $renderer   = $renderer->default_format('html');
  
  The default format to render if C<format> is not set in the stash, defaults to
  C<html>.
  
  =head2 default_handler
  
    my $default = $renderer->default_handler;
    $renderer   = $renderer->default_handler('ep');
  
  The default template handler to use for rendering in cases where auto-detection
  doesn't work, like for C<inline> templates.
  
  =head2 encoding
  
    my $encoding = $renderer->encoding;
    $renderer    = $renderer->encoding('koi8-r');
  
  Will encode generated content if set, defaults to C<UTF-8>. Note that many
  renderers such as L<Mojolicious::Plugin::EPRenderer> also use this value to
  determine if template files should be decoded before processing.
  
  =head2 handlers
  
    my $handlers = $renderer->handlers;
    $renderer    = $renderer->handlers({epl => sub {...}});
  
  Registered handlers.
  
  =head2 helpers
  
    my $helpers = $renderer->helpers;
    $renderer   = $renderer->helpers({url_for => sub {...}});
  
  Registered helpers.
  
  =head2 paths
  
    my $paths = $renderer->paths;
    $renderer = $renderer->paths(['/home/sri/templates']);
  
  Directories to look for templates in, first one has the highest precedence.
  
    # Add another "templates" directory
    push @{$renderer->paths}, '/home/sri/templates';
  
    # Add another "templates" directory with higher precedence
    unshift @{$renderer->paths}, '/home/sri/themes/blue/templates';
  
  =head1 METHODS
  
  L<Mojolicious::Renderer> inherits all methods from L<Mojo::Base> and implements
  the following new ones.
  
  =head2 accepts
  
    my $all  = $renderer->accepts(Mojolicious::Controller->new);
    my $best = $renderer->accepts(Mojolicious::Controller->new, 'html', 'json');
  
  Select best possible representation for L<Mojolicious::Controller> object from
  C<Accept> request header, C<format> stash value or C<format> C<GET>/C<POST>
  parameter, defaults to returning the first extension if no preference could be
  detected. Since browsers often don't really know what they actually want,
  unspecific C<Accept> request headers with more than one MIME type will be
  ignored, unless the C<X-Requested-With> header is set to the value
  C<XMLHttpRequest>.
  
  =head2 add_handler
  
    $renderer = $renderer->add_handler(epl => sub {...});
  
  Register a handler.
  
    $renderer->add_handler(foo => sub {
      my ($renderer, $c, $output, $options) = @_;
      ...
      $$output = 'Hello World!';
    });
  
  =head2 add_helper
  
    $renderer = $renderer->add_helper(url_for => sub {...});
  
  Register a helper.
  
    $renderer->add_helper(foo => sub {
      my ($c, @args) = @_;
      ...
    });
  
  =head2 get_data_template
  
    my $template = $renderer->get_data_template({
      template       => 'foo/bar',
      format         => 'html',
      handler        => 'epl'
    });
  
  Return a C<DATA> section template from L</"classes"> for an options hash
  reference with C<template>, C<format>, C<variant> and C<handler> values, or
  C<undef> if no template could be found, usually used by handlers.
  
  =head2 get_helper
  
    my $helper = $renderer->get_helper('url_for');
  
  Get a helper by full name, generate a helper dynamically for a prefix, or return
  C<undef> if no helper or prefix could be found. Generated helpers return a
  proxy object containing the current controller object and on which nested
  helpers can be called.
  
  =head2 render
  
    my ($output, $format) = $renderer->render(Mojolicious::Controller->new, {
      template => 'foo/bar',
      foo      => 'bar'
    });
  
  Render output through one of the renderers. See
  L<Mojolicious::Controller/"render"> for a more user-friendly interface.
  
  =head2 template_for
  
    my $name = $renderer->template_for(Mojolicious::Controller->new);
  
  Return default template name for L<Mojolicious::Controller> object, or C<undef>
  if no name could be generated.
  
  =head2 template_handler
  
    my $handler = $renderer->template_handler({
      template => 'foo/bar',
      format   => 'html'
    });
  
  Return handler for an options hash reference with C<template>, C<format> and
  C<variant> values, or C<undef> if no handler could be found.
  
  =head2 template_name
  
    my $template = $renderer->template_name({
      template => 'foo/bar',
      format   => 'html',
      handler  => 'epl'
    });
  
  Return a template name for an options hash reference with C<template>,
  C<format>, C<variant> and C<handler> values, or C<undef> if no template could be
  found, usually used by handlers.
  
  =head2 template_path
  
    my $path = $renderer->template_path({
      template => 'foo/bar',
      format   => 'html',
      handler  => 'epl'
    });
  
  Return the full template path for an options hash reference with C<template>,
  C<format>, C<variant> and C<handler> values, or C<undef> if the file does not
  exist in L</"paths">, usually used by handlers.
  
  =head2 warmup
  
    $renderer->warmup;
  
  Prepare templates from L</"classes"> for future use.
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<http://mojolicious.org>.
  
  =cut
MOJOLICIOUS_RENDERER

$fatpacked{"Mojolicious/Routes.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJOLICIOUS_ROUTES';
  package Mojolicious::Routes;
  use Mojo::Base 'Mojolicious::Routes::Route';
  
  use List::Util 'first';
  use Mojo::Cache;
  use Mojo::Loader 'load_class';
  use Mojo::Util 'camelize';
  use Mojolicious::Routes::Match;
  use Scalar::Util 'weaken';
  
  has base_classes => sub { [qw(Mojolicious::Controller Mojo)] };
  has cache        => sub { Mojo::Cache->new };
  has [qw(conditions shortcuts)] => sub { {} };
  has hidden     => sub { [qw(attr has new tap)] };
  has namespaces => sub { [] };
  
  sub add_condition { $_[0]->conditions->{$_[1]} = $_[2] and return $_[0] }
  sub add_shortcut  { $_[0]->shortcuts->{$_[1]}  = $_[2] and return $_[0] }
  
  sub continue {
    my ($self, $c) = @_;
  
    my $match    = $c->match;
    my $stack    = $match->stack;
    my $position = $match->position;
    return _render($c) unless my $field = $stack->[$position];
  
    # Merge captures into stash
    my $stash = $c->stash;
    @{$stash->{'mojo.captures'} //= {}}{keys %$field} = values %$field;
    @$stash{keys %$field} = values %$field;
  
    my $continue;
    my $last = !$stack->[++$position];
    if (my $cb = $field->{cb}) { $continue = $self->_callback($c, $cb, $last) }
    else { $continue = $self->_controller($c, $field, $last) }
    $match->position($position);
    $self->continue($c) if $last || $continue;
  }
  
  sub dispatch {
    my ($self, $c) = @_;
    $self->match($c);
    @{$c->match->stack} ? $self->continue($c) : return undef;
    return 1;
  }
  
  sub hide { push @{shift->hidden}, @_ }
  
  sub is_hidden {
    my ($self, $method) = @_;
    my $h = $self->{hiding} ||= {map { $_ => 1 } @{$self->hidden}};
    return !!($h->{$method} || $method =~ /^_/ || $method =~ /^[A-Z_]+$/);
  }
  
  sub lookup { ($_[0]{reverse} //= $_[0]->_index)->{$_[1]} }
  
  sub match {
    my ($self, $c) = @_;
  
    # Path (partial path gets priority)
    my $req  = $c->req;
    my $path = $c->stash->{path};
    if (defined $path) { $path = "/$path" if $path !~ m!^/! }
    else               { $path = $req->url->path->to_route }
  
    # Method (HEAD will be treated as GET)
    my $method = uc($req->url->query->clone->param('_method') || $req->method);
    $method = 'GET' if $method eq 'HEAD';
  
    # Check cache
    my $ws = $c->tx->is_websocket ? 1 : 0;
    my $match = Mojolicious::Routes::Match->new(root => $self);
    $c->match($match);
    my $cache = $self->cache;
    if (my $result = $cache->get("$method:$path:$ws")) {
      return $match->endpoint($result->{endpoint})->stack($result->{stack});
    }
  
    # Check routes
    $match->find($c => {method => $method, path => $path, websocket => $ws});
    return unless my $route = $match->endpoint;
    $cache->set(
      "$method:$path:$ws" => {endpoint => $route, stack => $match->stack});
  }
  
  sub _action { shift->plugins->emit_chain(around_action => @_) }
  
  sub _callback {
    my ($self, $c, $cb, $last) = @_;
    $c->stash->{'mojo.routed'} = 1 if $last;
    my $app = $c->app;
    $app->log->debug('Routing to a callback');
    return _action($app, $c, $cb, $last);
  }
  
  sub _class {
    my ($self, $c, $field) = @_;
  
    # Application instance
    return $field->{app} if ref $field->{app};
  
    # Application class
    my @classes;
    my $class = $field->{controller} ? camelize $field->{controller} : '';
    if ($field->{app}) { push @classes, $field->{app} }
  
    # Specific namespace
    elsif (defined(my $ns = $field->{namespace})) {
      if ($class) { push @classes, $ns ? "${ns}::$class" : $class }
      elsif ($ns) { push @classes, $ns }
    }
  
    # All namespaces
    elsif ($class) { push @classes, "${_}::$class" for @{$self->namespaces} }
  
    # Try to load all classes
    my $log = $c->app->log;
    for my $class (@classes) {
  
      # Failed
      next unless defined(my $found = $self->_load($class));
      return !$log->debug(qq{Class "$class" is not a controller}) unless $found;
  
      # Success
      my $new = $class->new(%$c);
      weaken $new->{$_} for qw(app tx);
      return $new;
    }
  
    # Nothing found
    $log->debug(qq{Controller "$classes[-1]" does not exist}) if @classes;
    return @classes ? undef : 0;
  }
  
  sub _controller {
    my ($self, $old, $field, $last) = @_;
  
    # Load and instantiate controller/application
    my $new;
    unless ($new = $self->_class($old, $field)) { return defined $new }
  
    # Application
    my $class = ref $new;
    my $app   = $old->app;
    my $log   = $app->log;
    if ($new->isa('Mojo')) {
      $log->debug(qq{Routing to application "$class"});
  
      # Try to connect routes
      if (my $sub = $new->can('routes')) {
        my $r = $new->$sub;
        weaken $r->parent($old->match->endpoint)->{parent} unless $r->parent;
      }
      $new->handler($old);
      $old->stash->{'mojo.routed'} = 1;
    }
  
    # Action
    elsif (my $method = $field->{action}) {
      if (!$self->is_hidden($method)) {
        $log->debug(qq{Routing to controller "$class" and action "$method"});
  
        if (my $sub = $new->can($method)) {
          $old->stash->{'mojo.routed'} = 1 if $last;
          return 1 if _action($app, $new, $sub, $last);
        }
  
        else { $log->debug('Action not found in controller') }
      }
      else { $log->debug(qq{Action "$method" is not allowed}) }
    }
  
    return undef;
  }
  
  sub _load {
    my ($self, $app) = @_;
  
    # Load unless already loaded
    return 1 if $self->{loaded}{$app};
    if (my $e = load_class $app) { ref $e ? die $e : return undef }
  
    # Check base classes
    return 0 unless first { $app->isa($_) } @{$self->base_classes};
    return $self->{loaded}{$app} = 1;
  }
  
  sub _render {
    my $c     = shift;
    my $stash = $c->stash;
    return if $stash->{'mojo.rendered'};
    $c->render_maybe or $stash->{'mojo.routed'} or $c->helpers->reply->not_found;
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojolicious::Routes - Always find your destination with routes
  
  =head1 SYNOPSIS
  
    use Mojolicious::Routes;
  
    # Simple route
    my $r = Mojolicious::Routes->new;
    $r->route('/')->to(controller => 'blog', action => 'welcome');
  
    # More advanced routes
    my $blog = $r->under('/blog');
    $blog->get('/list')->to('blog#list');
    $blog->get('/:id' => [id => qr/\d+/])->to('blog#show', id => 23);
    $blog->patch(sub { shift->render(text => 'Go away!', status => 405) });
  
  =head1 DESCRIPTION
  
  L<Mojolicious::Routes> is the core of the L<Mojolicious> web framework.
  
  See L<Mojolicious::Guides::Routing> for more.
  
  =head1 ATTRIBUTES
  
  L<Mojolicious::Routes> inherits all attributes from
  L<Mojolicious::Routes::Route> and implements the following new ones.
  
  =head2 base_classes
  
    my $classes = $r->base_classes;
    $r          = $r->base_classes(['MyApp::Controller']);
  
  Base classes used to identify controllers, defaults to
  L<Mojolicious::Controller> and L<Mojo>.
  
  =head2 cache
  
    my $cache = $r->cache;
    $r        = $r->cache(Mojo::Cache->new);
  
  Routing cache, defaults to a L<Mojo::Cache> object.
  
  =head2 conditions
  
    my $conditions = $r->conditions;
    $r             = $r->conditions({foo => sub {...}});
  
  Contains all available conditions.
  
  =head2 hidden
  
    my $hidden = $r->hidden;
    $r         = $r->hidden(['attr', 'has', 'new']);
  
  Controller attributes and methods that are hidden from router, defaults to
  C<attr>, C<has>, C<new> and C<tap>.
  
  =head2 namespaces
  
    my $namespaces = $r->namespaces;
    $r             = $r->namespaces(['MyApp::Controller', 'MyApp']);
  
  Namespaces to load controllers from.
  
    # Add another namespace to load controllers from
    push @{$r->namespaces}, 'MyApp::MyController';
  
  =head2 shortcuts
  
    my $shortcuts = $r->shortcuts;
    $r            = $r->shortcuts({foo => sub {...}});
  
  Contains all available shortcuts.
  
  =head1 METHODS
  
  L<Mojolicious::Routes> inherits all methods from L<Mojolicious::Routes::Route>
  and implements the following new ones.
  
  =head2 add_condition
  
    $r = $r->add_condition(foo => sub {...});
  
  Register a condition.
  
    $r->add_condition(foo => sub {
      my ($route, $c, $captures, $arg) = @_;
      ...
      return 1;
    });
  
  =head2 add_shortcut
  
    $r = $r->add_shortcut(foo => sub {...});
  
  Register a shortcut.
  
    $r->add_shortcut(foo => sub {
      my ($route, @args) = @_;
      ...
    });
  
  =head2 continue
  
    $r->continue(Mojolicious::Controller->new);
  
  Continue dispatch chain and emit the hook L<Mojolicious/"around_action"> for
  every action.
  
  =head2 dispatch
  
    my $bool = $r->dispatch(Mojolicious::Controller->new);
  
  Match routes with L</"match"> and dispatch with L</"continue">.
  
  =head2 hide
  
    $r = $r->hide('foo', 'bar');
  
  Hide controller attributes and methods from router.
  
  =head2 is_hidden
  
    my $bool = $r->is_hidden('foo');
  
  Check if controller attribute or method is hidden from router.
  
  =head2 lookup
  
    my $route = $r->lookup('foo');
  
  Find route by name with L<Mojolicious::Routes::Route/"find"> and cache all
  results for future lookups.
  
  =head2 match
  
    $r->match(Mojolicious::Controller->new);
  
  Match routes with L<Mojolicious::Routes::Match>.
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<http://mojolicious.org>.
  
  =cut
MOJOLICIOUS_ROUTES

$fatpacked{"Mojolicious/Routes/Match.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJOLICIOUS_ROUTES_MATCH';
  package Mojolicious::Routes::Match;
  use Mojo::Base -base;
  
  use Mojo::Util;
  
  has [qw(endpoint root)];
  has position => 0;
  has stack => sub { [] };
  
  sub find { $_[0]->_match($_[0]->root, $_[1], $_[2]) }
  
  sub path_for {
    my ($self, $name, %values) = (shift, Mojo::Util::_options(@_));
  
    # Current route
    my $route;
    if (!$name || $name eq 'current') {
      return {} unless $route = $self->endpoint;
    }
  
    # Find endpoint
    else { return {path => $name} unless $route = $self->root->lookup($name) }
  
    # Merge values (clear format)
    my $captures = $self->stack->[-1] || {};
    %values = (%$captures, format => undef, %values);
    my $pattern = $route->pattern;
    $values{format}
      //= defined $captures->{format}
      ? $captures->{format}
      : $pattern->defaults->{format}
      if $pattern->constraints->{format};
  
    my $path = $route->render(\%values);
    return {path => $path, websocket => $route->has_websocket};
  }
  
  sub _match {
    my ($self, $r, $c, $options) = @_;
  
    # Pattern
    my $path    = $options->{path};
    my $partial = $r->partial;
    my $detect  = (my $endpoint = $r->is_endpoint) && !$partial;
    return undef
      unless my $captures = $r->pattern->match_partial(\$path, $detect);
    local $options->{path} = $path;
    local @{$self->{captures} ||= {}}{keys %$captures} = values %$captures;
    $captures = $self->{captures};
  
    # Method
    my $methods = $r->via;
    return undef if $methods && !grep { $_ eq $options->{method} } @$methods;
  
    # Conditions
    if (my $over = $r->over) {
      my $conditions = $self->{conditions} ||= $self->root->conditions;
      for (my $i = 0; $i < @$over; $i += 2) {
        return undef unless my $condition = $conditions->{$over->[$i]};
        return undef if !$condition->($r, $c, $captures, $over->[$i + 1]);
      }
    }
  
    # WebSocket
    return undef if $r->is_websocket && !$options->{websocket};
  
    # Partial
    my $empty = !length $path || $path eq '/';
    if ($partial) {
      $captures->{path} = $path;
      $self->endpoint($r);
      $empty = 1;
    }
  
    # Endpoint (or intermediate destination)
    if (($endpoint && $empty) || $r->inline) {
      push @{$self->stack}, {%$captures};
      if ($endpoint && $empty) {
        my $format = $captures->{format};
        if ($format) { $_->{format} = $format for @{$self->stack} }
        return !!$self->endpoint($r);
      }
      delete @$captures{qw(app cb)};
    }
  
    # Match children
    my @snapshot = $r->parent ? ([@{$self->stack}], $captures) : ([], {});
    for my $child (@{$r->children}) {
      return 1 if $self->_match($child, $c, $options);
      $self->stack([@{$snapshot[0]}])->{captures} = $snapshot[1];
    }
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojolicious::Routes::Match - Find routes
  
  =head1 SYNOPSIS
  
    use Mojolicious::Controller;
    use Mojolicious::Routes;
    use Mojolicious::Routes::Match;
  
    # Routes
    my $r = Mojolicious::Routes->new;
    $r->get('/:controller/:action');
    $r->put('/:controller/:action');
  
    # Match
    my $c = Mojolicious::Controller->new;
    my $match = Mojolicious::Routes::Match->new(root => $r);
    $match->find($c => {method => 'PUT', path => '/foo/bar'});
    say $match->stack->[0]{controller};
    say $match->stack->[0]{action};
  
    # Render
    say $match->path_for->{path};
    say $match->path_for(action => 'baz')->{path};
  
  =head1 DESCRIPTION
  
  L<Mojolicious::Routes::Match> finds routes in L<Mojolicious::Routes>
  structures.
  
  =head1 ATTRIBUTES
  
  L<Mojolicious::Routes::Match> implements the following attributes.
  
  =head2 endpoint
  
    my $route = $match->endpoint;
    $match    = $match->endpoint(Mojolicious::Routes::Route->new);
  
  The route endpoint that matched, usually a L<Mojolicious::Routes::Route>
  object.
  
  =head2 position
  
    my $position = $match->position;
    $match       = $match->position(2);
  
  Current position on the L</"stack">, defaults to C<0>.
  
  =head2 root
  
    my $root = $match->root;
    $match   = $match->root(Mojolicious::Routes->new);
  
  The root of the route structure, usually a L<Mojolicious::Routes> object.
  
  =head2 stack
  
    my $stack = $match->stack;
    $match    = $match->stack([{action => 'foo'}, {action => 'bar'}]);
  
  Captured parameters with nesting history.
  
  =head1 METHODS
  
  L<Mojolicious::Routes::Match> inherits all methods from L<Mojo::Base> and
  implements the following new ones.
  
  =head2 find
  
    $match->find(Mojolicious::Controller->new, {method => 'GET', path => '/'});
  
  Match controller and options against L</"root"> to find an appropriate
  L</"endpoint">.
  
  =head2 path_for
  
    my $info = $match->path_for;
    my $info = $match->path_for(foo => 'bar');
    my $info = $match->path_for({foo => 'bar'});
    my $info = $match->path_for('named');
    my $info = $match->path_for('named', foo => 'bar');
    my $info = $match->path_for('named', {foo => 'bar'});
  
  Render matching route with parameters into path.
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<http://mojolicious.org>.
  
  =cut
MOJOLICIOUS_ROUTES_MATCH

$fatpacked{"Mojolicious/Routes/Pattern.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJOLICIOUS_ROUTES_PATTERN';
  package Mojolicious::Routes::Pattern;
  use Mojo::Base -base;
  
  has [qw(constraints defaults)] => sub { {} };
  has placeholder_start => ':';
  has [qw(placeholders tree)] => sub { [] };
  has quote_end   => ')';
  has quote_start => '(';
  has [qw(regex unparsed)];
  has relaxed_start  => '#';
  has wildcard_start => '*';
  
  sub match {
    my ($self, $path, $detect) = @_;
    my $captures = $self->match_partial(\$path, $detect);
    return !$path || $path eq '/' ? $captures : undef;
  }
  
  sub match_partial {
    my ($self, $pathref, $detect) = @_;
  
    # Compile on demand
    $self->_compile($detect) unless $self->{regex};
  
    return undef unless my @captures = $$pathref =~ $self->regex;
    $$pathref = ${^POSTMATCH};
    @captures = () if $#+ == 0;
    my $captures = {%{$self->defaults}};
    for my $placeholder (@{$self->placeholders}, 'format') {
      last unless @captures;
      my $capture = shift @captures;
      $captures->{$placeholder} = $capture if defined $capture;
    }
  
    return $captures;
  }
  
  sub new { @_ > 1 ? shift->SUPER::new->parse(@_) : shift->SUPER::new }
  
  sub parse {
    my $self = shift;
  
    my $pattern = @_ % 2 ? (shift // '/') : '/';
    $pattern =~ s!^/*|/+!/!g;
    return $self->constraints({@_}) if $pattern eq '/';
  
    $pattern =~ s!/$!!;
    return $self->constraints({@_})->_tokenize($pattern);
  }
  
  sub render {
    my ($self, $values, $endpoint) = @_;
  
    # Placeholders can only be optional without a format
    my $optional = !(my $format = $values->{format});
  
    my $str = '';
    for my $token (reverse @{$self->tree}) {
      my ($op, $value) = @$token;
      my $fragment = '';
  
      # Text
      if ($op eq 'text') { ($fragment, $optional) = ($value, 0) }
  
      # Slash
      elsif ($op eq 'slash') { $fragment = '/' unless $optional }
  
      # Placeholder
      else {
        my $default = $self->defaults->{$value};
        $fragment = $values->{$value} // $default // '';
        if (!defined $default || ($default ne $fragment)) { $optional = 0 }
        elsif ($optional) { $fragment = '' }
      }
  
      $str = $fragment . $str;
    }
  
    # Format can be optional
    return $endpoint && $format ? "$str.$format" : $str;
  }
  
  sub _compile {
    my ($self, $detect) = @_;
  
    my $placeholders = $self->placeholders;
    my $constraints  = $self->constraints;
    my $defaults     = $self->defaults;
  
    my $block = my $regex = '';
    my $optional = 1;
    for my $token (reverse @{$self->tree}) {
      my ($op, $value, $type) = @$token;
      my $fragment = '';
  
      # Text
      if ($op eq 'text') { ($fragment, $optional) = (quotemeta $value, 0) }
  
      # Slash
      elsif ($op eq 'slash') {
        $regex = ($optional ? "(?:/$block)?" : "/$block") . $regex;
        ($block, $optional) = ('', 1);
        next;
      }
  
      # Placeholder
      else {
        unshift @$placeholders, $value;
        $fragment = $type ? $type eq 'relaxed' ? '([^/]+)' : '(.+)' : '([^/.]+)';
  
        # Custom regex
        if (my $c = $constraints->{$value}) { $fragment = _compile_req($c) }
  
        # Optional placeholder
        exists $defaults->{$value} ? ($fragment .= '?') : ($optional = 0);
      }
  
      $block = $fragment . $block;
    }
  
    # Not rooted with a slash
    $regex = $block . $regex if $block;
  
    # Format
    $regex .= _compile_format($constraints->{format}, $defaults->{format})
      if $detect;
  
    $self->regex(qr/^$regex/ps);
  }
  
  sub _compile_format {
    my ($format, $default) = @_;
  
    # Default regex
    return '/?(?:\.([^/]+))?$' unless defined $format;
  
    # No regex
    return '' unless $format;
  
    # Compile custom regex
    my $regex = '\.' . _compile_req($format);
    return $default ? "/?(?:$regex)?\$" : "/?$regex\$";
  }
  
  sub _compile_req {
    my $req = shift;
    return "($req)" if ref $req ne 'ARRAY';
    return '(' . join('|', map {quotemeta} reverse sort @$req) . ')';
  }
  
  sub _tokenize {
    my ($self, $pattern) = @_;
  
    my $quote_end   = $self->quote_end;
    my $quote_start = $self->quote_start;
    my $start       = $self->placeholder_start;
    my $relaxed     = $self->relaxed_start;
    my $wildcard    = $self->wildcard_start;
  
    my (@tree, $spec);
    for my $char (split '', $pattern) {
  
      # Quoted
      if ($char eq $quote_start) { push @tree, ['placeholder', ''] if ++$spec }
      elsif ($char eq $quote_end) { $spec = 0 }
  
      # Placeholder
      elsif ($char eq $start) { push @tree, ['placeholder', ''] unless $spec++ }
  
      # Relaxed or wildcard (upgrade when quoted)
      elsif ($char eq $relaxed || $char eq $wildcard) {
        push @tree, ['placeholder', ''] unless $spec++;
        $tree[-1][2] = $char eq $relaxed ? 'relaxed' : 'wildcard';
      }
  
      # Slash
      elsif ($char eq '/') {
        push @tree, ['slash'];
        $spec = 0;
      }
  
      # Placeholder
      elsif ($spec) { $tree[-1][1] .= $char }
  
      # Text (optimize slash+text and *+text+slash+text)
      elsif ($tree[-1][0] eq 'text') { $tree[-1][-1] .= $char }
      elsif (!$tree[-2] && $tree[-1][0] eq 'slash') {
        @tree = (['text', "/$char"]);
      }
      elsif ($tree[-2] && $tree[-2][0] eq 'text' && $tree[-1][0] eq 'slash') {
        pop @tree && ($tree[-1][-1] .= "/$char");
      }
      else { push @tree, ['text', $char] }
    }
  
    return $self->unparsed($pattern)->tree(\@tree);
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojolicious::Routes::Pattern - Route pattern
  
  =head1 SYNOPSIS
  
    use Mojolicious::Routes::Pattern;
  
    # Create pattern
    my $pattern = Mojolicious::Routes::Pattern->new('/test/:name');
  
    # Match routes
    my $captures = $pattern->match('/test/sebastian');
    say $captures->{name};
  
  =head1 DESCRIPTION
  
  L<Mojolicious::Routes::Pattern> is the core of L<Mojolicious::Routes>.
  
  =head1 ATTRIBUTES
  
  L<Mojolicious::Routes::Pattern> implements the following attributes.
  
  =head2 constraints
  
    my $constraints = $pattern->constraints;
    $pattern        = $pattern->constraints({foo => qr/\w+/});
  
  Regular expression constraints.
  
  =head2 defaults
  
    my $defaults = $pattern->defaults;
    $pattern     = $pattern->defaults({foo => 'bar'});
  
  Default parameters.
  
  =head2 placeholder_start
  
    my $start = $pattern->placeholder_start;
    $pattern  = $pattern->placeholder_start(':');
  
  Character indicating a placeholder, defaults to C<:>.
  
  =head2 placeholders
  
    my $placeholders = $pattern->placeholders;
    $pattern         = $pattern->placeholders(['foo', 'bar']);
  
  Placeholder names.
  
  =head2 quote_end
  
    my $end  = $pattern->quote_end;
    $pattern = $pattern->quote_end(']');
  
  Character indicating the end of a quoted placeholder, defaults to C<)>.
  
  =head2 quote_start
  
    my $start = $pattern->quote_start;
    $pattern  = $pattern->quote_start('[');
  
  Character indicating the start of a quoted placeholder, defaults to C<(>.
  
  =head2 regex
  
    my $regex = $pattern->regex;
    $pattern  = $pattern->regex($regex);
  
  Pattern in compiled regular expression form.
  
  =head2 relaxed_start
  
    my $start = $pattern->relaxed_start;
    $pattern  = $pattern->relaxed_start('*');
  
  Character indicating a relaxed placeholder, defaults to C<#>.
  
  =head2 tree
  
    my $tree = $pattern->tree;
    $pattern = $pattern->tree([['text', '/foo']]);
  
  Pattern in parsed form. Note that this structure should only be used very
  carefully since it is very dynamic.
  
  =head2 unparsed
  
    my $unparsed = $pattern->unparsed;
    $pattern     = $pattern->unparsed('/(foo)/(bar)');
  
  Raw unparsed pattern.
  
  =head2 wildcard_start
  
    my $start = $pattern->wildcard_start;
    $pattern  = $pattern->wildcard_start('*');
  
  Character indicating the start of a wildcard placeholder, defaults to C<*>.
  
  =head1 METHODS
  
  L<Mojolicious::Routes::Pattern> inherits all methods from L<Mojo::Base> and
  implements the following new ones.
  
  =head2 match
  
    my $captures = $pattern->match('/foo/bar');
    my $captures = $pattern->match('/foo/bar', 1);
  
  Match pattern against entire path, format detection is disabled by default.
  
  =head2 match_partial
  
    my $captures = $pattern->match_partial(\$path);
    my $captures = $pattern->match_partial(\$path, 1);
  
  Match pattern against path and remove matching parts, format detection is
  disabled by default.
  
  =head2 new
  
    my $pattern = Mojolicious::Routes::Pattern->new;
    my $pattern = Mojolicious::Routes::Pattern->new('/:action');
    my $pattern
      = Mojolicious::Routes::Pattern->new('/:action', action => qr/\w+/);
    my $pattern = Mojolicious::Routes::Pattern->new(format => 0);
  
  Construct a new L<Mojolicious::Routes::Pattern> object and L</"parse"> pattern
  if necessary.
  
  =head2 parse
  
    $pattern = $pattern->parse('/:action');
    $pattern = $pattern->parse('/:action', action => qr/\w+/);
    $pattern = $pattern->parse(format => 0);
  
  Parse pattern.
  
  =head2 render
  
    my $path = $pattern->render({action => 'foo'});
    my $path = $pattern->render({action => 'foo'}, 1);
  
  Render pattern into a path with parameters, format rendering is disabled by
  default.
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<http://mojolicious.org>.
  
  =cut
MOJOLICIOUS_ROUTES_PATTERN

$fatpacked{"Mojolicious/Routes/Route.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJOLICIOUS_ROUTES_ROUTE';
  package Mojolicious::Routes::Route;
  use Mojo::Base -base;
  
  use Carp ();
  use Mojo::Util;
  use Mojolicious::Routes::Pattern;
  use Scalar::Util ();
  
  has [qw(inline parent partial)];
  has 'children' => sub { [] };
  has pattern    => sub { Mojolicious::Routes::Pattern->new };
  
  sub AUTOLOAD {
    my $self = shift;
  
    my ($package, $method) = our $AUTOLOAD =~ /^(.+)::(.+)$/;
    Carp::croak "Undefined subroutine &${package}::$method called"
      unless Scalar::Util::blessed $self && $self->isa(__PACKAGE__);
  
    # Call shortcut with current route
    Carp::croak qq{Can't locate object method "$method" via package "$package"}
      unless my $shortcut = $self->root->shortcuts->{$method};
    return $self->$shortcut(@_);
  }
  
  sub add_child {
    my ($self, $route) = @_;
    Scalar::Util::weaken $route->remove->parent($self)->{parent};
    push @{$self->children}, $route;
    return $self;
  }
  
  sub any { shift->_generate_route(ref $_[0] eq 'ARRAY' ? shift : [], @_) }
  
  sub delete { shift->_generate_route(DELETE => @_) }
  
  sub detour { shift->partial(1)->to(@_) }
  
  sub find { shift->_index->{shift()} }
  
  sub get { shift->_generate_route(GET => @_) }
  
  sub has_custom_name { !!shift->{custom} }
  
  sub has_websocket {
    my $self = shift;
    return $self->{has_websocket} if exists $self->{has_websocket};
    return $self->{has_websocket} = grep { $_->is_websocket } @{$self->_chain};
  }
  
  sub is_endpoint { $_[0]->inline ? undef : !@{$_[0]->children} }
  
  sub is_websocket { !!shift->{websocket} }
  
  sub name {
    my $self = shift;
    return $self->{name} unless @_;
    @$self{qw(name custom)} = (shift, 1);
    return $self;
  }
  
  sub options { shift->_generate_route(OPTIONS => @_) }
  
  sub over {
    my $self = shift;
  
    # Routes with conditions can't be cached
    return $self->{over} unless @_;
    my $conditions = ref $_[0] eq 'ARRAY' ? $_[0] : [@_];
    return $self unless @$conditions;
    $self->{over} = $conditions;
    $self->root->cache->max_keys(0);
  
    return $self;
  }
  
  sub parse {
    my $self = shift;
    $self->{name} = $self->pattern->parse(@_)->unparsed // '';
    $self->{name} =~ s/\W+//g;
    return $self;
  }
  
  sub patch { shift->_generate_route(PATCH => @_) }
  sub post  { shift->_generate_route(POST  => @_) }
  sub put   { shift->_generate_route(PUT   => @_) }
  
  sub remove {
    my $self = shift;
    return $self unless my $parent = $self->parent;
    @{$parent->children} = grep { $_ ne $self } @{$parent->children};
    return $self->parent(undef);
  }
  
  sub render {
    my ($self, $values) = @_;
    my $path = join '',
      map { $_->pattern->render($values, !@{$_->children} && !$_->partial) }
      @{$self->_chain};
    return $path || '/';
  }
  
  sub root { shift->_chain->[0] }
  
  sub route {
    my $self   = shift;
    my $route  = $self->add_child(__PACKAGE__->new->parse(@_))->children->[-1];
    my $format = $self->pattern->constraints->{format};
    $route->pattern->constraints->{format} //= 0 if defined $format && !$format;
    return $route;
  }
  
  sub suggested_method {
    my $self = shift;
  
    my %via;
    for my $route (@{$self->_chain}) {
      next unless my @via = @{$route->via || []};
      %via = map { $_ => 1 } keys %via ? grep { $via{$_} } @via : @via;
    }
  
    return 'POST' if $via{POST} && !$via{GET};
    return $via{GET} ? 'GET' : (sort keys %via)[0] || 'GET';
  }
  
  sub to {
    my $self = shift;
  
    my $pattern = $self->pattern;
    return $pattern->defaults unless @_;
    my ($shortcut, %defaults) = Mojo::Util::_options(@_);
  
    if ($shortcut) {
  
      # Application
      if (ref $shortcut || $shortcut =~ /^[\w:]+$/) {
        $defaults{app} = $shortcut;
      }
  
      # Controller and action
      elsif ($shortcut =~ /^([\w\-:]+)?\#(\w+)?$/) {
        $defaults{controller} = $1 if defined $1;
        $defaults{action}     = $2 if defined $2;
      }
    }
  
    @{$pattern->defaults}{keys %defaults} = values %defaults;
  
    return $self;
  }
  
  sub to_string {
    join '', map { $_->pattern->unparsed // '' } @{shift->_chain};
  }
  
  sub under { shift->_generate_route(under => @_) }
  
  sub via {
    my $self = shift;
    return $self->{via} unless @_;
    my $methods = [map uc($_), @{ref $_[0] ? $_[0] : [@_]}];
    $self->{via} = $methods if @$methods;
    return $self;
  }
  
  sub websocket {
    my $route = shift->get(@_);
    $route->{websocket} = 1;
    return $route;
  }
  
  sub _chain {
    my @chain = (my $parent = shift);
    unshift @chain, $parent while $parent = $parent->parent;
    return \@chain;
  }
  
  sub _generate_route {
    my ($self, $methods, @args) = @_;
  
    my (@conditions, @constraints, %defaults, $name, $pattern);
    while (defined(my $arg = shift @args)) {
  
      # First scalar is the pattern
      if (!ref $arg && !$pattern) { $pattern = $arg }
  
      # Scalar
      elsif (!ref $arg && @args) { push @conditions, $arg, shift @args }
  
      # Last scalar is the route name
      elsif (!ref $arg) { $name = $arg }
  
      # Callback
      elsif (ref $arg eq 'CODE') { $defaults{cb} = $arg }
  
      # Constraints
      elsif (ref $arg eq 'ARRAY') { push @constraints, @$arg }
  
      # Defaults
      elsif (ref $arg eq 'HASH') { %defaults = (%defaults, %$arg) }
    }
  
    my $route
      = $self->route($pattern, @constraints)->over(\@conditions)->to(\%defaults);
    $methods eq 'under' ? $route->inline(1) : $route->via($methods);
  
    return defined $name ? $route->name($name) : $route;
  }
  
  sub _index {
    my $self = shift;
  
    my (%auto, %custom);
    my @children = (@{$self->children});
    while (my $child = shift @children) {
      if   ($child->has_custom_name) { $custom{$child->name} ||= $child }
      else                           { $auto{$child->name}   ||= $child }
      push @children, @{$child->children};
    }
  
    return {%auto, %custom};
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojolicious::Routes::Route - Route
  
  =head1 SYNOPSIS
  
    use Mojolicious::Routes::Route;
  
    my $r = Mojolicious::Routes::Route->new;
  
  =head1 DESCRIPTION
  
  L<Mojolicious::Routes::Route> is the route container used by
  L<Mojolicious::Routes>.
  
  =head1 ATTRIBUTES
  
  L<Mojolicious::Routes::Route> implements the following attributes.
  
  =head2 children
  
    my $children = $r->children;
    $r           = $r->children([Mojolicious::Routes::Route->new]);
  
  The children of this route, used for nesting routes.
  
  =head2 inline
  
    my $bool = $r->inline;
    $r       = $r->inline($bool);
  
  Allow L</"under"> semantics for this route.
  
  =head2 parent
  
    my $parent = $r->parent;
    $r         = $r->parent(Mojolicious::Routes::Route->new);
  
  The parent of this route, usually a L<Mojolicious::Routes::Route> object.
  
  =head2 partial
  
    my $bool = $r->partial;
    $r       = $r->partial($bool);
  
  Route has no specific end, remaining characters will be captured in C<path>.
  
  =head2 pattern
  
    my $pattern = $r->pattern;
    $r          = $r->pattern(Mojolicious::Routes::Pattern->new);
  
  Pattern for this route, defaults to a L<Mojolicious::Routes::Pattern> object.
  
  =head1 METHODS
  
  L<Mojolicious::Routes::Route> inherits all methods from L<Mojo::Base> and
  implements the following new ones.
  
  =head2 add_child
  
    $r = $r->add_child(Mojolicious::Routes::Route->new);
  
  Add a child to this route, it will be automatically removed from its current
  parent if necessary.
  
    # Reattach route
    $r->add_child($r->find('foo'));
  
  =head2 any
  
    my $route = $r->any;
    my $route = $r->any('/:foo');
    my $route = $r->any('/:foo' => sub {...});
    my $route = $r->any('/:foo' => sub {...} => 'name');
    my $route = $r->any('/:foo' => {foo => 'bar'} => sub {...});
    my $route = $r->any('/:foo' => [foo => qr/\w+/] => sub {...});
    my $route = $r->any('/:foo' => (agent => qr/Firefox/) => sub {...});
    my $route = $r->any(['GET', 'POST'] => '/:foo' => sub {...});
    my $route = $r->any(['GET', 'POST'] => '/:foo' => [foo => qr/\w+/]);
  
  Generate L<Mojolicious::Routes::Route> object matching any of the listed HTTP
  request methods or all.
  
    # Route with pattern and destination
    $r->any('/user')->to('user#whatever');
  
  All arguments are optional, but some have to appear in a certain order, like the
  two supported array reference values, which contain the HTTP methods to match
  and restrictive placeholders.
  
    # Route with HTTP methods, pattern, restrictive placeholders and destination
    $r->any(['DELETE', 'PUT'] => '/:foo' => [foo => qr/\w+/])->to('foo#bar');
  
  There are also two supported string values, containing the route pattern and the
  route name, defaulting to the pattern C</> and a name based on the pattern.
  
    # Route with pattern, name and destination
    $r->any('/:foo' => 'foo_route')->to('foo#bar');
  
  An arbitrary number of key/value pairs in between the route pattern and name can
  be used to specify route conditions.
  
    # Route with pattern, condition and destination
    $r->any('/' => (agent => qr/Firefox/))->to('foo#bar');
  
  A hash reference is used to specify optional placeholders and default values for
  the stash.
  
    # Route with pattern, optional placeholder and destination
    $r->any('/:foo' => {foo => 'bar'})->to('foo#bar');
  
  And a code reference can be used to specify a C<cb> value to be merged into the
  default values for the stash.
  
    # Route with pattern and a closure as destination
    $r->any('/:foo' => sub {
      my $c = shift;
      $c->render(text => 'Hello World!');
    });
  
  See L<Mojolicious::Guides::Tutorial> and L<Mojolicious::Guides::Routing> for
  more information.
  
  =head2 delete
  
    my $route = $r->delete;
    my $route = $r->delete('/:foo');
    my $route = $r->delete('/:foo' => sub {...});
    my $route = $r->delete('/:foo' => sub {...} => 'name');
    my $route = $r->delete('/:foo' => {foo => 'bar'} => sub {...});
    my $route = $r->delete('/:foo' => [foo => qr/\w+/] => sub {...});
    my $route = $r->delete('/:foo' => (agent => qr/Firefox/) => sub {...});
  
  Generate L<Mojolicious::Routes::Route> object matching only C<DELETE> requests,
  takes the same arguments as L</"any"> (except for the HTTP methods to match,
  which are implied). See L<Mojolicious::Guides::Tutorial> and
  L<Mojolicious::Guides::Routing> for more information.
  
    # Route with destination
    $r->delete('/user')->to('user#remove');
  
  =head2 detour
  
    $r = $r->detour(action => 'foo');
    $r = $r->detour('controller#action');
    $r = $r->detour(Mojolicious->new, foo => 'bar');
    $r = $r->detour('MyApp', {foo => 'bar'});
  
  Set default parameters for this route and allow partial matching to simplify
  application embedding, takes the same arguments as L</"to">.
  
  =head2 find
  
    my $route = $r->find('foo');
  
  Find child route by name, custom names have precedence over automatically
  generated ones.
  
    # Change default parameters of a named route
    $r->find('show_user')->to(foo => 'bar');
  
  =head2 get
  
    my $route = $r->get;
    my $route = $r->get('/:foo');
    my $route = $r->get('/:foo' => sub {...});
    my $route = $r->get('/:foo' => sub {...} => 'name');
    my $route = $r->get('/:foo' => {foo => 'bar'} => sub {...});
    my $route = $r->get('/:foo' => [foo => qr/\w+/] => sub {...});
    my $route = $r->get('/:foo' => (agent => qr/Firefox/) => sub {...});
  
  Generate L<Mojolicious::Routes::Route> object matching only C<GET> requests,
  takes the same arguments as L</"any"> (except for the HTTP methods to match,
  which are implied). See L<Mojolicious::Guides::Tutorial> and
  L<Mojolicious::Guides::Routing> for more information.
  
    # Route with destination
    $r->get('/user')->to('user#show');
  
  =head2 has_custom_name
  
    my $bool = $r->has_custom_name;
  
  Check if this route has a custom name.
  
  =head2 has_websocket
  
    my $bool = $r->has_websocket;
  
  Check if this route has a WebSocket ancestor and cache the result for future
  checks.
  
  =head2 is_endpoint
  
    my $bool = $r->is_endpoint;
  
  Check if this route qualifies as an endpoint.
  
  =head2 is_websocket
  
    my $bool = $r->is_websocket;
  
  Check if this route is a WebSocket.
  
  =head2 name
  
    my $name = $r->name;
    $r       = $r->name('foo');
  
  The name of this route, defaults to an automatically generated name based on
  the route pattern. Note that the name C<current> is reserved for referring to
  the current route.
  
    # Route with destination and custom name
    $r->get('/user')->to('user#show')->name('show_user');
  
  =head2 options
  
    my $route = $r->options;
    my $route = $r->options('/:foo');
    my $route = $r->options('/:foo' => sub {...});
    my $route = $r->options('/:foo' => sub {...} => 'name');
    my $route = $r->options('/:foo' => {foo => 'bar'} => sub {...});
    my $route = $r->options('/:foo' => [foo => qr/\w+/] => sub {...});
    my $route = $r->options('/:foo' => (agent => qr/Firefox/) => sub {...});
  
  Generate L<Mojolicious::Routes::Route> object matching only C<OPTIONS>
  requests, takes the same arguments as L</"any"> (except for the HTTP methods to
  match, which are implied). See L<Mojolicious::Guides::Tutorial> and
  L<Mojolicious::Guides::Routing> for more information.
  
    # Route with destination
    $r->options('/user')->to('user#overview');
  
  =head2 over
  
    my $over = $r->over;
    $r       = $r->over(foo => 1);
    $r       = $r->over(foo => 1, bar => {baz => 'yada'});
    $r       = $r->over([foo => 1, bar => {baz => 'yada'}]);
  
  Activate conditions for this route. Note that this automatically disables the
  routing cache, since conditions are too complex for caching.
  
    # Route with condition and destination
    $r->get('/foo')->over(host => qr/mojolicious\.org/)->to('foo#bar');
  
  =head2 parse
  
    $r = $r->parse('/:action');
    $r = $r->parse('/:action', action => qr/\w+/);
    $r = $r->parse(format => 0);
  
  Parse pattern.
  
  =head2 patch
  
    my $route = $r->patch;
    my $route = $r->patch('/:foo');
    my $route = $r->patch('/:foo' => sub {...});
    my $route = $r->patch('/:foo' => sub {...} => 'name');
    my $route = $r->patch('/:foo' => {foo => 'bar'} => sub {...});
    my $route = $r->patch('/:foo' => [foo => qr/\w+/] => sub {...});
    my $route = $r->patch('/:foo' => (agent => qr/Firefox/) => sub {...});
  
  Generate L<Mojolicious::Routes::Route> object matching only C<PATCH> requests,
  takes the same arguments as L</"any"> (except for the HTTP methods to match,
  which are implied). See L<Mojolicious::Guides::Tutorial> and
  L<Mojolicious::Guides::Routing> for more information.
  
    # Route with destination
    $r->patch('/user')->to('user#update');
  
  =head2 post
  
    my $route = $r->post;
    my $route = $r->post('/:foo');
    my $route = $r->post('/:foo' => sub {...});
    my $route = $r->post('/:foo' => sub {...} => 'name');
    my $route = $r->post('/:foo' => {foo => 'bar'} => sub {...});
    my $route = $r->post('/:foo' => [foo => qr/\w+/] => sub {...});
    my $route = $r->post('/:foo' => (agent => qr/Firefox/) => sub {...});
  
  Generate L<Mojolicious::Routes::Route> object matching only C<POST> requests,
  takes the same arguments as L</"any"> (except for the HTTP methods to match,
  which are implied). See L<Mojolicious::Guides::Tutorial> and
  L<Mojolicious::Guides::Routing> for more information.
  
    # Route with destination
    $r->post('/user')->to('user#create');
  
  =head2 put
  
    my $route = $r->put;
    my $route = $r->put('/:foo');
    my $route = $r->put('/:foo' => sub {...});
    my $route = $r->put('/:foo' => sub {...} => 'name');
    my $route = $r->put('/:foo' => {foo => 'bar'} => sub {...});
    my $route = $r->put('/:foo' => [foo => qr/\w+/] => sub {...});
    my $route = $r->put('/:foo' => (agent => qr/Firefox/) => sub {...});
  
  Generate L<Mojolicious::Routes::Route> object matching only C<PUT> requests,
  takes the same arguments as L</"any"> (except for the HTTP methods to match,
  which are implied). See L<Mojolicious::Guides::Tutorial> and
  L<Mojolicious::Guides::Routing> for more information.
  
    # Route with destination
    $r->put('/user')->to('user#replace');
  
  =head2 remove
  
    $r = $r->remove;
  
  Remove route from parent.
  
    # Remove route completely
    $r->find('foo')->remove;
  
    # Reattach route to new parent
    $r->route('/foo')->add_child($r->find('bar')->remove);
  
  =head2 render
  
    my $path = $r->render({foo => 'bar'});
  
  Render route with parameters into a path.
  
  =head2 root
  
    my $root = $r->root;
  
  The L<Mojolicious::Routes> object this route is a descendant of.
  
  =head2 route
  
    my $route = $r->route;
    my $route = $r->route('/:action');
    my $route = $r->route('/:action', action => qr/\w+/);
    my $route = $r->route(format => 0);
  
  Low-level generator for routes matching all HTTP request methods, returns a
  L<Mojolicious::Routes::Route> object.
  
  =head2 suggested_method
  
    my $method = $r->suggested_method;
  
  Suggested HTTP method for reaching this route, C<GET> and C<POST> are
  preferred.
  
  =head2 to
  
    my $defaults = $r->to;
    $r           = $r->to(action => 'foo');
    $r           = $r->to({action => 'foo'});
    $r           = $r->to('controller#action');
    $r           = $r->to('controller#action', foo => 'bar');
    $r           = $r->to('controller#action', {foo => 'bar'});
    $r           = $r->to(Mojolicious->new);
    $r           = $r->to(Mojolicious->new, foo => 'bar');
    $r           = $r->to(Mojolicious->new, {foo => 'bar'});
    $r           = $r->to('MyApp');
    $r           = $r->to('MyApp', foo => 'bar');
    $r           = $r->to('MyApp', {foo => 'bar'});
  
  Set default parameters for this route.
  
  =head2 to_string
  
    my $str = $r->to_string;
  
  Stringify the whole route.
  
  =head2 under
  
    my $route = $r->under(sub {...});
    my $route = $r->under('/:foo' => sub {...});
    my $route = $r->under('/:foo' => {foo => 'bar'});
    my $route = $r->under('/:foo' => [foo => qr/\w+/]);
    my $route = $r->under('/:foo' => (agent => qr/Firefox/));
    my $route = $r->under([format => 0]);
  
  Generate L<Mojolicious::Routes::Route> object for a nested route with its own
  intermediate destination, takes the same arguments as L</"any"> (except for the
  HTTP methods to match, which are not available). See
  L<Mojolicious::Guides::Tutorial> and L<Mojolicious::Guides::Routing> for more
  information.
  
    # Intermediate destination and prefix shared between two routes
    my $auth = $r->under('/user')->to('user#auth');
    $auth->get('/show')->to('#show');
    $auth->post('/create')->to('#create');
  
  =head2 via
  
    my $methods = $r->via;
    $r          = $r->via('GET');
    $r          = $r->via('GET', 'POST');
    $r          = $r->via(['GET', 'POST']);
  
  Restrict HTTP methods this route is allowed to handle, defaults to no
  restrictions.
  
    # Route with two methods and destination
    $r->route('/foo')->via('GET', 'POST')->to('foo#bar');
  
  =head2 websocket
  
    my $route = $r->websocket;
    my $route = $r->websocket('/:foo');
    my $route = $r->websocket('/:foo' => sub {...});
    my $route = $r->websocket('/:foo' => sub {...} => 'name');
    my $route = $r->websocket('/:foo' => {foo => 'bar'} => sub {...});
    my $route = $r->websocket('/:foo' => [foo => qr/\w+/] => sub {...});
    my $route = $r->websocket('/:foo' => (agent => qr/Firefox/) => sub {...});
  
  Generate L<Mojolicious::Routes::Route> object matching only WebSocket
  handshakes, takes the same arguments as L</"any"> (except for the HTTP methods
  to match, which are implied). See L<Mojolicious::Guides::Tutorial> and
  L<Mojolicious::Guides::Routing> for more information.
  
    # Route with destination
    $r->websocket('/echo')->to('example#echo');
  
  =head1 AUTOLOAD
  
  In addition to the L</"ATTRIBUTES"> and L</"METHODS"> above you can also call
  shortcuts provided by L</"root"> on L<Mojolicious::Routes::Route> objects.
  
    # Add a "firefox" shortcut
    $r->root->add_shortcut(firefox => sub {
      my ($r, $path) = @_;
      $r->get($path, agent => qr/Firefox/);
    });
  
    # Use "firefox" shortcut to generate routes
    $r->firefox('/welcome')->to('firefox#welcome');
    $r->firefox('/bye')->to('firefox#bye');
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<http://mojolicious.org>.
  
  =cut
MOJOLICIOUS_ROUTES_ROUTE

$fatpacked{"Mojolicious/Sessions.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJOLICIOUS_SESSIONS';
  package Mojolicious::Sessions;
  use Mojo::Base -base;
  
  use Mojo::JSON;
  use Mojo::Util qw(b64_decode b64_encode);
  
  has [qw(cookie_domain secure)];
  has cookie_name        => 'mojolicious';
  has cookie_path        => '/';
  has default_expiration => 3600;
  has deserialize        => sub { \&Mojo::JSON::j };
  has serialize          => sub { \&Mojo::JSON::encode_json };
  
  sub load {
    my ($self, $c) = @_;
  
    return unless my $value = $c->signed_cookie($self->cookie_name);
    $value =~ y/-/=/;
    return unless my $session = $self->deserialize->(b64_decode $value);
  
    # "expiration" value is inherited
    my $expiration = $session->{expiration} // $self->default_expiration;
    return if !(my $expires = delete $session->{expires}) && $expiration;
    return if defined $expires && $expires <= time;
  
    my $stash = $c->stash;
    return unless $stash->{'mojo.active_session'} = keys %$session;
    $stash->{'mojo.session'} = $session;
    $session->{flash} = delete $session->{new_flash} if $session->{new_flash};
  }
  
  sub store {
    my ($self, $c) = @_;
  
    # Make sure session was active
    my $stash = $c->stash;
    return unless my $session = $stash->{'mojo.session'};
    return unless keys %$session || $stash->{'mojo.active_session'};
  
    # Don't reset flash for static files
    my $old = delete $session->{flash};
    $session->{new_flash} = $old if $stash->{'mojo.static'};
    delete $session->{new_flash} unless keys %{$session->{new_flash}};
  
    # Generate "expires" value from "expiration" if necessary
    my $expiration = $session->{expiration} // $self->default_expiration;
    my $default = delete $session->{expires};
    $session->{expires} = $default || time + $expiration
      if $expiration || $default;
  
    my $value = b64_encode $self->serialize->($session), '';
    $value =~ y/=/-/;
    my $options = {
      domain   => $self->cookie_domain,
      expires  => $session->{expires},
      httponly => 1,
      path     => $self->cookie_path,
      secure   => $self->secure
    };
    $c->signed_cookie($self->cookie_name, $value, $options);
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojolicious::Sessions - Session manager based on signed cookies
  
  =head1 SYNOPSIS
  
    use Mojolicious::Sessions;
  
    my $sessions = Mojolicious::Sessions->new;
    $sessions->cookie_name('myapp');
    $sessions->default_expiration(86400);
  
  =head1 DESCRIPTION
  
  L<Mojolicious::Sessions> manages sessions based on signed cookies for
  L<Mojolicious>. All data gets serialized with L<Mojo::JSON> and stored Base64
  encoded on the client-side, but is protected from unwanted changes with a
  HMAC-SHA1 signature.
  
  =head1 ATTRIBUTES
  
  L<Mojolicious::Sessions> implements the following attributes.
  
  =head2 cookie_domain
  
    my $domain = $sessions->cookie_domain;
    $sessions  = $sessions->cookie_domain('.example.com');
  
  Domain for session cookies, not defined by default.
  
  =head2 cookie_name
  
    my $name  = $sessions->cookie_name;
    $sessions = $sessions->cookie_name('session');
  
  Name for session cookies, defaults to C<mojolicious>.
  
  =head2 cookie_path
  
    my $path  = $sessions->cookie_path;
    $sessions = $sessions->cookie_path('/foo');
  
  Path for session cookies, defaults to C</>.
  
  =head2 default_expiration
  
    my $time  = $sessions->default_expiration;
    $sessions = $sessions->default_expiration(3600);
  
  Default time for sessions to expire in seconds from now, defaults to C<3600>.
  The expiration timeout gets refreshed for every request. Setting the value to
  C<0> will allow sessions to persist until the browser window is closed, this
  can have security implications though. For more control you can also use the
  C<expiration> and C<expires> session values.
  
    # Expiration date in seconds from now (persists between requests)
    $c->session(expiration => 604800);
  
    # Expiration date as absolute epoch time (only valid for one request)
    $c->session(expires => time + 604800);
  
    # Delete whole session by setting an expiration date in the past
    $c->session(expires => 1);
  
  =head2 deserialize
  
    my $cb    = $sessions->deserialize;
    $sessions = $sessions->deserialize(sub {...});
  
  A callback used to deserialize sessions, defaults to L<Mojo::JSON/"j">.
  
    $sessions->deserialize(sub {
      my $bytes = shift;
      return {};
    });
  
  =head2 secure
  
    my $bool  = $sessions->secure;
    $sessions = $sessions->secure($bool);
  
  Set the secure flag on all session cookies, so that browsers send them only
  over HTTPS connections.
  
  =head2 serialize
  
    my $cb    = $sessions->serialize;
    $sessions = $sessions->serialize(sub {...});
  
  A callback used to serialize sessions, defaults to L<Mojo::JSON/"encode_json">.
  
    $sessions->serialize(sub {
      my $hash = shift;
      return '';
    });
  
  =head1 METHODS
  
  L<Mojolicious::Sessions> inherits all methods from L<Mojo::Base> and implements
  the following new ones.
  
  =head2 load
  
    $sessions->load(Mojolicious::Controller->new);
  
  Load session data from signed cookie.
  
  =head2 store
  
    $sessions->store(Mojolicious::Controller->new);
  
  Store session data in signed cookie.
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<http://mojolicious.org>.
  
  =cut
MOJOLICIOUS_SESSIONS

$fatpacked{"Mojolicious/Static.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJOLICIOUS_STATIC';
  package Mojolicious::Static;
  use Mojo::Base -base;
  
  use Mojo::Asset::File;
  use Mojo::Asset::Memory;
  use Mojo::Date;
  use Mojo::File 'path';
  use Mojo::Home;
  use Mojo::Loader 'data_section';
  use Mojo::Util 'md5_sum';
  
  has classes => sub { ['main'] };
  has paths   => sub { [] };
  
  # Bundled files
  my $PUBLIC = Mojo::Home->new(Mojo::Home->new->mojo_lib_dir)
    ->child('Mojolicious', 'resources', 'public');
  
  sub dispatch {
    my ($self, $c) = @_;
  
    # Method (GET or HEAD)
    my $req    = $c->req;
    my $method = $req->method;
    return undef unless $method eq 'GET' || $method eq 'HEAD';
  
    # Canonical path
    my $stash = $c->stash;
    my $path  = $req->url->path;
    $path = $stash->{path} ? $path->new($stash->{path}) : $path->clone;
    return undef unless my @parts = @{$path->canonicalize->parts};
  
    # Serve static file and prevent path traversal
    return undef if $parts[0] eq '..' || !$self->serve($c, join('/', @parts));
    $stash->{'mojo.static'} = 1;
    return !!$c->rendered;
  }
  
  sub file {
    my ($self, $rel) = @_;
  
    # Search all paths
    for my $path (@{$self->paths}) {
      my $asset = $self->_get_file(path($path, split('/', $rel))->to_string);
      return $asset if $asset;
    }
  
    # Search DATA
    if (my $asset = $self->_get_data_file($rel)) { return $asset }
  
    # Search bundled files
    return $self->_get_file(path($PUBLIC, split('/', $rel))->to_string);
  }
  
  sub is_fresh {
    my ($self, $c, $options) = @_;
  
    my $res_headers = $c->res->headers;
    my ($last, $etag) = @$options{qw(last_modified etag)};
    $res_headers->last_modified(Mojo::Date->new($last)->to_string) if $last;
    $res_headers->etag($etag = qq{"$etag"}) if $etag;
  
    # Unconditional
    my $req_headers = $c->req->headers;
    my $match       = $req_headers->if_none_match;
    return undef unless (my $since = $req_headers->if_modified_since) || $match;
  
    # If-None-Match
    return undef if $match && ($etag // $res_headers->etag // '') ne $match;
  
    # If-Modified-Since
    return !!$match unless ($last //= $res_headers->last_modified) && $since;
    return _epoch($last) <= (_epoch($since) // 0);
  }
  
  sub serve {
    my ($self, $c, $rel) = @_;
  
    return undef unless my $asset = $self->file($rel);
    my $headers = $c->res->headers;
    return !!$self->serve_asset($c, $asset) if $headers->content_type;
  
    # Content-Type
    my $types = $c->app->types;
    my $type = $rel =~ /\.(\w+)$/ ? $types->type($1) : undef;
    $headers->content_type($type || $types->type('txt'));
    return !!$self->serve_asset($c, $asset);
  }
  
  sub serve_asset {
    my ($self, $c, $asset) = @_;
  
    # Last-Modified and ETag
    my $res = $c->res;
    $res->code(200)->headers->accept_ranges('bytes');
    my $mtime = $asset->mtime;
    my $options = {etag => md5_sum($mtime), last_modified => $mtime};
    return $res->code(304) if $self->is_fresh($c, $options);
  
    # Range
    return $res->content->asset($asset)
      unless my $range = $c->req->headers->range;
  
    # Not satisfiable
    return $res->code(416) unless my $size = $asset->size;
    return $res->code(416) unless $range =~ /^bytes=(\d+)?-(\d+)?/;
    my ($start, $end) = ($1 // 0, defined $2 && $2 < $size ? $2 : $size - 1);
    return $res->code(416) if $start > $end;
  
    # Satisfiable
    $res->code(206)->headers->content_length($end - $start + 1)
      ->content_range("bytes $start-$end/$size");
    return $res->content->asset($asset->start_range($start)->end_range($end));
  }
  
  sub warmup {
    my $self = shift;
    my $index = $self->{index} = {};
    for my $class (reverse @{$self->classes}) {
      $index->{$_} = $class for keys %{data_section $class};
    }
  }
  
  sub _epoch { Mojo::Date->new(shift)->epoch }
  
  sub _get_data_file {
    my ($self, $rel) = @_;
  
    # Protect files without extensions and templates with two extensions
    return undef if $rel !~ /\.\w+$/ || $rel =~ /\.\w+\.\w+$/;
  
    $self->warmup unless $self->{index};
  
    # Find file
    return undef
      unless defined(my $data = data_section($self->{index}{$rel}, $rel));
    return Mojo::Asset::Memory->new->add_chunk($data);
  }
  
  sub _get_file {
    my ($self, $path) = @_;
    no warnings 'newline';
    return -f $path && -r _ ? Mojo::Asset::File->new(path => $path) : undef;
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojolicious::Static - Serve static files
  
  =head1 SYNOPSIS
  
    use Mojolicious::Static;
  
    my $static = Mojolicious::Static->new;
    push @{$static->classes}, 'MyApp::Controller::Foo';
    push @{$static->paths}, '/home/sri/public';
  
  =head1 DESCRIPTION
  
  L<Mojolicious::Static> is a static file server with C<Range>,
  C<If-Modified-Since> and C<If-None-Match> support, based on
  L<RFC 7232|http://tools.ietf.org/html/rfc7232> and
  L<RFC 7233|http://tools.ietf.org/html/rfc7233>.
  
  =head1 ATTRIBUTES
  
  L<Mojolicious::Static> implements the following attributes.
  
  =head2 classes
  
    my $classes = $static->classes;
    $static     = $static->classes(['main']);
  
  Classes to use for finding files in C<DATA> sections with L<Mojo::Loader>,
  first one has the highest precedence, defaults to C<main>. Only files with
  exactly one extension will be used, like C<index.html>. Note that for files to
  be detected, these classes need to have already been loaded and added before
  L</"warmup"> is called, which usually happens automatically during application
  startup.
  
    # Add another class with static files in DATA section
    push @{$static->classes}, 'Mojolicious::Plugin::Fun';
  
    # Add another class with static files in DATA section and higher precedence
    unshift @{$static->classes}, 'Mojolicious::Plugin::MoreFun';
  
  =head2 paths
  
    my $paths = $static->paths;
    $static   = $static->paths(['/home/sri/public']);
  
  Directories to serve static files from, first one has the highest precedence.
  
    # Add another "public" directory
    push @{$static->paths}, '/home/sri/public';
  
    # Add another "public" directory with higher precedence
    unshift @{$static->paths}, '/home/sri/themes/blue/public';
  
  =head1 METHODS
  
  L<Mojolicious::Static> inherits all methods from L<Mojo::Base> and implements
  the following new ones.
  
  =head2 dispatch
  
    my $bool = $static->dispatch(Mojolicious::Controller->new);
  
  Serve static file for L<Mojolicious::Controller> object.
  
  =head2 file
  
    my $asset = $static->file('images/logo.png');
    my $asset = $static->file('../lib/MyApp.pm');
  
  Build L<Mojo::Asset::File> or L<Mojo::Asset::Memory> object for a file,
  relative to L</"paths"> or from L</"classes">, or return C<undef> if it doesn't
  exist. Note that this method uses a relative path, but does not protect from
  traversing to parent directories.
  
    my $content = $static->file('foo/bar.html')->slurp;
  
  =head2 is_fresh
  
    my $bool = $static->is_fresh(Mojolicious::Controller->new, {etag => 'abc'});
  
  Check freshness of request by comparing the C<If-None-Match> and
  C<If-Modified-Since> request headers to the C<ETag> and C<Last-Modified>
  response headers.
  
  These options are currently available:
  
  =over 2
  
  =item etag
  
    etag => 'abc'
  
  Add C<ETag> header before comparing.
  
  =item last_modified
  
    last_modified => $epoch
  
  Add C<Last-Modified> header before comparing.
  
  =back
  
  =head2 serve
  
    my $bool = $static->serve(Mojolicious::Controller->new, 'images/logo.png');
    my $bool = $static->serve(Mojolicious::Controller->new, '../lib/MyApp.pm');
  
  Serve a specific file, relative to L</"paths"> or from L</"classes">. Note that
  this method uses a relative path, but does not protect from traversing to parent
  directories.
  
  =head2 serve_asset
  
    $static->serve_asset(Mojolicious::Controller->new, Mojo::Asset::File->new);
  
  Serve a L<Mojo::Asset::File> or L<Mojo::Asset::Memory> object with C<Range>,
  C<If-Modified-Since> and C<If-None-Match> support.
  
  =head2 warmup
  
    $static->warmup;
  
  Prepare static files from L</"classes"> for future use.
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<http://mojolicious.org>.
  
  =cut
MOJOLICIOUS_STATIC

$fatpacked{"Mojolicious/Types.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJOLICIOUS_TYPES';
  package Mojolicious::Types;
  use Mojo::Base -base;
  
  has mapping => sub {
    {
      appcache => ['text/cache-manifest'],
      atom     => ['application/atom+xml'],
      bin      => ['application/octet-stream'],
      css      => ['text/css'],
      gif      => ['image/gif'],
      gz       => ['application/x-gzip'],
      htm      => ['text/html'],
      html     => ['text/html;charset=UTF-8'],
      ico      => ['image/x-icon'],
      jpeg     => ['image/jpeg'],
      jpg      => ['image/jpeg'],
      js       => ['application/javascript'],
      json     => ['application/json;charset=UTF-8'],
      mp3      => ['audio/mpeg'],
      mp4      => ['video/mp4'],
      ogg      => ['audio/ogg'],
      ogv      => ['video/ogg'],
      pdf      => ['application/pdf'],
      png      => ['image/png'],
      rss      => ['application/rss+xml'],
      svg      => ['image/svg+xml'],
      txt      => ['text/plain;charset=UTF-8'],
      webm     => ['video/webm'],
      woff     => ['application/font-woff'],
      xml      => ['application/xml', 'text/xml'],
      zip      => ['application/zip']
    };
  };
  
  sub detect {
    my ($self, $accept, $prioritize) = @_;
  
    # Extract and prioritize MIME types
    my %types;
    /^\s*([^,; ]+)(?:\s*\;\s*q\s*=\s*(\d+(?:\.\d+)?))?\s*$/i
      and $types{lc $1} = $2 // 1
      for split ',', $accept // '';
    my @detected = sort { $types{$b} <=> $types{$a} } sort keys %types;
    return [] if !$prioritize && @detected > 1;
  
    # Detect extensions from MIME types
    my %reverse;
    my $mapping = $self->mapping;
    for my $ext (sort keys %$mapping) {
      my @types = @{$mapping->{$ext}};
      push @{$reverse{$_}}, $ext for map { s/\;.*$//; lc $_ } @types;
    }
    return [map { @{$reverse{$_} // []} } @detected];
  }
  
  sub type {
    my ($self, $ext, $type) = @_;
    return $self->mapping->{lc $ext}[0] unless $type;
    $self->mapping->{lc $ext} = ref $type ? $type : [$type];
    return $self;
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojolicious::Types - MIME types
  
  =head1 SYNOPSIS
  
    use Mojolicious::Types;
  
    my $types = Mojolicious::Types->new;
    $types->type(foo => 'text/foo');
    say $types->type('foo');
  
  =head1 DESCRIPTION
  
  L<Mojolicious::Types> manages MIME types for L<Mojolicious>.
  
    appcache -> text/cache-manifest
    atom     -> application/atom+xml
    bin      -> application/octet-stream
    css      -> text/css
    gif      -> image/gif
    gz       -> application/x-gzip
    htm      -> text/html
    html     -> text/html;charset=UTF-8
    ico      -> image/x-icon
    jpeg     -> image/jpeg
    jpg      -> image/jpeg
    js       -> application/javascript
    json     -> application/json;charset=UTF-8
    mp3      -> audio/mpeg
    mp4      -> video/mp4
    ogg      -> audio/ogg
    ogv      -> video/ogg
    pdf      -> application/pdf
    png      -> image/png
    rss      -> application/rss+xml
    svg      -> image/svg+xml
    txt      -> text/plain;charset=UTF-8
    webm     -> video/webm
    woff     -> application/font-woff
    xml      -> application/xml,text/xml
    zip      -> application/zip
  
  The most common ones are already defined.
  
  =head1 ATTRIBUTES
  
  L<Mojolicious::Types> implements the following attributes.
  
  =head2 mapping
  
    my $mapping = $types->mapping;
    $types      = $types->mapping({png => ['image/png']});
  
  MIME type mapping.
  
  =head1 METHODS
  
  L<Mojolicious::Types> inherits all methods from L<Mojo::Base> and implements
  the following new ones.
  
  =head2 detect
  
    my $exts = $types->detect('application/json;q=9');
    my $exts = $types->detect('text/html, application/json;q=9', 1);
  
  Detect file extensions from C<Accept> header value, prioritization of
  unspecific values that contain more than one MIME type is disabled by default.
  
    # List detected extensions prioritized
    say for @{$types->detect('application/json, text/xml;q=0.1', 1)};
  
  =head2 type
  
    my $type = $types->type('png');
    $types   = $types->type(png => 'image/png');
    $types   = $types->type(json => ['application/json', 'text/x-json']);
  
  Get or set MIME types for file extension, alternatives are only used for
  detection.
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<http://mojolicious.org>.
  
  =cut
MOJOLICIOUS_TYPES

$fatpacked{"Mojolicious/Validator.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJOLICIOUS_VALIDATOR';
  package Mojolicious::Validator;
  use Mojo::Base -base;
  
  use Mojo::Util 'trim';
  use Mojolicious::Validator::Validation;
  
  has checks => sub {
    {
      equal_to => \&_equal_to,
      in       => \&_in,
      like     => sub { $_[2] !~ $_[3] },
      size     => \&_size,
      upload   => sub { !ref $_[2] || !$_[2]->isa('Mojo::Upload') }
    };
  };
  has filters => sub { {trim => \&_trim} };
  
  sub add_check  { $_[0]->checks->{$_[1]}  = $_[2] and return $_[0] }
  sub add_filter { $_[0]->filters->{$_[1]} = $_[2] and return $_[0] }
  
  sub validation {
    Mojolicious::Validator::Validation->new(validator => shift);
  }
  
  sub _equal_to {
    my ($validation, $name, $value, $to) = @_;
    return 1 unless defined(my $other = $validation->input->{$to});
    return $value ne $other;
  }
  
  sub _in {
    my ($validation, $name, $value) = (shift, shift, shift);
    $value eq $_ && return undef for @_;
    return 1;
  }
  
  sub _size {
    my ($validation, $name, $value, $min, $max) = @_;
    my $len = ref $value ? $value->size : length $value;
    return $len < $min || $len > $max;
  }
  
  sub _trim { trim $_[2] // '' }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojolicious::Validator - Validate values
  
  =head1 SYNOPSIS
  
    use Mojolicious::Validator;
  
    my $validator  = Mojolicious::Validator->new;
    my $validation = $validator->validation;
    $validation->input({foo => 'bar'});
    $validation->required('foo')->like(qr/ar$/);
    say $validation->param('foo');
  
  =head1 DESCRIPTION
  
  L<Mojolicious::Validator> validates values for L<Mojolicious>.
  
  =head1 CHECKS
  
  These validation checks are available by default.
  
  =head2 equal_to
  
    $validation = $validation->equal_to('foo');
  
  String value needs to be equal to the value of another field.
  
  =head2 in
  
    $validation = $validation->in('foo', 'bar', 'baz');
  
  String value needs to match one of the values in the list.
  
  =head2 like
  
    $validation = $validation->like(qr/^[A-Z]/);
  
  String value needs to match the regular expression.
  
  =head2 size
  
    $validation = $validation->size(2, 5);
  
  String value length or size of L<Mojo::Upload> object in bytes needs to be
  between these two values.
  
  =head2 upload
  
    $validation = $validation->upload;
  
  Value needs to be a L<Mojo::Upload> object, representing a file upload.
  
  =head1 FILTERS
  
  These filters are available by default.
  
  =head2 trim
  
    $validation = $validation->optional('foo', 'trim');
  
  Trim whitespace characters from both ends of string value with
  L<Mojo::Util/"trim">.
  
  =head1 ATTRIBUTES
  
  L<Mojolicious::Validator> implements the following attributes.
  
  =head2 checks
  
    my $checks = $validator->checks;
    $validator = $validator->checks({size => sub {...}});
  
  Registered validation checks, by default only L</"equal_to">, L</"in">,
  L</"like">, L</"size"> and L</"upload"> are already defined.
  
  =head1 METHODS
  
  L<Mojolicious::Validator> inherits all methods from L<Mojo::Base> and
  implements the following new ones.
  
  =head2 add_check
  
    $validator = $validator->add_check(size => sub {...});
  
  Register a validation check.
  
    $validator->add_check(foo => sub {
      my ($validation, $name, $value, @args) = @_;
      ...
      return undef;
    });
  
  =head2 add_filter
  
    $validator = $validator->add_filter(trim => sub {...});
  
  Register a new filter.
  
    $validator->add_filter(foo => sub {
      my ($validation, $name, $value) = @_;
      ...
      return $value;
    });
  
  =head2 validation
  
    my $validation = $validator->validation;
  
  Build L<Mojolicious::Validator::Validation> object to perform validations.
  
    my $validation = $validator->validation;
    $validation->input({foo => 'bar'});
    $validation->required('foo')->size(1, 5);
    say $validation->param('foo');
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<http://mojolicious.org>.
  
  =cut
MOJOLICIOUS_VALIDATOR

$fatpacked{"Mojolicious/Validator/Validation.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJOLICIOUS_VALIDATOR_VALIDATION';
  package Mojolicious::Validator::Validation;
  use Mojo::Base -base;
  
  use Carp         ();
  use Scalar::Util ();
  
  has [qw(csrf_token topic validator)];
  has [qw(input output)] => sub { {} };
  
  sub AUTOLOAD {
    my $self = shift;
  
    my ($package, $method) = our $AUTOLOAD =~ /^(.+)::(.+)$/;
    Carp::croak "Undefined subroutine &${package}::$method called"
      unless Scalar::Util::blessed $self && $self->isa(__PACKAGE__);
  
    return $self->check($method => @_) if $self->validator->checks->{$method};
    Carp::croak qq{Can't locate object method "$method" via package "$package"};
  }
  
  sub check {
    my ($self, $check) = (shift, shift);
  
    return $self unless $self->is_valid;
  
    my $cb     = $self->validator->checks->{$check};
    my $name   = $self->topic;
    my $values = $self->output->{$name};
    for my $value (ref $values eq 'ARRAY' ? @$values : $values) {
      next unless my $result = $self->$cb($name, $value, @_);
      return $self->error($name => [$check, $result, @_]);
    }
  
    return $self;
  }
  
  sub csrf_protect {
    my $self  = shift;
    my $token = $self->input->{csrf_token};
    $self->error(csrf_token => ['csrf_protect'])
      unless $token && $token eq ($self->csrf_token // '');
    return $self;
  }
  
  sub error {
    my ($self, $name) = (shift, shift);
    return $self->{error}{$name} unless @_;
    $self->{error}{$name} = shift;
    delete $self->output->{$name};
    return $self;
  }
  
  sub every_param {
    return [] unless defined(my $value = $_[0]->output->{$_[1] // $_[0]->topic});
    return [ref $value eq 'ARRAY' ? @$value : $value];
  }
  
  sub failed { [sort keys %{shift->{error}}] }
  
  sub has_data { !!keys %{shift->input} }
  
  sub has_error { $_[1] ? exists $_[0]{error}{$_[1]} : !!keys %{$_[0]{error}} }
  
  sub is_valid { exists $_[0]->output->{$_[1] // $_[0]->topic} }
  
  sub optional {
    my ($self, $name, @filters) = @_;
  
    return $self->topic($name) unless defined(my $input = $self->input->{$name});
  
    my @input = ref $input eq 'ARRAY' ? @$input : ($input);
    for my $cb (map { $self->validator->filters->{$_} } @filters) {
      @input = map { $self->$cb($name, $_) } @input;
    }
    $self->output->{$name} = ref $input eq 'ARRAY' ? \@input : $input[0]
      if @input && !grep { !length } @input;
  
    return $self->topic($name);
  }
  
  sub param { shift->every_param(shift)->[-1] }
  
  sub passed { [sort keys %{shift->output}] }
  
  sub required {
    my ($self, $name) = (shift, shift);
    return $self if $self->optional($name, @_)->is_valid;
    return $self->error($name => ['required']);
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojolicious::Validator::Validation - Perform validations
  
  =head1 SYNOPSIS
  
    use Mojolicious::Validator;
    use Mojolicious::Validator::Validation;
  
    my $validator = Mojolicious::Validator->new;
    my $validation
      = Mojolicious::Validator::Validation->new(validator => $validator);
    $validation->input({foo => 'bar'});
    $validation->required('foo')->in('bar', 'baz');
    say $validation->param('foo');
  
  =head1 DESCRIPTION
  
  L<Mojolicious::Validator::Validation> performs L<Mojolicious::Validator>
  validation checks.
  
  =head1 ATTRIBUTES
  
  L<Mojolicious::Validator::Validation> implements the following attributes.
  
  =head2 csrf_token
  
    my $token   = $validation->csrf_token;
    $validation = $validation->csrf_token('fa6a08...');
  
  CSRF token.
  
  =head2 input
  
    my $input   = $validation->input;
    $validation = $validation->input({foo => 'bar', baz => [123, 'yada']});
  
  Data to be validated.
  
  =head2 output
  
    my $output  = $validation->output;
    $validation = $validation->output({foo => 'bar', baz => [123, 'yada']});
  
  Validated data.
  
  =head2 topic
  
    my $topic   = $validation->topic;
    $validation = $validation->topic('foo');
  
  Name of field currently being validated.
  
  =head2 validator
  
    my $validator = $validation->validator;
    $validation   = $validation->validator(Mojolicious::Validator->new);
  
  L<Mojolicious::Validator> object this validation belongs to.
  
  =head1 METHODS
  
  L<Mojolicious::Validator::Validation> inherits all methods from L<Mojo::Base>
  and implements the following new ones.
  
  =head2 check
  
    $validation = $validation->check('size', 2, 7);
  
  Perform validation check on all values of the current L</"topic">, no more
  checks will be performed on them after the first one failed. All checks from
  L<Mojolicious::Validator/"CHECKS"> are supported.
  
  =head2 csrf_protect
  
    $validation = $validation->csrf_protect;
  
  Validate C<csrf_token> and protect from cross-site request forgery.
  
  =head2 error
  
    my $err     = $validation->error('foo');
    $validation = $validation->error(foo => ['custom_check']);
    $validation = $validation->error(foo => [$check, $result, @args]);
  
  Get or set details for failed validation check, at any given time there can
  only be one per field.
  
    # Details about failed validation
    my ($check, $result, @args) = @{$validation->error('foo')};
  
  =head2 every_param
  
    my $values = $validation->every_param;
    my $values = $validation->every_param('foo');
  
  Similar to L</"param">, but returns all values sharing the same name as an
  array reference.
  
    # Get first value
    my $first = $validation->every_param('foo')->[0];
  
  =head2 failed
  
    my $names = $validation->failed;
  
  Return an array reference with all names for values that failed validation.
  
    # Names of all values that failed
    say for @{$validation->failed};
  
  =head2 has_data
  
    my $bool = $validation->has_data;
  
  Check if L</"input"> is available for validation.
  
  =head2 has_error
  
    my $bool = $validation->has_error;
    my $bool = $validation->has_error('foo');
  
  Check if validation resulted in errors, defaults to checking all fields.
  
  =head2 is_valid
  
    my $bool = $validation->is_valid;
    my $bool = $validation->is_valid('foo');
  
  Check if validation was successful and field has a value, defaults to checking
  the current L</"topic">.
  
  =head2 optional
  
    $validation = $validation->optional('foo');
    $validation = $validation->optional('foo', 'filter1', 'filter2');
  
  Change validation L</"topic"> and apply filters. All filters from
  L<Mojolicious::Validator/"FILTERS"> are supported.
  
    # Trim value and check size
    $validation->optional('user', 'trim')->size(1, 15);
  
  =head2 param
  
    my $value = $validation->param;
    my $value = $validation->param('foo');
  
  Access validated values, defaults to the current L</"topic">. If there are
  multiple values sharing the same name, and you want to access more than just the
  last one, you can use L</"every_param">.
  
    # Get value right away
    my $user = $validation->optional('user')->size(1, 15)->param;
  
  =head2 passed
  
    my $names = $validation->passed;
  
  Return an array reference with all names for values that passed validation.
  
    # Names of all values that passed
    say for @{$validation->passed};
  
  =head2 required
  
    $validation = $validation->required('foo');
    $validation = $validation->required('foo', 'filter1', 'filter2');
  
  Change validation L</"topic">, apply filters, and make sure a value is present
  and not an empty string. All filters from L<Mojolicious::Validator/"FILTERS">
  are supported.
  
    # Trim value and check size
    $validation->required('user', 'trim')->size(1, 15);
  
  =head1 AUTOLOAD
  
  In addition to the L</"ATTRIBUTES"> and L</"METHODS"> above, you can also call
  validation checks provided by L</"validator"> on
  L<Mojolicious::Validator::Validation> objects, similar to L</"check">.
  
    # Call validation checks
    $validation->required('foo')->size(2, 5)->like(qr/^[A-Z]/);
    $validation->optional('bar')->equal_to('foo');
    $validation->optional('baz')->in('test', '123');
  
    # Longer version
    $validation->required('foo')->check('size', 2, 5)->check('like', qr/^[A-Z]/);
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<http://mojolicious.org>.
  
  =cut
MOJOLICIOUS_VALIDATOR_VALIDATION

$fatpacked{"Pod/Man.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POD_MAN';
  # Pod::Man -- Convert POD data to formatted *roff input.
  #
  # This module translates POD documentation into *roff markup using the man
  # macro set, and is intended for converting POD documents written as Unix
  # manual pages to manual pages that can be read by the man(1) command.  It is
  # a replacement for the pod2man command distributed with versions of Perl
  # prior to 5.6.
  #
  # Perl core hackers, please note that this module is also separately
  # maintained outside of the Perl core as part of the podlators.  Please send
  # me any patches at the address above in addition to sending them to the
  # standard Perl mailing lists.
  #
  # Written by Russ Allbery <rra@cpan.org>
  # Substantial contributions by Sean Burke <sburke@cpan.org>
  # Copyright 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009,
  #     2010, 2012, 2013, 2014, 2015, 2016 Russ Allbery <rra@cpan.org>
  #
  # This program is free software; you may redistribute it and/or modify it
  # under the same terms as Perl itself.
  
  ##############################################################################
  # Modules and declarations
  ##############################################################################
  
  package Pod::Man;
  
  use 5.006;
  use strict;
  use warnings;
  
  use subs qw(makespace);
  use vars qw(@ISA %ESCAPES $PREAMBLE $VERSION);
  
  use Carp qw(carp croak);
  use Pod::Simple ();
  
  # Conditionally import Encode and set $HAS_ENCODE if it is available.
  our $HAS_ENCODE;
  BEGIN {
      $HAS_ENCODE = eval { require Encode };
  }
  
  @ISA = qw(Pod::Simple);
  
  $VERSION = '4.09';
  
  # Set the debugging level.  If someone has inserted a debug function into this
  # class already, use that.  Otherwise, use any Pod::Simple debug function
  # that's defined, and failing that, define a debug level of 10.
  BEGIN {
      my $parent = defined (&Pod::Simple::DEBUG) ? \&Pod::Simple::DEBUG : undef;
      unless (defined &DEBUG) {
          *DEBUG = $parent || sub () { 10 };
      }
  }
  
  # Import the ASCII constant from Pod::Simple.  This is true iff we're in an
  # ASCII-based universe (including such things as ISO 8859-1 and UTF-8), and is
  # generally only false for EBCDIC.
  BEGIN { *ASCII = \&Pod::Simple::ASCII }
  
  # Pretty-print a data structure.  Only used for debugging.
  BEGIN { *pretty = \&Pod::Simple::pretty }
  
  # Formatting instructions for various types of blocks.  cleanup makes hyphens
  # hard, adds spaces between consecutive underscores, and escapes backslashes.
  # convert translates characters into escapes.  guesswork means to apply the
  # transformations done by the guesswork sub.  literal says to protect literal
  # quotes from being turned into UTF-8 quotes.  By default, all transformations
  # are on except literal, but some elements override.
  #
  # DEFAULT specifies the default settings.  All other elements should list only
  # those settings that they are overriding.  Data indicates =for roff blocks,
  # which should be passed along completely verbatim.
  #
  # Formatting inherits negatively, in the sense that if the parent has turned
  # off guesswork, all child elements should leave it off.
  my %FORMATTING = (
      DEFAULT  => { cleanup => 1, convert => 1, guesswork => 1, literal => 0 },
      Data     => { cleanup => 0, convert => 0, guesswork => 0, literal => 0 },
      Verbatim => {                             guesswork => 0, literal => 1 },
      C        => {                             guesswork => 0, literal => 1 },
      X        => { cleanup => 0,               guesswork => 0               },
  );
  
  ##############################################################################
  # Object initialization
  ##############################################################################
  
  # Initialize the object and set various Pod::Simple options that we need.
  # Here, we also process any additional options passed to the constructor or
  # set up defaults if none were given.  Note that all internal object keys are
  # in all-caps, reserving all lower-case object keys for Pod::Simple and user
  # arguments.
  sub new {
      my $class = shift;
      my $self = $class->SUPER::new;
  
      # Tell Pod::Simple not to handle S<> by automatically inserting &nbsp;.
      $self->nbsp_for_S (1);
  
      # Tell Pod::Simple to keep whitespace whenever possible.
      if (my $preserve_whitespace = $self->can ('preserve_whitespace')) {
          $self->$preserve_whitespace (1);
      } else {
          $self->fullstop_space_harden (1);
      }
  
      # The =for and =begin targets that we accept.
      $self->accept_targets (qw/man MAN roff ROFF/);
  
      # Ensure that contiguous blocks of code are merged together.  Otherwise,
      # some of the guesswork heuristics don't work right.
      $self->merge_text (1);
  
      # Pod::Simple doesn't do anything useful with our arguments, but we want
      # to put them in our object as hash keys and values.  This could cause
      # problems if we ever clash with Pod::Simple's own internal class
      # variables.
      %$self = (%$self, @_);
  
      # Send errors to stderr if requested.
      if ($$self{stderr} and not $$self{errors}) {
          $$self{errors} = 'stderr';
      }
      delete $$self{stderr};
  
      # Validate the errors parameter and act on it.
      if (not defined $$self{errors}) {
          $$self{errors} = 'pod';
      }
      if ($$self{errors} eq 'stderr' || $$self{errors} eq 'die') {
          $self->no_errata_section (1);
          $self->complain_stderr (1);
          if ($$self{errors} eq 'die') {
              $$self{complain_die} = 1;
          }
      } elsif ($$self{errors} eq 'pod') {
          $self->no_errata_section (0);
          $self->complain_stderr (0);
      } elsif ($$self{errors} eq 'none') {
          $self->no_whining (1);
      } else {
          croak (qq(Invalid errors setting: "$$self{errors}"));
      }
      delete $$self{errors};
  
      # Degrade back to non-utf8 if Encode is not available.
      #
      # Suppress the warning message when PERL_CORE is set, indicating this is
      # running as part of the core Perl build.  Perl builds podlators (and all
      # pure Perl modules) before Encode and other XS modules, so Encode won't
      # yet be available.  Rely on the Perl core build to generate man pages
      # later, after all the modules are available, so that UTF-8 handling will
      # be correct.
      if ($$self{utf8} and !$HAS_ENCODE) {
          if (!$ENV{PERL_CORE}) {
              carp ('utf8 mode requested but Encode module not available,'
                      . ' falling back to non-utf8');
          }
          delete $$self{utf8};
      }
  
      # Initialize various other internal constants based on our arguments.
      $self->init_fonts;
      $self->init_quotes;
      $self->init_page;
  
      # For right now, default to turning on all of the magic.
      $$self{MAGIC_CPP}       = 1;
      $$self{MAGIC_EMDASH}    = 1;
      $$self{MAGIC_FUNC}      = 1;
      $$self{MAGIC_MANREF}    = 1;
      $$self{MAGIC_SMALLCAPS} = 1;
      $$self{MAGIC_VARS}      = 1;
  
      return $self;
  }
  
  # Translate a font string into an escape.
  sub toescape { (length ($_[0]) > 1 ? '\f(' : '\f') . $_[0] }
  
  # Determine which fonts the user wishes to use and store them in the object.
  # Regular, italic, bold, and bold-italic are constants, but the fixed width
  # fonts may be set by the user.  Sets the internal hash key FONTS which is
  # used to map our internal font escapes to actual *roff sequences later.
  sub init_fonts {
      my ($self) = @_;
  
      # Figure out the fixed-width font.  If user-supplied, make sure that they
      # are the right length.
      for (qw/fixed fixedbold fixeditalic fixedbolditalic/) {
          my $font = $$self{$_};
          if (defined ($font) && (length ($font) < 1 || length ($font) > 2)) {
              croak qq(roff font should be 1 or 2 chars, not "$font");
          }
      }
  
      # Set the default fonts.  We can't be sure portably across different
      # implementations what fixed bold-italic may be called (if it's even
      # available), so default to just bold.
      $$self{fixed}           ||= 'CW';
      $$self{fixedbold}       ||= 'CB';
      $$self{fixeditalic}     ||= 'CI';
      $$self{fixedbolditalic} ||= 'CB';
  
      # Set up a table of font escapes.  First number is fixed-width, second is
      # bold, third is italic.
      $$self{FONTS} = { '000' => '\fR', '001' => '\fI',
                        '010' => '\fB', '011' => '\f(BI',
                        '100' => toescape ($$self{fixed}),
                        '101' => toescape ($$self{fixeditalic}),
                        '110' => toescape ($$self{fixedbold}),
                        '111' => toescape ($$self{fixedbolditalic}) };
  }
  
  # Initialize the quotes that we'll be using for C<> text.  This requires some
  # special handling, both to parse the user parameters if given and to make
  # sure that the quotes will be safe against *roff.  Sets the internal hash
  # keys LQUOTE and RQUOTE.
  sub init_quotes {
      my ($self) = (@_);
  
      # Handle the quotes option first, which sets both quotes at once.
      $$self{quotes} ||= '"';
      if ($$self{quotes} eq 'none') {
          $$self{LQUOTE} = $$self{RQUOTE} = '';
      } elsif (length ($$self{quotes}) == 1) {
          $$self{LQUOTE} = $$self{RQUOTE} = $$self{quotes};
      } elsif (length ($$self{quotes}) % 2 == 0) {
          my $length = length ($$self{quotes}) / 2;
          $$self{LQUOTE} = substr ($$self{quotes}, 0, $length);
          $$self{RQUOTE} = substr ($$self{quotes}, $length);
      } else {
          croak(qq(Invalid quote specification "$$self{quotes}"))
      }
  
      # Now handle the lquote and rquote options.
      if (defined $$self{lquote}) {
          $$self{LQUOTE} = $$self{lquote} eq 'none' ? q{} : $$self{lquote};
      }
      if (defined $$self{rquote}) {
          $$self{RQUOTE} = $$self{rquote} eq 'none' ? q{} : $$self{rquote};
      }
  
      # Double the first quote; note that this should not be s///g as two double
      # quotes is represented in *roff as three double quotes, not four.  Weird,
      # I know.
      $$self{LQUOTE} =~ s/\"/\"\"/;
      $$self{RQUOTE} =~ s/\"/\"\"/;
  }
  
  # Initialize the page title information and indentation from our arguments.
  sub init_page {
      my ($self) = @_;
  
      # We used to try first to get the version number from a local binary, but
      # we shouldn't need that any more.  Get the version from the running Perl.
      # Work a little magic to handle subversions correctly under both the
      # pre-5.6 and the post-5.6 version numbering schemes.
      my @version = ($] =~ /^(\d+)\.(\d{3})(\d{0,3})$/);
      $version[2] ||= 0;
      $version[2] *= 10 ** (3 - length $version[2]);
      for (@version) { $_ += 0 }
      my $version = join ('.', @version);
  
      # Set the defaults for page titles and indentation if the user didn't
      # override anything.
      $$self{center} = 'User Contributed Perl Documentation'
          unless defined $$self{center};
      $$self{release} = 'perl v' . $version
          unless defined $$self{release};
      $$self{indent} = 4
          unless defined $$self{indent};
  
      # Double quotes in things that will be quoted.
      for (qw/center release/) {
          $$self{$_} =~ s/\"/\"\"/g if $$self{$_};
      }
  }
  
  ##############################################################################
  # Core parsing
  ##############################################################################
  
  # This is the glue that connects the code below with Pod::Simple itself.  The
  # goal is to convert the event stream coming from the POD parser into method
  # calls to handlers once the complete content of a tag has been seen.  Each
  # paragraph or POD command will have textual content associated with it, and
  # as soon as all of a paragraph or POD command has been seen, that content
  # will be passed in to the corresponding method for handling that type of
  # object.  The exceptions are handlers for lists, which have opening tag
  # handlers and closing tag handlers that will be called right away.
  #
  # The internal hash key PENDING is used to store the contents of a tag until
  # all of it has been seen.  It holds a stack of open tags, each one
  # represented by a tuple of the attributes hash for the tag, formatting
  # options for the tag (which are inherited), and the contents of the tag.
  
  # Add a block of text to the contents of the current node, formatting it
  # according to the current formatting instructions as we do.
  sub _handle_text {
      my ($self, $text) = @_;
      DEBUG > 3 and print "== $text\n";
      my $tag = $$self{PENDING}[-1];
      $$tag[2] .= $self->format_text ($$tag[1], $text);
  }
  
  # Given an element name, get the corresponding method name.
  sub method_for_element {
      my ($self, $element) = @_;
      $element =~ tr/A-Z-/a-z_/;
      $element =~ tr/_a-z0-9//cd;
      return $element;
  }
  
  # Handle the start of a new element.  If cmd_element is defined, assume that
  # we need to collect the entire tree for this element before passing it to the
  # element method, and create a new tree into which we'll collect blocks of
  # text and nested elements.  Otherwise, if start_element is defined, call it.
  sub _handle_element_start {
      my ($self, $element, $attrs) = @_;
      DEBUG > 3 and print "++ $element (<", join ('> <', %$attrs), ">)\n";
      my $method = $self->method_for_element ($element);
  
      # If we have a command handler, we need to accumulate the contents of the
      # tag before calling it.  Turn off IN_NAME for any command other than
      # <Para> and the formatting codes so that IN_NAME isn't still set for the
      # first heading after the NAME heading.
      if ($self->can ("cmd_$method")) {
          DEBUG > 2 and print "<$element> starts saving a tag\n";
          $$self{IN_NAME} = 0 if ($element ne 'Para' && length ($element) > 1);
  
          # How we're going to format embedded text blocks depends on the tag
          # and also depends on our parent tags.  Thankfully, inside tags that
          # turn off guesswork and reformatting, nothing else can turn it back
          # on, so this can be strictly inherited.
          my $formatting = {
              %{ $$self{PENDING}[-1][1] || $FORMATTING{DEFAULT} },
              %{ $FORMATTING{$element} || {} },
          };
          push (@{ $$self{PENDING} }, [ $attrs, $formatting, '' ]);
          DEBUG > 4 and print "Pending: [", pretty ($$self{PENDING}), "]\n";
      } elsif (my $start_method = $self->can ("start_$method")) {
          $self->$start_method ($attrs, '');
      } else {
          DEBUG > 2 and print "No $method start method, skipping\n";
      }
  }
  
  # Handle the end of an element.  If we had a cmd_ method for this element,
  # this is where we pass along the tree that we built.  Otherwise, if we have
  # an end_ method for the element, call that.
  sub _handle_element_end {
      my ($self, $element) = @_;
      DEBUG > 3 and print "-- $element\n";
      my $method = $self->method_for_element ($element);
  
      # If we have a command handler, pull off the pending text and pass it to
      # the handler along with the saved attribute hash.
      if (my $cmd_method = $self->can ("cmd_$method")) {
          DEBUG > 2 and print "</$element> stops saving a tag\n";
          my $tag = pop @{ $$self{PENDING} };
          DEBUG > 4 and print "Popped: [", pretty ($tag), "]\n";
          DEBUG > 4 and print "Pending: [", pretty ($$self{PENDING}), "]\n";
          my $text = $self->$cmd_method ($$tag[0], $$tag[2]);
          if (defined $text) {
              if (@{ $$self{PENDING} } > 1) {
                  $$self{PENDING}[-1][2] .= $text;
              } else {
                  $self->output ($text);
              }
          }
      } elsif (my $end_method = $self->can ("end_$method")) {
          $self->$end_method ();
      } else {
          DEBUG > 2 and print "No $method end method, skipping\n";
      }
  }
  
  ##############################################################################
  # General formatting
  ##############################################################################
  
  # Format a text block.  Takes a hash of formatting options and the text to
  # format.  Currently, the only formatting options are guesswork, cleanup, and
  # convert, all of which are boolean.
  sub format_text {
      my ($self, $options, $text) = @_;
      my $guesswork = $$options{guesswork} && !$$self{IN_NAME};
      my $cleanup = $$options{cleanup};
      my $convert = $$options{convert};
      my $literal = $$options{literal};
  
      # Cleanup just tidies up a few things, telling *roff that the hyphens are
      # hard, putting a bit of space between consecutive underscores, and
      # escaping backslashes.  Be careful not to mangle our character
      # translations by doing this before processing character translation.
      if ($cleanup) {
          $text =~ s/\\/\\e/g;
          $text =~ s/-/\\-/g;
          $text =~ s/_(?=_)/_\\|/g;
      }
  
      # Normally we do character translation, but we won't even do that in
      # <Data> blocks or if UTF-8 output is desired.
      if ($convert && !$$self{utf8} && ASCII) {
          $text =~ s/([^\x00-\x7F])/$ESCAPES{ord ($1)} || "X"/eg;
      }
  
      # Ensure that *roff doesn't convert literal quotes to UTF-8 single quotes,
      # but don't mess up our accept escapes.
      if ($literal) {
          $text =~ s/(?<!\\\*)\'/\\*\(Aq/g;
          $text =~ s/(?<!\\\*)\`/\\\`/g;
      }
  
      # If guesswork is asked for, do that.  This involves more substantial
      # formatting based on various heuristics that may only be appropriate for
      # particular documents.
      if ($guesswork) {
          $text = $self->guesswork ($text);
      }
  
      return $text;
  }
  
  # Handles C<> text, deciding whether to put \*C` around it or not.  This is a
  # whole bunch of messy heuristics to try to avoid overquoting, originally from
  # Barrie Slaymaker.  This largely duplicates similar code in Pod::Text.
  sub quote_literal {
      my $self = shift;
      local $_ = shift;
  
      # A regex that matches the portion of a variable reference that's the
      # array or hash index, separated out just because we want to use it in
      # several places in the following regex.
      my $index = '(?: \[.*\] | \{.*\} )?';
  
      # If in NAME section, just return an ASCII quoted string to avoid
      # confusing tools like whatis.
      return qq{"$_"} if $$self{IN_NAME};
  
      # Check for things that we don't want to quote, and if we find any of
      # them, return the string with just a font change and no quoting.
      m{
        ^\s*
        (?:
           ( [\'\`\"] ) .* \1                             # already quoted
         | \\\*\(Aq .* \\\*\(Aq                           # quoted and escaped
         | \\?\` .* ( \' | \\\*\(Aq )                     # `quoted'
         | \$+ [\#^]? \S $index                           # special ($^Foo, $")
         | [\$\@%&*]+ \#? [:\'\w]+ $index                 # plain var or func
         | [\$\@%&*]* [:\'\w]+ (?: -> )? \(\s*[^\s,]\s*\) # 0/1-arg func call
         | [-+]? ( \d[\d.]* | \.\d+ ) (?: [eE][-+]?\d+ )? # a number
         | 0x [a-fA-F\d]+                                 # a hex constant
        )
        \s*\z
       }xso and return '\f(FS' . $_ . '\f(FE';
  
      # If we didn't return, go ahead and quote the text.
      return '\f(FS\*(C`' . $_ . "\\*(C'\\f(FE";
  }
  
  # Takes a text block to perform guesswork on.  Returns the text block with
  # formatting codes added.  This is the code that marks up various Perl
  # constructs and things commonly used in man pages without requiring the user
  # to add any explicit markup, and is applied to all non-literal text.  We're
  # guaranteed that the text we're applying guesswork to does not contain any
  # *roff formatting codes.  Note that the inserted font sequences must be
  # treated later with mapfonts or textmapfonts.
  #
  # This method is very fragile, both in the regular expressions it uses and in
  # the ordering of those modifications.  Care and testing is required when
  # modifying it.
  sub guesswork {
      my $self = shift;
      local $_ = shift;
      DEBUG > 5 and print "   Guesswork called on [$_]\n";
  
      # By the time we reach this point, all hyphens will be escaped by adding a
      # backslash.  We want to undo that escaping if they're part of regular
      # words and there's only a single dash, since that's a real hyphen that
      # *roff gets to consider a possible break point.  Make sure that a dash
      # after the first character of a word stays non-breaking, however.
      #
      # Note that this is not user-controllable; we pretty much have to do this
      # transformation or *roff will mangle the output in unacceptable ways.
      s{
          ( (?:\G|^|\s) [\(\"]* [a-zA-Z] ) ( \\- )?
          ( (?: [a-zA-Z\']+ \\-)+ )
          ( [a-zA-Z\']+ ) (?= [\)\".?!,;:]* (?:\s|\Z|\\\ ) )
          \b
      } {
          my ($prefix, $hyphen, $main, $suffix) = ($1, $2, $3, $4);
          $hyphen ||= '';
          $main =~ s/\\-/-/g;
          $prefix . $hyphen . $main . $suffix;
      }egx;
  
      # Translate "--" into a real em-dash if it's used like one.  This means
      # that it's either surrounded by whitespace, it follows a regular word, or
      # it occurs between two regular words.
      if ($$self{MAGIC_EMDASH}) {
          s{          (\s) \\-\\- (\s)                } { $1 . '\*(--' . $2 }egx;
          s{ (\b[a-zA-Z]+) \\-\\- (\s|\Z|[a-zA-Z]+\b) } { $1 . '\*(--' . $2 }egx;
      }
  
      # Make words in all-caps a little bit smaller; they look better that way.
      # However, we don't want to change Perl code (like @ARGV), nor do we want
      # to fix the MIME in MIME-Version since it looks weird with the
      # full-height V.
      #
      # We change only a string of all caps (2) either at the beginning of the
      # line or following regular punctuation (like quotes) or whitespace (1),
      # and followed by either similar punctuation, an em-dash, or the end of
      # the line (3).
      #
      # Allow the text we're changing to small caps to include double quotes,
      # commas, newlines, and periods as long as it doesn't otherwise interrupt
      # the string of small caps and still fits the criteria.  This lets us turn
      # entire warranty disclaimers in man page output into small caps.
      if ($$self{MAGIC_SMALLCAPS}) {
          s{
              ( ^ | [\s\(\"\'\`\[\{<>] | \\[ ]  )                           # (1)
              ( [A-Z] [A-Z] (?: \s? [/A-Z+:\d_\$&] | \\- | \s? [.,\"] )* )  # (2)
              (?= [\s>\}\]\(\)\'\".?!,;] | \\*\(-- | \\[ ] | $ )            # (3)
          } {
              $1 . '\s-1' . $2 . '\s0'
          }egx;
      }
  
      # Note that from this point forward, we have to adjust for \s-1 and \s-0
      # strings inserted around things that we've made small-caps if later
      # transforms should work on those strings.
  
      # Italicize functions in the form func(), including functions that are in
      # all capitals, but don't italize if there's anything between the parens.
      # The function must start with an alphabetic character or underscore and
      # then consist of word characters or colons.
      if ($$self{MAGIC_FUNC}) {
          s{
              ( \b | \\s-1 )
              ( [A-Za-z_] ([:\w] | \\s-?[01])+ \(\) )
          } {
              $1 . '\f(IS' . $2 . '\f(IE'
          }egx;
      }
  
      # Change references to manual pages to put the page name in italics but
      # the number in the regular font, with a thin space between the name and
      # the number.  Only recognize func(n) where func starts with an alphabetic
      # character or underscore and contains only word characters, periods (for
      # configuration file man pages), or colons, and n is a single digit,
      # optionally followed by some number of lowercase letters.  Note that this
      # does not recognize man page references like perl(l) or socket(3SOCKET).
      if ($$self{MAGIC_MANREF}) {
          s{
              ( \b | \\s-1 )
              (?<! \\ )                                   # rule out \s0(1)
              ( [A-Za-z_] (?:[.:\w] | \\- | \\s-?[01])+ )
              ( \( \d [a-z]* \) )
          } {
              $1 . '\f(IS' . $2 . '\f(IE\|' . $3
          }egx;
      }
  
      # Convert simple Perl variable references to a fixed-width font.  Be
      # careful not to convert functions, though; there are too many subtleties
      # with them to want to perform this transformation.
      if ($$self{MAGIC_VARS}) {
          s{
             ( ^ | \s+ )
             ( [\$\@%] [\w:]+ )
             (?! \( )
          } {
              $1 . '\f(FS' . $2 . '\f(FE'
          }egx;
      }
  
      # Fix up double quotes.  Unfortunately, we miss this transformation if the
      # quoted text contains any code with formatting codes and there's not much
      # we can effectively do about that, which makes it somewhat unclear if
      # this is really a good idea.
      s{ \" ([^\"]+) \" } { '\*(L"' . $1 . '\*(R"' }egx;
  
      # Make C++ into \*(C+, which is a squinched version.
      if ($$self{MAGIC_CPP}) {
          s{ \b C\+\+ } {\\*\(C+}gx;
      }
  
      # Done.
      DEBUG > 5 and print "   Guesswork returning [$_]\n";
      return $_;
  }
  
  ##############################################################################
  # Output
  ##############################################################################
  
  # When building up the *roff code, we don't use real *roff fonts.  Instead, we
  # embed font codes of the form \f(<font>[SE] where <font> is one of B, I, or
  # F, S stands for start, and E stands for end.  This method turns these into
  # the right start and end codes.
  #
  # We add this level of complexity because the old pod2man didn't get code like
  # B<someI<thing> else> right; after I<> it switched back to normal text rather
  # than bold.  We take care of this by using variables that state whether bold,
  # italic, or fixed are turned on as a combined pointer to our current font
  # sequence, and set each to the number of current nestings of start tags for
  # that font.
  #
  # \fP changes to the previous font, but only one previous font is kept.  We
  # don't know what the outside level font is; normally it's R, but if we're
  # inside a heading it could be something else.  So arrange things so that the
  # outside font is always the "previous" font and end with \fP instead of \fR.
  # Idea from Zack Weinberg.
  sub mapfonts {
      my ($self, $text) = @_;
      my ($fixed, $bold, $italic) = (0, 0, 0);
      my %magic = (F => \$fixed, B => \$bold, I => \$italic);
      my $last = '\fR';
      $text =~ s<
          \\f\((.)(.)
      > <
          my $sequence = '';
          my $f;
          if ($last ne '\fR') { $sequence = '\fP' }
          ${ $magic{$1} } += ($2 eq 'S') ? 1 : -1;
          $f = $$self{FONTS}{ ($fixed && 1) . ($bold && 1) . ($italic && 1) };
          if ($f eq $last) {
              '';
          } else {
              if ($f ne '\fR') { $sequence .= $f }
              $last = $f;
              $sequence;
          }
      >gxe;
      return $text;
  }
  
  # Unfortunately, there is a bug in Solaris 2.6 nroff (not present in GNU
  # groff) where the sequence \fB\fP\f(CW\fP leaves the font set to B rather
  # than R, presumably because \f(CW doesn't actually do a font change.  To work
  # around this, use a separate textmapfonts for text blocks where the default
  # font is always R and only use the smart mapfonts for headings.
  sub textmapfonts {
      my ($self, $text) = @_;
      my ($fixed, $bold, $italic) = (0, 0, 0);
      my %magic = (F => \$fixed, B => \$bold, I => \$italic);
      $text =~ s<
          \\f\((.)(.)
      > <
          ${ $magic{$1} } += ($2 eq 'S') ? 1 : -1;
          $$self{FONTS}{ ($fixed && 1) . ($bold && 1) . ($italic && 1) };
      >gxe;
      return $text;
  }
  
  # Given a command and a single argument that may or may not contain double
  # quotes, handle double-quote formatting for it.  If there are no double
  # quotes, just return the command followed by the argument in double quotes.
  # If there are double quotes, use an if statement to test for nroff, and for
  # nroff output the command followed by the argument in double quotes with
  # embedded double quotes doubled.  For other formatters, remap paired double
  # quotes to LQUOTE and RQUOTE.
  sub switchquotes {
      my ($self, $command, $text, $extra) = @_;
      $text =~ s/\\\*\([LR]\"/\"/g;
  
      # We also have to deal with \*C` and \*C', which are used to add the
      # quotes around C<> text, since they may expand to " and if they do this
      # confuses the .SH macros and the like no end.  Expand them ourselves.
      # Also separate troff from nroff if there are any fixed-width fonts in use
      # to work around problems with Solaris nroff.
      my $c_is_quote = ($$self{LQUOTE} =~ /\"/) || ($$self{RQUOTE} =~ /\"/);
      my $fixedpat = join '|', @{ $$self{FONTS} }{'100', '101', '110', '111'};
      $fixedpat =~ s/\\/\\\\/g;
      $fixedpat =~ s/\(/\\\(/g;
      if ($text =~ m/\"/ || $text =~ m/$fixedpat/) {
          $text =~ s/\"/\"\"/g;
          my $nroff = $text;
          my $troff = $text;
          $troff =~ s/\"\"([^\"]*)\"\"/\`\`$1\'\'/g;
          if ($c_is_quote and $text =~ m/\\\*\(C[\'\`]/) {
              $nroff =~ s/\\\*\(C\`/$$self{LQUOTE}/g;
              $nroff =~ s/\\\*\(C\'/$$self{RQUOTE}/g;
              $troff =~ s/\\\*\(C[\'\`]//g;
          }
          $nroff = qq("$nroff") . ($extra ? " $extra" : '');
          $troff = qq("$troff") . ($extra ? " $extra" : '');
  
          # Work around the Solaris nroff bug where \f(CW\fP leaves the font set
          # to Roman rather than the actual previous font when used in headings.
          # troff output may still be broken, but at least we can fix nroff by
          # just switching the font changes to the non-fixed versions.
          my $font_end = "(?:\\f[PR]|\Q$$self{FONTS}{100}\E)";
          $nroff =~ s/\Q$$self{FONTS}{100}\E(.*?)\\f([PR])/$1/g;
          $nroff =~ s/\Q$$self{FONTS}{101}\E(.*?)$font_end/\\fI$1\\fP/g;
          $nroff =~ s/\Q$$self{FONTS}{110}\E(.*?)$font_end/\\fB$1\\fP/g;
          $nroff =~ s/\Q$$self{FONTS}{111}\E(.*?)$font_end/\\f\(BI$1\\fP/g;
  
          # Now finally output the command.  Bother with .ie only if the nroff
          # and troff output aren't the same.
          if ($nroff ne $troff) {
              return ".ie n $command $nroff\n.el $command $troff\n";
          } else {
              return "$command $nroff\n";
          }
      } else {
          $text = qq("$text") . ($extra ? " $extra" : '');
          return "$command $text\n";
      }
  }
  
  # Protect leading quotes and periods against interpretation as commands.  Also
  # protect anything starting with a backslash, since it could expand or hide
  # something that *roff would interpret as a command.  This is overkill, but
  # it's much simpler than trying to parse *roff here.
  sub protect {
      my ($self, $text) = @_;
      $text =~ s/^([.\'\\])/\\&$1/mg;
      return $text;
  }
  
  # Make vertical whitespace if NEEDSPACE is set, appropriate to the indentation
  # level the situation.  This function is needed since in *roff one has to
  # create vertical whitespace after paragraphs and between some things, but
  # other macros create their own whitespace.  Also close out a sequence of
  # repeated =items, since calling makespace means we're about to begin the item
  # body.
  sub makespace {
      my ($self) = @_;
      $self->output (".PD\n") if $$self{ITEMS} > 1;
      $$self{ITEMS} = 0;
      $self->output ($$self{INDENT} > 0 ? ".Sp\n" : ".PP\n")
          if $$self{NEEDSPACE};
  }
  
  # Output any pending index entries, and optionally an index entry given as an
  # argument.  Support multiple index entries in X<> separated by slashes, and
  # strip special escapes from index entries.
  sub outindex {
      my ($self, $section, $index) = @_;
      my @entries = map { split m%\s*/\s*% } @{ $$self{INDEX} };
      return unless ($section || @entries);
  
      # We're about to output all pending entries, so clear our pending queue.
      $$self{INDEX} = [];
  
      # Build the output.  Regular index entries are marked Xref, and headings
      # pass in their own section.  Undo some *roff formatting on headings.
      my @output;
      if (@entries) {
          push @output, [ 'Xref', join (' ', @entries) ];
      }
      if ($section) {
          $index =~ s/\\-/-/g;
          $index =~ s/\\(?:s-?\d|.\(..|.)//g;
          push @output, [ $section, $index ];
      }
  
      # Print out the .IX commands.
      for (@output) {
          my ($type, $entry) = @$_;
          $entry =~ s/\s+/ /g;
          $entry =~ s/\"/\"\"/g;
          $entry =~ s/\\/\\\\/g;
          $self->output (".IX $type " . '"' . $entry . '"' . "\n");
      }
  }
  
  # Output some text, without any additional changes.
  sub output {
      my ($self, @text) = @_;
      if ($$self{ENCODE}) {
          print { $$self{output_fh} } Encode::encode ('UTF-8', join ('', @text));
      } else {
          print { $$self{output_fh} } @text;
      }
  }
  
  ##############################################################################
  # Document initialization
  ##############################################################################
  
  # Handle the start of the document.  Here we handle empty documents, as well
  # as setting up our basic macros in a preamble and building the page title.
  sub start_document {
      my ($self, $attrs) = @_;
      if ($$attrs{contentless} && !$$self{ALWAYS_EMIT_SOMETHING}) {
          DEBUG and print "Document is contentless\n";
          $$self{CONTENTLESS} = 1;
      } else {
          delete $$self{CONTENTLESS};
      }
  
      # When UTF-8 output is set, check whether our output file handle already
      # has a PerlIO encoding layer set.  If it does not, we'll need to encode
      # our output before printing it (handled in the output() sub).  Wrap the
      # check in an eval to handle versions of Perl without PerlIO.
      $$self{ENCODE} = 0;
      if ($$self{utf8}) {
          $$self{ENCODE} = 1;
          eval {
              my @options = (output => 1, details => 1);
              my $flag = (PerlIO::get_layers ($$self{output_fh}, @options))[-1];
              if ($flag & PerlIO::F_UTF8 ()) {
                  $$self{ENCODE} = 0;
              }
          }
      }
  
      # Determine information for the preamble and then output it unless the
      # document was content-free.
      if (!$$self{CONTENTLESS}) {
          my ($name, $section);
          if (defined $$self{name}) {
              $name = $$self{name};
              $section = $$self{section} || 1;
          } else {
              ($name, $section) = $self->devise_title;
          }
          my $date = defined($$self{date}) ? $$self{date} : $self->devise_date;
          $self->preamble ($name, $section, $date)
              unless $self->bare_output or DEBUG > 9;
      }
  
      # Initialize a few per-document variables.
      $$self{INDENT}    = 0;      # Current indentation level.
      $$self{INDENTS}   = [];     # Stack of indentations.
      $$self{INDEX}     = [];     # Index keys waiting to be printed.
      $$self{IN_NAME}   = 0;      # Whether processing the NAME section.
      $$self{ITEMS}     = 0;      # The number of consecutive =items.
      $$self{ITEMTYPES} = [];     # Stack of =item types, one per list.
      $$self{SHIFTWAIT} = 0;      # Whether there is a shift waiting.
      $$self{SHIFTS}    = [];     # Stack of .RS shifts.
      $$self{PENDING}   = [[]];   # Pending output.
  }
  
  # Handle the end of the document.  This handles dying on POD errors, since
  # Pod::Parser currently doesn't.  Otherwise, does nothing but print out a
  # final comment at the end of the document under debugging.
  sub end_document {
      my ($self) = @_;
      if ($$self{complain_die} && $self->errors_seen) {
          croak ("POD document had syntax errors");
      }
      return if $self->bare_output;
      return if ($$self{CONTENTLESS} && !$$self{ALWAYS_EMIT_SOMETHING});
      $self->output (q(.\" [End document]) . "\n") if DEBUG;
  }
  
  # Try to figure out the name and section from the file name and return them as
  # a list, returning an empty name and section 1 if we can't find any better
  # information.  Uses File::Basename and File::Spec as necessary.
  sub devise_title {
      my ($self) = @_;
      my $name = $self->source_filename || '';
      my $section = $$self{section} || 1;
      $section = 3 if (!$$self{section} && $name =~ /\.pm\z/i);
      $name =~ s/\.p(od|[lm])\z//i;
  
      # If Pod::Parser gave us an IO::File reference as the source file name,
      # convert that to the empty string as well.  Then, if we don't have a
      # valid name, convert it to STDIN.
      #
      # In podlators 4.00 through 4.07, this also produced a warning, but that
      # was surprising to a lot of programs that had expected to be able to pipe
      # POD through pod2man without specifying the name.  In the name of
      # backward compatibility, just quietly set STDIN as the page title.
      if ($name =~ /^IO::File(?:=\w+)\(0x[\da-f]+\)$/i) {
          $name = '';
      }
      if ($name eq '') {
          $name = 'STDIN';
      }
  
      # If the section isn't 3, then the name defaults to just the basename of
      # the file.
      if ($section !~ /^3/) {
          require File::Basename;
          $name = uc File::Basename::basename ($name);
      } else {
          require File::Spec;
          my ($volume, $dirs, $file) = File::Spec->splitpath ($name);
  
          # Otherwise, assume we're dealing with a module.  We want to figure
          # out the full module name from the path to the file, but we don't
          # want to include too much of the path into the module name.  Lose
          # anything up to the first of:
          #
          #     */lib/*perl*/         standard or site_perl module
          #     */*perl*/lib/         from -Dprefix=/opt/perl
          #     */*perl*/             random module hierarchy
          #
          # Also strip off a leading site, site_perl, or vendor_perl component,
          # any OS-specific component, and any version number component, and
          # strip off an initial component of "lib" or "blib/lib" since that's
          # what ExtUtils::MakeMaker creates.
          #
          # splitdir requires at least File::Spec 0.8.
          my @dirs = File::Spec->splitdir ($dirs);
          if (@dirs) {
              my $cut = 0;
              my $i;
              for ($i = 0; $i < @dirs; $i++) {
                  if ($dirs[$i] =~ /perl/) {
                      $cut = $i + 1;
                      $cut++ if ($dirs[$i + 1] && $dirs[$i + 1] eq 'lib');
                      last;
                  }
              }
              if ($cut > 0) {
                  splice (@dirs, 0, $cut);
                  shift @dirs if ($dirs[0] =~ /^(site|vendor)(_perl)?$/);
                  shift @dirs if ($dirs[0] =~ /^[\d.]+$/);
                  shift @dirs if ($dirs[0] =~ /^(.*-$^O|$^O-.*|$^O)$/);
              }
              shift @dirs if $dirs[0] eq 'lib';
              splice (@dirs, 0, 2) if ($dirs[0] eq 'blib' && $dirs[1] eq 'lib');
          }
  
          # Remove empty directories when building the module name; they
          # occur too easily on Unix by doubling slashes.
          $name = join ('::', (grep { $_ ? $_ : () } @dirs), $file);
      }
      return ($name, $section);
  }
  
  # Determine the modification date and return that, properly formatted in ISO
  # format.
  #
  # If POD_MAN_DATE is set, that overrides anything else.  This can be used for
  # reproducible generation of the same file even if the input file timestamps
  # are unpredictable or the POD coms from standard input.
  #
  # Otherwise, if SOURCE_DATE_EPOCH is set and can be parsed as seconds since
  # the UNIX epoch, base the timestamp on that.  See
  # <https://reproducible-builds.org/specs/source-date-epoch/>
  #
  # Otherwise, use the modification date of the input if we can stat it.  Be
  # aware that Pod::Simple returns the stringification of the file handle as
  # source_filename for input from a file handle, so we'll stat some random ref
  # string in that case.  If that fails, instead use the current time.
  #
  # $self - Pod::Man object, used to get the source file
  #
  # Returns: YYYY-MM-DD date suitable for the left-hand footer
  sub devise_date {
      my ($self) = @_;
  
      # If POD_MAN_DATE is set, always use it.
      if (defined($ENV{POD_MAN_DATE})) {
          return $ENV{POD_MAN_DATE};
      }
  
      # If SOURCE_DATE_EPOCH is set and can be parsed, use that.
      my $time;
      if (defined($ENV{SOURCE_DATE_EPOCH}) && $ENV{SOURCE_DATE_EPOCH} !~ /\D/) {
          $time = $ENV{SOURCE_DATE_EPOCH};
      }
  
      # Otherwise, get the input filename and try to stat it.  If that fails,
      # use the current time.
      if (!defined $time) {
          my $input = $self->source_filename;
          if ($input) {
              $time = (stat($input))[9] || time();
          } else {
              $time = time();
          }
      }
  
      # Can't use POSIX::strftime(), which uses Fcntl, because MakeMaker uses
      # this and it has to work in the core which can't load dynamic libraries.
      # Use gmtime instead of localtime so that the generated man page does not
      # depend on the local time zone setting and is more reproducible
      my ($year, $month, $day) = (gmtime($time))[5,4,3];
      return sprintf("%04d-%02d-%02d", $year + 1900, $month + 1, $day);
  }
  
  # Print out the preamble and the title.  The meaning of the arguments to .TH
  # unfortunately vary by system; some systems consider the fourth argument to
  # be a "source" and others use it as a version number.  Generally it's just
  # presented as the left-side footer, though, so it doesn't matter too much if
  # a particular system gives it another interpretation.
  #
  # The order of date and release used to be reversed in older versions of this
  # module, but this order is correct for both Solaris and Linux.
  sub preamble {
      my ($self, $name, $section, $date) = @_;
      my $preamble = $self->preamble_template (!$$self{utf8});
  
      # Build the index line and make sure that it will be syntactically valid.
      my $index = "$name $section";
      $index =~ s/\"/\"\"/g;
  
      # If name or section contain spaces, quote them (section really never
      # should, but we may as well be cautious).
      for ($name, $section) {
          if (/\s/) {
              s/\"/\"\"/g;
              $_ = '"' . $_ . '"';
          }
      }
  
      # Double quotes in date, since it will be quoted.
      $date =~ s/\"/\"\"/g;
  
      # Substitute into the preamble the configuration options.
      $preamble =~ s/\@CFONT\@/$$self{fixed}/;
      $preamble =~ s/\@LQUOTE\@/$$self{LQUOTE}/;
      $preamble =~ s/\@RQUOTE\@/$$self{RQUOTE}/;
      chomp $preamble;
  
      # Get the version information.
      my $version = $self->version_report;
  
      # Finally output everything.
      $self->output (<<"----END OF HEADER----");
  .\\" Automatically generated by $version
  .\\"
  .\\" Standard preamble:
  .\\" ========================================================================
  $preamble
  .\\" ========================================================================
  .\\"
  .IX Title "$index"
  .TH $name $section "$date" "$$self{release}" "$$self{center}"
  .\\" For nroff, turn off justification.  Always turn off hyphenation; it makes
  .\\" way too many mistakes in technical documents.
  .if n .ad l
  .nh
  ----END OF HEADER----
      $self->output (".\\\" [End of preamble]\n") if DEBUG;
  }
  
  ##############################################################################
  # Text blocks
  ##############################################################################
  
  # Handle a basic block of text.  The only tricky part of this is if this is
  # the first paragraph of text after an =over, in which case we have to change
  # indentations for *roff.
  sub cmd_para {
      my ($self, $attrs, $text) = @_;
      my $line = $$attrs{start_line};
  
      # Output the paragraph.  We also have to handle =over without =item.  If
      # there's an =over without =item, SHIFTWAIT will be set, and we need to
      # handle creation of the indent here.  Add the shift to SHIFTS so that it
      # will be cleaned up on =back.
      $self->makespace;
      if ($$self{SHIFTWAIT}) {
          $self->output (".RS $$self{INDENT}\n");
          push (@{ $$self{SHIFTS} }, $$self{INDENT});
          $$self{SHIFTWAIT} = 0;
      }
  
      # Add the line number for debugging, but not in the NAME section just in
      # case the comment would confuse apropos.
      $self->output (".\\\" [At source line $line]\n")
          if defined ($line) && DEBUG && !$$self{IN_NAME};
  
      # Force exactly one newline at the end and strip unwanted trailing
      # whitespace at the end, but leave "\ " backslashed space from an S< > at
      # the end of a line.  Reverse the text first, to avoid having to scan the
      # entire paragraph.
      $text = reverse $text;
      $text =~ s/\A\s*?(?= \\|\S|\z)/\n/;
      $text = reverse $text;
  
      # Output the paragraph.
      $self->output ($self->protect ($self->textmapfonts ($text)));
      $self->outindex;
      $$self{NEEDSPACE} = 1;
      return '';
  }
  
  # Handle a verbatim paragraph.  Put a null token at the beginning of each line
  # to protect against commands and wrap in .Vb/.Ve (which we define in our
  # prelude).
  sub cmd_verbatim {
      my ($self, $attrs, $text) = @_;
  
      # Ignore an empty verbatim paragraph.
      return unless $text =~ /\S/;
  
      # Force exactly one newline at the end and strip unwanted trailing
      # whitespace at the end.  Reverse the text first, to avoid having to scan
      # the entire paragraph.
      $text = reverse $text;
      $text =~ s/\A\s*/\n/;
      $text = reverse $text;
  
      # Get a count of the number of lines before the first blank line, which
      # we'll pass to .Vb as its parameter.  This tells *roff to keep that many
      # lines together.  We don't want to tell *roff to keep huge blocks
      # together.
      my @lines = split (/\n/, $text);
      my $unbroken = 0;
      for (@lines) {
          last if /^\s*$/;
          $unbroken++;
      }
      $unbroken = 10 if ($unbroken > 12 && !$$self{MAGIC_VNOPAGEBREAK_LIMIT});
  
      # Prepend a null token to each line.
      $text =~ s/^/\\&/gm;
  
      # Output the results.
      $self->makespace;
      $self->output (".Vb $unbroken\n$text.Ve\n");
      $$self{NEEDSPACE} = 1;
      return '';
  }
  
  # Handle literal text (produced by =for and similar constructs).  Just output
  # it with the minimum of changes.
  sub cmd_data {
      my ($self, $attrs, $text) = @_;
      $text =~ s/^\n+//;
      $text =~ s/\n{0,2}$/\n/;
      $self->output ($text);
      return '';
  }
  
  ##############################################################################
  # Headings
  ##############################################################################
  
  # Common code for all headings.  This is called before the actual heading is
  # output.  It returns the cleaned up heading text (putting the heading all on
  # one line) and may do other things, like closing bad =item blocks.
  sub heading_common {
      my ($self, $text, $line) = @_;
      $text =~ s/\s+$//;
      $text =~ s/\s*\n\s*/ /g;
  
      # This should never happen; it means that we have a heading after =item
      # without an intervening =back.  But just in case, handle it anyway.
      if ($$self{ITEMS} > 1) {
          $$self{ITEMS} = 0;
          $self->output (".PD\n");
      }
  
      # Output the current source line.
      $self->output ( ".\\\" [At source line $line]\n" )
          if defined ($line) && DEBUG;
      return $text;
  }
  
  # First level heading.  We can't output .IX in the NAME section due to a bug
  # in some versions of catman, so don't output a .IX for that section.  .SH
  # already uses small caps, so remove \s0 and \s-1.  Maintain IN_NAME as
  # appropriate.
  sub cmd_head1 {
      my ($self, $attrs, $text) = @_;
      $text =~ s/\\s-?\d//g;
      $text = $self->heading_common ($text, $$attrs{start_line});
      my $isname = ($text eq 'NAME' || $text =~ /\(NAME\)/);
      $self->output ($self->switchquotes ('.SH', $self->mapfonts ($text)));
      $self->outindex ('Header', $text) unless $isname;
      $$self{NEEDSPACE} = 0;
      $$self{IN_NAME} = $isname;
      return '';
  }
  
  # Second level heading.
  sub cmd_head2 {
      my ($self, $attrs, $text) = @_;
      $text = $self->heading_common ($text, $$attrs{start_line});
      $self->output ($self->switchquotes ('.SS', $self->mapfonts ($text)));
      $self->outindex ('Subsection', $text);
      $$self{NEEDSPACE} = 0;
      return '';
  }
  
  # Third level heading.  *roff doesn't have this concept, so just put the
  # heading in italics as a normal paragraph.
  sub cmd_head3 {
      my ($self, $attrs, $text) = @_;
      $text = $self->heading_common ($text, $$attrs{start_line});
      $self->makespace;
      $self->output ($self->textmapfonts ('\f(IS' . $text . '\f(IE') . "\n");
      $self->outindex ('Subsection', $text);
      $$self{NEEDSPACE} = 1;
      return '';
  }
  
  # Fourth level heading.  *roff doesn't have this concept, so just put the
  # heading as a normal paragraph.
  sub cmd_head4 {
      my ($self, $attrs, $text) = @_;
      $text = $self->heading_common ($text, $$attrs{start_line});
      $self->makespace;
      $self->output ($self->textmapfonts ($text) . "\n");
      $self->outindex ('Subsection', $text);
      $$self{NEEDSPACE} = 1;
      return '';
  }
  
  ##############################################################################
  # Formatting codes
  ##############################################################################
  
  # All of the formatting codes that aren't handled internally by the parser,
  # other than L<> and X<>.
  sub cmd_b { return $_[0]->{IN_NAME} ? $_[2] : '\f(BS' . $_[2] . '\f(BE' }
  sub cmd_i { return $_[0]->{IN_NAME} ? $_[2] : '\f(IS' . $_[2] . '\f(IE' }
  sub cmd_f { return $_[0]->{IN_NAME} ? $_[2] : '\f(IS' . $_[2] . '\f(IE' }
  sub cmd_c { return $_[0]->quote_literal ($_[2]) }
  
  # Index entries are just added to the pending entries.
  sub cmd_x {
      my ($self, $attrs, $text) = @_;
      push (@{ $$self{INDEX} }, $text);
      return '';
  }
  
  # Links reduce to the text that we're given, wrapped in angle brackets if it's
  # a URL, followed by the URL.  We take an option to suppress the URL if anchor
  # text is given.  We need to format the "to" value of the link before
  # comparing it to the text since we may escape hyphens.
  sub cmd_l {
      my ($self, $attrs, $text) = @_;
      if ($$attrs{type} eq 'url') {
          my $to = $$attrs{to};
          if (defined $to) {
              my $tag = $$self{PENDING}[-1];
              $to = $self->format_text ($$tag[1], $to);
          }
          if (not defined ($to) or $to eq $text) {
              return "<$text>";
          } elsif ($$self{nourls}) {
              return $text;
          } else {
              return "$text <$$attrs{to}>";
          }
      } else {
          return $text;
      }
  }
  
  ##############################################################################
  # List handling
  ##############################################################################
  
  # Handle the beginning of an =over block.  Takes the type of the block as the
  # first argument, and then the attr hash.  This is called by the handlers for
  # the four different types of lists (bullet, number, text, and block).
  sub over_common_start {
      my ($self, $type, $attrs) = @_;
      my $line = $$attrs{start_line};
      my $indent = $$attrs{indent};
      DEBUG > 3 and print " Starting =over $type (line $line, indent ",
          ($indent || '?'), "\n";
  
      # Find the indentation level.
      unless (defined ($indent) && $indent =~ /^[-+]?\d{1,4}\s*$/) {
          $indent = $$self{indent};
      }
  
      # If we've gotten multiple indentations in a row, we need to emit the
      # pending indentation for the last level that we saw and haven't acted on
      # yet.  SHIFTS is the stack of indentations that we've actually emitted
      # code for.
      if (@{ $$self{SHIFTS} } < @{ $$self{INDENTS} }) {
          $self->output (".RS $$self{INDENT}\n");
          push (@{ $$self{SHIFTS} }, $$self{INDENT});
      }
  
      # Now, do record-keeping.  INDENTS is a stack of indentations that we've
      # seen so far, and INDENT is the current level of indentation.  ITEMTYPES
      # is a stack of list types that we've seen.
      push (@{ $$self{INDENTS} }, $$self{INDENT});
      push (@{ $$self{ITEMTYPES} }, $type);
      $$self{INDENT} = $indent + 0;
      $$self{SHIFTWAIT} = 1;
  }
  
  # End an =over block.  Takes no options other than the class pointer.
  # Normally, once we close a block and therefore remove something from INDENTS,
  # INDENTS will now be longer than SHIFTS, indicating that we also need to emit
  # *roff code to close the indent.  This isn't *always* true, depending on the
  # circumstance.  If we're still inside an indentation, we need to emit another
  # .RE and then a new .RS to unconfuse *roff.
  sub over_common_end {
      my ($self) = @_;
      DEBUG > 3 and print " Ending =over\n";
      $$self{INDENT} = pop @{ $$self{INDENTS} };
      pop @{ $$self{ITEMTYPES} };
  
      # If we emitted code for that indentation, end it.
      if (@{ $$self{SHIFTS} } > @{ $$self{INDENTS} }) {
          $self->output (".RE\n");
          pop @{ $$self{SHIFTS} };
      }
  
      # If we're still in an indentation, *roff will have now lost track of the
      # right depth of that indentation, so fix that.
      if (@{ $$self{INDENTS} } > 0) {
          $self->output (".RE\n");
          $self->output (".RS $$self{INDENT}\n");
      }
      $$self{NEEDSPACE} = 1;
      $$self{SHIFTWAIT} = 0;
  }
  
  # Dispatch the start and end calls as appropriate.
  sub start_over_bullet { my $s = shift; $s->over_common_start ('bullet', @_) }
  sub start_over_number { my $s = shift; $s->over_common_start ('number', @_) }
  sub start_over_text   { my $s = shift; $s->over_common_start ('text',   @_) }
  sub start_over_block  { my $s = shift; $s->over_common_start ('block',  @_) }
  sub end_over_bullet { $_[0]->over_common_end }
  sub end_over_number { $_[0]->over_common_end }
  sub end_over_text   { $_[0]->over_common_end }
  sub end_over_block  { $_[0]->over_common_end }
  
  # The common handler for all item commands.  Takes the type of the item, the
  # attributes, and then the text of the item.
  #
  # Emit an index entry for anything that's interesting, but don't emit index
  # entries for things like bullets and numbers.  Newlines in an item title are
  # turned into spaces since *roff can't handle them embedded.
  sub item_common {
      my ($self, $type, $attrs, $text) = @_;
      my $line = $$attrs{start_line};
      DEBUG > 3 and print "  $type item (line $line): $text\n";
  
      # Clean up the text.  We want to end up with two variables, one ($text)
      # which contains any body text after taking out the item portion, and
      # another ($item) which contains the actual item text.
      $text =~ s/\s+$//;
      my ($item, $index);
      if ($type eq 'bullet') {
          $item = "\\\(bu";
          $text =~ s/\n*$/\n/;
      } elsif ($type eq 'number') {
          $item = $$attrs{number} . '.';
      } else {
          $item = $text;
          $item =~ s/\s*\n\s*/ /g;
          $text = '';
          $index = $item if ($item =~ /\w/);
      }
  
      # Take care of the indentation.  If shifts and indents are equal, close
      # the top shift, since we're about to create an indentation with .IP.
      # Also output .PD 0 to turn off spacing between items if this item is
      # directly following another one.  We only have to do that once for a
      # whole chain of items so do it for the second item in the change.  Note
      # that makespace is what undoes this.
      if (@{ $$self{SHIFTS} } == @{ $$self{INDENTS} }) {
          $self->output (".RE\n");
          pop @{ $$self{SHIFTS} };
      }
      $self->output (".PD 0\n") if ($$self{ITEMS} == 1);
  
      # Now, output the item tag itself.
      $item = $self->textmapfonts ($item);
      $self->output ($self->switchquotes ('.IP', $item, $$self{INDENT}));
      $$self{NEEDSPACE} = 0;
      $$self{ITEMS}++;
      $$self{SHIFTWAIT} = 0;
  
      # If body text for this item was included, go ahead and output that now.
      if ($text) {
          $text =~ s/\s*$/\n/;
          $self->makespace;
          $self->output ($self->protect ($self->textmapfonts ($text)));
          $$self{NEEDSPACE} = 1;
      }
      $self->outindex ($index ? ('Item', $index) : ());
  }
  
  # Dispatch the item commands to the appropriate place.
  sub cmd_item_bullet { my $self = shift; $self->item_common ('bullet', @_) }
  sub cmd_item_number { my $self = shift; $self->item_common ('number', @_) }
  sub cmd_item_text   { my $self = shift; $self->item_common ('text',   @_) }
  sub cmd_item_block  { my $self = shift; $self->item_common ('block',  @_) }
  
  ##############################################################################
  # Backward compatibility
  ##############################################################################
  
  # Reset the underlying Pod::Simple object between calls to parse_from_file so
  # that the same object can be reused to convert multiple pages.
  sub parse_from_file {
      my $self = shift;
      $self->reinit;
  
      # Fake the old cutting option to Pod::Parser.  This fiddings with internal
      # Pod::Simple state and is quite ugly; we need a better approach.
      if (ref ($_[0]) eq 'HASH') {
          my $opts = shift @_;
          if (defined ($$opts{-cutting}) && !$$opts{-cutting}) {
              $$self{in_pod} = 1;
              $$self{last_was_blank} = 1;
          }
      }
  
      # Do the work.
      my $retval = $self->SUPER::parse_from_file (@_);
  
      # Flush output, since Pod::Simple doesn't do this.  Ideally we should also
      # close the file descriptor if we had to open one, but we can't easily
      # figure this out.
      my $fh = $self->output_fh ();
      my $oldfh = select $fh;
      my $oldflush = $|;
      $| = 1;
      print $fh '';
      $| = $oldflush;
      select $oldfh;
      return $retval;
  }
  
  # Pod::Simple failed to provide this backward compatibility function, so
  # implement it ourselves.  File handles are one of the inputs that
  # parse_from_file supports.
  sub parse_from_filehandle {
      my $self = shift;
      return $self->parse_from_file (@_);
  }
  
  # Pod::Simple's parse_file doesn't set output_fh.  Wrap the call and do so
  # ourself unless it was already set by the caller, since our documentation has
  # always said that this should work.
  sub parse_file {
      my ($self, $in) = @_;
      unless (defined $$self{output_fh}) {
          $self->output_fh (\*STDOUT);
      }
      return $self->SUPER::parse_file ($in);
  }
  
  # Do the same for parse_lines, just to be polite.  Pod::Simple's man page
  # implies that the caller is responsible for setting this, but I don't see any
  # reason not to set a default.
  sub parse_lines {
      my ($self, @lines) = @_;
      unless (defined $$self{output_fh}) {
          $self->output_fh (\*STDOUT);
      }
      return $self->SUPER::parse_lines (@lines);
  }
  
  # Likewise for parse_string_document.
  sub parse_string_document {
      my ($self, $doc) = @_;
      unless (defined $$self{output_fh}) {
          $self->output_fh (\*STDOUT);
      }
      return $self->SUPER::parse_string_document ($doc);
  }
  
  ##############################################################################
  # Translation tables
  ##############################################################################
  
  # The following table is adapted from Tom Christiansen's pod2man.  It assumes
  # that the standard preamble has already been printed, since that's what
  # defines all of the accent marks.  We really want to do something better than
  # this when *roff actually supports other character sets itself, since these
  # results are pretty poor.
  #
  # This only works in an ASCII world.  What to do in a non-ASCII world is very
  # unclear -- hopefully we can assume UTF-8 and just leave well enough alone.
  @ESCAPES{0xA0 .. 0xFF} = (
      "\\ ", undef, undef, undef,            undef, undef, undef, undef,
      undef, undef, undef, undef,            undef, "\\%", undef, undef,
  
      undef, undef, undef, undef,            undef, undef, undef, undef,
      undef, undef, undef, undef,            undef, undef, undef, undef,
  
      "A\\*`",  "A\\*'", "A\\*^", "A\\*~",   "A\\*:", "A\\*o", "\\*(Ae", "C\\*,",
      "E\\*`",  "E\\*'", "E\\*^", "E\\*:",   "I\\*`", "I\\*'", "I\\*^",  "I\\*:",
  
      "\\*(D-", "N\\*~", "O\\*`", "O\\*'",   "O\\*^", "O\\*~", "O\\*:",  undef,
      "O\\*/",  "U\\*`", "U\\*'", "U\\*^",   "U\\*:", "Y\\*'", "\\*(Th", "\\*8",
  
      "a\\*`",  "a\\*'", "a\\*^", "a\\*~",   "a\\*:", "a\\*o", "\\*(ae", "c\\*,",
      "e\\*`",  "e\\*'", "e\\*^", "e\\*:",   "i\\*`", "i\\*'", "i\\*^",  "i\\*:",
  
      "\\*(d-", "n\\*~", "o\\*`", "o\\*'",   "o\\*^", "o\\*~", "o\\*:",  undef,
      "o\\*/" , "u\\*`", "u\\*'", "u\\*^",   "u\\*:", "y\\*'", "\\*(th", "y\\*:",
  ) if ASCII;
  
  ##############################################################################
  # Premable
  ##############################################################################
  
  # The following is the static preamble which starts all *roff output we
  # generate.  Most is static except for the font to use as a fixed-width font,
  # which is designed by @CFONT@, and the left and right quotes to use for C<>
  # text, designated by @LQOUTE@ and @RQUOTE@.  However, the second part, which
  # defines the accent marks, is only used if $escapes is set to true.
  sub preamble_template {
      my ($self, $accents) = @_;
      my $preamble = <<'----END OF PREAMBLE----';
  .de Sp \" Vertical space (when we can't use .PP)
  .if t .sp .5v
  .if n .sp
  ..
  .de Vb \" Begin verbatim text
  .ft @CFONT@
  .nf
  .ne \\$1
  ..
  .de Ve \" End verbatim text
  .ft R
  .fi
  ..
  .\" Set up some character translations and predefined strings.  \*(-- will
  .\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
  .\" double quote, and \*(R" will give a right double quote.  \*(C+ will
  .\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
  .\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
  .\" nothing in troff, for use with C<>.
  .tr \(*W-
  .ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
  .ie n \{\
  .    ds -- \(*W-
  .    ds PI pi
  .    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
  .    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
  .    ds L" ""
  .    ds R" ""
  .    ds C` @LQUOTE@
  .    ds C' @RQUOTE@
  'br\}
  .el\{\
  .    ds -- \|\(em\|
  .    ds PI \(*p
  .    ds L" ``
  .    ds R" ''
  .    ds C`
  .    ds C'
  'br\}
  .\"
  .\" Escape single quotes in literal strings from groff's Unicode transform.
  .ie \n(.g .ds Aq \(aq
  .el       .ds Aq '
  .\"
  .\" If the F register is >0, we'll generate index entries on stderr for
  .\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
  .\" entries marked with X<> in POD.  Of course, you'll have to process the
  .\" output yourself in some meaningful fashion.
  .\"
  .\" Avoid warning from groff about undefined register 'F'.
  .de IX
  ..
  .if !\nF .nr F 0
  .if \nF>0 \{\
  .    de IX
  .    tm Index:\\$1\t\\n%\t"\\$2"
  ..
  .    if !\nF==2 \{\
  .        nr % 0
  .        nr F 2
  .    \}
  .\}
  ----END OF PREAMBLE----
  #'# for cperl-mode
  
      if ($accents) {
          $preamble .= <<'----END OF PREAMBLE----'
  .\"
  .\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
  .\" Fear.  Run.  Save yourself.  No user-serviceable parts.
  .    \" fudge factors for nroff and troff
  .if n \{\
  .    ds #H 0
  .    ds #V .8m
  .    ds #F .3m
  .    ds #[ \f1
  .    ds #] \fP
  .\}
  .if t \{\
  .    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
  .    ds #V .6m
  .    ds #F 0
  .    ds #[ \&
  .    ds #] \&
  .\}
  .    \" simple accents for nroff and troff
  .if n \{\
  .    ds ' \&
  .    ds ` \&
  .    ds ^ \&
  .    ds , \&
  .    ds ~ ~
  .    ds /
  .\}
  .if t \{\
  .    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
  .    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
  .    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
  .    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
  .    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
  .    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
  .\}
  .    \" troff and (daisy-wheel) nroff accents
  .ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
  .ds 8 \h'\*(#H'\(*b\h'-\*(#H'
  .ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
  .ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
  .ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
  .ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
  .ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
  .ds ae a\h'-(\w'a'u*4/10)'e
  .ds Ae A\h'-(\w'A'u*4/10)'E
  .    \" corrections for vroff
  .if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
  .if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
  .    \" for low resolution devices (crt and lpr)
  .if \n(.H>23 .if \n(.V>19 \
  \{\
  .    ds : e
  .    ds 8 ss
  .    ds o a
  .    ds d- d\h'-1'\(ga
  .    ds D- D\h'-1'\(hy
  .    ds th \o'bp'
  .    ds Th \o'LP'
  .    ds ae ae
  .    ds Ae AE
  .\}
  .rm #[ #] #H #V #F C
  ----END OF PREAMBLE----
  #`# for cperl-mode
      }
      return $preamble;
  }
  
  ##############################################################################
  # Module return value and documentation
  ##############################################################################
  
  1;
  __END__
  
  =for stopwords
  en em ALLCAPS teeny fixedbold fixeditalic fixedbolditalic stderr utf8
  UTF-8 Allbery Sean Burke Ossanna Solaris formatters troff uppercased
  Christiansen nourls parsers Kernighan lquote rquote
  
  =head1 NAME
  
  Pod::Man - Convert POD data to formatted *roff input
  
  =head1 SYNOPSIS
  
      use Pod::Man;
      my $parser = Pod::Man->new (release => $VERSION, section => 8);
  
      # Read POD from STDIN and write to STDOUT.
      $parser->parse_file (\*STDIN);
  
      # Read POD from file.pod and write to file.1.
      $parser->parse_from_file ('file.pod', 'file.1');
  
  =head1 DESCRIPTION
  
  Pod::Man is a module to convert documentation in the POD format (the
  preferred language for documenting Perl) into *roff input using the man
  macro set.  The resulting *roff code is suitable for display on a terminal
  using L<nroff(1)>, normally via L<man(1)>, or printing using L<troff(1)>.
  It is conventionally invoked using the driver script B<pod2man>, but it can
  also be used directly.
  
  As a derived class from Pod::Simple, Pod::Man supports the same methods and
  interfaces.  See L<Pod::Simple> for all the details.
  
  new() can take options, in the form of key/value pairs that control the
  behavior of the parser.  See below for details.
  
  If no options are given, Pod::Man uses the name of the input file with any
  trailing C<.pod>, C<.pm>, or C<.pl> stripped as the man page title, to
  section 1 unless the file ended in C<.pm> in which case it defaults to
  section 3, to a centered title of "User Contributed Perl Documentation", to
  a centered footer of the Perl version it is run with, and to a left-hand
  footer of the modification date of its input (or the current date if given
  C<STDIN> for input).
  
  Pod::Man assumes that your *roff formatters have a fixed-width font named
  C<CW>.  If yours is called something else (like C<CR>), use the C<fixed>
  option to specify it.  This generally only matters for troff output for
  printing.  Similarly, you can set the fonts used for bold, italic, and
  bold italic fixed-width output.
  
  Besides the obvious pod conversions, Pod::Man also takes care of
  formatting func(), func(3), and simple variable references like $foo or
  @bar so you don't have to use code escapes for them; complex expressions
  like C<$fred{'stuff'}> will still need to be escaped, though.  It also
  translates dashes that aren't used as hyphens into en dashes, makes long
  dashes--like this--into proper em dashes, fixes "paired quotes," makes C++
  look right, puts a little space between double underscores, makes ALLCAPS
  a teeny bit smaller in B<troff>, and escapes stuff that *roff treats as
  special so that you don't have to.
  
  The recognized options to new() are as follows.  All options take a single
  argument.
  
  =over 4
  
  =item center
  
  Sets the centered page header for the C<.TH> macro.  The default, if this
  option is not specified, is "User Contributed Perl Documentation".
  
  =item date
  
  Sets the left-hand footer for the C<.TH> macro.  If this option is not set,
  the contents of the environment variable POD_MAN_DATE, if set, will be used.
  Failing that, the value of SOURCE_DATE_EPOCH, the modification date of the
  input file, or the current time if stat() can't find that file (which will be
  the case if the input is from C<STDIN>) will be used.  If obtained from the
  file modification date or the current time, the date will be formatted as
  C<YYYY-MM-DD> and will be based on UTC (so that the output will be
  reproducible regardless of local time zone).
  
  =item errors
  
  How to report errors.  C<die> says to throw an exception on any POD
  formatting error.  C<stderr> says to report errors on standard error, but
  not to throw an exception.  C<pod> says to include a POD ERRORS section
  in the resulting documentation summarizing the errors.  C<none> ignores
  POD errors entirely, as much as possible.
  
  The default is C<pod>.
  
  =item fixed
  
  The fixed-width font to use for verbatim text and code.  Defaults to
  C<CW>.  Some systems may want C<CR> instead.  Only matters for B<troff>
  output.
  
  =item fixedbold
  
  Bold version of the fixed-width font.  Defaults to C<CB>.  Only matters
  for B<troff> output.
  
  =item fixeditalic
  
  Italic version of the fixed-width font (actually, something of a misnomer,
  since most fixed-width fonts only have an oblique version, not an italic
  version).  Defaults to C<CI>.  Only matters for B<troff> output.
  
  =item fixedbolditalic
  
  Bold italic (probably actually oblique) version of the fixed-width font.
  Pod::Man doesn't assume you have this, and defaults to C<CB>.  Some
  systems (such as Solaris) have this font available as C<CX>.  Only matters
  for B<troff> output.
  
  =item lquote
  
  =item rquote
  
  Sets the quote marks used to surround CE<lt>> text.  C<lquote> sets the
  left quote mark and C<rquote> sets the right quote mark.  Either may also
  be set to the special value C<none>, in which case no quote mark is added
  on that side of CE<lt>> text (but the font is still changed for troff
  output).
  
  Also see the C<quotes> option, which can be used to set both quotes at once.
  If both C<quotes> and one of the other options is set, C<lquote> or C<rquote>
  overrides C<quotes>.
  
  =item name
  
  Set the name of the manual page for the C<.TH> macro.  Without this
  option, the manual name is set to the uppercased base name of the file
  being converted unless the manual section is 3, in which case the path is
  parsed to see if it is a Perl module path.  If it is, a path like
  C<.../lib/Pod/Man.pm> is converted into a name like C<Pod::Man>.  This
  option, if given, overrides any automatic determination of the name.
  
  If generating a manual page from standard input, the name will be set to
  C<STDIN> if this option is not provided.  Providing this option is strongly
  recommended to set a meaningful manual page name.
  
  =item nourls
  
  Normally, LZ<><> formatting codes with a URL but anchor text are formatted
  to show both the anchor text and the URL.  In other words:
  
      L<foo|http://example.com/>
  
  is formatted as:
  
      foo <http://example.com/>
  
  This option, if set to a true value, suppresses the URL when anchor text
  is given, so this example would be formatted as just C<foo>.  This can
  produce less cluttered output in cases where the URLs are not particularly
  important.
  
  =item quotes
  
  Sets the quote marks used to surround CE<lt>> text.  If the value is a
  single character, it is used as both the left and right quote.  Otherwise,
  it is split in half, and the first half of the string is used as the left
  quote and the second is used as the right quote.
  
  This may also be set to the special value C<none>, in which case no quote
  marks are added around CE<lt>> text (but the font is still changed for troff
  output).
  
  Also see the C<lquote> and C<rquote> options, which can be used to set the
  left and right quotes independently.  If both C<quotes> and one of the other
  options is set, C<lquote> or C<rquote> overrides C<quotes>.
  
  =item release
  
  Set the centered footer for the C<.TH> macro.  By default, this is set to
  the version of Perl you run Pod::Man under.  Setting this to the empty
  string will cause some *roff implementations to use the system default
  value.
  
  Note that some system C<an> macro sets assume that the centered footer
  will be a modification date and will prepend something like "Last
  modified: ".  If this is the case for your target system, you may want to
  set C<release> to the last modified date and C<date> to the version
  number.
  
  =item section
  
  Set the section for the C<.TH> macro.  The standard section numbering
  convention is to use 1 for user commands, 2 for system calls, 3 for
  functions, 4 for devices, 5 for file formats, 6 for games, 7 for
  miscellaneous information, and 8 for administrator commands.  There is a lot
  of variation here, however; some systems (like Solaris) use 4 for file
  formats, 5 for miscellaneous information, and 7 for devices.  Still others
  use 1m instead of 8, or some mix of both.  About the only section numbers
  that are reliably consistent are 1, 2, and 3.
  
  By default, section 1 will be used unless the file ends in C<.pm> in which
  case section 3 will be selected.
  
  =item stderr
  
  Send error messages about invalid POD to standard error instead of
  appending a POD ERRORS section to the generated *roff output.  This is
  equivalent to setting C<errors> to C<stderr> if C<errors> is not already
  set.  It is supported for backward compatibility.
  
  =item utf8
  
  By default, Pod::Man produces the most conservative possible *roff output
  to try to ensure that it will work with as many different *roff
  implementations as possible.  Many *roff implementations cannot handle
  non-ASCII characters, so this means all non-ASCII characters are converted
  either to a *roff escape sequence that tries to create a properly accented
  character (at least for troff output) or to C<X>.
  
  If this option is set, Pod::Man will instead output UTF-8.  If your *roff
  implementation can handle it, this is the best output format to use and
  avoids corruption of documents containing non-ASCII characters.  However,
  be warned that *roff source with literal UTF-8 characters is not supported
  by many implementations and may even result in segfaults and other bad
  behavior.
  
  Be aware that, when using this option, the input encoding of your POD
  source should be properly declared unless it's US-ASCII.  Pod::Simple will
  attempt to guess the encoding and may be successful if it's Latin-1 or
  UTF-8, but it will produce warnings.  Use the C<=encoding> command to
  declare the encoding.  See L<perlpod(1)> for more information.
  
  =back
  
  The standard Pod::Simple method parse_file() takes one argument naming the
  POD file to read from.  By default, the output is sent to C<STDOUT>, but
  this can be changed with the output_fh() method.
  
  The standard Pod::Simple method parse_from_file() takes up to two
  arguments, the first being the input file to read POD from and the second
  being the file to write the formatted output to.
  
  You can also call parse_lines() to parse an array of lines or
  parse_string_document() to parse a document already in memory.  As with
  parse_file(), parse_lines() and parse_string_document() default to sending
  their output to C<STDOUT> unless changed with the output_fh() method.
  
  To put the output from any parse method into a string instead of a file
  handle, call the output_string() method instead of output_fh().
  
  See L<Pod::Simple> for more specific details on the methods available to
  all derived parsers.
  
  =head1 DIAGNOSTICS
  
  =over 4
  
  =item roff font should be 1 or 2 chars, not "%s"
  
  (F) You specified a *roff font (using C<fixed>, C<fixedbold>, etc.) that
  wasn't either one or two characters.  Pod::Man doesn't support *roff fonts
  longer than two characters, although some *roff extensions do (the
  canonical versions of B<nroff> and B<troff> don't either).
  
  =item Invalid errors setting "%s"
  
  (F) The C<errors> parameter to the constructor was set to an unknown value.
  
  =item Invalid quote specification "%s"
  
  (F) The quote specification given (the C<quotes> option to the
  constructor) was invalid.  A quote specification must be either one
  character long or an even number (greater than one) characters long.
  
  =item POD document had syntax errors
  
  (F) The POD document being formatted had syntax errors and the C<errors>
  option was set to C<die>.
  
  =back
  
  =head1 ENVIRONMENT
  
  =over 4
  
  =item PERL_CORE
  
  If set and Encode is not available, silently fall back to non-UTF-8 mode
  without complaining to standard error.  This environment variable is set
  during Perl core builds, which build Encode after podlators.  Encode is
  expected to not (yet) be available in that case.
  
  =item POD_MAN_DATE
  
  If set, this will be used as the value of the left-hand footer unless the
  C<date> option is explicitly set, overriding the timestamp of the input
  file or the current time.  This is primarily useful to ensure reproducible
  builds of the same output file given the same source and Pod::Man version,
  even when file timestamps may not be consistent.
  
  =item SOURCE_DATE_EPOCH
  
  If set, and POD_MAN_DATE and the C<date> options are not set, this will be
  used as the modification time of the source file, overriding the timestamp of
  the input file or the current time.  It should be set to the desired time in
  seconds since UNIX epoch.  This is primarily useful to ensure reproducible
  builds of the same output file given the same source and Pod::Man version,
  even when file timestamps may not be consistent.  See
  L<https://reproducible-builds.org/specs/source-date-epoch/> for the full
  specification.
  
  (Arguably, according to the specification, this variable should be used only
  if the timestamp of the input file is not available and Pod::Man uses the
  current time.  However, for reproducible builds in Debian, results were more
  reliable if this variable overrode the timestamp of the input file.)
  
  =back
  
  =head1 BUGS
  
  Encoding handling assumes that PerlIO is available and does not work
  properly if it isn't.  The C<utf8> option is therefore not supported
  unless Perl is built with PerlIO support.
  
  There is currently no way to turn off the guesswork that tries to format
  unmarked text appropriately, and sometimes it isn't wanted (particularly
  when using POD to document something other than Perl).  Most of the work
  toward fixing this has now been done, however, and all that's still needed
  is a user interface.
  
  The NAME section should be recognized specially and index entries emitted
  for everything in that section.  This would have to be deferred until the
  next section, since extraneous things in NAME tends to confuse various man
  page processors.  Currently, no index entries are emitted for anything in
  NAME.
  
  Pod::Man doesn't handle font names longer than two characters.  Neither do
  most B<troff> implementations, but GNU troff does as an extension.  It would
  be nice to support as an option for those who want to use it.
  
  The preamble added to each output file is rather verbose, and most of it
  is only necessary in the presence of non-ASCII characters.  It would
  ideally be nice if all of those definitions were only output if needed,
  perhaps on the fly as the characters are used.
  
  Pod::Man is excessively slow.
  
  =head1 CAVEATS
  
  If Pod::Man is given the C<utf8> option, the encoding of its output file
  handle will be forced to UTF-8 if possible, overriding any existing
  encoding.  This will be done even if the file handle is not created by
  Pod::Man and was passed in from outside.  This maintains consistency
  regardless of PERL_UNICODE and other settings.
  
  The handling of hyphens and em dashes is somewhat fragile, and one may get
  the wrong one under some circumstances.  This should only matter for
  B<troff> output.
  
  When and whether to use small caps is somewhat tricky, and Pod::Man doesn't
  necessarily get it right.
  
  Converting neutral double quotes to properly matched double quotes doesn't
  work unless there are no formatting codes between the quote marks.  This
  only matters for troff output.
  
  =head1 AUTHOR
  
  Russ Allbery <rra@cpan.org>, based I<very> heavily on the original
  B<pod2man> by Tom Christiansen <tchrist@mox.perl.com>.  The modifications to
  work with Pod::Simple instead of Pod::Parser were originally contributed by
  Sean Burke (but I've since hacked them beyond recognition and all bugs are
  mine).
  
  =head1 COPYRIGHT AND LICENSE
  
  Copyright 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008,
  2009, 2010, 2012, 2013, 2014, 2015, 2016 Russ Allbery <rra@cpan.org>
  
  This program is free software; you may redistribute it and/or modify it
  under the same terms as Perl itself.
  
  =head1 SEE ALSO
  
  L<Pod::Simple>, L<perlpod(1)>, L<pod2man(1)>, L<nroff(1)>, L<troff(1)>,
  L<man(1)>, L<man(7)>
  
  Ossanna, Joseph F., and Brian W. Kernighan.  "Troff User's Manual,"
  Computing Science Technical Report No. 54, AT&T Bell Laboratories.  This is
  the best documentation of standard B<nroff> and B<troff>.  At the time of
  this writing, it's available at
  L<http://www.cs.bell-labs.com/cm/cs/cstr.html>.
  
  The man page documenting the man macro set may be L<man(5)> instead of
  L<man(7)> on your system.  Also, please see L<pod2man(1)> for extensive
  documentation on writing manual pages if you've not done it before and
  aren't familiar with the conventions.
  
  The current version of this module is always available from its web site at
  L<http://www.eyrie.org/~eagle/software/podlators/>.  It is also part of the
  Perl core distribution as of 5.6.0.
  
  =cut
POD_MAN

$fatpacked{"Pod/ParseLink.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POD_PARSELINK';
  # Pod::ParseLink -- Parse an L<> formatting code in POD text.
  #
  # Copyright 2001, 2008, 2009, 2014 by Russ Allbery <rra@cpan.org>
  #
  # This program is free software; you may redistribute it and/or modify it
  # under the same terms as Perl itself.
  #
  # This module implements parsing of the text of an L<> formatting code as
  # defined in perlpodspec.  It should be suitable for any POD formatter.  It
  # exports only one function, parselink(), which returns the five-item parse
  # defined in perlpodspec.
  #
  # Perl core hackers, please note that this module is also separately
  # maintained outside of the Perl core as part of the podlators.  Please send
  # me any patches at the address above in addition to sending them to the
  # standard Perl mailing lists.
  
  ##############################################################################
  # Modules and declarations
  ##############################################################################
  
  package Pod::ParseLink;
  
  use 5.006;
  use strict;
  use warnings;
  
  use vars qw(@EXPORT @ISA $VERSION);
  
  use Exporter;
  @ISA    = qw(Exporter);
  @EXPORT = qw(parselink);
  
  $VERSION = '4.09';
  
  ##############################################################################
  # Implementation
  ##############################################################################
  
  # Parse the name and section portion of a link into a name and section.
  sub _parse_section {
      my ($link) = @_;
      $link =~ s/^\s+//;
      $link =~ s/\s+$//;
  
      # If the whole link is enclosed in quotes, interpret it all as a section
      # even if it contains a slash.
      return (undef, $1) if ($link =~ /^"\s*(.*?)\s*"$/);
  
      # Split into page and section on slash, and then clean up quoting in the
      # section.  If there is no section and the name contains spaces, also
      # guess that it's an old section link.
      my ($page, $section) = split (/\s*\/\s*/, $link, 2);
      $section =~ s/^"\s*(.*?)\s*"$/$1/ if $section;
      if ($page && $page =~ / / && !defined ($section)) {
          $section = $page;
          $page = undef;
      } else {
          $page = undef unless $page;
          $section = undef unless $section;
      }
      return ($page, $section);
  }
  
  # Infer link text from the page and section.
  sub _infer_text {
      my ($page, $section) = @_;
      my $inferred;
      if ($page && !$section) {
          $inferred = $page;
      } elsif (!$page && $section) {
          $inferred = '"' . $section . '"';
      } elsif ($page && $section) {
          $inferred = '"' . $section . '" in ' . $page;
      }
      return $inferred;
  }
  
  # Given the contents of an L<> formatting code, parse it into the link text,
  # the possibly inferred link text, the name or URL, the section, and the type
  # of link (pod, man, or url).
  sub parselink {
      my ($link) = @_;
      $link =~ s/\s+/ /g;
      my $text;
      if ($link =~ /\|/) {
          ($text, $link) = split (/\|/, $link, 2);
      }
      if ($link =~ /\A\w+:[^:\s]\S*\Z/) {
          my $inferred;
          if (defined ($text) && length ($text) > 0) {
              return ($text, $text, $link, undef, 'url');
          } else {
              return ($text, $link, $link, undef, 'url');
          }
      } else {
          my ($name, $section) = _parse_section ($link);
          my $inferred;
          if (defined ($text) && length ($text) > 0) {
              $inferred = $text;
          } else {
              $inferred = _infer_text ($name, $section);
          }
          my $type = ($name && $name =~ /\(\S*\)/) ? 'man' : 'pod';
          return ($text, $inferred, $name, $section, $type);
      }
  }
  
  ##############################################################################
  # Module return value and documentation
  ##############################################################################
  
  # Ensure we evaluate to true.
  1;
  __END__
  
  =head1 NAME
  
  Pod::ParseLink - Parse an LE<lt>E<gt> formatting code in POD text
  
  =for stopwords
  markup Allbery URL
  
  =head1 SYNOPSIS
  
      use Pod::ParseLink;
      my $link = get_link();
      my ($text, $inferred, $name, $section, $type) = parselink($link);
  
  =head1 DESCRIPTION
  
  This module only provides a single function, parselink(), which takes the
  text of an LE<lt>E<gt> formatting code and parses it.  It returns the
  anchor text for the link (if any was given), the anchor text possibly
  inferred from the name and section, the name or URL, the section if any,
  and the type of link.  The type will be one of C<url>, C<pod>, or C<man>,
  indicating a URL, a link to a POD page, or a link to a Unix manual page.
  
  Parsing is implemented per L<perlpodspec>.  For backward compatibility,
  links where there is no section and name contains spaces, or links where the
  entirety of the link (except for the anchor text if given) is enclosed in
  double-quotes are interpreted as links to a section (LE<lt>/sectionE<gt>).
  
  The inferred anchor text is implemented per L<perlpodspec>:
  
      L<name>         =>  L<name|name>
      L</section>     =>  L<"section"|/section>
      L<name/section> =>  L<"section" in name|name/section>
  
  The name may contain embedded EE<lt>E<gt> and ZE<lt>E<gt> formatting codes,
  and the section, anchor text, and inferred anchor text may contain any
  formatting codes.  Any double quotes around the section are removed as part
  of the parsing, as is any leading or trailing whitespace.
  
  If the text of the LE<lt>E<gt> escape is entirely enclosed in double
  quotes, it's interpreted as a link to a section for backward
  compatibility.
  
  No attempt is made to resolve formatting codes.  This must be done after
  calling parselink() (since EE<lt>E<gt> formatting codes can be used to
  escape characters that would otherwise be significant to the parser and
  resolving them before parsing would result in an incorrect parse of a
  formatting code like:
  
      L<verticalE<verbar>barE<sol>slash>
  
  which should be interpreted as a link to the C<vertical|bar/slash> POD page
  and not as a link to the C<slash> section of the C<bar> POD page with an
  anchor text of C<vertical>.  Note that not only the anchor text will need to
  have formatting codes expanded, but so will the target of the link (to deal
  with EE<lt>E<gt> and ZE<lt>E<gt> formatting codes), and special handling of
  the section may be necessary depending on whether the translator wants to
  consider markup in sections to be significant when resolving links.  See
  L<perlpodspec> for more information.
  
  =head1 SEE ALSO
  
  L<Pod::Parser>
  
  The current version of this module is always available from its web site at
  L<http://www.eyrie.org/~eagle/software/podlators/>.
  
  =head1 AUTHOR
  
  Russ Allbery <rra@cpan.org>.
  
  =head1 COPYRIGHT AND LICENSE
  
  Copyright 2001, 2008, 2009 Russ Allbery <rra@cpan.org>.
  
  This program is free software; you may redistribute it and/or modify it
  under the same terms as Perl itself.
  
  =cut
POD_PARSELINK

$fatpacked{"Pod/Simple.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POD_SIMPLE';
  
  require 5;
  package Pod::Simple;
  use strict;
  use Carp ();
  BEGIN           { *DEBUG = sub () {0} unless defined &DEBUG }
  use integer;
  use Pod::Escapes 1.04 ();
  use Pod::Simple::LinkSection ();
  use Pod::Simple::BlackBox ();
  #use utf8;
  
  use vars qw(
    $VERSION @ISA
    @Known_formatting_codes  @Known_directives
    %Known_formatting_codes  %Known_directives
    $NL
  );
  
  @ISA = ('Pod::Simple::BlackBox');
  $VERSION = '3.35';
  
  @Known_formatting_codes = qw(I B C L E F S X Z); 
  %Known_formatting_codes = map(($_=>1), @Known_formatting_codes);
  @Known_directives       = qw(head1 head2 head3 head4 item over back); 
  %Known_directives       = map(($_=>'Plain'), @Known_directives);
  $NL = $/ unless defined $NL;
  
  #-----------------------------------------------------------------------------
  # Set up some constants:
  
  BEGIN {
    if(defined &ASCII)    { }
    elsif(chr(65) eq 'A') { *ASCII = sub () {1}  }
    else                  { *ASCII = sub () {''} }
  
    unless(defined &MANY_LINES) { *MANY_LINES = sub () {20} }
    DEBUG > 4 and print STDERR "MANY_LINES is ", MANY_LINES(), "\n";
    unless(MANY_LINES() >= 1) {
      die "MANY_LINES is too small (", MANY_LINES(), ")!\nAborting";
    }
    if(defined &UNICODE) { }
    elsif($] >= 5.008)   { *UNICODE = sub() {1}  }
    else                 { *UNICODE = sub() {''} }
  }
  if(DEBUG > 2) {
    print STDERR "# We are ", ASCII ? '' : 'not ', "in ASCII-land\n";
    print STDERR "# We are under a Unicode-safe Perl.\n";
  }
  
  # The NO BREAK SPACE and SOFT HYHPEN are used in several submodules.
  if ($] ge 5.007_003) {  # On sufficiently modern Perls we can handle any
                          # character set
    $Pod::Simple::nbsp = chr utf8::unicode_to_native(0xA0);
    $Pod::Simple::shy  = chr utf8::unicode_to_native(0xAD);
  }
  elsif (Pod::Simple::ASCII) {  # Hard code ASCII early Perl
    $Pod::Simple::nbsp = "\xA0";
    $Pod::Simple::shy  = "\xAD";
  }
  else { # EBCDIC on early Perl.  We know what the values are for the code
          # pages supported then.
    $Pod::Simple::nbsp = "\x41";
    $Pod::Simple::shy  = "\xCA";
  }
  
  # Design note:
  # This is a parser for Pod.  It is not a parser for the set of Pod-like
  #  languages which happens to contain Pod -- it is just for Pod, plus possibly
  #  some extensions.
  
  # @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @
  #@ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @
  #@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
  
  __PACKAGE__->_accessorize(
    'nbsp_for_S',        # Whether to map S<...>'s to \xA0 characters
    'source_filename',   # Filename of the source, for use in warnings
    'source_dead',       # Whether to consider this parser's source dead
  
    'output_fh',         # The filehandle we're writing to, if applicable.
                         # Used only in some derived classes.
  
    'hide_line_numbers', # For some dumping subclasses: whether to pointedly
                         # suppress the start_line attribute
  
    'line_count',        # the current line number
    'pod_para_count',    # count of pod paragraphs seen so far
  
    'no_whining',        # whether to suppress whining
    'no_errata_section', # whether to suppress the errata section
    'complain_stderr',   # whether to complain to stderr
  
    'doc_has_started',   # whether we've fired the open-Document event yet
  
    'bare_output',       # For some subclasses: whether to prepend
                         #  header-code and postpend footer-code
  
    'keep_encoding_directive',  # whether to emit =encoding
    'nix_X_codes',       # whether to ignore X<...> codes
    'merge_text',        # whether to avoid breaking a single piece of
                         #  text up into several events
  
    'preserve_whitespace', # whether to try to keep whitespace as-is
    'strip_verbatim_indent', # What indent to strip from verbatim
  
    'parse_characters',  # Whether parser should expect chars rather than octets
  
   'content_seen',      # whether we've seen any real Pod content
   'errors_seen',       # TODO: document.  whether we've seen any errors (fatal or not)
  
   'codes_in_verbatim', # for PseudoPod extensions
  
   'code_handler',      # coderef to call when a code (non-pod) line is seen
   'cut_handler',       # ... when a =cut line is seen
   'pod_handler',       # ... when a =pod line is seen
   'whiteline_handler', # ... when a line with only whitespace is seen
   #Called like:
   # $code_handler->($line, $self->{'line_count'}, $self) if $code_handler;
   #  $cut_handler->($line, $self->{'line_count'}, $self) if $cut_handler;
   #  $pod_handler->($line, $self->{'line_count'}, $self) if $pod_handler;
   #   $wl_handler->($line, $self->{'line_count'}, $self) if $wl_handler;
   'parse_empty_lists', # whether to acknowledge empty =over/=back blocks
   'raw_mode',          # to report entire raw lines instead of Pod elements
  );
  
  #@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
  
  sub any_errata_seen {  # good for using as an exit() value...
    return shift->{'errors_seen'} || 0;
  }
  
  sub errata_seen {
    return shift->{'all_errata'} || {};
  }
  
  # Returns the encoding only if it was recognized as being handled and set
  sub detected_encoding {
    return shift->{'detected_encoding'};
  }
  
  sub encoding {
    my $this = shift;
    return $this->{'encoding'} unless @_;  # GET.
  
    $this->_handle_encoding_line("=encoding $_[0]");
    if ($this->{'_processed_encoding'}) {
      delete $this->{'_processed_encoding'};
      if(! $this->{'encoding_command_statuses'} ) {
        DEBUG > 2 and print STDERR " CRAZY ERROR: encoding wasn't really handled?!\n";
      } elsif( $this->{'encoding_command_statuses'}[-1] ) {
        $this->scream( "=encoding $_[0]",
           sprintf "Couldn't do %s: %s",
           $this->{'encoding_command_reqs'  }[-1],
           $this->{'encoding_command_statuses'}[-1],
        );
      } else {
        DEBUG > 2 and print STDERR " (encoding successfully handled.)\n";
      }
      return $this->{'encoding'};
    } else {
      return undef;
    }
  }
  
  #@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
  # Pull in some functions that, for some reason, I expect to see here too:
  BEGIN {
    *pretty        = \&Pod::Simple::BlackBox::pretty;
    *stringify_lol = \&Pod::Simple::BlackBox::stringify_lol;
  }
  
  #@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
  
  sub version_report {
    my $class = ref($_[0]) || $_[0];
    if($class eq __PACKAGE__) {
      return "$class $VERSION";
    } else {
      my $v = $class->VERSION;
      return "$class $v (" . __PACKAGE__ . " $VERSION)";
    }
  }
  
  #@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
  
  #sub curr_open { # read-only list accessor
  #  return @{ $_[0]{'curr_open'} || return() };
  #}
  #sub _curr_open_listref { $_[0]{'curr_open'} ||= [] }
  
  
  sub output_string {
    # Works by faking out output_fh.  Simplifies our code.
    #
    my $this = shift;
    return $this->{'output_string'} unless @_;  # GET.
    
    require Pod::Simple::TiedOutFH;
    my $x = (defined($_[0]) and ref($_[0])) ? $_[0] : \( $_[0] );
    $$x = '' unless defined $$x;
    DEBUG > 4 and print STDERR "# Output string set to $x ($$x)\n";
    $this->{'output_fh'} = Pod::Simple::TiedOutFH->handle_on($_[0]);
    return
      $this->{'output_string'} = $_[0];
      #${ ${ $this->{'output_fh'} } };
  }
  
  sub abandon_output_string { $_[0]->abandon_output_fh; delete $_[0]{'output_string'} }
  sub abandon_output_fh     { $_[0]->output_fh(undef) }
  # These don't delete the string or close the FH -- they just delete our
  #  references to it/them.
  # TODO: document these
  
  #@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
  
  sub new {
    # takes no parameters
    my $class = ref($_[0]) || $_[0];
    #Carp::croak(__PACKAGE__ . " is a virtual base class -- see perldoc "
    #  . __PACKAGE__ );
    return bless {
      'accept_codes'      => { map( ($_=>$_), @Known_formatting_codes ) },
      'accept_directives' => { %Known_directives },
      'accept_targets'    => {},
    }, $class;
  }
  
  
  
  # TODO: an option for whether to interpolate E<...>'s, or just resolve to codes.
  
  #@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
  
  sub _handle_element_start {     # OVERRIDE IN DERIVED CLASS
    my($self, $element_name, $attr_hash_r) = @_;
    return;
  }
  
  sub _handle_element_end {       # OVERRIDE IN DERIVED CLASS
    my($self, $element_name) = @_;
    return;
  }
  
  sub _handle_text          {     # OVERRIDE IN DERIVED CLASS
    my($self, $text) = @_;
    return;
  }
  
  #@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
  #
  # And now directives (not targets)
  
  sub accept_directive_as_verbatim  { shift->_accept_directives('Verbatim', @_) }
  sub accept_directive_as_data      { shift->_accept_directives('Data',     @_) }
  sub accept_directive_as_processed { shift->_accept_directives('Plain',    @_) }
  
  sub _accept_directives {
    my($this, $type) = splice @_,0,2;
    foreach my $d (@_) {
      next unless defined $d and length $d;
      Carp::croak "\"$d\" isn't a valid directive name"
       unless $d =~ m/^[a-zA-Z][a-zA-Z0-9]*$/s;
      Carp::croak "\"$d\" is already a reserved Pod directive name"
       if exists $Known_directives{$d};
      $this->{'accept_directives'}{$d} = $type;
      DEBUG > 2 and print STDERR "Learning to accept \"=$d\" as directive of type $type\n";
    }
    DEBUG > 6 and print STDERR "$this\'s accept_directives : ",
     pretty($this->{'accept_directives'}), "\n";
    
    return sort keys %{ $this->{'accept_directives'} } if wantarray;
    return;
  }
  
  #--------------------------------------------------------------------------
  # TODO: document these:
  
  sub unaccept_directive { shift->unaccept_directives(@_) };
  
  sub unaccept_directives {
    my $this = shift;
    foreach my $d (@_) {
      next unless defined $d and length $d;
      Carp::croak "\"$d\" isn't a valid directive name"
       unless $d =~ m/^[a-zA-Z][a-zA-Z0-9]*$/s;
      Carp::croak "But you must accept \"$d\" directives -- it's a builtin!"
       if exists $Known_directives{$d};
      delete $this->{'accept_directives'}{$d};
      DEBUG > 2 and print STDERR "OK, won't accept \"=$d\" as directive.\n";
    }
    return sort keys %{ $this->{'accept_directives'} } if wantarray;
    return
  }
  
  #@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
  #
  # And now targets (not directives)
  
  sub accept_target         { shift->accept_targets(@_)         } # alias
  sub accept_target_as_text { shift->accept_targets_as_text(@_) } # alias
  
  
  sub accept_targets         { shift->_accept_targets('1', @_) }
  
  sub accept_targets_as_text { shift->_accept_targets('force_resolve', @_) }
   # forces them to be processed, even when there's no ":".
  
  sub _accept_targets {
    my($this, $type) = splice @_,0,2;
    foreach my $t (@_) {
      next unless defined $t and length $t;
      # TODO: enforce some limitations on what a target name can be?
      $this->{'accept_targets'}{$t} = $type;
      DEBUG > 2 and print STDERR "Learning to accept \"$t\" as target of type $type\n";
    }    
    return sort keys %{ $this->{'accept_targets'} } if wantarray;
    return;
  }
  
  #--------------------------------------------------------------------------
  sub unaccept_target         { shift->unaccept_targets(@_) }
  
  sub unaccept_targets {
    my $this = shift;
    foreach my $t (@_) {
      next unless defined $t and length $t;
      # TODO: enforce some limitations on what a target name can be?
      delete $this->{'accept_targets'}{$t};
      DEBUG > 2 and print STDERR "OK, won't accept \"$t\" as target.\n";
    }    
    return sort keys %{ $this->{'accept_targets'} } if wantarray;
    return;
  }
  
  #@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
  #
  # And now codes (not targets or directives)
  
  # XXX Probably it is an error that the digit '9' is excluded from these re's.
  # Broken for early Perls on EBCDIC
  my $xml_name_re = eval "qr/[^-.0-8:A-Z_a-z[:^ascii:]]/";
  if (! defined $xml_name_re) {
      $xml_name_re = qr/[\x00-\x2C\x2F\x39\x3B-\x40\x5B-\x5E\x60\x7B-\x7F]/;
  }
  
  sub accept_code { shift->accept_codes(@_) } # alias
  
  sub accept_codes {  # Add some codes
    my $this = shift;
    
    foreach my $new_code (@_) {
      next unless defined $new_code and length $new_code;
      # A good-enough check that it's good as an XML Name symbol:
      Carp::croak "\"$new_code\" isn't a valid element name"
        if $new_code =~ $xml_name_re
            # Characters under 0x80 that aren't legal in an XML Name.
        or $new_code =~ m/^[-\.0-9]/s
        or $new_code =~ m/:[-\.0-9]/s;
            # The legal under-0x80 Name characters that
            #  an XML Name still can't start with.
  
      $this->{'accept_codes'}{$new_code} = $new_code;
  
      # Yes, map to itself -- just so that when we
      #  see "=extend W [whatever] thatelementname", we say that W maps
      #  to whatever $this->{accept_codes}{thatelementname} is,
      #  i.e., "thatelementname".  Then when we go re-mapping,
      #  a "W" in the treelet turns into "thatelementname".  We only
      #  remap once.
      # If we say we accept "W", then a "W" in the treelet simply turns
      #  into "W".
    }
    
    return;
  }
  
  #--------------------------------------------------------------------------
  sub unaccept_code { shift->unaccept_codes(@_) }
  
  sub unaccept_codes { # remove some codes
    my $this = shift;
    
    foreach my $new_code (@_) {
      next unless defined $new_code and length $new_code;
      # A good-enough check that it's good as an XML Name symbol:
      Carp::croak "\"$new_code\" isn't a valid element name"
        if $new_code =~ $xml_name_re
            # Characters under 0x80 that aren't legal in an XML Name.
        or $new_code =~ m/^[-\.0-9]/s
        or $new_code =~ m/:[-\.0-9]/s;
            # The legal under-0x80 Name characters that
            #  an XML Name still can't start with.
  
      Carp::croak "But you must accept \"$new_code\" codes -- it's a builtin!"
       if grep $new_code eq $_, @Known_formatting_codes;
  
      delete $this->{'accept_codes'}{$new_code};
  
      DEBUG > 2 and print STDERR "OK, won't accept the code $new_code<...>.\n";
    }
    
    return;
  }
  
  
  #@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
  #@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
  
  sub parse_string_document {
    my $self = shift;
    my @lines;
    foreach my $line_group (@_) {
      next unless defined $line_group and length $line_group;
      pos($line_group) = 0;
      while($line_group =~
        m/([^\n\r]*)(\r?\n?)/g # supports \r, \n ,\r\n
        #m/([^\n\r]*)((?:\r?\n)?)/g
      ) {
        #print(">> $1\n"),
        $self->parse_lines($1)
         if length($1) or length($2)
          or pos($line_group) != length($line_group);
         # I.e., unless it's a zero-length "empty line" at the very
         #  end of "foo\nbar\n" (i.e., between the \n and the EOS).
      }
    }
    $self->parse_lines(undef); # to signal EOF
    return $self;
  }
  
  sub _init_fh_source {
    my($self, $source) = @_;
  
    #DEBUG > 1 and print STDERR "Declaring $source as :raw for starters\n";
    #$self->_apply_binmode($source, ':raw');
    #binmode($source, ":raw");
  
    return;
  }
  
  #:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.
  #
  
  sub parse_file {
    my($self, $source) = (@_);
  
    if(!defined $source) {
      Carp::croak("Can't use empty-string as a source for parse_file");
    } elsif(ref(\$source) eq 'GLOB') {
      $self->{'source_filename'} = '' . ($source);
    } elsif(ref $source) {
      $self->{'source_filename'} = '' . ($source);
    } elsif(!length $source) {
      Carp::croak("Can't use empty-string as a source for parse_file");
    } else {
      {
        local *PODSOURCE;
        open(PODSOURCE, "<$source") || Carp::croak("Can't open $source: $!");
        $self->{'source_filename'} = $source;
        $source = *PODSOURCE{IO};
      }
      $self->_init_fh_source($source);
    }
    # By here, $source is a FH.
  
    $self->{'source_fh'} = $source;
  
    my($i, @lines);
    until( $self->{'source_dead'} ) {
      splice @lines;
  
      for($i = MANY_LINES; $i--;) {  # read those many lines at a time
        local $/ = $NL;
        push @lines, scalar(<$source>);  # readline
        last unless defined $lines[-1];
         # but pass thru the undef, which will set source_dead to true
      }
  
      my $at_eof = ! $lines[-1]; # keep track of the undef
      pop @lines if $at_eof; # silence warnings
  
      # be eol agnostic
      s/\r\n?/\n/g for @lines;
   
      # make sure there are only one line elements for parse_lines
      @lines = split(/(?<=\n)/, join('', @lines));
  
      # push the undef back after popping it to set source_dead to true
      push @lines, undef if $at_eof;
  
      $self->parse_lines(@lines);
    }
    delete($self->{'source_fh'}); # so it can be GC'd
    return $self;
  }
  
  #:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.
  
  sub parse_from_file {
    # An emulation of Pod::Parser's interface, for the sake of Perldoc.
    # Basically just a wrapper around parse_file.
  
    my($self, $source, $to) = @_;
    $self = $self->new unless ref($self); # so we tolerate being a class method
    
    if(!defined $source)             { $source = *STDIN{IO}
    } elsif(ref(\$source) eq 'GLOB') { # stet
    } elsif(ref($source)           ) { # stet
    } elsif(!length $source
       or $source eq '-' or $source =~ m/^<&(?:STDIN|0)$/i
    ) { 
      $source = *STDIN{IO};
    }
  
    if(!defined $to) {             $self->output_fh( *STDOUT{IO}   );
    } elsif(ref(\$to) eq 'GLOB') { $self->output_fh( $to );
    } elsif(ref($to)) {            $self->output_fh( $to );
    } elsif(!length $to
       or $to eq '-' or $to =~ m/^>&?(?:STDOUT|1)$/i
    ) {
      $self->output_fh( *STDOUT{IO} );
    } elsif($to =~ m/^>&(?:STDERR|2)$/i) {
      $self->output_fh( *STDERR{IO} );
    } else {
      require Symbol;
      my $out_fh = Symbol::gensym();
      DEBUG and print STDERR "Write-opening to $to\n";
      open($out_fh, ">$to")  or  Carp::croak "Can't write-open $to: $!";
      binmode($out_fh)
       if $self->can('write_with_binmode') and $self->write_with_binmode;
      $self->output_fh($out_fh);
    }
  
    return $self->parse_file($source);
  }
  
  #-----------------------------------------------------------------------------
  
  sub whine {
    #my($self,$line,$complaint) = @_;
    my $self = shift(@_);
    ++$self->{'errors_seen'};
    if($self->{'no_whining'}) {
      DEBUG > 9 and print STDERR "Discarding complaint (at line $_[0]) $_[1]\n because no_whining is on.\n";
      return;
    }
    push @{$self->{'all_errata'}{$_[0]}}, $_[1];
    return $self->_complain_warn(@_) if $self->{'complain_stderr'};
    return $self->_complain_errata(@_);
  }
  
  sub scream {    # like whine, but not suppressible
    #my($self,$line,$complaint) = @_;
    my $self = shift(@_);
    ++$self->{'errors_seen'};
    push @{$self->{'all_errata'}{$_[0]}}, $_[1];
    return $self->_complain_warn(@_) if $self->{'complain_stderr'};
    return $self->_complain_errata(@_);
  }
  
  sub _complain_warn {
    my($self,$line,$complaint) = @_;
    return printf STDERR "%s around line %s: %s\n",
      $self->{'source_filename'} || 'Pod input', $line, $complaint;
  }
  
  sub _complain_errata {
    my($self,$line,$complaint) = @_;
    if( $self->{'no_errata_section'} ) {
      DEBUG > 9 and print STDERR "Discarding erratum (at line $line) $complaint\n because no_errata_section is on.\n";
    } else {
      DEBUG > 9 and print STDERR "Queuing erratum (at line $line) $complaint\n";
      push @{$self->{'errata'}{$line}}, $complaint
        # for a report to be generated later!
    }
    return 1;
  }
  
  #@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
  
  sub _get_initial_item_type {
    # A hack-wrapper here for when you have like "=over\n\n=item 456\n\n"
    my($self, $para) = @_;
    return $para->[1]{'~type'}  if $para->[1]{'~type'};
  
    return $para->[1]{'~type'} = 'text'
     if join("\n", @{$para}[2 .. $#$para]) =~ m/^\s*(\d+)\.?\s*$/s and $1 ne '1';
    # Else fall thru to the general case:
    return $self->_get_item_type($para);
  }
  
  
  
  sub _get_item_type {       # mutates the item!!
    my($self, $para) = @_;
    return $para->[1]{'~type'} if $para->[1]{'~type'};
  
  
    # Otherwise we haven't yet been to this node.  Maybe alter it...
    
    my $content = join "\n", @{$para}[2 .. $#$para];
  
    if($content =~ m/^\s*\*\s*$/s or $content =~ m/^\s*$/s) {
      # Like: "=item *", "=item   *   ", "=item"
      splice @$para, 2; # so it ends up just being ['=item', { attrhash } ]
      $para->[1]{'~orig_content'} = $content;
      return $para->[1]{'~type'} = 'bullet';
  
    } elsif($content =~ m/^\s*\*\s+(.+)/s) {  # tolerance
    
      # Like: "=item * Foo bar baz";
      $para->[1]{'~orig_content'}      = $content;
      $para->[1]{'~_freaky_para_hack'} = $1;
      DEBUG > 2 and print STDERR " Tolerating $$para[2] as =item *\\n\\n$1\n";
      splice @$para, 2; # so it ends up just being ['=item', { attrhash } ]
      return $para->[1]{'~type'} = 'bullet';
  
    } elsif($content =~ m/^\s*(\d+)\.?\s*$/s) {
      # Like: "=item 1.", "=item    123412"
      
      $para->[1]{'~orig_content'} = $content;
      $para->[1]{'number'} = $1;  # Yes, stores the number there!
  
      splice @$para, 2; # so it ends up just being ['=item', { attrhash } ]
      return $para->[1]{'~type'} = 'number';
      
    } else {
      # It's anything else.
      return $para->[1]{'~type'} = 'text';
  
    }
  }
  
  #-----------------------------------------------------------------------------
  
  sub _make_treelet {
    my $self = shift;  # and ($para, $start_line)
    my $treelet;
    if(!@_) {
      return [''];
    } if(ref $_[0] and ref $_[0][0] and $_[0][0][0] eq '~Top') {
      # Hack so we can pass in fake-o pre-cooked paragraphs:
      #  just have the first line be a reference to a ['~Top', {}, ...]
      # We use this feechure in gen_errata and stuff.
  
      DEBUG and print STDERR "Applying precooked treelet hack to $_[0][0]\n";
      $treelet = $_[0][0];
      splice @$treelet, 0, 2;  # lop the top off
      return $treelet;
    } else {
      $treelet = $self->_treelet_from_formatting_codes(@_);
    }
    
    if( $self->_remap_sequences($treelet) ) {
      $self->_treat_Zs($treelet);  # Might as well nix these first
      $self->_treat_Ls($treelet);  # L has to precede E and S
      $self->_treat_Es($treelet);
      $self->_treat_Ss($treelet);  # S has to come after E
  
      $self->_wrap_up($treelet); # Nix X's and merge texties
      
    } else {
      DEBUG and print STDERR "Formatless treelet gets fast-tracked.\n";
       # Very common case!
    }
    
    splice @$treelet, 0, 2;  # lop the top off
  
    return $treelet;
  }
  
  #:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.
  
  sub _wrap_up {
    my($self, @stack) = @_;
    my $nixx  = $self->{'nix_X_codes'};
    my $merge = $self->{'merge_text' };
    return unless $nixx or $merge;
  
    DEBUG > 2 and print STDERR "\nStarting _wrap_up traversal.\n",
     $merge ? (" Merge mode on\n") : (),
     $nixx  ? (" Nix-X mode on\n") : (),
    ;    
    
  
    my($i, $treelet);
    while($treelet = shift @stack) {
      DEBUG > 3 and print STDERR " Considering children of this $treelet->[0] node...\n";
      for($i = 2; $i < @$treelet; ++$i) { # iterate over children
        DEBUG > 3 and print STDERR " Considering child at $i ", pretty($treelet->[$i]), "\n";
        if($nixx and ref $treelet->[$i] and $treelet->[$i][0] eq 'X') {
          DEBUG > 3 and print STDERR "   Nixing X node at $i\n";
          splice(@$treelet, $i, 1); # just nix this node (and its descendants)
          # no need to back-update the counter just yet
          redo;
  
        } elsif($merge and $i != 2 and  # non-initial
           !ref $treelet->[$i] and !ref $treelet->[$i - 1]
        ) {
          DEBUG > 3 and print STDERR "   Merging ", $i-1,
           ":[$treelet->[$i-1]] and $i\:[$treelet->[$i]]\n";
          $treelet->[$i-1] .= ( splice(@$treelet, $i, 1) )[0];
          DEBUG > 4 and print STDERR "    Now: ", $i-1, ":[$treelet->[$i-1]]\n";
          --$i;
          next; 
          # since we just pulled the possibly last node out from under
          #  ourselves, we can't just redo()
  
        } elsif( ref $treelet->[$i] ) {
          DEBUG > 4 and print STDERR "  Enqueuing ", pretty($treelet->[$i]), " for traversal.\n";
          push @stack, $treelet->[$i];
  
          if($treelet->[$i][0] eq 'L') {
            my $thing;
            foreach my $attrname ('section', 'to') {        
              if(defined($thing = $treelet->[$i][1]{$attrname}) and ref $thing) {
                unshift @stack, $thing;
                DEBUG > 4 and print STDERR "  +Enqueuing ",
                 pretty( $treelet->[$i][1]{$attrname} ),
                 " as an attribute value to tweak.\n";
              }
            }
          }
        }
      }
    }
    DEBUG > 2 and print STDERR "End of _wrap_up traversal.\n\n";
  
    return;
  }
  
  #:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.
  
  sub _remap_sequences {
    my($self,@stack) = @_;
    
    if(@stack == 1 and @{ $stack[0] } == 3 and !ref $stack[0][2]) {
      # VERY common case: abort it.
      DEBUG and print STDERR "Skipping _remap_sequences: formatless treelet.\n";
      return 0;
    }
    
    my $map = ($self->{'accept_codes'} || die "NO accept_codes in $self?!?");
  
    my $start_line = $stack[0][1]{'start_line'};
    DEBUG > 2 and printf
     "\nAbout to start _remap_sequences on treelet from line %s.\n",
     $start_line || '[?]'
    ;
    DEBUG > 3 and print STDERR " Map: ",
      join('; ', map "$_=" . (
          ref($map->{$_}) ? join(",", @{$map->{$_}}) : $map->{$_}
        ),
        sort keys %$map ),
      ("B~C~E~F~I~L~S~X~Z" eq join '~', sort keys %$map)
       ? "  (all normal)\n" : "\n"
    ;
  
    # A recursive algorithm implemented iteratively!  Whee!
    
    my($is, $was, $i, $treelet); # scratch
    while($treelet = shift @stack) {
      DEBUG > 3 and print STDERR " Considering children of this $treelet->[0] node...\n";
      for($i = 2; $i < @$treelet; ++$i) { # iterate over children
        next unless ref $treelet->[$i];  # text nodes are uninteresting
        
        DEBUG > 4 and print STDERR "  Noting child $i : $treelet->[$i][0]<...>\n";
        
        $is = $treelet->[$i][0] = $map->{ $was = $treelet->[$i][0] };
        if( DEBUG > 3 ) {
          if(!defined $is) {
            print STDERR "   Code $was<> is UNKNOWN!\n";
          } elsif($is eq $was) {
            DEBUG > 4 and print STDERR "   Code $was<> stays the same.\n";
          } else  {
            print STDERR "   Code $was<> maps to ",
             ref($is)
              ? ( "tags ", map("$_<", @$is), '...', map('>', @$is), "\n" )
              : "tag $is<...>.\n";
          }
        }
        
        if(!defined $is) {
          $self->whine($start_line, "Deleting unknown formatting code $was<>");
          $is = $treelet->[$i][0] = '1';  # But saving the children!
          # I could also insert a leading "$was<" and tailing ">" as
          # children of this node, but something about that seems icky.
        }
        if(ref $is) {
          my @dynasty = @$is;
          DEBUG > 4 and print STDERR "    Renaming $was node to $dynasty[-1]\n";
          $treelet->[$i][0] = pop @dynasty;
          my $nugget;
          while(@dynasty) {
            DEBUG > 4 and printf
             "    Grafting a new %s node between %s and %s\n",
             $dynasty[-1], $treelet->[0], $treelet->[$i][0], 
            ;
            
            #$nugget = ;
            splice @$treelet, $i, 1, [pop(@dynasty), {}, $treelet->[$i]];
              # relace node with a new parent
          }
        } elsif($is eq '0') {
          splice(@$treelet, $i, 1); # just nix this node (and its descendants)
          --$i;  # back-update the counter
        } elsif($is eq '1') {
          splice(@$treelet, $i, 1 # replace this node with its children!
            => splice @{ $treelet->[$i] },2
                # (not catching its first two (non-child) items)
          );
          --$i;  # back up for new stuff
        } else {
          # otherwise it's unremarkable
          unshift @stack, $treelet->[$i];  # just recurse
        }
      }
    }
    
    DEBUG > 2 and print STDERR "End of _remap_sequences traversal.\n\n";
  
    if(@_ == 2 and @{ $_[1] } == 3 and !ref $_[1][2]) {
      DEBUG and print STDERR "Noting that the treelet is now formatless.\n";
      return 0;
    }
    return 1;
  }
  
  # . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
  sub _ponder_extend {
  
    # "Go to an extreme, move back to a more comfortable place"
    #  -- /Oblique Strategies/,  Brian Eno and Peter Schmidt
    
    my($self, $para) = @_;
    my $content = join ' ', splice @$para, 2;
    $content =~ s/^\s+//s;
    $content =~ s/\s+$//s;
  
    DEBUG > 2 and print STDERR "Ogling extensor: =extend $content\n";
  
    if($content =~
      m/^
        (\S+)         # 1 : new item
        \s+
        (\S+)         # 2 : fallback(s)
        (?:\s+(\S+))? # 3 : element name(s)
        \s*
        $
      /xs
    ) {
      my $new_letter = $1;
      my $fallbacks_one = $2;
      my $elements_one;
      $elements_one = defined($3) ? $3 : $1;
  
      DEBUG > 2 and print STDERR "Extensor has good syntax.\n";
  
      unless($new_letter =~ m/^[A-Z]$/s or $new_letter) {
        DEBUG > 2 and print STDERR " $new_letter isn't a valid thing to entend.\n";
        $self->whine(
          $para->[1]{'start_line'},
          "You can extend only formatting codes A-Z, not like \"$new_letter\""
        );
        return;
      }
      
      if(grep $new_letter eq $_, @Known_formatting_codes) {
        DEBUG > 2 and print STDERR " $new_letter isn't a good thing to extend, because known.\n";
        $self->whine(
          $para->[1]{'start_line'},
          "You can't extend an established code like \"$new_letter\""
        );
        
        #TODO: or allow if last bit is same?
        
        return;
      }
  
      unless($fallbacks_one =~ m/^[A-Z](,[A-Z])*$/s  # like "B", "M,I", etc.
        or $fallbacks_one eq '0' or $fallbacks_one eq '1'
      ) {
        $self->whine(
          $para->[1]{'start_line'},
          "Format for second =extend parameter must be like"
          . " M or 1 or 0 or M,N or M,N,O but you have it like "
          . $fallbacks_one
        );
        return;
      }
      
      unless($elements_one =~ m/^[^ ,]+(,[^ ,]+)*$/s) { # like "B", "M,I", etc.
        $self->whine(
          $para->[1]{'start_line'},
          "Format for third =extend parameter: like foo or bar,Baz,qu:ux but not like "
          . $elements_one
        );
        return;
      }
  
      my @fallbacks  = split ',', $fallbacks_one,  -1;
      my @elements   = split ',', $elements_one, -1;
  
      foreach my $f (@fallbacks) {
        next if exists $Known_formatting_codes{$f} or $f eq '0' or $f eq '1';
        DEBUG > 2 and print STDERR "  Can't fall back on unknown code $f\n";
        $self->whine(
          $para->[1]{'start_line'},
          "Can't use unknown formatting code '$f' as a fallback for '$new_letter'"
        );
        return;
      }
  
      DEBUG > 3 and printf STDERR "Extensor: Fallbacks <%s> Elements <%s>.\n",
       @fallbacks, @elements;
  
      my $canonical_form;
      foreach my $e (@elements) {
        if(exists $self->{'accept_codes'}{$e}) {
          DEBUG > 1 and print STDERR " Mapping '$new_letter' to known extension '$e'\n";
          $canonical_form = $e;
          last; # first acceptable elementname wins!
        } else {
          DEBUG > 1 and print STDERR " Can't map '$new_letter' to unknown extension '$e'\n";
        }
      }
  
  
      if( defined $canonical_form ) {
        # We found a good N => elementname mapping
        $self->{'accept_codes'}{$new_letter} = $canonical_form;
        DEBUG > 2 and print
         "Extensor maps $new_letter => known element $canonical_form.\n";
      } else {
        # We have to use the fallback(s), which might be '0', or '1'.
        $self->{'accept_codes'}{$new_letter}
          = (@fallbacks == 1) ? $fallbacks[0] : \@fallbacks;
        DEBUG > 2 and print
         "Extensor maps $new_letter => fallbacks @fallbacks.\n";
      }
  
    } else {
      DEBUG > 2 and print STDERR "Extensor has bad syntax.\n";
      $self->whine(
        $para->[1]{'start_line'},
        "Unknown =extend syntax: $content"
      )
    }
    return;
  }
  
  
  #:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.
  
  sub _treat_Zs {  # Nix Z<...>'s
    my($self,@stack) = @_;
  
    my($i, $treelet);
    my $start_line = $stack[0][1]{'start_line'};
  
    # A recursive algorithm implemented iteratively!  Whee!
  
    while($treelet = shift @stack) {
      for($i = 2; $i < @$treelet; ++$i) { # iterate over children
        next unless ref $treelet->[$i];  # text nodes are uninteresting
        unless($treelet->[$i][0] eq 'Z') {
          unshift @stack, $treelet->[$i]; # recurse
          next;
        }
          
        DEBUG > 1 and print STDERR "Nixing Z node @{$treelet->[$i]}\n";
          
        # bitch UNLESS it's empty
        unless(  @{$treelet->[$i]} == 2
             or (@{$treelet->[$i]} == 3 and $treelet->[$i][2] eq '')
        ) {
          $self->whine( $start_line, "A non-empty Z<>" );
        }      # but kill it anyway
          
        splice(@$treelet, $i, 1); # thereby just nix this node.
        --$i;
          
      }
    }
    
    return;
  }
  
  # . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
  # Quoting perlpodspec:
  
  # In parsing an L<...> code, Pod parsers must distinguish at least four
  # attributes:
  
  ############# Not used.  Expressed via the element children plus
  #############  the value of the "content-implicit" flag.
  # First:
  # The link-text. If there is none, this must be undef. (E.g., in "L<Perl
  # Functions|perlfunc>", the link-text is "Perl Functions". In
  # "L<Time::HiRes>" and even "L<|Time::HiRes>", there is no link text. Note
  # that link text may contain formatting.)
  # 
  
  ############# The element children
  # Second:
  # The possibly inferred link-text -- i.e., if there was no real link text,
  # then this is the text that we'll infer in its place. (E.g., for
  # "L<Getopt::Std>", the inferred link text is "Getopt::Std".)
  #
  
  ############# The "to" attribute (which might be text, or a treelet)
  # Third:
  # The name or URL, or undef if none. (E.g., in "L<Perl
  # Functions|perlfunc>", the name -- also sometimes called the page -- is
  # "perlfunc". In "L</CAVEATS>", the name is undef.)
  # 
  
  ############# The "section" attribute (which might be next, or a treelet)
  # Fourth:
  # The section (AKA "item" in older perlpods), or undef if none. E.g., in
  # Getopt::Std/DESCRIPTION, "DESCRIPTION" is the section. (Note that this
  # is not the same as a manpage section like the "5" in "man 5 crontab".
  # "Section Foo" in the Pod sense means the part of the text that's
  # introduced by the heading or item whose text is "Foo".)
  # 
  # Pod parsers may also note additional attributes including:
  #
  
  ############# The "type" attribute.
  # Fifth:
  # A flag for whether item 3 (if present) is a URL (like
  # "http://lists.perl.org" is), in which case there should be no section
  # attribute; a Pod name (like "perldoc" and "Getopt::Std" are); or
  # possibly a man page name (like "crontab(5)" is).
  #
  
  ############# The "raw" attribute that is already there.
  # Sixth:
  # The raw original L<...> content, before text is split on "|", "/", etc,
  # and before E<...> codes are expanded.
  
  
  # For L<...> codes without a "name|" part, only E<...> and Z<> codes may
  # occur -- no other formatting codes. That is, authors should not use
  # "L<B<Foo::Bar>>".
  #
  # Note, however, that formatting codes and Z<>'s can occur in any and all
  # parts of an L<...> (i.e., in name, section, text, and url).
  
  sub _treat_Ls {  # Process our dear dear friends, the L<...> sequences
  
    # L<name>
    # L<name/"sec"> or L<name/sec>
    # L</"sec"> or L</sec> or L<"sec">
    # L<text|name>
    # L<text|name/"sec"> or L<text|name/sec>
    # L<text|/"sec"> or L<text|/sec> or L<text|"sec">
    # L<scheme:...>
    # L<text|scheme:...>
  
    my($self,@stack) = @_;
  
    my($i, $treelet);
    my $start_line = $stack[0][1]{'start_line'};
  
    # A recursive algorithm implemented iteratively!  Whee!
  
    while($treelet = shift @stack) {
      for(my $i = 2; $i < @$treelet; ++$i) {
        # iterate over children of current tree node
        next unless ref $treelet->[$i];  # text nodes are uninteresting
        unless($treelet->[$i][0] eq 'L') {
          unshift @stack, $treelet->[$i]; # recurse
          next;
        }
        
        
        # By here, $treelet->[$i] is definitely an L node
        my $ell = $treelet->[$i];
        DEBUG > 1 and print STDERR "Ogling L node $ell\n";
          
        # bitch if it's empty
        if(  @{$ell} == 2
         or (@{$ell} == 3 and $ell->[2] eq '')
        ) {
          $self->whine( $start_line, "An empty L<>" );
          $treelet->[$i] = 'L<>';  # just make it a text node
          next;  # and move on
        }
  
        if( (! ref $ell->[2]  && $ell->[2] =~ /\A\s/)
          ||(! ref $ell->[-1] && $ell->[-1] =~ /\s\z/)
        ) {
          $self->whine( $start_line, "L<> starts or ends with whitespace" );
        }
       
        # Catch URLs:
  
        # there are a number of possible cases:
        # 1) text node containing url: http://foo.com
        #   -> [ 'http://foo.com' ]
        # 2) text node containing url and text: foo|http://foo.com
        #   -> [ 'foo|http://foo.com' ]
        # 3) text node containing url start: mailto:xE<at>foo.com
        #   -> [ 'mailto:x', [ E ... ], 'foo.com' ]
        # 4) text node containing url start and text: foo|mailto:xE<at>foo.com
        #   -> [ 'foo|mailto:x', [ E ... ], 'foo.com' ]
        # 5) other nodes containing text and url start: OE<39>Malley|http://foo.com
        #   -> [ 'O', [ E ... ], 'Malley', '|http://foo.com' ]
        # ... etc.
  
        # anything before the url is part of the text.
        # anything after it is part of the url.
        # the url text node itself may contain parts of both.
  
        if (my ($url_index, $text_part, $url_part) =
          # grep is no good here; we want to bail out immediately so that we can
          # use $1, $2, etc. without having to do the match twice.
          sub {
            for (2..$#$ell) {
              next if ref $ell->[$_];
              next unless $ell->[$_] =~ m/^(?:([^|]*)\|)?(\w+:[^:\s]\S*)$/s;
              return ($_, $1, $2);
            }
            return;
          }->()
        ) {
          $ell->[1]{'type'} = 'url';
  
          my @text = @{$ell}[2..$url_index-1];
          push @text, $text_part if defined $text_part;
  
          my @url  = @{$ell}[$url_index+1..$#$ell];
          unshift @url, $url_part;
  
          unless (@text) {
            $ell->[1]{'content-implicit'} = 'yes';
            @text = @url;
          }
  
          $ell->[1]{to} = Pod::Simple::LinkSection->new(
            @url == 1
            ? $url[0]
            : [ '', {}, @url ],
          );
  
          splice @$ell, 2, $#$ell, @text;
  
          next;
        }
        
        # Catch some very simple and/or common cases
        if(@{$ell} == 3 and ! ref $ell->[2]) {
          my $it = $ell->[2];
          if($it =~ m{^[^/|]+[(][-a-zA-Z0-9]+[)]$}s) { # man sections
            # Hopefully neither too broad nor too restrictive a RE
            DEBUG > 1 and print STDERR "Catching \"$it\" as manpage link.\n";
            $ell->[1]{'type'} = 'man';
            # This's the only place where man links can get made.
            $ell->[1]{'content-implicit'} = 'yes';
            $ell->[1]{'to'  } =
              Pod::Simple::LinkSection->new( $it ); # treelet!
  
            next;
          }
          if($it =~ m/^[^\/\|,\$\%\@\ \"\<\>\:\#\&\*\{\}\[\]\(\)]+(\:\:[^\/\|,\$\%\@\ \"\<\>\:\#\&\*\{\}\[\]\(\)]+)*$/s) {
            # Extremely forgiving idea of what constitutes a bare
            #  modulename link like L<Foo::Bar> or even L<Thing::1.0::Docs::Tralala>
            DEBUG > 1 and print STDERR "Catching \"$it\" as ho-hum L<Modulename> link.\n";
            $ell->[1]{'type'} = 'pod';
            $ell->[1]{'content-implicit'} = 'yes';
            $ell->[1]{'to'  } =
              Pod::Simple::LinkSection->new( $it ); # treelet!
            next;
          }
          # else fall thru...
        }
        
        
  
        # ...Uhoh, here's the real L<...> parsing stuff...
        # "With the ill behavior, with the ill behavior, with the ill behavior..."
  
        DEBUG > 1 and print STDERR "Running a real parse on this non-trivial L\n";
        
        
        my $link_text; # set to an arrayref if found
        my @ell_content = @$ell;
        splice @ell_content,0,2; # Knock off the 'L' and {} bits
  
        DEBUG > 3 and print STDERR " Ell content to start: ",
         pretty(@ell_content), "\n";
  
  
        # Look for the "|" -- only in CHILDREN (not all underlings!)
        # Like L<I like the strictness|strict>
        DEBUG > 3 and
           print STDERR "  Peering at L content for a '|' ...\n";
        for(my $j = 0; $j < @ell_content; ++$j) {
          next if ref $ell_content[$j];
          DEBUG > 3 and
           print STDERR "    Peering at L-content text bit \"$ell_content[$j]\" for a '|'.\n";
  
          if($ell_content[$j] =~ m/^([^\|]*)\|(.*)$/s) {
            my @link_text = ($1);   # might be 0-length
            $ell_content[$j] = $2;  # might be 0-length
  
            DEBUG > 3 and
             print STDERR "     FOUND a '|' in it.  Splitting into [$1] + [$2]\n";
  
            if ($link_text[0] =~ m{[|/]}) {
              $self->whine(
                $start_line,
                "alternative text '$link_text[0]' contains non-escaped | or /"
              );
            }
  
            unshift @link_text, splice @ell_content, 0, $j;
              # leaving only things at J and after
            @ell_content =  grep ref($_)||length($_), @ell_content ;
            $link_text   = [grep ref($_)||length($_), @link_text  ];
            DEBUG > 3 and printf
             "  So link text is %s\n  and remaining ell content is %s\n",
              pretty($link_text), pretty(@ell_content);
            last;
          }
        }
        
        
        # Now look for the "/" -- only in CHILDREN (not all underlings!)
        # And afterward, anything left in @ell_content will be the raw name
        # Like L<Foo::Bar/Object Methods>
        my $section_name;  # set to arrayref if found
        DEBUG > 3 and print STDERR "  Peering at L-content for a '/' ...\n";
        for(my $j = 0; $j < @ell_content; ++$j) {
          next if ref $ell_content[$j];
          DEBUG > 3 and
           print STDERR "    Peering at L-content text bit \"$ell_content[$j]\" for a '/'.\n";
  
          if($ell_content[$j] =~ m/^([^\/]*)\/(.*)$/s) {
            my @section_name = ($2); # might be 0-length
            $ell_content[$j] =  $1;  # might be 0-length
  
            DEBUG > 3 and
             print STDERR "     FOUND a '/' in it.",
               "  Splitting to page [...$1] + section [$2...]\n";
  
            push @section_name, splice @ell_content, 1+$j;
              # leaving only things before and including J
            
            @ell_content  = grep ref($_)||length($_), @ell_content  ;
            @section_name = grep ref($_)||length($_), @section_name ;
  
            # Turn L<.../"foo"> into L<.../foo>
            if(@section_name
              and !ref($section_name[0]) and !ref($section_name[-1])
              and $section_name[ 0] =~ m/^\"/s
              and $section_name[-1] =~ m/\"$/s
              and !( # catch weird degenerate case of L<"> !
                @section_name == 1 and $section_name[0] eq '"'
              )
            ) {
              $section_name[ 0] =~ s/^\"//s;
              $section_name[-1] =~ s/\"$//s;
              DEBUG > 3 and
               print STDERR "     Quotes removed: ", pretty(@section_name), "\n";
            } else {
              DEBUG > 3 and
               print STDERR "     No need to remove quotes in ", pretty(@section_name), "\n";
            }
  
            $section_name = \@section_name;
            last;
          }
        }
  
        # Turn L<"Foo Bar"> into L</Foo Bar>
        if(!$section_name and @ell_content
           and !ref($ell_content[0]) and !ref($ell_content[-1])
           and $ell_content[ 0] =~ m/^\"/s
           and $ell_content[-1] =~ m/\"$/s
           and !( # catch weird degenerate case of L<"> !
             @ell_content == 1 and $ell_content[0] eq '"'
           )
        ) {
          $section_name = [splice @ell_content];
          $section_name->[ 0] =~ s/^\"//s;
          $section_name->[-1] =~ s/\"$//s;
        }
  
        # Turn L<Foo Bar> into L</Foo Bar>.
        if(!$section_name and !$link_text and @ell_content
           and grep !ref($_) && m/ /s, @ell_content
        ) {
          $section_name = [splice @ell_content];
          # That's support for the now-deprecated syntax.
          # (Maybe generate a warning eventually?)
          # Note that it deliberately won't work on L<...|Foo Bar>
        }
  
  
        # Now make up the link_text
        # L<Foo>     -> L<Foo|Foo>
        # L</Bar>    -> L<"Bar"|Bar>
        # L<Foo/Bar> -> L<"Bar" in Foo/Foo>
        unless($link_text) {
          $ell->[1]{'content-implicit'} = 'yes';
          $link_text = [];
          push @$link_text, '"', @$section_name, '"' if $section_name;
  
          if(@ell_content) {
            $link_text->[-1] .= ' in ' if $section_name;
            push @$link_text, @ell_content;
          }
        }
  
  
        # And the E resolver will have to deal with all our treeletty things:
  
        if(@ell_content == 1 and !ref($ell_content[0])
           and $ell_content[0] =~ m{^[^/]+[(][-a-zA-Z0-9]+[)]$}s
        ) {
          $ell->[1]{'type'}    = 'man';
          DEBUG > 3 and print STDERR "Considering this ($ell_content[0]) a man link.\n";
        } else {
          $ell->[1]{'type'}    = 'pod';
          DEBUG > 3 and print STDERR "Considering this a pod link (not man or url).\n";
        }
  
        if( defined $section_name ) {
          $ell->[1]{'section'} = Pod::Simple::LinkSection->new(
            ['', {}, @$section_name]
          );
          DEBUG > 3 and print STDERR "L-section content: ", pretty($ell->[1]{'section'}), "\n";
        }
  
        if( @ell_content ) {
          $ell->[1]{'to'} = Pod::Simple::LinkSection->new(
            ['', {}, @ell_content]
          );
          DEBUG > 3 and print STDERR "L-to content: ", pretty($ell->[1]{'to'}), "\n";
        }
        
        # And update children to be the link-text:
        @$ell = (@$ell[0,1], defined($link_text) ? splice(@$link_text) : '');
        
        DEBUG > 2 and print STDERR "End of L-parsing for this node $treelet->[$i]\n";
  
        unshift @stack, $treelet->[$i]; # might as well recurse
      }
    }
  
    return;
  }
  
  # . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
  sub _treat_Es {
    my($self,@stack) = @_;
  
    my($i, $treelet, $content, $replacer, $charnum);
    my $start_line = $stack[0][1]{'start_line'};
  
    # A recursive algorithm implemented iteratively!  Whee!
  
  
    # Has frightening side effects on L nodes' attributes.
  
    #my @ells_to_tweak;
  
    while($treelet = shift @stack) {
      for(my $i = 2; $i < @$treelet; ++$i) { # iterate over children
        next unless ref $treelet->[$i];  # text nodes are uninteresting
        if($treelet->[$i][0] eq 'L') {
          # SPECIAL STUFF for semi-processed L<>'s
          
          my $thing;
          foreach my $attrname ('section', 'to') {        
            if(defined($thing = $treelet->[$i][1]{$attrname}) and ref $thing) {
              unshift @stack, $thing;
              DEBUG > 2 and print STDERR "  Enqueuing ",
               pretty( $treelet->[$i][1]{$attrname} ),
               " as an attribute value to tweak.\n";
            }
          }
          
          unshift @stack, $treelet->[$i]; # recurse
          next;
        } elsif($treelet->[$i][0] ne 'E') {
          unshift @stack, $treelet->[$i]; # recurse
          next;
        }
        
        DEBUG > 1 and print STDERR "Ogling E node ", pretty($treelet->[$i]), "\n";
  
        # bitch if it's empty
        if(  @{$treelet->[$i]} == 2
         or (@{$treelet->[$i]} == 3 and $treelet->[$i][2] eq '')
        ) {
          $self->whine( $start_line, "An empty E<>" );
          $treelet->[$i] = 'E<>'; # splice in a literal
          next;
        }
          
        # bitch if content is weird
        unless(@{$treelet->[$i]} == 3 and !ref($content = $treelet->[$i][2])) {
          $self->whine( $start_line, "An E<...> surrounding strange content" );
          $replacer = $treelet->[$i]; # scratch
          splice(@$treelet, $i, 1,   # fake out a literal
            'E<',
            splice(@$replacer,2), # promote its content
            '>'
          );
          # Don't need to do --$i, as the 'E<' we just added isn't interesting.
          next;
        }
  
        DEBUG > 1 and print STDERR "Ogling E<$content>\n";
  
        # XXX E<>'s contents *should* be a valid char in the scope of the current
        # =encoding directive. Defaults to iso-8859-1, I believe. Fix this in the
        # future sometime.
  
        $charnum  = Pod::Escapes::e2charnum($content);
        DEBUG > 1 and print STDERR " Considering E<$content> with char ",
          defined($charnum) ? $charnum : "undef", ".\n";
  
        if(!defined( $charnum )) {
          DEBUG > 1 and print STDERR "I don't know how to deal with E<$content>.\n";
          $self->whine( $start_line, "Unknown E content in E<$content>" );
          $replacer = "E<$content>"; # better than nothing
        } elsif($charnum >= 255 and !UNICODE) {
          $replacer = ASCII ? "\xA4" : "?";
          DEBUG > 1 and print STDERR "This Perl version can't handle ",
            "E<$content> (chr $charnum), so replacing with $replacer\n";
        } else {
          $replacer = Pod::Escapes::e2char($content);
          DEBUG > 1 and print STDERR " Replacing E<$content> with $replacer\n";
        }
  
        splice(@$treelet, $i, 1, $replacer); # no need to back up $i, tho
      }
    }
  
    return;
  }
  
  
  # . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
  sub _treat_Ss {
    my($self,$treelet) = @_;
    
    _change_S_to_nbsp($treelet,0) if $self->{'nbsp_for_S'};
  
    # TODO: or a change_nbsp_to_S
    #  Normalizing nbsp's to S is harder: for each text node, make S content
    #  out of anything matching m/([^ \xA0]*(?:\xA0+[^ \xA0]*)+)/
  
  
    return;
  }
  
  sub _change_S_to_nbsp { #  a recursive function
    # Sanely assumes that the top node in the excursion won't be an S node.
    my($treelet, $in_s) = @_;
    
    my $is_s = ('S' eq $treelet->[0]);
    $in_s ||= $is_s; # So in_s is on either by this being an S element,
                     #  or by an ancestor being an S element.
  
    for(my $i = 2; $i < @$treelet; ++$i) {
      if(ref $treelet->[$i]) {
        if( _change_S_to_nbsp( $treelet->[$i], $in_s ) ) {
          my $to_pull_up = $treelet->[$i];
          splice @$to_pull_up,0,2;   # ...leaving just its content
          splice @$treelet, $i, 1, @$to_pull_up;  # Pull up content
          $i +=  @$to_pull_up - 1;   # Make $i skip the pulled-up stuff
        }
      } else {
        $treelet->[$i] =~ s/\s/$Pod::Simple::nbsp/g if $in_s;
         
         # Note that if you apply nbsp_for_S to text, and so turn
         # "foo S<bar baz> quux" into "foo bar&#160;faz quux", you
         # end up with something that fails to say "and don't hyphenate
         # any part of 'bar baz'".  However, hyphenation is such a vexing
         # problem anyway, that most Pod renderers just don't render it
         # at all.  But if you do want to implement hyphenation, I guess
         # that you'd better have nbsp_for_S off.
      }
    }
  
    return $is_s;
  }
  
  #-----------------------------------------------------------------------------
  
  sub _accessorize {  # A simple-minded method-maker
    no strict 'refs';
    foreach my $attrname (@_) {
      next if $attrname =~ m/::/; # a hack
      *{caller() . '::' . $attrname} = sub {
        use strict;
        $Carp::CarpLevel = 1,  Carp::croak(
         "Accessor usage: \$obj->$attrname() or \$obj->$attrname(\$new_value)"
        ) unless (@_ == 1 or @_ == 2) and ref $_[0];
        (@_ == 1) ?  $_[0]->{$attrname}
                  : ($_[0]->{$attrname} = $_[1]);
      };
    }
    # Ya know, they say accessories make the ensemble!
    return;
  }
  
  # . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  # . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  #=============================================================================
  
  sub filter {
    my($class, $source) = @_;
    my $new = $class->new;
    $new->output_fh(*STDOUT{IO});
    
    if(ref($source || '') eq 'SCALAR') {
      $new->parse_string_document( $$source );
    } elsif(ref($source)) {  # it's a file handle
      $new->parse_file($source);
    } else {  # it's a filename
      $new->parse_file($source);
    }
    
    return $new;
  }
  
  
  #-----------------------------------------------------------------------------
  
  sub _out {
    # For use in testing: Class->_out($source)
    #  returns the transformation of $source
    
    my $class = shift(@_);
  
    my $mutor = shift(@_) if @_ and ref($_[0] || '') eq 'CODE';
  
    DEBUG and print STDERR "\n\n", '#' x 76,
     "\nAbout to parse source: {{\n$_[0]\n}}\n\n";
    
    
    my $parser = ref $class && $class->isa(__PACKAGE__) ? $class : $class->new;
    $parser->hide_line_numbers(1);
  
    my $out = '';
    $parser->output_string( \$out );
    DEBUG and print STDERR " _out to ", \$out, "\n";
    
    $mutor->($parser) if $mutor;
  
    $parser->parse_string_document( $_[0] );
    # use Data::Dumper; print STDERR Dumper($parser), "\n";
    return $out;
  }
  
  
  sub _duo {
    # For use in testing: Class->_duo($source1, $source2)
    #  returns the parse trees of $source1 and $source2.
    # Good in things like: &ok( Class->duo(... , ...) );
    
    my $class = shift(@_);
    
    Carp::croak "But $class->_duo is useful only in list context!"
     unless wantarray;
  
    my $mutor = shift(@_) if @_ and ref($_[0] || '') eq 'CODE';
  
    Carp::croak "But $class->_duo takes two parameters, not: @_"
     unless @_ == 2;
  
    my(@out);
    
    while( @_ ) {
      my $parser = $class->new;
  
      push @out, '';
      $parser->output_string( \( $out[-1] ) );
  
      DEBUG and print STDERR " _duo out to ", $parser->output_string(),
        " = $parser->{'output_string'}\n";
  
      $parser->hide_line_numbers(1);
      $mutor->($parser) if $mutor;
      $parser->parse_string_document( shift( @_ ) );
      # use Data::Dumper; print STDERR Dumper($parser), "\n";
    }
  
    return @out;
  }
  
  
  
  #-----------------------------------------------------------------------------
  1;
  __END__
  
  TODO:
  A start_formatting_code and end_formatting_code methods, which in the
  base class call start_L, end_L, start_C, end_C, etc., if they are
  defined.
  
  have the POD FORMATTING ERRORS section note the localtime, and the
  version of Pod::Simple.
  
  option to delete all E<shy>s?
  option to scream if under-0x20 literals are found in the input, or
  under-E<32> E codes are found in the tree. And ditto \x7f-\x9f
  
  Option to turn highbit characters into their compromised form? (applies
  to E parsing too)
  
  TODO: BOM/encoding things.
  
  TODO: ascii-compat things in the XML classes?
  
POD_SIMPLE

$fatpacked{"Pod/Simple/BlackBox.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POD_SIMPLE_BLACKBOX';
  package Pod::Simple::BlackBox;
  #
  # "What's in the box?"  "Pain."
  #
  ###########################################################################
  #
  # This is where all the scary things happen: parsing lines into
  #  paragraphs; and then into directives, verbatims, and then also
  #  turning formatting sequences into treelets.
  #
  # Are you really sure you want to read this code?
  #
  #-----------------------------------------------------------------------------
  #
  # The basic work of this module Pod::Simple::BlackBox is doing the dirty work
  # of parsing Pod into treelets (generally one per non-verbatim paragraph), and
  # to call the proper callbacks on the treelets.
  #
  # Every node in a treelet is a ['name', {attrhash}, ...children...]
  
  use integer; # vroom!
  use strict;
  use Carp ();
  use vars qw($VERSION );
  $VERSION = '3.35';
  #use constant DEBUG => 7;
  BEGIN {
    require Pod::Simple;
    *DEBUG = \&Pod::Simple::DEBUG unless defined &DEBUG
  }
  
  # Matches a character iff the character will have a different meaning
  # if we choose CP1252 vs UTF-8 if there is no =encoding line.
  # This is broken for early Perls on non-ASCII platforms.
  my $non_ascii_re = eval "qr/[[:^ascii:]]/";
  $non_ascii_re = qr/[\x80-\xFF]/ if ! defined $non_ascii_re;
  
  my $utf8_bom;
  if (($] ge 5.007_003)) {
    $utf8_bom = "\x{FEFF}";
    utf8::encode($utf8_bom);
  } else {
    $utf8_bom = "\xEF\xBB\xBF";   # No EBCDIC BOM detection for early Perls.
  }
  
  #@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
  
  sub parse_line { shift->parse_lines(@_) } # alias
  
  # - - -  Turn back now!  Run away!  - - -
  
  sub parse_lines {             # Usage: $parser->parse_lines(@lines)
    # an undef means end-of-stream
    my $self = shift;
  
    my $code_handler = $self->{'code_handler'};
    my $cut_handler  = $self->{'cut_handler'};
    my $wl_handler   = $self->{'whiteline_handler'};
    $self->{'line_count'} ||= 0;
   
    my $scratch;
  
    DEBUG > 4 and 
     print STDERR "# Parsing starting at line ", $self->{'line_count'}, ".\n";
  
    DEBUG > 5 and
     print STDERR "#  About to parse lines: ",
       join(' ', map defined($_) ? "[$_]" : "EOF", @_), "\n";
  
    my $paras = ($self->{'paras'} ||= []);
     # paragraph buffer.  Because we need to defer processing of =over
     # directives and verbatim paragraphs.  We call _ponder_paragraph_buffer
     # to process this.
    
    $self->{'pod_para_count'} ||= 0;
  
    my $line;
    foreach my $source_line (@_) {
      if( $self->{'source_dead'} ) {
        DEBUG > 4 and print STDERR "# Source is dead.\n";
        last;
      }
  
      unless( defined $source_line ) {
        DEBUG > 4 and print STDERR "# Undef-line seen.\n";
  
        push @$paras, ['~end', {'start_line' => $self->{'line_count'}}];
        push @$paras, $paras->[-1], $paras->[-1];
         # So that it definitely fills the buffer.
        $self->{'source_dead'} = 1;
        $self->_ponder_paragraph_buffer;
        next;
      }
  
  
      if( $self->{'line_count'}++ ) {
        ($line = $source_line) =~ tr/\n\r//d;
         # If we don't have two vars, we'll end up with that there
         # tr/// modding the (potentially read-only) original source line!
      
      } else {
        DEBUG > 2 and print STDERR "First line: [$source_line]\n";
  
        if( ($line = $source_line) =~ s/^$utf8_bom//s ) {
          DEBUG and print STDERR "UTF-8 BOM seen.  Faking a '=encoding utf8'.\n";
          $self->_handle_encoding_line( "=encoding utf8" );
          delete $self->{'_processed_encoding'};
          $line =~ tr/\n\r//d;
          
        } elsif( $line =~ s/^\xFE\xFF//s ) {
          DEBUG and print STDERR "Big-endian UTF-16 BOM seen.  Aborting parsing.\n";
          $self->scream(
            $self->{'line_count'},
            "UTF16-BE Byte Encoding Mark found; but Pod::Simple v$Pod::Simple::VERSION doesn't implement UTF16 yet."
          );
          splice @_;
          push @_, undef;
          next;
  
          # TODO: implement somehow?
  
        } elsif( $line =~ s/^\xFF\xFE//s ) {
          DEBUG and print STDERR "Little-endian UTF-16 BOM seen.  Aborting parsing.\n";
          $self->scream(
            $self->{'line_count'},
            "UTF16-LE Byte Encoding Mark found; but Pod::Simple v$Pod::Simple::VERSION doesn't implement UTF16 yet."
          );
          splice @_;
          push @_, undef;
          next;
  
          # TODO: implement somehow?
          
        } else {
          DEBUG > 2 and print STDERR "First line is BOM-less.\n";
          ($line = $source_line) =~ tr/\n\r//d;
        }
      }
  
      if(!$self->{'parse_characters'} && !$self->{'encoding'}
        && ($self->{'in_pod'} || $line =~ /^=/s)
        && $line =~ /$non_ascii_re/
      ) {
  
        my $encoding;
  
        # No =encoding line, and we are at the first line in the input that
        # contains a non-ascii byte, that is one whose meaning varies depending
        # on whether the file is encoded in UTF-8 or CP1252, which are the two
        # possibilities permitted by the pod spec.  (ASCII is assumed if the
        # file only contains ASCII bytes.)  In order to process this line, we
        # need to figure out what encoding we will use for the file.
        #
        # Strictly speaking ISO 8859-1 (Latin 1) refers to the code points
        # 160-255, but it is used here, as it often colloquially is, to refer to
        # the complete set of code points 0-255, including ASCII (0-127), the C1
        # controls (128-159), and strict Latin 1 (160-255).
        #
        # CP1252 is effectively a superset of Latin 1, because it differs only
        # from colloquial 8859-1 in the C1 controls, which are very unlikely to
        # actually be present in 8859-1 files, so can be used for other purposes
        # without conflict.  CP 1252 uses most of them for graphic characters.
        #
        # Note that all ASCII-range bytes represent their corresponding code
        # points in CP1252 and UTF-8.  In ASCII platform UTF-8 all other code
        # points require multiple (non-ASCII) bytes to represent.  (A separate
        # paragraph for EBCDIC is below.)  The multi-byte representation is
        # quite structured.  If we find an isolated byte that requires multiple
        # bytes to represent in UTF-8, we know that the encoding is not UTF-8.
        # If we find a sequence of bytes that violates the UTF-8 structure, we
        # also can presume the encoding isn't UTF-8, and hence must be 1252.
        #
        # But there are ambiguous cases where we could guess wrong.  If so, the
        # user will end up having to supply an =encoding line.  We use all
        # readily available information to improve our chances of guessing
        # right.  The odds of something not being UTF-8, but still passing a
        # UTF-8 validity test go down very rapidly with increasing length of the
        # sequence.  Therefore we look at all the maximal length non-ascii
        # sequences on the line.  If any of the sequences can't be UTF-8, we
        # quit there and choose CP1252.  If all could be UTF-8, we guess UTF-8.
        #
        # On EBCDIC platforms, the situation is somewhat different.  In
        # UTF-EBCDIC, not only do ASCII-range bytes represent their code points,
        # but so do the bytes that are for the C1 controls.  Recall that these
        # correspond to the unused portion of 8859-1 that 1252 mostly takes
        # over.  That means that there are fewer code points that are
        # represented by multi-bytes.  But, note that the these controls are
        # very unlikely to be in pod text.  So if we encounter one of them, it
        # means that it is quite likely CP1252 and not UTF-8.  The net result is
        # the same code below is used for both platforms.
        while ($line =~ m/($non_ascii_re+)/g) {
          my $non_ascii_seq = $1;
  
          if (length $non_ascii_seq == 1) {
            $encoding = 'CP1252';
            goto guessed;
          } elsif ($] ge 5.007_003) {
  
            # On Perls that have this function, we can see if the sequence is
            # valid UTF-8 or not.
            my $is_utf8;
            {
              no warnings 'utf8';
              $is_utf8 = utf8::decode($non_ascii_seq);
            }
            if (! $is_utf8) {
              $encoding = 'CP1252';
              goto guessed;
            }
          } elsif (ord("A") == 65) {  # An early Perl, ASCII platform
  
            # Without utf8::decode, it's a lot harder to do a rigorous check
            # (though some early releases had a different function that
            # accomplished the same thing).  Since these are ancient Perls, not
            # likely to be in use today, we take the easy way out, and look at
            # just the first two bytes of the sequence to see if they are the
            # start of a UTF-8 character.  In ASCII UTF-8, continuation bytes
            # must be between 0x80 and 0xBF.  Start bytes can range from 0xC2
            # through 0xFF, but anything above 0xF4 is not Unicode, and hence
            # extremely unlikely to be in a pod.
            if ($non_ascii_seq !~ /^[\xC2-\xF4][\x80-\xBF]/) {
              $encoding = 'CP1252';
              goto guessed;
            }
  
            # We don't bother doing anything special for EBCDIC on early Perls.
            # If there is a solitary variant, CP1252 will be chosen; otherwise
            # UTF-8.
          }
        } # End of loop through all variant sequences on the line
  
        # All sequences in the line could be UTF-8.  Guess that.
        $encoding = 'UTF-8';
  
      guessed:
        $self->_handle_encoding_line( "=encoding $encoding" );
        delete $self->{'_processed_encoding'};
        $self->{'_transcoder'} && $self->{'_transcoder'}->($line);
  
        my ($word) = $line =~ /(\S*$non_ascii_re\S*)/;
  
        $self->whine(
          $self->{'line_count'},
          "Non-ASCII character seen before =encoding in '$word'. Assuming $encoding"
        );
      }
  
      DEBUG > 5 and print STDERR "# Parsing line: [$line]\n";
  
      if(!$self->{'in_pod'}) {
        if($line =~ m/^=([a-zA-Z][a-zA-Z0-9]*)(?:\s|$)/s) {
          if($1 eq 'cut') {
            $self->scream(
              $self->{'line_count'},
              "=cut found outside a pod block.  Skipping to next block."
            );
            
            ## Before there were errata sections in the world, it was
            ## least-pessimal to abort processing the file.  But now we can
            ## just barrel on thru (but still not start a pod block).
            #splice @_;
            #push @_, undef;
            
            next;
          } else {
            $self->{'in_pod'} = $self->{'start_of_pod_block'}
                              = $self->{'last_was_blank'}     = 1;
            # And fall thru to the pod-mode block further down
          }
        } else {
          DEBUG > 5 and print STDERR "# It's a code-line.\n";
          $code_handler->(map $_, $line, $self->{'line_count'}, $self)
           if $code_handler;
          # Note: this may cause code to be processed out of order relative
          #  to pods, but in order relative to cuts.
          
          # Note also that we haven't yet applied the transcoding to $line
          #  by time we call $code_handler!
  
          if( $line =~ m/^#\s*line\s+(\d+)\s*(?:\s"([^"]+)")?\s*$/ ) {
            # That RE is from perlsyn, section "Plain Old Comments (Not!)",
            #$fname = $2 if defined $2;
            #DEBUG > 1 and defined $2 and print STDERR "# Setting fname to \"$fname\"\n";
            DEBUG > 1 and print STDERR "# Setting nextline to $1\n";
            $self->{'line_count'} = $1 - 1;
          }
          
          next;
        }
      }
      
      # . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
      # Else we're in pod mode:
  
      # Apply any necessary transcoding:
      $self->{'_transcoder'} && $self->{'_transcoder'}->($line);
  
      # HERE WE CATCH =encoding EARLY!
      if( $line =~ m/^=encoding\s+\S+\s*$/s ) {
        next if $self->parse_characters;   # Ignore this line
        $line = $self->_handle_encoding_line( $line );
      }
  
      if($line =~ m/^=cut/s) {
        # here ends the pod block, and therefore the previous pod para
        DEBUG > 1 and print STDERR "Noting =cut at line ${$self}{'line_count'}\n";
        $self->{'in_pod'} = 0;
        # ++$self->{'pod_para_count'};
        $self->_ponder_paragraph_buffer();
         # by now it's safe to consider the previous paragraph as done.
        $cut_handler->(map $_, $line, $self->{'line_count'}, $self)
         if $cut_handler;
  
        # TODO: add to docs: Note: this may cause cuts to be processed out
        #  of order relative to pods, but in order relative to code.
        
      } elsif($line =~ m/^(\s*)$/s) {  # it's a blank line
        if (defined $1 and $1 =~ /[^\S\r\n]/) { # it's a white line
          $wl_handler->(map $_, $line, $self->{'line_count'}, $self)
            if $wl_handler;
        }
  
        if(!$self->{'start_of_pod_block'} and @$paras and $paras->[-1][0] eq '~Verbatim') {
          DEBUG > 1 and print STDERR "Saving blank line at line ${$self}{'line_count'}\n";
          push @{$paras->[-1]}, $line;
        }  # otherwise it's not interesting
        
        if(!$self->{'start_of_pod_block'} and !$self->{'last_was_blank'}) {
          DEBUG > 1 and print STDERR "Noting para ends with blank line at ${$self}{'line_count'}\n";
        }
        
        $self->{'last_was_blank'} = 1;
        
      } elsif($self->{'last_was_blank'}) {  # A non-blank line starting a new para...
        
        if($line =~ m/^(=[a-zA-Z][a-zA-Z0-9]*)(?:\s+|$)(.*)/s) {
          # THIS IS THE ONE PLACE WHERE WE CONSTRUCT NEW DIRECTIVE OBJECTS
          my $new = [$1, {'start_line' => $self->{'line_count'}}, $2];
           # Note that in "=head1 foo", the WS is lost.
           # Example: ['=head1', {'start_line' => 123}, ' foo']
          
          ++$self->{'pod_para_count'};
          
          $self->_ponder_paragraph_buffer();
           # by now it's safe to consider the previous paragraph as done.
                  
          push @$paras, $new; # the new incipient paragraph
          DEBUG > 1 and print STDERR "Starting new ${$paras}[-1][0] para at line ${$self}{'line_count'}\n";
          
        } elsif($line =~ m/^\s/s) {
  
          if(!$self->{'start_of_pod_block'} and @$paras and $paras->[-1][0] eq '~Verbatim') {
            DEBUG > 1 and print STDERR "Resuming verbatim para at line ${$self}{'line_count'}\n";
            push @{$paras->[-1]}, $line;
          } else {
            ++$self->{'pod_para_count'};
            $self->_ponder_paragraph_buffer();
             # by now it's safe to consider the previous paragraph as done.
            DEBUG > 1 and print STDERR "Starting verbatim para at line ${$self}{'line_count'}\n";
            push @$paras, ['~Verbatim', {'start_line' => $self->{'line_count'}}, $line];
          }
        } else {
          ++$self->{'pod_para_count'};
          $self->_ponder_paragraph_buffer();
           # by now it's safe to consider the previous paragraph as done.
          push @$paras, ['~Para',  {'start_line' => $self->{'line_count'}}, $line];
          DEBUG > 1 and print STDERR "Starting plain para at line ${$self}{'line_count'}\n";
        }
        $self->{'last_was_blank'} = $self->{'start_of_pod_block'} = 0;
  
      } else {
        # It's a non-blank line /continuing/ the current para
        if(@$paras) {
          DEBUG > 2 and print STDERR "Line ${$self}{'line_count'} continues current paragraph\n";
          push @{$paras->[-1]}, $line;
        } else {
          # Unexpected case!
          die "Continuing a paragraph but \@\$paras is empty?";
        }
        $self->{'last_was_blank'} = $self->{'start_of_pod_block'} = 0;
      }
      
    } # ends the big while loop
  
    DEBUG > 1 and print STDERR (pretty(@$paras), "\n");
    return $self;
  }
  
  #@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
  
  sub _handle_encoding_line {
    my($self, $line) = @_;
    
    return if $self->parse_characters;
  
    # The point of this routine is to set $self->{'_transcoder'} as indicated.
  
    return $line unless $line =~ m/^=encoding\s+(\S+)\s*$/s;
    DEBUG > 1 and print STDERR "Found an encoding line \"=encoding $1\"\n";
  
    my $e    = $1;
    my $orig = $e;
    push @{ $self->{'encoding_command_reqs'} }, "=encoding $orig";
  
    my $enc_error;
  
    # Cf.   perldoc Encode   and   perldoc Encode::Supported
  
    require Pod::Simple::Transcode;
  
    if( $self->{'encoding'} ) {
      my $norm_current = $self->{'encoding'};
      my $norm_e = $e;
      foreach my $that ($norm_current, $norm_e) {
        $that =  lc($that);
        $that =~ s/[-_]//g;
      }
      if($norm_current eq $norm_e) {
        DEBUG > 1 and print STDERR "The '=encoding $orig' line is ",
         "redundant.  ($norm_current eq $norm_e).  Ignoring.\n";
        $enc_error = '';
         # But that doesn't necessarily mean that the earlier one went okay
      } else {
        $enc_error = "Encoding is already set to " . $self->{'encoding'};
        DEBUG > 1 and print STDERR $enc_error;
      }
    } elsif (
      # OK, let's turn on the encoding
      do {
        DEBUG > 1 and print STDERR " Setting encoding to $e\n";
        $self->{'encoding'} = $e;
        1;
      }
      and $e eq 'HACKRAW'
    ) {
      DEBUG and print STDERR " Putting in HACKRAW (no-op) encoding mode.\n";
  
    } elsif( Pod::Simple::Transcode::->encoding_is_available($e) ) {
  
      die($enc_error = "WHAT? _transcoder is already set?!")
       if $self->{'_transcoder'};   # should never happen
      require Pod::Simple::Transcode;
      $self->{'_transcoder'} = Pod::Simple::Transcode::->make_transcoder($e);
      eval {
        my @x = ('', "abc", "123");
        $self->{'_transcoder'}->(@x);
      };
      $@ && die( $enc_error =
        "Really unexpected error setting up encoding $e: $@\nAborting"
      );
      $self->{'detected_encoding'} = $e;
  
    } else {
      my @supported = Pod::Simple::Transcode::->all_encodings;
  
      # Note unsupported, and complain
      DEBUG and print STDERR " Encoding [$e] is unsupported.",
        "\nSupporteds: @supported\n";
      my $suggestion = '';
  
      # Look for a near match:
      my $norm = lc($e);
      $norm =~ tr[-_][]d;
      my $n;
      foreach my $enc (@supported) {
        $n = lc($enc);
        $n =~ tr[-_][]d;
        next unless $n eq $norm;
        $suggestion = "  (Maybe \"$e\" should be \"$enc\"?)";
        last;
      }
      my $encmodver = Pod::Simple::Transcode::->encmodver;
      $enc_error = join '' =>
        "This document probably does not appear as it should, because its ",
        "\"=encoding $e\" line calls for an unsupported encoding.",
        $suggestion, "  [$encmodver\'s supported encodings are: @supported]"
      ;
  
      $self->scream( $self->{'line_count'}, $enc_error );
    }
    push @{ $self->{'encoding_command_statuses'} }, $enc_error;
    if (defined($self->{'_processed_encoding'})) {
      # Double declaration.
      $self->scream( $self->{'line_count'}, 'Cannot have multiple =encoding directives');
    }
    $self->{'_processed_encoding'} = $orig;
  
    return $line;
  }
  
  # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  
  sub _handle_encoding_second_level {
    # By time this is called, the encoding (if well formed) will already
    #  have been acted one.
    my($self, $para) = @_;
    my @x = @$para;
    my $content = join ' ', splice @x, 2;
    $content =~ s/^\s+//s;
    $content =~ s/\s+$//s;
  
    DEBUG > 2 and print STDERR "Ogling encoding directive: =encoding $content\n";
    
    if (defined($self->{'_processed_encoding'})) {
      #if($content ne $self->{'_processed_encoding'}) {
      #  Could it happen?
      #}
      delete $self->{'_processed_encoding'};
      # It's already been handled.  Check for errors.
      if(! $self->{'encoding_command_statuses'} ) {
        DEBUG > 2 and print STDERR " CRAZY ERROR: It wasn't really handled?!\n";
      } elsif( $self->{'encoding_command_statuses'}[-1] ) {
        $self->whine( $para->[1]{'start_line'},
          sprintf "Couldn't do %s: %s",
            $self->{'encoding_command_reqs'  }[-1],
            $self->{'encoding_command_statuses'}[-1],
        );
      } else {
        DEBUG > 2 and print STDERR " (Yup, it was successfully handled already.)\n";
      }
      
    } else {
      # Otherwise it's a syntax error
      $self->whine( $para->[1]{'start_line'},
        "Invalid =encoding syntax: $content"
      );
    }
    
    return;
  }
  
  #~`~`~`~`~`~`~`~`~`~`~`~`~`~`~`~`~`~`~`~`~`~`~`~`~`~`~`~`~`~`~`~`~`~`~`~`~`
  
  {
  my $m = -321;   # magic line number
  
  sub _gen_errata {
    my $self = $_[0];
    # Return 0 or more fake-o paragraphs explaining the accumulated
    #  errors on this document.
  
    return() unless $self->{'errata'} and keys %{$self->{'errata'}};
  
    my @out;
    
    foreach my $line (sort {$a <=> $b} keys %{$self->{'errata'}}) {
      push @out,
        ['=item', {'start_line' => $m}, "Around line $line:"],
        map( ['~Para', {'start_line' => $m, '~cooked' => 1},
          #['~Top', {'start_line' => $m},
          $_
          #]
          ],
          @{$self->{'errata'}{$line}}
        )
      ;
    }
    
    # TODO: report of unknown entities? unrenderable characters?
  
    unshift @out,
      ['=head1', {'start_line' => $m, 'errata' => 1}, 'POD ERRORS'],
      ['~Para', {'start_line' => $m, '~cooked' => 1, 'errata' => 1},
       "Hey! ",
       ['B', {},
        'The above document had some coding errors, which are explained below:'
       ]
      ],
      ['=over',  {'start_line' => $m, 'errata' => 1}, ''],
    ;
  
    push @out, 
      ['=back',  {'start_line' => $m, 'errata' => 1}, ''],
    ;
  
    DEBUG and print STDERR "\n<<\n", pretty(\@out), "\n>>\n\n";
  
    return @out;
  }
  
  }
  
  #@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
  
  ##############################################################################
  ##
  ##  stop reading now stop reading now stop reading now stop reading now stop
  ##
  ##                         HERE IT BECOMES REALLY SCARY
  ##
  ##  stop reading now stop reading now stop reading now stop reading now stop
  ##
  ##############################################################################
  
  sub _ponder_paragraph_buffer {
  
    # Para-token types as found in the buffer.
    #   ~Verbatim, ~Para, ~end, =head1..4, =for, =begin, =end,
    #   =over, =back, =item
    #   and the null =pod (to be complained about if over one line)
    #
    # "~data" paragraphs are something we generate at this level, depending on
    # a currently open =over region
  
    # Events fired:  Begin and end for:
    #                   directivename (like head1 .. head4), item, extend,
    #                   for (from =begin...=end, =for),
    #                   over-bullet, over-number, over-text, over-block,
    #                   item-bullet, item-number, item-text,
    #                   Document,
    #                   Data, Para, Verbatim
    #                   B, C, longdirname (TODO -- wha?), etc. for all directives
    # 
  
    my $self = $_[0];
    my $paras;
    return unless @{$paras = $self->{'paras'}};
    my $curr_open = ($self->{'curr_open'} ||= []);
  
    my $scratch;
  
    DEBUG > 10 and print STDERR "# Paragraph buffer: <<", pretty($paras), ">>\n";
  
    # We have something in our buffer.  So apparently the document has started.
    unless($self->{'doc_has_started'}) {
      $self->{'doc_has_started'} = 1;
      
      my $starting_contentless;
      $starting_contentless =
       (
         !@$curr_open  
         and @$paras and ! grep $_->[0] ne '~end', @$paras
          # i.e., if the paras is all ~ends
       )
      ;
      DEBUG and print STDERR "# Starting ",
        $starting_contentless ? 'contentless' : 'contentful',
        " document\n"
      ;
      
      $self->_handle_element_start(
        ($scratch = 'Document'),
        {
          'start_line' => $paras->[0][1]{'start_line'},
          $starting_contentless ? ( 'contentless' => 1 ) : (),
        },
      );
    }
  
    my($para, $para_type);
    while(@$paras) {
      last if @$paras == 1 and
        ( $paras->[0][0] eq '=over' or $paras->[0][0] eq '~Verbatim'
          or $paras->[0][0] eq '=item' )
      ;
      # Those're the three kinds of paragraphs that require lookahead.
      #   Actually, an "=item Foo" inside an <over type=text> region
      #   and any =item inside an <over type=block> region (rare)
      #   don't require any lookahead, but all others (bullets
      #   and numbers) do.
  
  # TODO: whinge about many kinds of directives in non-resolving =for regions?
  # TODO: many?  like what?  =head1 etc?
  
      $para = shift @$paras;
      $para_type = $para->[0];
  
      DEBUG > 1 and print STDERR "Pondering a $para_type paragraph, given the stack: (",
        $self->_dump_curr_open(), ")\n";
      
      if($para_type eq '=for') {
        next if $self->_ponder_for($para,$curr_open,$paras);
  
      } elsif($para_type eq '=begin') {
        next if $self->_ponder_begin($para,$curr_open,$paras);
  
      } elsif($para_type eq '=end') {
        next if $self->_ponder_end($para,$curr_open,$paras);
  
      } elsif($para_type eq '~end') { # The virtual end-document signal
        next if $self->_ponder_doc_end($para,$curr_open,$paras);
      }
  
  
      # ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~
      #~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~
      if(grep $_->[1]{'~ignore'}, @$curr_open) {
        DEBUG > 1 and
         print STDERR "Skipping $para_type paragraph because in ignore mode.\n";
        next;
      }
      #~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~
      # ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~
  
      if($para_type eq '=pod') {
        $self->_ponder_pod($para,$curr_open,$paras);
  
      } elsif($para_type eq '=over') {
        next if $self->_ponder_over($para,$curr_open,$paras);
  
      } elsif($para_type eq '=back') {
        next if $self->_ponder_back($para,$curr_open,$paras);
  
      } else {
  
        # All non-magical codes!!!
        
        # Here we start using $para_type for our own twisted purposes, to
        #  mean how it should get treated, not as what the element name
        #  should be.
  
        DEBUG > 1 and print STDERR "Pondering non-magical $para_type\n";
  
        my $i;
  
        # Enforce some =headN discipline
        if($para_type =~ m/^=head\d$/s
           and ! $self->{'accept_heads_anywhere'}
           and @$curr_open
           and $curr_open->[-1][0] eq '=over'
        ) {
          DEBUG > 2 and print STDERR "'=$para_type' inside an '=over'!\n";
          $self->whine(
            $para->[1]{'start_line'},
            "You forgot a '=back' before '$para_type'"
          );
          unshift @$paras, ['=back', {}, ''], $para;   # close the =over
          next;
        }
  
  
        if($para_type eq '=item') {
  
          my $over;
          unless(@$curr_open and
                 $over = (grep { $_->[0] eq '=over' } @$curr_open)[-1]) {
            $self->whine(
              $para->[1]{'start_line'},
              "'=item' outside of any '=over'"
            );
            unshift @$paras,
              ['=over', {'start_line' => $para->[1]{'start_line'}}, ''],
              $para
            ;
            next;
          }
          
          
          my $over_type = $over->[1]{'~type'};
          
          if(!$over_type) {
            # Shouldn't happen1
            die "Typeless over in stack, starting at line "
             . $over->[1]{'start_line'};
  
          } elsif($over_type eq 'block') {
            unless($curr_open->[-1][1]{'~bitched_about'}) {
              $curr_open->[-1][1]{'~bitched_about'} = 1;
              $self->whine(
                $curr_open->[-1][1]{'start_line'},
                "You can't have =items (as at line "
                . $para->[1]{'start_line'}
                . ") unless the first thing after the =over is an =item"
              );
            }
            # Just turn it into a paragraph and reconsider it
            $para->[0] = '~Para';
            unshift @$paras, $para;
            next;
  
          } elsif($over_type eq 'text') {
            my $item_type = $self->_get_item_type($para);
              # That kills the content of the item if it's a number or bullet.
            DEBUG and print STDERR " Item is of type ", $para->[0], " under $over_type\n";
            
            if($item_type eq 'text') {
              # Nothing special needs doing for 'text'
            } elsif($item_type eq 'number' or $item_type eq 'bullet') {
              $self->whine(
                $para->[1]{'start_line'},
                "Expected text after =item, not a $item_type"
              );
              # Undo our clobbering:
              push @$para, $para->[1]{'~orig_content'};
              delete $para->[1]{'number'};
               # Only a PROPER item-number element is allowed
               #  to have a number attribute.
            } else {
              die "Unhandled item type $item_type"; # should never happen
            }
            
            # =item-text thingies don't need any assimilation, it seems.
  
          } elsif($over_type eq 'number') {
            my $item_type = $self->_get_item_type($para);
              # That kills the content of the item if it's a number or bullet.
            DEBUG and print STDERR " Item is of type ", $para->[0], " under $over_type\n";
            
            my $expected_value = ++ $curr_open->[-1][1]{'~counter'};
            
            if($item_type eq 'bullet') {
              # Hm, it's not numeric.  Correct for this.
              $para->[1]{'number'} = $expected_value;
              $self->whine(
                $para->[1]{'start_line'},
                "Expected '=item $expected_value'"
              );
              push @$para, $para->[1]{'~orig_content'};
                # restore the bullet, blocking the assimilation of next para
  
            } elsif($item_type eq 'text') {
              # Hm, it's not numeric.  Correct for this.
              $para->[1]{'number'} = $expected_value;
              $self->whine(
                $para->[1]{'start_line'},
                "Expected '=item $expected_value'"
              );
              # Text content will still be there and will block next ~Para
  
            } elsif($item_type ne 'number') {
              die "Unknown item type $item_type"; # should never happen
  
            } elsif($expected_value == $para->[1]{'number'}) {
              DEBUG > 1 and print STDERR " Numeric item has the expected value of $expected_value\n";
              
            } else {
              DEBUG > 1 and print STDERR " Numeric item has ", $para->[1]{'number'},
               " instead of the expected value of $expected_value\n";
              $self->whine(
                $para->[1]{'start_line'},
                "You have '=item " . $para->[1]{'number'} .
                "' instead of the expected '=item $expected_value'"
              );
              $para->[1]{'number'} = $expected_value;  # correcting!!
            }
              
            if(@$para == 2) {
              # For the cases where we /didn't/ push to @$para
              if($paras->[0][0] eq '~Para') {
                DEBUG and print STDERR "Assimilating following ~Para content into $over_type item\n";
                push @$para, splice @{shift @$paras},2;
              } else {
                DEBUG and print STDERR "Can't assimilate following ", $paras->[0][0], "\n";
                push @$para, '';  # Just so it's not contentless
              }
            }
  
  
          } elsif($over_type eq 'bullet') {
            my $item_type = $self->_get_item_type($para);
              # That kills the content of the item if it's a number or bullet.
            DEBUG and print STDERR " Item is of type ", $para->[0], " under $over_type\n";
            
            if($item_type eq 'bullet') {
              # as expected!
  
              if( $para->[1]{'~_freaky_para_hack'} ) {
                DEBUG and print STDERR "Accomodating '=item * Foo' tolerance hack.\n";
                push @$para, delete $para->[1]{'~_freaky_para_hack'};
              }
  
            } elsif($item_type eq 'number') {
              $self->whine(
                $para->[1]{'start_line'},
                "Expected '=item *'"
              );
              push @$para, $para->[1]{'~orig_content'};
               # and block assimilation of the next paragraph
              delete $para->[1]{'number'};
               # Only a PROPER item-number element is allowed
               #  to have a number attribute.
            } elsif($item_type eq 'text') {
              $self->whine(
                $para->[1]{'start_line'},
                "Expected '=item *'"
              );
               # But doesn't need processing.  But it'll block assimilation
               #  of the next para.
            } else {
              die "Unhandled item type $item_type"; # should never happen
            }
  
            if(@$para == 2) {
              # For the cases where we /didn't/ push to @$para
              if($paras->[0][0] eq '~Para') {
                DEBUG and print STDERR "Assimilating following ~Para content into $over_type item\n";
                push @$para, splice @{shift @$paras},2;
              } else {
                DEBUG and print STDERR "Can't assimilate following ", $paras->[0][0], "\n";
                push @$para, '';  # Just so it's not contentless
              }
            }
  
          } else {
            die "Unhandled =over type \"$over_type\"?";
            # Shouldn't happen!
          }
  
          $para_type = 'Plain';
          $para->[0] .= '-' . $over_type;
          # Whew.  Now fall thru and process it.
  
  
        } elsif($para_type eq '=extend') {
          # Well, might as well implement it here.
          $self->_ponder_extend($para);
          next;  # and skip
        } elsif($para_type eq '=encoding') {
          # Not actually acted on here, but we catch errors here.
          $self->_handle_encoding_second_level($para);
          next unless $self->keep_encoding_directive;
          $para_type = 'Plain';
        } elsif($para_type eq '~Verbatim') {
          $para->[0] = 'Verbatim';
          $para_type = '?Verbatim';
        } elsif($para_type eq '~Para') {
          $para->[0] = 'Para';
          $para_type = '?Plain';
        } elsif($para_type eq 'Data') {
          $para->[0] = 'Data';
          $para_type = '?Data';
        } elsif( $para_type =~ s/^=//s
          and defined( $para_type = $self->{'accept_directives'}{$para_type} )
        ) {
          DEBUG > 1 and print STDERR " Pondering known directive ${$para}[0] as $para_type\n";
        } else {
          # An unknown directive!
          DEBUG > 1 and printf STDERR "Unhandled directive %s (Handled: %s)\n",
           $para->[0], join(' ', sort keys %{$self->{'accept_directives'}} )
          ;
          $self->whine(
            $para->[1]{'start_line'},
            "Unknown directive: $para->[0]"
          );
  
          # And maybe treat it as text instead of just letting it go?
          next;
        }
  
        if($para_type =~ s/^\?//s) {
          if(! @$curr_open) {  # usual case
            DEBUG and print STDERR "Treating $para_type paragraph as such because stack is empty.\n";
          } else {
            my @fors = grep $_->[0] eq '=for', @$curr_open;
            DEBUG > 1 and print STDERR "Containing fors: ",
              join(',', map $_->[1]{'target'}, @fors), "\n";
            
            if(! @fors) {
              DEBUG and print STDERR "Treating $para_type paragraph as such because stack has no =for's\n";
              
            #} elsif(grep $_->[1]{'~resolve'}, @fors) {
            #} elsif(not grep !$_->[1]{'~resolve'}, @fors) {
            } elsif( $fors[-1][1]{'~resolve'} ) {
              # Look to the immediately containing for
            
              if($para_type eq 'Data') {
                DEBUG and print STDERR "Treating Data paragraph as Plain/Verbatim because the containing =for ($fors[-1][1]{'target'}) is a resolver\n";
                $para->[0] = 'Para';
                $para_type = 'Plain';
              } else {
                DEBUG and print STDERR "Treating $para_type paragraph as such because the containing =for ($fors[-1][1]{'target'}) is a resolver\n";
              }
            } else {
              DEBUG and print STDERR "Treating $para_type paragraph as Data because the containing =for ($fors[-1][1]{'target'}) is a non-resolver\n";
              $para->[0] = $para_type = 'Data';
            }
          }
        }
  
        #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        if($para_type eq 'Plain') {
          $self->_ponder_Plain($para);
        } elsif($para_type eq 'Verbatim') {
          $self->_ponder_Verbatim($para);        
        } elsif($para_type eq 'Data') {
          $self->_ponder_Data($para);
        } else {
          die "\$para type is $para_type -- how did that happen?";
          # Shouldn't happen.
        }
  
        #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        $para->[0] =~ s/^[~=]//s;
  
        DEBUG and print STDERR "\n", pretty($para), "\n";
  
        # traverse the treelet (which might well be just one string scalar)
        $self->{'content_seen'} ||= 1;
        $self->_traverse_treelet_bit(@$para);
      }
    }
    
    return;
  }
  
  ###########################################################################
  # The sub-ponderers...
  
  
  
  sub _ponder_for {
    my ($self,$para,$curr_open,$paras) = @_;
  
    # Fake it out as a begin/end
    my $target;
  
    if(grep $_->[1]{'~ignore'}, @$curr_open) {
      DEBUG > 1 and print STDERR "Ignoring ignorable =for\n";
      return 1;
    }
  
    for(my $i = 2; $i < @$para; ++$i) {
      if($para->[$i] =~ s/^\s*(\S+)\s*//s) {
        $target = $1;
        last;
      }
    }
    unless(defined $target) {
      $self->whine(
        $para->[1]{'start_line'},
        "=for without a target?"
      );
      return 1;
    }
    DEBUG > 1 and
     print STDERR "Faking out a =for $target as a =begin $target / =end $target\n";
    
    $para->[0] = 'Data';
    
    unshift @$paras,
      ['=begin',
        {'start_line' => $para->[1]{'start_line'}, '~really' => '=for'},
        $target,
      ],
      $para,
      ['=end',
        {'start_line' => $para->[1]{'start_line'}, '~really' => '=for'},
        $target,
      ],
    ;
    
    return 1;
  }
  
  sub _ponder_begin {
    my ($self,$para,$curr_open,$paras) = @_;
    my $content = join ' ', splice @$para, 2;
    $content =~ s/^\s+//s;
    $content =~ s/\s+$//s;
    unless(length($content)) {
      $self->whine(
        $para->[1]{'start_line'},
        "=begin without a target?"
      );
      DEBUG and print STDERR "Ignoring targetless =begin\n";
      return 1;
    }
    
    my ($target, $title) = $content =~ m/^(\S+)\s*(.*)$/;
    $para->[1]{'title'} = $title if ($title);
    $para->[1]{'target'} = $target;  # without any ':'
    $content = $target; # strip off the title
    
    $content =~ s/^:!/!:/s;
    my $neg;  # whether this is a negation-match
    $neg = 1        if $content =~ s/^!//s;
    my $to_resolve;  # whether to process formatting codes
    $to_resolve = 1 if $content =~ s/^://s;
    
    my $dont_ignore; # whether this target matches us
    
    foreach my $target_name (
      split(',', $content, -1),
      $neg ? () : '*'
    ) {
      DEBUG > 2 and
       print STDERR " Considering whether =begin $content matches $target_name\n";
      next unless $self->{'accept_targets'}{$target_name};
      
      DEBUG > 2 and
       print STDERR "  It DOES match the acceptable target $target_name!\n";
      $to_resolve = 1
        if $self->{'accept_targets'}{$target_name} eq 'force_resolve';
      $dont_ignore = 1;
      $para->[1]{'target_matching'} = $target_name;
      last; # stop looking at other target names
    }
  
    if($neg) {
      if( $dont_ignore ) {
        $dont_ignore = '';
        delete $para->[1]{'target_matching'};
        DEBUG > 2 and print STDERR " But the leading ! means that this is a NON-match!\n";
      } else {
        $dont_ignore = 1;
        $para->[1]{'target_matching'} = '!';
        DEBUG > 2 and print STDERR " But the leading ! means that this IS a match!\n";
      }
    }
  
    $para->[0] = '=for';  # Just what we happen to call these, internally
    $para->[1]{'~really'} ||= '=begin';
    $para->[1]{'~ignore'}   = (! $dont_ignore) || 0;
    $para->[1]{'~resolve'}  = $to_resolve || 0;
  
    DEBUG > 1 and print STDERR " Making note to ", $dont_ignore ? 'not ' : '',
      "ignore contents of this region\n";
    DEBUG > 1 and $dont_ignore and print STDERR " Making note to treat contents as ",
      ($to_resolve ? 'verbatim/plain' : 'data'), " paragraphs\n";
    DEBUG > 1 and print STDERR " (Stack now: ", $self->_dump_curr_open(), ")\n";
  
    push @$curr_open, $para;
    if(!$dont_ignore or scalar grep $_->[1]{'~ignore'}, @$curr_open) {
      DEBUG > 1 and print STDERR "Ignoring ignorable =begin\n";
    } else {
      $self->{'content_seen'} ||= 1;
      $self->_handle_element_start((my $scratch='for'), $para->[1]);
    }
  
    return 1;
  }
  
  sub _ponder_end {
    my ($self,$para,$curr_open,$paras) = @_;
    my $content = join ' ', splice @$para, 2;
    $content =~ s/^\s+//s;
    $content =~ s/\s+$//s;
    DEBUG and print STDERR "Ogling '=end $content' directive\n";
  
    unless(length($content)) {
      $self->whine(
        $para->[1]{'start_line'},
        "'=end' without a target?" . (
          ( @$curr_open and $curr_open->[-1][0] eq '=for' )
          ? ( " (Should be \"=end " . $curr_open->[-1][1]{'target'} . '")' )
          : ''
        )
      );
      DEBUG and print STDERR "Ignoring targetless =end\n";
      return 1;
    }
    
    unless($content =~ m/^\S+$/) {  # i.e., unless it's one word
      $self->whine(
        $para->[1]{'start_line'},
        "'=end $content' is invalid.  (Stack: "
        . $self->_dump_curr_open() . ')'
      );
      DEBUG and print STDERR "Ignoring mistargetted =end $content\n";
      return 1;
    }
    
    unless(@$curr_open and $curr_open->[-1][0] eq '=for') {
      $self->whine(
        $para->[1]{'start_line'},
        "=end $content without matching =begin.  (Stack: "
        . $self->_dump_curr_open() . ')'
      );
      DEBUG and print STDERR "Ignoring mistargetted =end $content\n";
      return 1;
    }
    
    unless($content eq $curr_open->[-1][1]{'target'}) {
      $self->whine(
        $para->[1]{'start_line'},
        "=end $content doesn't match =begin " 
        . $curr_open->[-1][1]{'target'}
        . ".  (Stack: "
        . $self->_dump_curr_open() . ')'
      );
      DEBUG and print STDERR "Ignoring mistargetted =end $content at line $para->[1]{'start_line'}\n";
      return 1;
    }
  
    # Else it's okay to close...
    if(grep $_->[1]{'~ignore'}, @$curr_open) {
      DEBUG > 1 and print STDERR "Not firing any event for this =end $content because in an ignored region\n";
      # And that may be because of this to-be-closed =for region, or some
      #  other one, but it doesn't matter.
    } else {
      $curr_open->[-1][1]{'start_line'} = $para->[1]{'start_line'};
        # what's that for?
      
      $self->{'content_seen'} ||= 1;
      $self->_handle_element_end( my $scratch = 'for', $para->[1]);
    }
    DEBUG > 1 and print STDERR "Popping $curr_open->[-1][0] $curr_open->[-1][1]{'target'} because of =end $content\n";
    pop @$curr_open;
  
    return 1;
  } 
  
  sub _ponder_doc_end {
    my ($self,$para,$curr_open,$paras) = @_;
    if(@$curr_open) { # Deal with things left open
      DEBUG and print STDERR "Stack is nonempty at end-document: (",
        $self->_dump_curr_open(), ")\n";
        
      DEBUG > 9 and print STDERR "Stack: ", pretty($curr_open), "\n";
      unshift @$paras, $self->_closers_for_all_curr_open;
      # Make sure there is exactly one ~end in the parastack, at the end:
      @$paras = grep $_->[0] ne '~end', @$paras;
      push @$paras, $para, $para;
       # We need two -- once for the next cycle where we
       #  generate errata, and then another to be at the end
       #  when that loop back around to process the errata.
      return 1;
      
    } else {
      DEBUG and print STDERR "Okay, stack is empty now.\n";
    }
    
    # Try generating errata section, if applicable
    unless($self->{'~tried_gen_errata'}) {
      $self->{'~tried_gen_errata'} = 1;
      my @extras = $self->_gen_errata();
      if(@extras) {
        unshift @$paras, @extras;
        DEBUG and print STDERR "Generated errata... relooping...\n";
        return 1;  # I.e., loop around again to process these fake-o paragraphs
      }
    }
    
    splice @$paras; # Well, that's that for this paragraph buffer.
    DEBUG and print STDERR "Throwing end-document event.\n";
  
    $self->_handle_element_end( my $scratch = 'Document' );
    return 1; # Hasta la byebye
  }
  
  sub _ponder_pod {
    my ($self,$para,$curr_open,$paras) = @_;
    $self->whine(
      $para->[1]{'start_line'},
      "=pod directives shouldn't be over one line long!  Ignoring all "
       . (@$para - 2) . " lines of content"
    ) if @$para > 3;
  
    # Content ignored unless 'pod_handler' is set
    if (my $pod_handler = $self->{'pod_handler'}) {
        my ($line_num, $line) = map $_, $para->[1]{'start_line'}, $para->[2];
        $line = $line eq '' ? "=pod" : "=pod $line"; # imitate cut_handler output
        $pod_handler->($line, $line_num, $self);
    }
  
    # The surrounding methods set content_seen, so let us remain consistent.
    # I do not know why it was not here before -- should it not be here?
    # $self->{'content_seen'} ||= 1;
  
    return;
  }
  
  sub _ponder_over {
    my ($self,$para,$curr_open,$paras) = @_;
    return 1 unless @$paras;
    my $list_type;
  
    if($paras->[0][0] eq '=item') { # most common case
      $list_type = $self->_get_initial_item_type($paras->[0]);
  
    } elsif($paras->[0][0] eq '=back') {
      # Ignore empty lists by default
      if ($self->{'parse_empty_lists'}) {
        $list_type = 'empty';
      } else {
        shift @$paras;
        return 1;
      }
    } elsif($paras->[0][0] eq '~end') {
      $self->whine(
        $para->[1]{'start_line'},
        "=over is the last thing in the document?!"
      );
      return 1; # But feh, ignore it.
    } else {
      $list_type = 'block';
    }
    $para->[1]{'~type'} = $list_type;
    push @$curr_open, $para;
     # yes, we reuse the paragraph as a stack item
    
    my $content = join ' ', splice @$para, 2;
    my $overness;
    if($content =~ m/^\s*$/s) {
      $para->[1]{'indent'} = 4;
    } elsif($content =~ m/^\s*((?:\d*\.)?\d+)\s*$/s) {
      no integer;
      $para->[1]{'indent'} = $1;
      if($1 == 0) {
        $self->whine(
          $para->[1]{'start_line'},
          "Can't have a 0 in =over $content"
        );
        $para->[1]{'indent'} = 4;
      }
    } else {
      $self->whine(
        $para->[1]{'start_line'},
        "=over should be: '=over' or '=over positive_number'"
      );
      $para->[1]{'indent'} = 4;
    }
    DEBUG > 1 and print STDERR "=over found of type $list_type\n";
    
    $self->{'content_seen'} ||= 1;
    $self->_handle_element_start((my $scratch = 'over-' . $list_type), $para->[1]);
  
    return;
  }
        
  sub _ponder_back {
    my ($self,$para,$curr_open,$paras) = @_;
    # TODO: fire off </item-number> or </item-bullet> or </item-text> ??
  
    my $content = join ' ', splice @$para, 2;
    if($content =~ m/\S/) {
      $self->whine(
        $para->[1]{'start_line'},
        "=back doesn't take any parameters, but you said =back $content"
      );
    }
  
    if(@$curr_open and $curr_open->[-1][0] eq '=over') {
      DEBUG > 1 and print STDERR "=back happily closes matching =over\n";
      # Expected case: we're closing the most recently opened thing
      #my $over = pop @$curr_open;
      $self->{'content_seen'} ||= 1;
      $self->_handle_element_end( my $scratch =
        'over-' . ( (pop @$curr_open)->[1]{'~type'} ), $para->[1]
      );
    } else {
      DEBUG > 1 and print STDERR "=back found without a matching =over.  Stack: (",
          join(', ', map $_->[0], @$curr_open), ").\n";
      $self->whine(
        $para->[1]{'start_line'},
        '=back without =over'
      );
      return 1; # and ignore it
    }
  }
  
  sub _ponder_item {
    my ($self,$para,$curr_open,$paras) = @_;
    my $over;
    unless(@$curr_open and
           $over = (grep { $_->[0] eq '=over' } @$curr_open)[-1]) {
      $self->whine(
        $para->[1]{'start_line'},
        "'=item' outside of any '=over'"
      );
      unshift @$paras,
        ['=over', {'start_line' => $para->[1]{'start_line'}}, ''],
        $para
      ;
      return 1;
    }
    
    
    my $over_type = $over->[1]{'~type'};
    
    if(!$over_type) {
      # Shouldn't happen1
      die "Typeless over in stack, starting at line "
       . $over->[1]{'start_line'};
  
    } elsif($over_type eq 'block') {
      unless($curr_open->[-1][1]{'~bitched_about'}) {
        $curr_open->[-1][1]{'~bitched_about'} = 1;
        $self->whine(
          $curr_open->[-1][1]{'start_line'},
          "You can't have =items (as at line "
          . $para->[1]{'start_line'}
          . ") unless the first thing after the =over is an =item"
        );
      }
      # Just turn it into a paragraph and reconsider it
      $para->[0] = '~Para';
      unshift @$paras, $para;
      return 1;
  
    } elsif($over_type eq 'text') {
      my $item_type = $self->_get_item_type($para);
        # That kills the content of the item if it's a number or bullet.
      DEBUG and print STDERR " Item is of type ", $para->[0], " under $over_type\n";
      
      if($item_type eq 'text') {
        # Nothing special needs doing for 'text'
      } elsif($item_type eq 'number' or $item_type eq 'bullet') {
        $self->whine(
            $para->[1]{'start_line'},
            "Expected text after =item, not a $item_type"
        );
        # Undo our clobbering:
        push @$para, $para->[1]{'~orig_content'};
        delete $para->[1]{'number'};
         # Only a PROPER item-number element is allowed
         #  to have a number attribute.
      } else {
        die "Unhandled item type $item_type"; # should never happen
      }
      
      # =item-text thingies don't need any assimilation, it seems.
  
    } elsif($over_type eq 'number') {
      my $item_type = $self->_get_item_type($para);
        # That kills the content of the item if it's a number or bullet.
      DEBUG and print STDERR " Item is of type ", $para->[0], " under $over_type\n";
      
      my $expected_value = ++ $curr_open->[-1][1]{'~counter'};
      
      if($item_type eq 'bullet') {
        # Hm, it's not numeric.  Correct for this.
        $para->[1]{'number'} = $expected_value;
        $self->whine(
          $para->[1]{'start_line'},
          "Expected '=item $expected_value'"
        );
        push @$para, $para->[1]{'~orig_content'};
          # restore the bullet, blocking the assimilation of next para
  
      } elsif($item_type eq 'text') {
        # Hm, it's not numeric.  Correct for this.
        $para->[1]{'number'} = $expected_value;
        $self->whine(
          $para->[1]{'start_line'},
          "Expected '=item $expected_value'"
        );
        # Text content will still be there and will block next ~Para
  
      } elsif($item_type ne 'number') {
        die "Unknown item type $item_type"; # should never happen
  
      } elsif($expected_value == $para->[1]{'number'}) {
        DEBUG > 1 and print STDERR " Numeric item has the expected value of $expected_value\n";
        
      } else {
        DEBUG > 1 and print STDERR " Numeric item has ", $para->[1]{'number'},
         " instead of the expected value of $expected_value\n";
        $self->whine(
          $para->[1]{'start_line'},
          "You have '=item " . $para->[1]{'number'} .
          "' instead of the expected '=item $expected_value'"
        );
        $para->[1]{'number'} = $expected_value;  # correcting!!
      }
        
      if(@$para == 2) {
        # For the cases where we /didn't/ push to @$para
        if($paras->[0][0] eq '~Para') {
          DEBUG and print STDERR "Assimilating following ~Para content into $over_type item\n";
          push @$para, splice @{shift @$paras},2;
        } else {
          DEBUG and print STDERR "Can't assimilate following ", $paras->[0][0], "\n";
          push @$para, '';  # Just so it's not contentless
        }
      }
  
  
    } elsif($over_type eq 'bullet') {
      my $item_type = $self->_get_item_type($para);
        # That kills the content of the item if it's a number or bullet.
      DEBUG and print STDERR " Item is of type ", $para->[0], " under $over_type\n";
      
      if($item_type eq 'bullet') {
        # as expected!
  
        if( $para->[1]{'~_freaky_para_hack'} ) {
          DEBUG and print STDERR "Accomodating '=item * Foo' tolerance hack.\n";
          push @$para, delete $para->[1]{'~_freaky_para_hack'};
        }
  
      } elsif($item_type eq 'number') {
        $self->whine(
          $para->[1]{'start_line'},
          "Expected '=item *'"
        );
        push @$para, $para->[1]{'~orig_content'};
         # and block assimilation of the next paragraph
        delete $para->[1]{'number'};
         # Only a PROPER item-number element is allowed
         #  to have a number attribute.
      } elsif($item_type eq 'text') {
        $self->whine(
          $para->[1]{'start_line'},
          "Expected '=item *'"
        );
         # But doesn't need processing.  But it'll block assimilation
         #  of the next para.
      } else {
        die "Unhandled item type $item_type"; # should never happen
      }
  
      if(@$para == 2) {
        # For the cases where we /didn't/ push to @$para
        if($paras->[0][0] eq '~Para') {
          DEBUG and print STDERR "Assimilating following ~Para content into $over_type item\n";
          push @$para, splice @{shift @$paras},2;
        } else {
          DEBUG and print STDERR "Can't assimilate following ", $paras->[0][0], "\n";
          push @$para, '';  # Just so it's not contentless
        }
      }
  
    } else {
      die "Unhandled =over type \"$over_type\"?";
      # Shouldn't happen!
    }
    $para->[0] .= '-' . $over_type;
  
    return;
  }
  
  sub _ponder_Plain {
    my ($self,$para) = @_;
    DEBUG and print STDERR " giving plain treatment...\n";
    unless( @$para == 2 or ( @$para == 3 and $para->[2] eq '' )
      or $para->[1]{'~cooked'}
    ) {
      push @$para,
      @{$self->_make_treelet(
        join("\n", splice(@$para, 2)),
        $para->[1]{'start_line'}
      )};
    }
    # Empty paragraphs don't need a treelet for any reason I can see.
    # And precooked paragraphs already have a treelet.
    return;
  }
  
  sub _ponder_Verbatim {
    my ($self,$para) = @_;
    DEBUG and print STDERR " giving verbatim treatment...\n";
  
    $para->[1]{'xml:space'} = 'preserve';
  
    my $indent = $self->strip_verbatim_indent;
    if ($indent && ref $indent eq 'CODE') {
        my @shifted = (shift @{$para}, shift @{$para});
        $indent = $indent->($para);
        unshift @{$para}, @shifted;
    }
  
    for(my $i = 2; $i < @$para; $i++) {
      foreach my $line ($para->[$i]) { # just for aliasing
        # Strip indentation.
        $line =~ s/^\Q$indent// if $indent
            && !($self->{accept_codes} && $self->{accept_codes}{VerbatimFormatted});
        while( $line =~
          # Sort of adapted from Text::Tabs -- yes, it's hardwired in that
          # tabs are at every EIGHTH column.  For portability, it has to be
          # one setting everywhere, and 8th wins.
          s/^([^\t]*)(\t+)/$1.(" " x ((length($2)<<3)-(length($1)&7)))/e
        ) {}
  
        # TODO: whinge about (or otherwise treat) unindented or overlong lines
  
      }
    }
    
    # Now the VerbatimFormatted hoodoo...
    if( $self->{'accept_codes'} and
        $self->{'accept_codes'}{'VerbatimFormatted'}
    ) {
      while(@$para > 3 and $para->[-1] !~ m/\S/) { pop @$para }
       # Kill any number of terminal newlines
      $self->_verbatim_format($para);
    } elsif ($self->{'codes_in_verbatim'}) {
      push @$para,
      @{$self->_make_treelet(
        join("\n", splice(@$para, 2)),
        $para->[1]{'start_line'}, $para->[1]{'xml:space'}
      )};
      $para->[-1] =~ s/\n+$//s; # Kill any number of terminal newlines
    } else {
      push @$para, join "\n", splice(@$para, 2) if @$para > 3;
      $para->[-1] =~ s/\n+$//s; # Kill any number of terminal newlines
    }
    return;
  }
  
  sub _ponder_Data {
    my ($self,$para) = @_;
    DEBUG and print STDERR " giving data treatment...\n";
    $para->[1]{'xml:space'} = 'preserve';
    push @$para, join "\n", splice(@$para, 2) if @$para > 3;
    return;
  }
  
  
  
  
  ###########################################################################
  
  sub _traverse_treelet_bit {  # for use only by the routine above
    my($self, $name) = splice @_,0,2;
  
    my $scratch;
    $self->_handle_element_start(($scratch=$name), shift @_);
    
    while (@_) {
      my $x = shift;
      if (ref($x)) {
        &_traverse_treelet_bit($self, @$x);
      } else {
        $x .= shift while @_ && !ref($_[0]);
        $self->_handle_text($x);
      }
    }
    
    $self->_handle_element_end($scratch=$name);
    return;
  }
  
  #@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
  
  sub _closers_for_all_curr_open {
    my $self = $_[0];
    my @closers;
    foreach my $still_open (@{  $self->{'curr_open'} || return  }) {
      my @copy = @$still_open;
      $copy[1] = {%{ $copy[1] }};
      #$copy[1]{'start_line'} = -1;
      if($copy[0] eq '=for') {
        $copy[0] = '=end';
      } elsif($copy[0] eq '=over') {
        $self->whine(
          $still_open->[1]{start_line} ,
          "=over without closing =back"
        );
  
        $copy[0] = '=back';
      } else {
        die "I don't know how to auto-close an open $copy[0] region";
      }
  
      unless( @copy > 2 ) {
        push @copy, $copy[1]{'target'};
        $copy[-1] = '' unless defined $copy[-1];
         # since =over's don't have targets
      }
  
      $copy[1]{'fake-closer'} = 1;
  
      DEBUG and print STDERR "Queuing up fake-o event: ", pretty(\@copy), "\n";
      unshift @closers, \@copy;
    }
    return @closers;
  }
  
  #--------------------------------------------------------------------------
  
  sub _verbatim_format {
    my($it, $p) = @_;
    
    my $formatting;
  
    for(my $i = 2; $i < @$p; $i++) { # work backwards over the lines
      DEBUG and print STDERR "_verbatim_format appends a newline to $i: $p->[$i]\n";
      $p->[$i] .= "\n";
       # Unlike with simple Verbatim blocks, we don't end up just doing
       # a join("\n", ...) on the contents, so we have to append a
       # newline to ever line, and then nix the last one later.
    }
  
    if( DEBUG > 4 ) {
      print STDERR "<<\n";
      for(my $i = $#$p; $i >= 2; $i--) { # work backwards over the lines
        print STDERR "_verbatim_format $i: $p->[$i]";
      }
      print STDERR ">>\n";
    }
  
    for(my $i = $#$p; $i > 2; $i--) {
      # work backwards over the lines, except the first (#2)
      
      #next unless $p->[$i]   =~ m{^#:([ \^\/\%]*)\n?$}s
      #        and $p->[$i-1] !~ m{^#:[ \^\/\%]*\n?$}s;
       # look at a formatty line preceding a nonformatty one
      DEBUG > 5 and print STDERR "Scrutinizing line $i: $$p[$i]\n";
      if($p->[$i]   =~ m{^#:([ \^\/\%]*)\n?$}s) {
        DEBUG > 5 and print STDERR "  It's a formatty line.  ",
         "Peeking at previous line ", $i-1, ": $$p[$i-1]: \n";
        
        if( $p->[$i-1] =~ m{^#:[ \^\/\%]*\n?$}s ) {
          DEBUG > 5 and print STDERR "  Previous line is formatty!  Skipping this one.\n";
          next;
        } else {
          DEBUG > 5 and print STDERR "  Previous line is non-formatty!  Yay!\n";
        }
      } else {
        DEBUG > 5 and print STDERR "  It's not a formatty line.  Ignoring\n";
        next;
      }
  
      # A formatty line has to have #: in the first two columns, and uses
      # "^" to mean bold, "/" to mean underline, and "%" to mean bold italic.
      # Example:
      #   What do you want?  i like pie. [or whatever]
      # #:^^^^^^^^^^^^^^^^^              /////////////         
      
  
      DEBUG > 4 and print STDERR "_verbatim_format considers:\n<$p->[$i-1]>\n<$p->[$i]>\n";
      
      $formatting = '  ' . $1;
      $formatting =~ s/\s+$//s; # nix trailing whitespace
      unless(length $formatting and $p->[$i-1] =~ m/\S/) { # no-op
        splice @$p,$i,1; # remove this line
        $i--; # don't consider next line
        next;
      }
  
      if( length($formatting) >= length($p->[$i-1]) ) {
        $formatting = substr($formatting, 0, length($p->[$i-1]) - 1) . ' ';
      } else {
        $formatting .= ' ' x (length($p->[$i-1]) - length($formatting));
      }
      # Make $formatting and the previous line be exactly the same length,
      # with $formatting having a " " as the last character.
   
      DEBUG > 4 and print STDERR "Formatting <$formatting>    on <", $p->[$i-1], ">\n";
  
  
      my @new_line;
      while( $formatting =~ m{\G(( +)|(\^+)|(\/+)|(\%+))}g ) {
        #print STDERR "Format matches $1\n";
  
        if($2) {
          #print STDERR "SKIPPING <$2>\n";
          push @new_line,
            substr($p->[$i-1], pos($formatting)-length($1), length($1));
        } else {
          #print STDERR "SNARING $+\n";
          push @new_line, [
            (
              $3 ? 'VerbatimB'  :
              $4 ? 'VerbatimI'  :
              $5 ? 'VerbatimBI' : die("Should never get called")
            ), {},
            substr($p->[$i-1], pos($formatting)-length($1), length($1))
          ];
          #print STDERR "Formatting <$new_line[-1][-1]> as $new_line[-1][0]\n";
        }
      }
      my @nixed =    
        splice @$p, $i-1, 2, @new_line; # replace myself and the next line
      DEBUG > 10 and print STDERR "Nixed count: ", scalar(@nixed), "\n";
      
      DEBUG > 6 and print STDERR "New version of the above line is these tokens (",
        scalar(@new_line), "):",
        map( ref($_)?"<@$_> ":"<$_>", @new_line ), "\n";
      $i--; # So the next line we scrutinize is the line before the one
            #  that we just went and formatted
    }
  
    $p->[0] = 'VerbatimFormatted';
  
    # Collapse adjacent text nodes, just for kicks.
    for( my $i = 2; $i > $#$p; $i++ ) { # work forwards over the tokens except for the last
      if( !ref($p->[$i]) and !ref($p->[$i + 1]) ) {
        DEBUG > 5 and print STDERR "_verbatim_format merges {$p->[$i]} and {$p->[$i+1]}\n";
        $p->[$i] .= splice @$p, $i+1, 1; # merge
        --$i;  # and back up
      }
    }
  
    # Now look for the last text token, and remove the terminal newline
    for( my $i = $#$p; $i >= 2; $i-- ) {
      # work backwards over the tokens, even the first
      if( !ref($p->[$i]) ) {
        if($p->[$i] =~ s/\n$//s) {
          DEBUG > 5 and print STDERR "_verbatim_format killed the terminal newline on #$i: {$p->[$i]}, after {$p->[$i-1]}\n";
        } else {
          DEBUG > 5 and print STDERR
           "No terminal newline on #$i: {$p->[$i]}, after {$p->[$i-1]} !?\n";
        }
        last; # we only want the next one
      }
    }
  
    return;
  }
  
  
  #@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
  
  
  sub _treelet_from_formatting_codes {
    # Given a paragraph, returns a treelet.  Full of scary tokenizing code.
    #  Like [ '~Top', {'start_line' => $start_line},
    #            "I like ",
    #            [ 'B', {}, "pie" ],
    #            "!"
    #       ]
    
    my($self, $para, $start_line, $preserve_space) = @_;
    
    my $treelet = ['~Top', {'start_line' => $start_line},];
    
    unless ($preserve_space || $self->{'preserve_whitespace'}) {
      $para =~ s/\s+/ /g; # collapse and trim all whitespace first.
      $para =~ s/ $//;
      $para =~ s/^ //;
    }
    
    # Only apparent problem the above code is that N<<  >> turns into
    # N<< >>.  But then, word wrapping does that too!  So don't do that!
    
    my @stack;
    my @lineage = ($treelet);
    my $raw = ''; # raw content of L<> fcode before splitting/processing
      # XXX 'raw' is not 100% accurate: all surrounding whitespace is condensed
      # into just 1 ' '. Is this the regex's doing or 'raw's?
    my $inL = 0;
  
    DEBUG > 4 and print STDERR "Paragraph:\n$para\n\n";
   
    # Here begins our frightening tokenizer RE.  The following regex matches
    # text in four main parts:
    #
    #  * Start-codes.  The first alternative matches C< or C<<, the latter
    #    followed by some whitespace.  $1 will hold the entire start code
    #    (including any space following a multiple-angle-bracket delimiter),
    #    and $2 will hold only the additional brackets past the first in a
    #    multiple-bracket delimiter.  length($2) + 1 will be the number of
    #    closing brackets we have to find.
    #
    #  * Closing brackets.  Match some amount of whitespace followed by
    #    multiple close brackets.  The logic to see if this closes anything
    #    is down below.  Note that in order to parse C<<  >> correctly, we
    #    have to use look-behind (?<=\s\s), since the match of the starting
    #    code will have consumed the whitespace.
    #
    #  * A single closing bracket, to close a simple code like C<>.
    #
    #  * Something that isn't a start or end code.  We have to be careful
    #    about accepting whitespace, since perlpodspec says that any whitespace
    #    before a multiple-bracket closing delimiter should be ignored.
    #
    while($para =~
      m/\G
        (?:
          # Match starting codes, including the whitespace following a
          # multiple-delimiter start code.  $1 gets the whole start code and
          # $2 gets all but one of the <s in the multiple-bracket case.
          ([A-Z]<(?:(<+)\s+)?)
          |
          # Match multiple-bracket end codes.  $3 gets the whitespace that
          # should be discarded before an end bracket but kept in other cases
          # and $4 gets the end brackets themselves.
          (\s+|(?<=\s\s))(>{2,})
          |
          (\s?>)          # $5: simple end-codes
          |
          (               # $6: stuff containing no start-codes or end-codes
            (?:
              [^A-Z\s>]
              |
              (?:
                [A-Z](?!<)
              )
              |
              # whitespace is ok, but we don't want to eat the whitespace before
              # a multiple-bracket end code.
              # NOTE: we may still have problems with e.g. S<<    >>
              (?:
                \s(?!\s*>{2,})
              )
            )+
          )
        )
      /xgo
    ) {
      DEBUG > 4 and print STDERR "\nParagraphic tokenstack = (@stack)\n";
      if(defined $1) {
        if(defined $2) {
          DEBUG > 3 and print STDERR "Found complex start-text code \"$1\"\n";
          push @stack, length($2) + 1; 
            # length of the necessary complex end-code string
        } else {
          DEBUG > 3 and print STDERR "Found simple start-text code \"$1\"\n";
          push @stack, 0;  # signal that we're looking for simple
        }
        push @lineage, [ substr($1,0,1), {}, ];  # new node object
        push @{ $lineage[-2] }, $lineage[-1];
        if ('L' eq substr($1,0,1)) {
          $raw = $inL ? $raw.$1 : ''; # reset raw content accumulator
          $inL = 1;
        } else {
          $raw .= $1 if $inL;
        }
  
      } elsif(defined $4) {
        DEBUG > 3 and print STDERR "Found apparent complex end-text code \"$3$4\"\n";
        # This is where it gets messy...
        if(! @stack) {
          # We saw " >>>>" but needed nothing.  This is ALL just stuff then.
          DEBUG > 4 and print STDERR " But it's really just stuff.\n";
          push @{ $lineage[-1] }, $3, $4;
          next;
        } elsif(!$stack[-1]) {
          # We saw " >>>>" but needed only ">".  Back pos up.
          DEBUG > 4 and print STDERR " And that's more than we needed to close simple.\n";
          push @{ $lineage[-1] }, $3; # That was a for-real space, too.
          pos($para) = pos($para) - length($4) + 1;
        } elsif($stack[-1] == length($4)) {
          # We found " >>>>", and it was exactly what we needed.  Commonest case.
          DEBUG > 4 and print STDERR " And that's exactly what we needed to close complex.\n";
        } elsif($stack[-1] < length($4)) {
          # We saw " >>>>" but needed only " >>".  Back pos up.
          DEBUG > 4 and print STDERR " And that's more than we needed to close complex.\n";
          pos($para) = pos($para) - length($4) + $stack[-1];
        } else {
          # We saw " >>>>" but needed " >>>>>>".  So this is all just stuff!
          DEBUG > 4 and print STDERR " But it's really just stuff, because we needed more.\n";
          push @{ $lineage[-1] }, $3, $4;
          next;
        }
        #print STDERR "\nHOOBOY ", scalar(@{$lineage[-1]}), "!!!\n";
  
        push @{ $lineage[-1] }, '' if 2 == @{ $lineage[-1] };
        # Keep the element from being childless
        
        pop @stack;
        pop @lineage;
  
        unless (@stack) { # not in an L if there are no open fcodes
          $inL = 0;
          if (ref $lineage[-1][-1] && $lineage[-1][-1][0] eq 'L') {
            $lineage[-1][-1][1]{'raw'} = $raw
          }
        }
        $raw .= $3.$4 if $inL;
        
      } elsif(defined $5) {
        DEBUG > 3 and print STDERR "Found apparent simple end-text code \"$5\"\n";
  
        if(@stack and ! $stack[-1]) {
          # We're indeed expecting a simple end-code
          DEBUG > 4 and print STDERR " It's indeed an end-code.\n";
  
          if(length($5) == 2) { # There was a space there: " >"
            push @{ $lineage[-1] }, ' ';
          } elsif( 2 == @{ $lineage[-1] } ) { # Closing a childless element
            push @{ $lineage[-1] }, ''; # keep it from being really childless
          }
  
          pop @stack;
          pop @lineage;
        } else {
          DEBUG > 4 and print STDERR " It's just stuff.\n";
          push @{ $lineage[-1] }, $5;
        }
  
        unless (@stack) { # not in an L if there are no open fcodes
          $inL = 0;
          if (ref $lineage[-1][-1] && $lineage[-1][-1][0] eq 'L') {
            $lineage[-1][-1][1]{'raw'} = $raw
          }
        }
        $raw .= $5 if $inL;
  
      } elsif(defined $6) {
        DEBUG > 3 and print STDERR "Found stuff \"$6\"\n";
        push @{ $lineage[-1] }, $6;
        $raw .= $6 if $inL;
          # XXX does not capture multiplace whitespaces -- 'raw' ends up with
          #     at most 1 leading/trailing whitespace, why not all of it?
  
      } else {
        # should never ever ever ever happen
        DEBUG and print STDERR "AYYAYAAAAA at line ", __LINE__, "\n";
        die "SPORK 512512!";
      }
    }
  
    if(@stack) { # Uhoh, some sequences weren't closed.
      my $x= "...";
      while(@stack) {
        push @{ $lineage[-1] }, '' if 2 == @{ $lineage[-1] };
        # Hmmmmm!
  
        my $code         = (pop @lineage)->[0];
        my $ender_length =  pop @stack;
        if($ender_length) {
          --$ender_length;
          $x = $code . ("<" x $ender_length) . " $x " . (">" x $ender_length);
        } else {
          $x = $code . "<$x>";
        }
      }
      DEBUG > 1 and print STDERR "Unterminated $x sequence\n";
      $self->whine($start_line,
        "Unterminated $x sequence",
      );
    }
  
    return $treelet;
  }
  
  #@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
  
  sub text_content_of_treelet {  # method: $parser->text_content_of_treelet($lol)
    return stringify_lol($_[1]);
  }
  
  sub stringify_lol {  # function: stringify_lol($lol)
    my $string_form = '';
    _stringify_lol( $_[0] => \$string_form );
    return $string_form;
  }
  
  sub _stringify_lol {  # the real recursor
    my($lol, $to) = @_;
    for(my $i = 2; $i < @$lol; ++$i) {
      if( ref($lol->[$i] || '') and UNIVERSAL::isa($lol->[$i], 'ARRAY') ) {
        _stringify_lol( $lol->[$i], $to);  # recurse!
      } else {
        $$to .= $lol->[$i];
      }
    }
    return;
  }
  
  #@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
  
  sub _dump_curr_open { # return a string representation of the stack
    my $curr_open = $_[0]{'curr_open'};
  
    return '[empty]' unless @$curr_open;
    return join '; ',
      map {;
             ($_->[0] eq '=for')
               ? ( ($_->[1]{'~really'} || '=over')
                 . ' ' . $_->[1]{'target'})
               : $_->[0]
          }
      @$curr_open
    ;
  }
  
  ###########################################################################
  my %pretty_form = (
    "\a" => '\a', # ding!
    "\b" => '\b', # BS
    "\e" => '\e', # ESC
    "\f" => '\f', # FF
    "\t" => '\t', # tab
    "\cm" => '\cm',
    "\cj" => '\cj',
    "\n" => '\n', # probably overrides one of either \cm or \cj
    '"' => '\"',
    '\\' => '\\\\',
    '$' => '\\$',
    '@' => '\\@',
    '%' => '\\%',
    '#' => '\\#',
  );
  
  sub pretty { # adopted from Class::Classless
    # Not the most brilliant routine, but passable.
    # Don't give it a cyclic data structure!
    my @stuff = @_; # copy
    my $x;
    my $out =
      # join ",\n" .
      join ", ",
      map {;
      if(!defined($_)) {
        "undef";
      } elsif(ref($_) eq 'ARRAY' or ref($_) eq 'Pod::Simple::LinkSection') {
        $x = "[ " . pretty(@$_) . " ]" ;
        $x;
      } elsif(ref($_) eq 'SCALAR') {
        $x = "\\" . pretty($$_) ;
        $x;
      } elsif(ref($_) eq 'HASH') {
        my $hr = $_;
        $x = "{" . join(", ",
          map(pretty($_) . '=>' . pretty($hr->{$_}),
              sort keys %$hr ) ) . "}" ;
        $x;
      } elsif(!length($_)) { q{''} # empty string
      } elsif(
        $_ eq '0' # very common case
        or(
           m/^-?(?:[123456789]\d*|0)(?:\.\d+)?$/s
           and $_ ne '-0' # the strange case that RE lets thru
        )
      ) { $_;
      } else {
          # Yes, explicitly name every character desired. There are shorcuts one
          # could make, but I (Karl Williamson) was afraid that some Perl
          # releases would have bugs in some of them. For example [A-Z] works
          # even on EBCDIC platforms to match exactly the 26 uppercase English
          # letters, but I don't know if it has always worked without bugs. It
          # seemed safest just to list the characters.
          # s<([^\x20\x21\x23\x27-\x3F\x41-\x5B\x5D-\x7E])>
          s<([^ !#'()*+,\-./0123456789:;\<=\>?ABCDEFGHIJKLMNOPQRSTUVWXYZ\[\]^_`abcdefghijklmnopqrstuvwxyz{|}~])>
           <$pretty_form{$1} || '\\x{'.sprintf("%x", ord($1)).'}'>eg;
           #<$pretty_form{$1} || '\\x'.(unpack("H2",$1))>eg;
        qq{"$_"};
      }
    } @stuff;
    # $out =~ s/\n */ /g if length($out) < 75;
    return $out;
  }
  
  #@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
  
  # A rather unsubtle method of blowing away all the state information
  # from a parser object so it can be reused. Provided as a utility for
  # backward compatibility in Pod::Man, etc. but not recommended for
  # general use.
  
  sub reinit {
    my $self = shift;
    foreach (qw(source_dead source_filename doc_has_started
  start_of_pod_block content_seen last_was_blank paras curr_open
  line_count pod_para_count in_pod ~tried_gen_errata all_errata errata errors_seen
  Title)) {
  
      delete $self->{$_};
    }
  }
  
  #@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
  1;
  
POD_SIMPLE_BLACKBOX

$fatpacked{"Pod/Simple/Checker.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POD_SIMPLE_CHECKER';
  
  # A quite dimwitted pod2plaintext that need only know how to format whatever
  # text comes out of Pod::BlackBox's _gen_errata
  
  require 5;
  package Pod::Simple::Checker;
  use strict;
  use Carp ();
  use Pod::Simple::Methody ();
  use Pod::Simple ();
  use vars qw( @ISA $VERSION );
  $VERSION = '3.35';
  @ISA = ('Pod::Simple::Methody');
  BEGIN { *DEBUG = defined(&Pod::Simple::DEBUG)
            ? \&Pod::Simple::DEBUG
            : sub() {0}
        }
  
  use Text::Wrap 98.112902 (); # was 2001.0131, but I don't think we need that
  $Text::Wrap::wrap = 'overflow';
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  
  sub any_errata_seen {  # read-only accessor
    return $_[1]->{'Errata_seen'};
  }
  
  sub new {
    my $self = shift;
    my $new = $self->SUPER::new(@_);
    $new->{'output_fh'} ||= *STDOUT{IO};
    $new->nix_X_codes(1);
    $new->nbsp_for_S(1);
    $new->{'Thispara'} = '';
    $new->{'Indent'} = 0;
    $new->{'Indentstring'} = '   ';
    $new->{'Errata_seen'} = 0;
    return $new;
  }
  
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  
  sub handle_text {  $_[0]{'Errata_seen'} and $_[0]{'Thispara'} .= $_[1] }
  
  sub start_Para  {  $_[0]{'Thispara'} = '' }
  
  sub start_head1 {
    if($_[0]{'Errata_seen'}) {
      $_[0]{'Thispara'} = '';
    } else {
      if($_[1]{'errata'}) { # start of errata!
        $_[0]{'Errata_seen'} = 1;
        $_[0]{'Thispara'} = $_[0]{'source_filename'} ?
          "$_[0]{'source_filename'} -- " : ''
      }
    }
  }
  sub start_head2 {  $_[0]{'Thispara'} = '' }
  sub start_head3 {  $_[0]{'Thispara'} = '' }
  sub start_head4 {  $_[0]{'Thispara'} = '' }
  
  sub start_Verbatim    { $_[0]{'Thispara'} = ''   }
  sub start_item_bullet { $_[0]{'Thispara'} = '* ' }
  sub start_item_number { $_[0]{'Thispara'} = "$_[1]{'number'}. "  }
  sub start_item_text   { $_[0]{'Thispara'} = ''   }
  
  sub start_over_bullet  { ++$_[0]{'Indent'} }
  sub start_over_number  { ++$_[0]{'Indent'} }
  sub start_over_text    { ++$_[0]{'Indent'} }
  sub start_over_block   { ++$_[0]{'Indent'} }
  
  sub   end_over_bullet  { --$_[0]{'Indent'} }
  sub   end_over_number  { --$_[0]{'Indent'} }
  sub   end_over_text    { --$_[0]{'Indent'} }
  sub   end_over_block   { --$_[0]{'Indent'} }
  
  
  # . . . . . Now the actual formatters:
  
  sub end_head1       { $_[0]->emit_par(-4) }
  sub end_head2       { $_[0]->emit_par(-3) }
  sub end_head3       { $_[0]->emit_par(-2) }
  sub end_head4       { $_[0]->emit_par(-1) }
  sub end_Para        { $_[0]->emit_par( 0) }
  sub end_item_bullet { $_[0]->emit_par( 0) }
  sub end_item_number { $_[0]->emit_par( 0) }
  sub end_item_text   { $_[0]->emit_par(-2) }
  
  sub emit_par {
    return unless $_[0]{'Errata_seen'};
    my($self, $tweak_indent) = splice(@_,0,2);
    my $indent = ' ' x ( 2 * $self->{'Indent'} + ($tweak_indent||0) );
     # Yes, 'STRING' x NEGATIVE gives '', same as 'STRING' x 0
  
    $self->{'Thispara'} =~ s/$Pod::Simple::shy//g;
    my $out = Text::Wrap::wrap($indent, $indent, $self->{'Thispara'} .= "\n");
    $out =~ s/$Pod::Simple::nbsp/ /g;
    print {$self->{'output_fh'}} $out,
      #"\n"
    ;
    $self->{'Thispara'} = '';
    
    return;
  }
  
  # . . . . . . . . . . And then off by its lonesome:
  
  sub end_Verbatim  {
    return unless $_[0]{'Errata_seen'};
    my $self = shift;
    $self->{'Thispara'} =~ s/$Pod::Simple::nbsp/ /g;
    $self->{'Thispara'} =~ s/$Pod::Simple::shy//g;
  
    my $i = ' ' x ( 2 * $self->{'Indent'} + 4);
    
    $self->{'Thispara'} =~ s/^/$i/mg;
    
    print { $self->{'output_fh'} }   '', 
      $self->{'Thispara'},
      "\n\n"
    ;
    $self->{'Thispara'} = '';
    return;
  }
  
  #@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
  1;
  
  __END__
  
  =head1 NAME
  
  Pod::Simple::Checker -- check the Pod syntax of a document
  
  =head1 SYNOPSIS
  
    perl -MPod::Simple::Checker -e \
     "exit Pod::Simple::Checker->filter(shift)->any_errata_seen" \
     thingy.pod
  
  =head1 DESCRIPTION
  
  This class is for checking the syntactic validity of Pod.
  It works by basically acting like a simple-minded version of
  L<Pod::Simple::Text> that formats only the "Pod Errors" section
  (if Pod::Simple even generates one for the given document).
  
  This is a subclass of L<Pod::Simple> and inherits all its methods.
  
  =head1 SEE ALSO
  
  L<Pod::Simple>, L<Pod::Simple::Text>, L<Pod::Checker>
  
  =head1 SUPPORT
  
  Questions or discussion about POD and Pod::Simple should be sent to the
  pod-people@perl.org mail list. Send an empty email to
  pod-people-subscribe@perl.org to subscribe.
  
  This module is managed in an open GitHub repository,
  L<https://github.com/perl-pod/pod-simple/>. Feel free to fork and contribute, or
  to clone L<git://github.com/perl-pod/pod-simple.git> and send patches!
  
  Patches against Pod::Simple are welcome. Please send bug reports to
  <bug-pod-simple@rt.cpan.org>.
  
  =head1 COPYRIGHT AND DISCLAIMERS
  
  Copyright (c) 2002 Sean M. Burke.
  
  This library is free software; you can redistribute it and/or modify it
  under the same terms as Perl itself.
  
  This program is distributed in the hope that it will be useful, but
  without any warranty; without even the implied warranty of
  merchantability or fitness for a particular purpose.
  
  =head1 AUTHOR
  
  Pod::Simple was created by Sean M. Burke <sburke@cpan.org>.
  But don't bother him, he's retired.
  
  Pod::Simple is maintained by:
  
  =over
  
  =item * Allison Randal C<allison@perl.org>
  
  =item * Hans Dieter Pearcey C<hdp@cpan.org>
  
  =item * David E. Wheeler C<dwheeler@cpan.org>
  
  =back
  
  =cut
POD_SIMPLE_CHECKER

$fatpacked{"Pod/Simple/Debug.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POD_SIMPLE_DEBUG';
  require 5;
  package Pod::Simple::Debug;
  use strict;
  use vars qw($VERSION );
  $VERSION = '3.35';
  
  sub import {
    my($value,$variable);
    
    if(@_ == 2) {
      $value = $_[1];
    } elsif(@_ == 3) {
      ($variable, $value) = @_[1,2];
      
      ($variable, $value) = ($value, $variable)
         if     defined $value    and ref($value)    eq 'SCALAR'
        and not(defined $variable and ref($variable) eq 'SCALAR')
      ; # tolerate getting it backwards
      
      unless( defined $variable and ref($variable) eq 'SCALAR') {
        require Carp;
        Carp::croak("Usage:\n use Pod::Simple::Debug (NUMVAL)\nor"
                  . "\n use Pod::Simple::Debug (\\\$var, STARTNUMVAL)\nAborting");
      }
    } else {
      require Carp;
      Carp::croak("Usage:\n use Pod::Simple::Debug (NUMVAL)\nor"
                      . "\n use Pod::Simple::Debug (\\\$var, STARTNUMVAL)\nAborting");
    }
  
    if( defined &Pod::Simple::DEBUG ) {
      require Carp;
      Carp::croak("It's too late to call Pod::Simple::Debug -- "
                . "Pod::Simple has already loaded\nAborting");
    }
    
    $value = 0 unless defined $value;
  
    unless($value =~ m/^-?\d+$/) {
      require Carp;
      Carp::croak( "$value isn't a numeric value."
              . "\nUsage:\n use Pod::Simple::Debug (NUMVAL)\nor"
                      . "\n use Pod::Simple::Debug (\\\$var, STARTNUMVAL)\nAborting");
    }
  
    if( defined $variable ) {
      # make a not-really-constant
      *Pod::Simple::DEBUG = sub () { $$variable } ;
      $$variable = $value;
      print STDERR "# Starting Pod::Simple::DEBUG = non-constant $variable with val $value\n";
    } else {
      *Pod::Simple::DEBUG = eval " sub () { $value } ";
      print STDERR "# Starting Pod::Simple::DEBUG = $value\n";
    }
    
    require Pod::Simple;
    return;
  }
  
  1;
  
  
  __END__
  
  =head1 NAME
  
  Pod::Simple::Debug -- put Pod::Simple into trace/debug mode
  
  =head1 SYNOPSIS
  
   use Pod::Simple::Debug (5);  # or some integer
  
  Or:
  
   my $debuglevel;
   use Pod::Simple::Debug (\$debuglevel, 0);
   ...some stuff that uses Pod::Simple to do stuff, but which
    you don't want debug output from...
  
   $debug_level = 4;
   ...some stuff that uses Pod::Simple to do stuff, but which
    you DO want debug output from...
  
   $debug_level = 0;
  
  =head1 DESCRIPTION
  
  This is an internal module for controlling the debug level (a.k.a. trace
  level) of Pod::Simple.  This is of interest only to Pod::Simple
  developers.
  
  
  =head1 CAVEATS
  
  Note that you should load this module I<before> loading Pod::Simple (or
  any Pod::Simple-based class).  If you try loading Pod::Simple::Debug
  after &Pod::Simple::DEBUG is already defined, Pod::Simple::Debug will
  throw a fatal error to the effect that
  "It's too late to call Pod::Simple::Debug".
  
  Note that the C<use Pod::Simple::Debug (\$x, I<somenum>)> mode will make
  Pod::Simple (et al) run rather slower, since &Pod::Simple::DEBUG won't
  be a constant sub anymore, and so Pod::Simple (et al) won't compile with
  constant-folding.
  
  
  =head1 GUTS
  
  Doing this:
  
    use Pod::Simple::Debug (5);  # or some integer
  
  is basically equivalent to:
  
    BEGIN { sub Pod::Simple::DEBUG () {5} }  # or some integer
    use Pod::Simple ();
  
  And this:
  
    use Pod::Simple::Debug (\$debug_level,0);  # or some integer
  
  is basically equivalent to this:
  
    my $debug_level;
    BEGIN { $debug_level = 0 }
    BEGIN { sub Pod::Simple::DEBUG () { $debug_level }
    use Pod::Simple ();
  
  =head1 SEE ALSO
  
  L<Pod::Simple>
  
  The article "Constants in Perl", in I<The Perl Journal> issue
  21.  See L<http://interglacial.com/tpj/21/>
  
  =head1 SUPPORT
  
  Questions or discussion about POD and Pod::Simple should be sent to the
  pod-people@perl.org mail list. Send an empty email to
  pod-people-subscribe@perl.org to subscribe.
  
  This module is managed in an open GitHub repository,
  L<https://github.com/perl-pod/pod-simple/>. Feel free to fork and contribute, or
  to clone L<git://github.com/perl-pod/pod-simple.git> and send patches!
  
  Patches against Pod::Simple are welcome. Please send bug reports to
  <bug-pod-simple@rt.cpan.org>.
  
  =head1 COPYRIGHT AND DISCLAIMERS
  
  Copyright (c) 2002 Sean M. Burke.
  
  This library is free software; you can redistribute it and/or modify it
  under the same terms as Perl itself.
  
  This program is distributed in the hope that it will be useful, but
  without any warranty; without even the implied warranty of
  merchantability or fitness for a particular purpose.
  
  =head1 AUTHOR
  
  Pod::Simple was created by Sean M. Burke <sburke@cpan.org>.
  But don't bother him, he's retired.
  
  Pod::Simple is maintained by:
  
  =over
  
  =item * Allison Randal C<allison@perl.org>
  
  =item * Hans Dieter Pearcey C<hdp@cpan.org>
  
  =item * David E. Wheeler C<dwheeler@cpan.org>
  
  =back
  
  =cut
POD_SIMPLE_DEBUG

$fatpacked{"Pod/Simple/DumpAsText.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POD_SIMPLE_DUMPASTEXT';
  
  require 5;
  package Pod::Simple::DumpAsText;
  $VERSION = '3.35';
  use Pod::Simple ();
  BEGIN {@ISA = ('Pod::Simple')}
  
  use strict;
  
  use Carp ();
  
  BEGIN { *DEBUG = \&Pod::Simple::DEBUG unless defined &DEBUG }
  
  sub new {
    my $self = shift;
    my $new = $self->SUPER::new(@_);
    $new->{'output_fh'} ||= *STDOUT{IO};
    $new->accept_codes('VerbatimFormatted');
    $new->keep_encoding_directive(1);
    return $new;
  }
  
  #@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
  
  sub _handle_element_start {
    # ($self, $element_name, $attr_hash_r)
    my $fh = $_[0]{'output_fh'};
    my($key, $value);
    DEBUG and print STDERR "++ $_[1]\n";
    
    print $fh   '  ' x ($_[0]{'indent'} || 0),  "++", $_[1], "\n";
    $_[0]{'indent'}++;
    while(($key,$value) = each %{$_[2]}) {
      unless($key =~ m/^~/s) {
        next if $key eq 'start_line' and $_[0]{'hide_line_numbers'};
        _perly_escape($key);
        _perly_escape($value);
        printf $fh qq{%s \\ "%s" => "%s"\n},
          '  ' x ($_[0]{'indent'} || 0), $key, $value;
      }
    }
    return;
  }
  
  sub _handle_text {
    DEBUG and print STDERR "== \"$_[1]\"\n";
    
    if(length $_[1]) {
      my $indent = '  ' x $_[0]{'indent'};
      my $text = $_[1];
      _perly_escape($text);
      $text =~  # A not-totally-brilliant wrapping algorithm:
        s/(
           [^\n]{55}         # Snare some characters from a line
           [^\n\ ]{0,50}     #  and finish any current word
          )
          \ {1,10}(?!\n)     # capture some spaces not at line-end
         /$1"\n$indent . "/gx     # => line-break here
      ;
      
      print {$_[0]{'output_fh'}} $indent, '* "', $text, "\"\n";
    }
    return;
  }
  
  sub _handle_element_end {
    DEBUG and print STDERR "-- $_[1]\n";
    print {$_[0]{'output_fh'}}
     '  ' x --$_[0]{'indent'}, "--", $_[1], "\n";
    return;
  }
  
  # . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
  sub _perly_escape {
    foreach my $x (@_) {
      $x =~ s/([^\x00-\xFF])/sprintf'\x{%X}',ord($1)/eg;
      # Escape things very cautiously:
      $x =~ s/([^-\n\t \&\<\>\'!\#\%\(\)\*\+,\.\/\:\;=\?\~\[\]\^_\`\{\|\}abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789])/sprintf'\x%02X',ord($1)/eg;
    }
    return;
  }
  
  #@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
  1;
  
  
  __END__
  
  =head1 NAME
  
  Pod::Simple::DumpAsText -- dump Pod-parsing events as text
  
  =head1 SYNOPSIS
  
    perl -MPod::Simple::DumpAsText -e \
     "exit Pod::Simple::DumpAsText->filter(shift)->any_errata_seen" \
     thingy.pod
  
  =head1 DESCRIPTION
  
  This class is for dumping, as text, the events gotten from parsing a Pod
  document.  This class is of interest to people writing Pod formatters
  based on Pod::Simple. It is useful for seeing exactly what events you
  get out of some Pod that you feed in.
  
  This is a subclass of L<Pod::Simple> and inherits all its methods.
  
  =head1 SEE ALSO
  
  L<Pod::Simple::DumpAsXML>
  
  L<Pod::Simple>
  
  =head1 SUPPORT
  
  Questions or discussion about POD and Pod::Simple should be sent to the
  pod-people@perl.org mail list. Send an empty email to
  pod-people-subscribe@perl.org to subscribe.
  
  This module is managed in an open GitHub repository,
  L<https://github.com/perl-pod/pod-simple/>. Feel free to fork and contribute, or
  to clone L<git://github.com/perl-pod/pod-simple.git> and send patches!
  
  Patches against Pod::Simple are welcome. Please send bug reports to
  <bug-pod-simple@rt.cpan.org>.
  
  =head1 COPYRIGHT AND DISCLAIMERS
  
  Copyright (c) 2002 Sean M. Burke.
  
  This library is free software; you can redistribute it and/or modify it
  under the same terms as Perl itself.
  
  This program is distributed in the hope that it will be useful, but
  without any warranty; without even the implied warranty of
  merchantability or fitness for a particular purpose.
  
  =head1 AUTHOR
  
  Pod::Simple was created by Sean M. Burke <sburke@cpan.org>.
  But don't bother him, he's retired.
  
  Pod::Simple is maintained by:
  
  =over
  
  =item * Allison Randal C<allison@perl.org>
  
  =item * Hans Dieter Pearcey C<hdp@cpan.org>
  
  =item * David E. Wheeler C<dwheeler@cpan.org>
  
  =back
  
  =cut
POD_SIMPLE_DUMPASTEXT

$fatpacked{"Pod/Simple/DumpAsXML.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POD_SIMPLE_DUMPASXML';
  
  require 5;
  package Pod::Simple::DumpAsXML;
  $VERSION = '3.35';
  use Pod::Simple ();
  BEGIN {@ISA = ('Pod::Simple')}
  
  use strict;
  
  use Carp ();
  use Text::Wrap qw(wrap);
  
  BEGIN { *DEBUG = \&Pod::Simple::DEBUG unless defined &DEBUG }
  
  sub new {
    my $self = shift;
    my $new = $self->SUPER::new(@_);
    $new->{'output_fh'} ||= *STDOUT{IO};
    $new->accept_codes('VerbatimFormatted');
    $new->keep_encoding_directive(1);
    return $new;
  }
  
  #@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
  
  sub _handle_element_start {
    # ($self, $element_name, $attr_hash_r)
    my $fh = $_[0]{'output_fh'};
    my($key, $value);
    DEBUG and print STDERR "++ $_[1]\n";
    
    print $fh   '  ' x ($_[0]{'indent'} || 0),  "<", $_[1];
  
    foreach my $key (sort keys %{$_[2]}) {
      unless($key =~ m/^~/s) {
        next if $key eq 'start_line' and $_[0]{'hide_line_numbers'};
        _xml_escape($value = $_[2]{$key});
        print $fh ' ', $key, '="', $value, '"';
      }
    }
  
  
    print $fh ">\n";
    $_[0]{'indent'}++;
    return;
  }
  
  sub _handle_text {
    DEBUG and print STDERR "== \"$_[1]\"\n";
    if(length $_[1]) {
      my $indent = '  ' x $_[0]{'indent'};
      my $text = $_[1];
      _xml_escape($text);
      local $Text::Wrap::huge = 'overflow';
      $text = wrap('', $indent, $text);
      print {$_[0]{'output_fh'}} $indent, $text, "\n";
    }
    return;
  }
  
  sub _handle_element_end {
    DEBUG and print STDERR "-- $_[1]\n";
    print {$_[0]{'output_fh'}}
     '  ' x --$_[0]{'indent'}, "</", $_[1], ">\n";
    return;
  }
  
  # . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
  sub _xml_escape {
    foreach my $x (@_) {
      # Escape things very cautiously:
      if ($] ge 5.007_003) {
        $x =~ s/([^-\n\t !\#\$\%\(\)\*\+,\.\~\/\:\;=\?\@\[\\\]\^_\`\{\|\}abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789])/'&#'.(utf8::native_to_unicode(ord($1))).';'/eg;
      } else { # Is broken for non-ASCII platforms on early perls
        $x =~ s/([^-\n\t !\#\$\%\(\)\*\+,\.\~\/\:\;=\?\@\[\\\]\^_\`\{\|\}abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789])/'&#'.(ord($1)).';'/eg;
      }
      # Yes, stipulate the list without a range, so that this can work right on
      #  all charsets that this module happens to run under.
    }
    return;
  }
  
  #@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
  1;
  
  __END__
  
  =head1 NAME
  
  Pod::Simple::DumpAsXML -- turn Pod into XML
  
  =head1 SYNOPSIS
  
    perl -MPod::Simple::DumpAsXML -e \
     "exit Pod::Simple::DumpAsXML->filter(shift)->any_errata_seen" \
     thingy.pod
  
  =head1 DESCRIPTION
  
  Pod::Simple::DumpAsXML is a subclass of L<Pod::Simple> that parses Pod
  and turns it into indented and wrapped XML.  This class is of
  interest to people writing Pod formatters based on Pod::Simple.
  
  Pod::Simple::DumpAsXML inherits methods from
  L<Pod::Simple>.
  
  
  =head1 SEE ALSO
  
  L<Pod::Simple::XMLOutStream> is rather like this class.
  Pod::Simple::XMLOutStream's output is space-padded in a way
  that's better for sending to an XML processor (that is, it has
  no ignorable whitespace). But
  Pod::Simple::DumpAsXML's output is much more human-readable, being
  (more-or-less) one token per line, with line-wrapping.
  
  L<Pod::Simple::DumpAsText> is rather like this class,
  except that it doesn't dump with XML syntax.  Try them and see
  which one you like best!
  
  L<Pod::Simple>, L<Pod::Simple::DumpAsXML>
  
  The older libraries L<Pod::PXML>, L<Pod::XML>, L<Pod::SAX>
  
  =head1 SUPPORT
  
  Questions or discussion about POD and Pod::Simple should be sent to the
  pod-people@perl.org mail list. Send an empty email to
  pod-people-subscribe@perl.org to subscribe.
  
  This module is managed in an open GitHub repository,
  L<https://github.com/perl-pod/pod-simple/>. Feel free to fork and contribute, or
  to clone L<git://github.com/perl-pod/pod-simple.git> and send patches!
  
  Patches against Pod::Simple are welcome. Please send bug reports to
  <bug-pod-simple@rt.cpan.org>.
  
  =head1 COPYRIGHT AND DISCLAIMERS
  
  Copyright (c) 2002 Sean M. Burke.
  
  This library is free software; you can redistribute it and/or modify it
  under the same terms as Perl itself.
  
  This program is distributed in the hope that it will be useful, but
  without any warranty; without even the implied warranty of
  merchantability or fitness for a particular purpose.
  
  =head1 AUTHOR
  
  Pod::Simple was created by Sean M. Burke <sburke@cpan.org>.
  But don't bother him, he's retired.
  
  Pod::Simple is maintained by:
  
  =over
  
  =item * Allison Randal C<allison@perl.org>
  
  =item * Hans Dieter Pearcey C<hdp@cpan.org>
  
  =item * David E. Wheeler C<dwheeler@cpan.org>
  
  =back
  
  =cut
POD_SIMPLE_DUMPASXML

$fatpacked{"Pod/Simple/HTML.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POD_SIMPLE_HTML';
  require 5;
  package Pod::Simple::HTML;
  use strict;
  use Pod::Simple::PullParser ();
  use vars qw(
    @ISA %Tagmap $Computerese $LamePad $Linearization_Limit $VERSION
    $Perldoc_URL_Prefix $Perldoc_URL_Postfix $Man_URL_Prefix $Man_URL_Postfix
    $Title_Prefix $Title_Postfix $HTML_EXTENSION %ToIndex
    $Doctype_decl  $Content_decl
  );
  @ISA = ('Pod::Simple::PullParser');
  $VERSION = '3.35';
  BEGIN {
    if(defined &DEBUG) { } # no-op
    elsif( defined &Pod::Simple::DEBUG ) { *DEBUG = \&Pod::Simple::DEBUG }
    else { *DEBUG = sub () {0}; }
  }
  
  $Doctype_decl ||= '';  # No.  Just No.  Don't even ask me for it.
   # qq{<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
   #    "http://www.w3.org/TR/html4/loose.dtd">\n};
  
  $Content_decl ||=
   q{<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1" >};
  
  $HTML_EXTENSION = '.html' unless defined $HTML_EXTENSION;
  $Computerese =  "" unless defined $Computerese;
  $LamePad = '' unless defined $LamePad;
  
  $Linearization_Limit = 120 unless defined $Linearization_Limit;
   # headings/items longer than that won't get an <a name="...">
  $Perldoc_URL_Prefix  = 'http://search.cpan.org/perldoc?'
   unless defined $Perldoc_URL_Prefix;
  $Perldoc_URL_Postfix = ''
   unless defined $Perldoc_URL_Postfix;
  
  
  $Man_URL_Prefix  = 'http://man.he.net/man';
  $Man_URL_Postfix = '';
  
  $Title_Prefix  = '' unless defined $Title_Prefix;
  $Title_Postfix = '' unless defined $Title_Postfix;
  %ToIndex = map {; $_ => 1 } qw(head1 head2 head3 head4 ); # item-text
    # 'item-text' stuff in the index doesn't quite work, and may
    # not be a good idea anyhow.
  
  
  __PACKAGE__->_accessorize(
   'perldoc_url_prefix',
     # In turning L<Foo::Bar> into http://whatever/Foo%3a%3aBar, what
     #  to put before the "Foo%3a%3aBar".
     # (for singleton mode only?)
   'perldoc_url_postfix',
     # what to put after "Foo%3a%3aBar" in the URL.  Normally "".
  
   'man_url_prefix',
     # In turning L<crontab(5)> into http://whatever/man/1/crontab, what
     #  to put before the "1/crontab".
   'man_url_postfix',
     #  what to put after the "1/crontab" in the URL. Normally "".
  
   'batch_mode', # whether we're in batch mode
   'batch_mode_current_level',
      # When in batch mode, how deep the current module is: 1 for "LWP",
      #  2 for "LWP::Procotol", 3 for "LWP::Protocol::GHTTP", etc
      
   'title_prefix',  'title_postfix',
    # What to put before and after the title in the head.
    # Should already be &-escaped
  
   'html_h_level',
    
   'html_header_before_title',
   'html_header_after_title',
   'html_footer',
   'top_anchor',
  
   'index', # whether to add an index at the top of each page
      # (actually it's a table-of-contents, but we'll call it an index,
      #  out of apparently longstanding habit)
  
   'html_css', # URL of CSS file to point to
   'html_javascript', # URL of Javascript file to point to
  
   'force_title',   # should already be &-escaped
   'default_title', # should already be &-escaped
  );
  
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  my @_to_accept;
  
  %Tagmap = (
    'Verbatim'  => "\n<pre$Computerese>",
    '/Verbatim' => "</pre>\n",
    'VerbatimFormatted'  => "\n<pre$Computerese>",
    '/VerbatimFormatted' => "</pre>\n",
    'VerbatimB'  => "<b>",
    '/VerbatimB' => "</b>",
    'VerbatimI'  => "<i>",
    '/VerbatimI' => "</i>",
    'VerbatimBI'  => "<b><i>",
    '/VerbatimBI' => "</i></b>",
  
  
    'Data'  => "\n",
    '/Data' => "\n",
    
    'head1' => "\n<h1>",  # And also stick in an <a name="...">
    'head2' => "\n<h2>",  #  ''
    'head3' => "\n<h3>",  #  ''
    'head4' => "\n<h4>",  #  ''
    '/head1' => "</a></h1>\n",
    '/head2' => "</a></h2>\n",
    '/head3' => "</a></h3>\n",
    '/head4' => "</a></h4>\n",
  
    'X'  => "<!--\n\tINDEX: ",
    '/X' => "\n-->",
  
    changes(qw(
      Para=p
      B=b I=i
      over-bullet=ul
      over-number=ol
      over-text=dl
      over-block=blockquote
      item-bullet=li
      item-number=li
      item-text=dt
    )),
    changes2(
      map {; m/^([-a-z]+)/s && push @_to_accept, $1; $_ }
      qw[
        sample=samp
        definition=dfn
        keyboard=kbd
        variable=var
        citation=cite
        abbreviation=abbr
        acronym=acronym
        subscript=sub
        superscript=sup
        big=big
        small=small
        underline=u
        strikethrough=s
        preformat=pre
        teletype=tt
      ]  # no point in providing a way to get <q>...</q>, I think
    ),
    
    '/item-bullet' => "</li>$LamePad\n",
    '/item-number' => "</li>$LamePad\n",
    '/item-text'   => "</a></dt>$LamePad\n",
    'item-body'    => "\n<dd>",
    '/item-body'   => "</dd>\n",
  
  
    'B'      =>  "<b>",                  '/B'     =>  "</b>",
    'I'      =>  "<i>",                  '/I'     =>  "</i>",
    'F'      =>  "<em$Computerese>",     '/F'     =>  "</em>",
    'C'      =>  "<code$Computerese>",   '/C'     =>  "</code>",
    'L'  =>  "<a href='YOU_SHOULD_NEVER_SEE_THIS'>", # ideally never used!
    '/L' =>  "</a>",
  );
  
  sub changes {
    return map {; m/^([-_:0-9a-zA-Z]+)=([-_:0-9a-zA-Z]+)$/s
       ? ( $1, => "\n<$2>", "/$1", => "</$2>\n" ) : die "Funky $_"
    } @_;
  }
  sub changes2 {
    return map {; m/^([-_:0-9a-zA-Z]+)=([-_:0-9a-zA-Z]+)$/s
       ? ( $1, => "<$2>", "/$1", => "</$2>" ) : die "Funky $_"
    } @_;
  }
  
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  sub go { Pod::Simple::HTML->parse_from_file(@ARGV); exit 0 }
   # Just so we can run from the command line.  No options.
   #  For that, use perldoc!
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  
  sub new {
    my $new = shift->SUPER::new(@_);
    #$new->nix_X_codes(1);
    $new->nbsp_for_S(1);
    $new->accept_targets( 'html', 'HTML' );
    $new->accept_codes('VerbatimFormatted');
    $new->accept_codes(@_to_accept);
    DEBUG > 2 and print STDERR "To accept: ", join(' ',@_to_accept), "\n";
  
    $new->perldoc_url_prefix(  $Perldoc_URL_Prefix  );
    $new->perldoc_url_postfix( $Perldoc_URL_Postfix );
    $new->man_url_prefix(  $Man_URL_Prefix  );
    $new->man_url_postfix( $Man_URL_Postfix );
    $new->title_prefix(  $Title_Prefix  );
    $new->title_postfix( $Title_Postfix );
  
    $new->html_header_before_title(
     qq[$Doctype_decl<html><head><title>]
    );
    $new->html_header_after_title( join "\n" =>
      "</title>",
      $Content_decl,
      "</head>\n<body class='pod'>",
      $new->version_tag_comment,
      "<!-- start doc -->\n",
    );
    $new->html_footer( qq[\n<!-- end doc -->\n\n</body></html>\n] );
    $new->top_anchor( "<a name='___top' class='dummyTopAnchor' ></a>\n" );
  
    $new->{'Tagmap'} = {%Tagmap};
  
    return $new;
  }
  
  sub __adjust_html_h_levels {
    my ($self) = @_;
    my $Tagmap = $self->{'Tagmap'};
  
    my $add = $self->html_h_level;
    return unless defined $add;
    return if ($self->{'Adjusted_html_h_levels'}||0) == $add;
  
    $add -= 1;
    for (1 .. 4) {
      $Tagmap->{"head$_"}  =~ s/$_/$_ + $add/e;
      $Tagmap->{"/head$_"} =~ s/$_/$_ + $add/e;
    }
  }
  
  sub batch_mode_page_object_init {
    my($self, $batchconvobj, $module, $infile, $outfile, $depth) = @_;
    DEBUG and print STDERR "Initting $self\n  for $module\n",
      "  in $infile\n  out $outfile\n  depth $depth\n";
    $self->batch_mode(1);
    $self->batch_mode_current_level($depth);
    return $self;
  }
  
  sub run {
    my $self = $_[0];
    return $self->do_middle if $self->bare_output;
    return
     $self->do_beginning && $self->do_middle && $self->do_end;
  }
  
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  
  sub do_beginning {
    my $self = $_[0];
  
    my $title;
    
    if(defined $self->force_title) {
      $title = $self->force_title;
      DEBUG and print STDERR "Forcing title to be $title\n";
    } else {
      # Actually try looking for the title in the document:
      $title = $self->get_short_title();
      unless($self->content_seen) {
        DEBUG and print STDERR "No content seen in search for title.\n";
        return;
      }
      $self->{'Title'} = $title;
  
      if(defined $title and $title =~ m/\S/) {
        $title = $self->title_prefix . esc($title) . $self->title_postfix;
      } else {
        $title = $self->default_title;    
        $title = '' unless defined $title;
        DEBUG and print STDERR "Title defaults to $title\n";
      }
    }
  
    
    my $after = $self->html_header_after_title  || '';
    if($self->html_css) {
      my $link =
      $self->html_css =~ m/</
       ? $self->html_css # It's a big blob of markup, let's drop it in
       : sprintf(        # It's just a URL, so let's wrap it up
        qq[<link rel="stylesheet" type="text/css" title="pod_stylesheet" href="%s">\n],
        $self->html_css,
      );
      $after =~ s{(</head>)}{$link\n$1}i;  # otherwise nevermind
    }
    $self->_add_top_anchor(\$after);
  
    if($self->html_javascript) {
      my $link =
      $self->html_javascript =~ m/</
       ? $self->html_javascript # It's a big blob of markup, let's drop it in
       : sprintf(        # It's just a URL, so let's wrap it up
        qq[<script type="text/javascript" src="%s"></script>\n],
        $self->html_javascript,
      );
      $after =~ s{(</head>)}{$link\n$1}i;  # otherwise nevermind
    }
  
    print {$self->{'output_fh'}}
      $self->html_header_before_title || '',
      $title, # already escaped
      $after,
    ;
  
    DEBUG and print STDERR "Returning from do_beginning...\n";
    return 1;
  }
  
  sub _add_top_anchor {
    my($self, $text_r) = @_;
    unless($$text_r and $$text_r =~ m/name=['"]___top['"]/) { # a hack
      $$text_r .= $self->top_anchor || '';
    }
    return;
  }
  
  sub version_tag_comment {
    my $self = shift;
    return sprintf
     "<!--\n  generated by %s v%s,\n  using %s v%s,\n  under Perl v%s at %s GMT.\n\n %s\n\n-->\n",
     esc(
      ref($self), $self->VERSION(), $ISA[0], $ISA[0]->VERSION(),
      $], scalar(gmtime),
     ), $self->_modnote(),
    ;
  }
  
  sub _modnote {
    my $class = ref($_[0]) || $_[0];
    return join "\n   " => grep m/\S/, split "\n",
  
  qq{
  If you want to change this HTML document, you probably shouldn't do that
  by changing it directly.  Instead, see about changing the calling options
  to $class, and/or subclassing $class,
  then reconverting this document from the Pod source.
  When in doubt, email the author of $class for advice.
  See 'perldoc $class' for more info.
  };
  
  }
  
  sub do_end {
    my $self = $_[0];
    print {$self->{'output_fh'}}  $self->html_footer || '';
    return 1;
  }
  
  # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  # Normally this would just be a call to _do_middle_main_loop -- but we
  #  have to do some elaborate things to emit all the content and then
  #  summarize it and output it /before/ the content that it's a summary of.
  
  sub do_middle {
    my $self = $_[0];
    return $self->_do_middle_main_loop unless $self->index;
  
    if( $self->output_string ) {
      # An efficiency hack
      my $out = $self->output_string; #it's a reference to it
      my $sneakytag = "\f\f\e\e\b\bIndex Here\e\e\b\b\f\f\n";
      $$out .= $sneakytag;
      $self->_do_middle_main_loop;
      $sneakytag = quotemeta($sneakytag);
      my $index = $self->index_as_html();
      if( $$out =~ s/$sneakytag/$index/s ) {
        # Expected case
        DEBUG and print STDERR "Inserted ", length($index), " bytes of index HTML into $out.\n";
      } else {
        DEBUG and print STDERR "Odd, couldn't find where to insert the index in the output!\n";
        # I don't think this should ever happen.
      }
      return 1;
    }
  
    unless( $self->output_fh ) {
      require Carp;
      Carp::confess("Parser object \$p doesn't seem to have any output object!  I don't know how to deal with that.");
    }
  
    # If we get here, we're outputting to a FH.  So we need to do some magic.
    # Namely, divert all content to a string, which we output after the index.
    my $fh = $self->output_fh;
    my $content = '';
    {
      # Our horrible bait and switch:
      $self->output_string( \$content );
      $self->_do_middle_main_loop;
      $self->abandon_output_string();
      $self->output_fh($fh);
    }
    print $fh $self->index_as_html();
    print $fh $content;
  
    return 1;
  }
  
  ###########################################################################
  
  sub index_as_html {
    my $self = $_[0];
    # This is meant to be called AFTER the input document has been parsed!
  
    my $points = $self->{'PSHTML_index_points'} || [];
    
    @$points > 1 or return qq[<div class='indexgroupEmpty'></div>\n];
     # There's no point in having a 0-item or 1-item index, I dare say.
    
    my(@out) = qq{\n<div class='indexgroup'>};
    my $level = 0;
  
    my( $target_level, $previous_tagname, $tagname, $text, $anchorname, $indent);
    foreach my $p (@$points, ['head0', '(end)']) {
      ($tagname, $text) = @$p;
      $anchorname = $self->section_escape($text);
      if( $tagname =~ m{^head(\d+)$} ) {
        $target_level = 0 + $1;
      } else {  # must be some kinda list item
        if($previous_tagname =~ m{^head\d+$} ) {
          $target_level = $level + 1;
        } else {
          $target_level = $level;  # no change needed
        }
      }
      
      # Get to target_level by opening or closing ULs
      while($level > $target_level)
       { --$level; push @out, ("  " x $level) . "</ul>"; }
      while($level < $target_level)
       { ++$level; push @out, ("  " x ($level-1))
         . "<ul   class='indexList indexList$level'>"; }
  
      $previous_tagname = $tagname;
      next unless $level;
      
      $indent = '  '  x $level;
      push @out, sprintf
        "%s<li class='indexItem indexItem%s'><a href='#%s'>%s</a>",
        $indent, $level, esc($anchorname), esc($text)
      ;
    }
    push @out, "</div>\n";
    return join "\n", @out;
  }
  
  ###########################################################################
  
  sub _do_middle_main_loop {
    my $self = $_[0];
    my $fh = $self->{'output_fh'};
    my $tagmap = $self->{'Tagmap'};
  
    $self->__adjust_html_h_levels;
    
    my($token, $type, $tagname, $linkto, $linktype);
    my @stack;
    my $dont_wrap = 0;
  
    while($token = $self->get_token) {
  
      # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      if( ($type = $token->type) eq 'start' ) {
        if(($tagname = $token->tagname) eq 'L') {
          $linktype = $token->attr('type') || 'insane';
          
          $linkto = $self->do_link($token);
  
          if(defined $linkto and length $linkto) {
            esc($linkto);
              #   (Yes, SGML-escaping applies on top of %-escaping!
              #   But it's rarely noticeable in practice.)
            print $fh qq{<a href="$linkto" class="podlink$linktype"\n>};
          } else {
            print $fh "<a>"; # Yes, an 'a' element with no attributes!
          }
  
        } elsif ($tagname eq 'item-text' or $tagname =~ m/^head\d$/s) {
          print $fh $tagmap->{$tagname} || next;
  
          my @to_unget;
          while(1) {
            push @to_unget, $self->get_token;
            last if $to_unget[-1]->is_end
                and $to_unget[-1]->tagname eq $tagname;
            
            # TODO: support for X<...>'s found in here?  (maybe hack into linearize_tokens)
          }
  
          my $name = $self->linearize_tokens(@to_unget);
          $name = $self->do_section($name, $token) if defined $name;
  
          print $fh "<a ";
          if ($tagname =~ m/^head\d$/s) {
              print $fh "class='u'", $self->index
                  ? " href='#___top' title='click to go to top of document'\n"
                  : "\n";
          }
          
          if(defined $name) {
            my $esc = esc(  $self->section_name_tidy( $name ) );
            print $fh qq[name="$esc"];
            DEBUG and print STDERR "Linearized ", scalar(@to_unget),
             " tokens as \"$name\".\n";
            push @{ $self->{'PSHTML_index_points'} }, [$tagname, $name]
             if $ToIndex{ $tagname };
              # Obviously, this discards all formatting codes (saving
              #  just their content), but ahwell.
             
          } else {  # ludicrously long, so nevermind
            DEBUG and print STDERR "Linearized ", scalar(@to_unget),
             " tokens, but it was too long, so nevermind.\n";
          }
          print $fh "\n>";
          $self->unget_token(@to_unget);
  
        } elsif ($tagname eq 'Data') {
          my $next = $self->get_token;
          next unless defined $next;
          unless( $next->type eq 'text' ) {
            $self->unget_token($next);
            next;
          }
          DEBUG and print STDERR "    raw text ", $next->text, "\n";
          # The parser sometimes preserves newlines and sometimes doesn't!
          (my $text = $next->text) =~ s/\n\z//;
          print $fh $text, "\n";
          next;
         
        } else {
          if( $tagname =~ m/^over-/s ) {
            push @stack, '';
          } elsif( $tagname =~ m/^item-/s and @stack and $stack[-1] ) {
            print $fh $stack[-1];
            $stack[-1] = '';
          }
          print $fh $tagmap->{$tagname} || next;
          ++$dont_wrap if $tagname eq 'Verbatim' or $tagname eq "VerbatimFormatted"
            or $tagname eq 'X';
        }
  
      # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      } elsif( $type eq 'end' ) {
        if( ($tagname = $token->tagname) =~ m/^over-/s ) {
          if( my $end = pop @stack ) {
            print $fh $end;
          }
        } elsif( $tagname =~ m/^item-/s and @stack) {
          $stack[-1] = $tagmap->{"/$tagname"};
          if( $tagname eq 'item-text' and defined(my $next = $self->get_token) ) {
            $self->unget_token($next);
            if( $next->type eq 'start' ) {
              print $fh $tagmap->{"/item-text"},$tagmap->{"item-body"};
              $stack[-1] = $tagmap->{"/item-body"};
            }
          }
          next;
        }
        print $fh $tagmap->{"/$tagname"} || next;
        --$dont_wrap if $tagname eq 'Verbatim' or $tagname eq 'X';
  
      # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      } elsif( $type eq 'text' ) {
        esc($type = $token->text);  # reuse $type, why not
        $type =~ s/([\?\!\"\'\.\,]) /$1\n/g unless $dont_wrap;
        print $fh $type;
      }
  
    }
    return 1;
  }
  
  ###########################################################################
  #
  
  sub do_section {
    my($self, $name, $token) = @_;
    return $name;
  }
  
  sub do_link {
    my($self, $token) = @_;
    my $type = $token->attr('type');
    if(!defined $type) {
      $self->whine("Typeless L!?", $token->attr('start_line'));
    } elsif( $type eq 'pod') { return $self->do_pod_link($token);
    } elsif( $type eq 'url') { return $self->do_url_link($token);
    } elsif( $type eq 'man') { return $self->do_man_link($token);
    } else {
      $self->whine("L of unknown type $type!?", $token->attr('start_line'));
    }
    return 'FNORG'; # should never get called
  }
  
  # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  
  sub do_url_link { return $_[1]->attr('to') }
  
  sub do_man_link {
    my ($self, $link) = @_;
    my $to = $link->attr('to');
    my $frag = $link->attr('section');
  
    return undef unless defined $to and length $to; # should never happen
  
    $frag = $self->section_escape($frag)
     if defined $frag and length($frag .= ''); # (stringify)
  
    DEBUG and print STDERR "Resolving \"$to/$frag\"\n\n";
  
    return $self->resolve_man_page_link($to, $frag);
  }
  
  
  sub do_pod_link {
    # And now things get really messy...
    my($self, $link) = @_;
    my $to = $link->attr('to');
    my $section = $link->attr('section');
    return undef unless(  # should never happen
      (defined $to and length $to) or
      (defined $section and length $section)
    );
  
    $section = $self->section_escape($section)
     if defined $section and length($section .= ''); # (stringify)
  
    DEBUG and printf STDERR "Resolving \"%s\" \"%s\"...\n",
     $to || "(nil)",  $section || "(nil)";
     
    {
      # An early hack:
      my $complete_url = $self->resolve_pod_link_by_table($to, $section);
      if( $complete_url ) {
        DEBUG > 1 and print STDERR "resolve_pod_link_by_table(T,S) gives ",
          $complete_url, "\n  (Returning that.)\n";
        return $complete_url;
      } else {
        DEBUG > 4 and print STDERR " resolve_pod_link_by_table(T,S)",
         " didn't return anything interesting.\n";
      }
    }
  
    if(defined $to and length $to) {
      # Give this routine first hack again
      my $there = $self->resolve_pod_link_by_table($to);
      if(defined $there and length $there) {
        DEBUG > 1
         and print STDERR "resolve_pod_link_by_table(T) gives $there\n";
      } else {
        $there = 
          $self->resolve_pod_page_link($to, $section);
           # (I pass it the section value, but I don't see a
           #  particular reason it'd use it.)
        DEBUG > 1 and print STDERR "resolve_pod_page_link gives ", $there || "(nil)", "\n";
        unless( defined $there and length $there ) {
          DEBUG and print STDERR "Can't resolve $to\n";
          return undef;
        }
        # resolve_pod_page_link returning undef is how it
        #  can signal that it gives up on making a link
      }
      $to = $there;
    }
  
    #DEBUG and print STDERR "So far [", $to||'nil', "] [", $section||'nil', "]\n";
  
    my $out = (defined $to and length $to) ? $to : '';
    $out .= "#" . $section if defined $section and length $section;
    
    unless(length $out) { # sanity check
      DEBUG and printf STDERR "Oddly, couldn't resolve \"%s\" \"%s\"...\n",
       $to || "(nil)",  $section || "(nil)";
      return undef;
    }
  
    DEBUG and print STDERR "Resolved to $out\n";
    return $out;  
  }
  
  
  # . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
  sub section_escape {
    my($self, $section) = @_;
    return $self->section_url_escape(
      $self->section_name_tidy($section)
    );
  }
  
  sub section_name_tidy {
    my($self, $section) = @_;
    $section =~ s/^\s+//;
    $section =~ s/\s+$//;
    $section =~ tr/ /_/;
    if ($] ge 5.006) {
      $section =~ s/[[:cntrl:][:^ascii:]]//g; # drop crazy characters
    } elsif ('A' eq chr(65)) { # But not on early EBCDIC
      $section =~ tr/\x00-\x1F\x80-\x9F//d;
    }
    $section = $self->unicode_escape_url($section);
    $section = '_' unless length $section;
    return $section;
  }
  
  sub section_url_escape  { shift->general_url_escape(@_) }
  sub pagepath_url_escape { shift->general_url_escape(@_) }
  sub manpage_url_escape  { shift->general_url_escape(@_) }
  
  sub general_url_escape {
    my($self, $string) = @_;
   
    $string =~ s/([^\x00-\xFF])/join '', map sprintf('%%%02X',$_), unpack 'C*', $1/eg;
       # express Unicode things as urlencode(utf(orig)).
    
    # A pretty conservative escaping, behoovey even for query components
    #  of a URL (see RFC 2396)
    
    if ($] ge 5.007_003) {
      $string =~ s/([^-_\.!~*()abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789])/sprintf('%%%02X',utf8::native_to_unicode(ord($1)))/eg;
    } else { # Is broken for non-ASCII platforms on early perls
      $string =~ s/([^-_\.!~*()abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789])/sprintf('%%%02X',ord($1))/eg;
    }
     # Yes, stipulate the list without a range, so that this can work right on
     #  all charsets that this module happens to run under.
    
    return $string;
  }
  
  #--------------------------------------------------------------------------
  #
  # Oh look, a yawning portal to Hell!  Let's play touch football right by it!
  #
  
  sub resolve_pod_page_link {
    # resolve_pod_page_link must return a properly escaped URL
    my $self = shift;
    return $self->batch_mode()
     ? $self->resolve_pod_page_link_batch_mode(@_)
     : $self->resolve_pod_page_link_singleton_mode(@_)
    ;
  }
  
  sub resolve_pod_page_link_singleton_mode {
    my($self, $it) = @_;
    return undef unless defined $it and length $it;
    my $url = $self->pagepath_url_escape($it);
    
    $url =~ s{::$}{}s; # probably never comes up anyway
    $url =~ s{::}{/}g unless $self->perldoc_url_prefix =~ m/\?/s; # sane DWIM?
    
    return undef unless length $url;
    return $self->perldoc_url_prefix . $url . $self->perldoc_url_postfix;
  }
  
  sub resolve_pod_page_link_batch_mode {
    my($self, $to) = @_;
    DEBUG > 1 and print STDERR " During batch mode, resolving $to ...\n";
    my @path = grep length($_), split m/::/s, $to, -1;
    unless( @path ) { # sanity
      DEBUG and print STDERR "Very odd!  Splitting $to gives (nil)!\n";
      return undef;
    }
    $self->batch_mode_rectify_path(\@path);
    my $out = join('/', map $self->pagepath_url_escape($_), @path)
      . $HTML_EXTENSION;
    DEBUG > 1 and print STDERR " => $out\n";
    return $out;
  }
  
  sub batch_mode_rectify_path {
    my($self, $pathbits) = @_;
    my $level = $self->batch_mode_current_level;
    $level--; # how many levels up to go to get to the root
    if($level < 1) {
      unshift @$pathbits, '.'; # just to be pretty
    } else {
      unshift @$pathbits, ('..') x $level;
    }
    return;
  }
  
  sub resolve_man_page_link {
    my ($self, $to, $frag) = @_;
    my ($page, $section) = $to =~ /^([^(]+)(?:[(](\d+)[)])?$/;
  
    return undef unless defined $page and length $page;
    $section ||= 1;
  
    return $self->man_url_prefix . "$section/"
        . $self->manpage_url_escape($page)
        . $self->man_url_postfix;
  }
  
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  
  sub resolve_pod_link_by_table {
    # A crazy hack to allow specifying custom L<foo> => URL mappings
  
    return unless $_[0]->{'podhtml_LOT'};  # An optimizy shortcut
  
    my($self, $to, $section) = @_;
  
    # TODO: add a method that actually populates podhtml_LOT from a file?
  
    if(defined $section) {
      $to = '' unless defined $to and length $to;
      return $self->{'podhtml_LOT'}{"$to#$section"}; # quite possibly undef!
    } else {
      return $self->{'podhtml_LOT'}{$to};            # quite possibly undef!
    }
    return;
  }
  
  ###########################################################################
  
  sub linearize_tokens {  # self, tokens
    my $self = shift;
    my $out = '';
    
    my $t;
    while($t = shift @_) {
      if(!ref $t or !UNIVERSAL::can($t, 'is_text')) {
        $out .= $t; # a string, or some insane thing
      } elsif($t->is_text) {
        $out .= $t->text;
      } elsif($t->is_start and $t->tag eq 'X') {
        # Ignore until the end of this X<...> sequence:
        my $x_open = 1;
        while($x_open) {
          next if( ($t = shift @_)->is_text );
          if(   $t->is_start and $t->tag eq 'X') { ++$x_open }
          elsif($t->is_end   and $t->tag eq 'X') { --$x_open }
        }
      }
    }
    return undef if length $out > $Linearization_Limit;
    return $out;
  }
  
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  
  sub unicode_escape_url {
    my($self, $string) = @_;
    $string =~ s/([^\x00-\xFF])/'('.ord($1).')'/eg;
      #  Turn char 1234 into "(1234)"
    return $string;
  }
  
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  sub esc { # a function.
    if(defined wantarray) {
      if(wantarray) {
        @_ = splice @_; # break aliasing
      } else {
        my $x = shift;
        if ($] ge 5.007_003) {
          $x =~ s/([^-\n\t !\#\$\%\(\)\*\+,\.\~\/\:\;=\?\@\[\\\]\^_\`\{\|\}abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789])/'&#'.(utf8::native_to_unicode(ord($1))).';'/eg;
        } else { # Is broken for non-ASCII platforms on early perls
          $x =~ s/([^-\n\t !\#\$\%\(\)\*\+,\.\~\/\:\;=\?\@\[\\\]\^_\`\{\|\}abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789])/'&#'.(ord($1)).';'/eg;
        }
        return $x;
      }
    }
    foreach my $x (@_) {
      # Escape things very cautiously:
      if (defined $x) {
        if ($] ge 5.007_003) {
          $x =~ s/([^-\n\t !\#\$\%\(\)\*\+,\.\~\/\:\;=\?\@\[\\\]\^_\`\{\|\}abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789])/'&#'.(utf8::native_to_unicode(ord($1))).';'/eg
        } else { # Is broken for non-ASCII platforms on early perls
          $x =~ s/([^-\n\t !\#\$\%\(\)\*\+,\.\~\/\:\;=\?\@\[\\\]\^_\`\{\|\}abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789])/'&#'.(ord($1)).';'/eg
        }
      }
      # Leave out "- so that "--" won't make it thru in X-generated comments
      #  with text in them.
  
      # Yes, stipulate the list without a range, so that this can work right on
      #  all charsets that this module happens to run under.
    }
    return @_;
  }
  
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  
  1;
  __END__
  
  =head1 NAME
  
  Pod::Simple::HTML - convert Pod to HTML
  
  =head1 SYNOPSIS
  
    perl -MPod::Simple::HTML -e Pod::Simple::HTML::go thingy.pod
  
  
  =head1 DESCRIPTION
  
  This class is for making an HTML rendering of a Pod document.
  
  This is a subclass of L<Pod::Simple::PullParser> and inherits all its
  methods (and options).
  
  Note that if you want to do a batch conversion of a lot of Pod
  documents to HTML, you should see the module L<Pod::Simple::HTMLBatch>.
  
  
  
  =head1 CALLING FROM THE COMMAND LINE
  
  TODO
  
    perl -MPod::Simple::HTML -e Pod::Simple::HTML::go Thing.pod Thing.html
  
  
  
  =head1 CALLING FROM PERL
  
  =head2 Minimal code
  
    use Pod::Simple::HTML;
    my $p = Pod::Simple::HTML->new;
    $p->output_string(\my $html);
    $p->parse_file('path/to/Module/Name.pm');
    open my $out, '>', 'out.html' or die "Cannot open 'out.html': $!\n";
    print $out $html;
  
  =head2 More detailed example
  
    use Pod::Simple::HTML;
  
  Set the content type:
  
    $Pod::Simple::HTML::Content_decl =  q{<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" >};
  
    my $p = Pod::Simple::HTML->new;
  
  Include a single javascript source:
  
    $p->html_javascript('http://abc.com/a.js');
  
  Or insert multiple javascript source in the header 
  (or for that matter include anything, thought this is not recommended)
  
    $p->html_javascript('
        <script type="text/javascript" src="http://abc.com/b.js"></script>
        <script type="text/javascript" src="http://abc.com/c.js"></script>');
  
  Include a single css source in the header:
  
    $p->html_css('/style.css');
  
  or insert multiple css sources:
  
    $p->html_css('
        <link rel="stylesheet" type="text/css" title="pod_stylesheet" href="http://remote.server.com/jquery.css">
        <link rel="stylesheet" type="text/css" title="pod_stylesheet" href="/style.css">');
  
  Tell the parser where should the output go. In this case it will be placed in the $html variable:
  
    my $html;
    $p->output_string(\$html);
  
  Parse and process a file with pod in it:
  
    $p->parse_file('path/to/Module/Name.pm');
  
  =head1 METHODS
  
  TODO
  all (most?) accessorized methods
  
  The following variables need to be set B<before> the call to the ->new constructor.
  
  Set the string that is included before the opening <html> tag:
  
    $Pod::Simple::HTML::Doctype_decl = qq{<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" 
  	 "http://www.w3.org/TR/html4/loose.dtd">\n};
  
  Set the content-type in the HTML head: (defaults to ISO-8859-1)
  
    $Pod::Simple::HTML::Content_decl =  q{<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" >};
  
  Set the value that will be embedded in the opening tags of F, C tags and verbatim text.
  F maps to <em>, C maps to <code>, Verbatim text maps to <pre> (Computerese defaults to "")
  
    $Pod::Simple::HTML::Computerese =  ' class="some_class_name';
  
  =head2 html_css
  
  =head2 html_javascript
  
  =head2 title_prefix
  
  =head2 title_postfix
  
  =head2 html_header_before_title
  
  This includes everything before the <title> opening tag including the Document type
  and including the opening <title> tag. The following call will set it to be a simple HTML
  file:
  
    $p->html_header_before_title('<html><head><title>');
  
  =head2 top_anchor
  
  By default Pod::Simple::HTML adds a dummy anchor at the top of the HTML.
  You can change it by calling
  
    $p->top_anchor('<a name="zz" >');
  
  =head2 html_h_level
  
  Normally =head1 will become <h1>, =head2 will become <h2> etc.
  Using the html_h_level method will change these levels setting the h level
  of =head1 tags:
  
    $p->html_h_level(3);
  
  Will make sure that =head1 will become <h3> and =head2 will become <h4> etc...
  
  
  =head2 index
  
  Set it to some true value if you want to have an index (in reality a table of contents)
  to be added at the top of the generated HTML.
  
    $p->index(1);
  
  =head2 html_header_after_title
  
  Includes the closing tag of </title> and through the rest of the head
  till the opening of the body
  
    $p->html_header_after_title('</title>...</head><body id="my_id">');
  
  =head2 html_footer
  
  The very end of the document:
  
    $p->html_footer( qq[\n<!-- end doc -->\n\n</body></html>\n] );
  
  =head1 SUBCLASSING
  
  Can use any of the methods described above but for further customization
  one needs to override some of the methods:
  
    package My::Pod;
    use strict;
    use warnings;
  
    use base 'Pod::Simple::HTML';
  
    # needs to return a URL string such
    # http://some.other.com/page.html
    # #anchor_in_the_same_file
    # /internal/ref.html
    sub do_pod_link {
      # My::Pod object and Pod::Simple::PullParserStartToken object
      my ($self, $link) = @_;
  
      say $link->tagname;          # will be L for links
      say $link->attr('to');       # 
      say $link->attr('type');     # will be 'pod' always
      say $link->attr('section');
  
      # Links local to our web site
      if ($link->tagname eq 'L' and $link->attr('type') eq 'pod') {
        my $to = $link->attr('to');
        if ($to =~ /^Padre::/) {
            $to =~ s{::}{/}g;
            return "/docs/Padre/$to.html";
        }
      }
  
      # all other links are generated by the parent class
      my $ret = $self->SUPER::do_pod_link($link);
      return $ret;
    }
  
    1;
  
  Meanwhile in script.pl:
  
    use My::Pod;
  
    my $p = My::Pod->new;
  
    my $html;
    $p->output_string(\$html);
    $p->parse_file('path/to/Module/Name.pm');
    open my $out, '>', 'out.html' or die;
    print $out $html;
  
  TODO
  
  maybe override do_beginning do_end
  
  =head1 SEE ALSO
  
  L<Pod::Simple>, L<Pod::Simple::HTMLBatch>
  
  TODO: a corpus of sample Pod input and HTML output?  Or common
  idioms?
  
  =head1 SUPPORT
  
  Questions or discussion about POD and Pod::Simple should be sent to the
  pod-people@perl.org mail list. Send an empty email to
  pod-people-subscribe@perl.org to subscribe.
  
  This module is managed in an open GitHub repository,
  L<https://github.com/perl-pod/pod-simple/>. Feel free to fork and contribute, or
  to clone L<git://github.com/perl-pod/pod-simple.git> and send patches!
  
  Patches against Pod::Simple are welcome. Please send bug reports to
  <bug-pod-simple@rt.cpan.org>.
  
  =head1 COPYRIGHT AND DISCLAIMERS
  
  Copyright (c) 2002-2004 Sean M. Burke.
  
  This library is free software; you can redistribute it and/or modify it
  under the same terms as Perl itself.
  
  This program is distributed in the hope that it will be useful, but
  without any warranty; without even the implied warranty of
  merchantability or fitness for a particular purpose.
  
  =head1 ACKNOWLEDGEMENTS
  
  Thanks to L<Hurricane Electric|http://he.net/> for permission to use its
  L<Linux man pages online|http://man.he.net/> site for man page links.
  
  Thanks to L<search.cpan.org|http://search.cpan.org/> for permission to use the
  site for Perl module links.
  
  =head1 AUTHOR
  
  Pod::Simple was created by Sean M. Burke <sburke@cpan.org>.
  But don't bother him, he's retired.
  
  Pod::Simple is maintained by:
  
  =over
  
  =item * Allison Randal C<allison@perl.org>
  
  =item * Hans Dieter Pearcey C<hdp@cpan.org>
  
  =item * David E. Wheeler C<dwheeler@cpan.org>
  
  =back
  
  =cut
POD_SIMPLE_HTML

$fatpacked{"Pod/Simple/HTMLBatch.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POD_SIMPLE_HTMLBATCH';
  
  require 5;
  package Pod::Simple::HTMLBatch;
  use strict;
  use vars qw( $VERSION $HTML_RENDER_CLASS $HTML_EXTENSION
   $CSS $JAVASCRIPT $SLEEPY $SEARCH_CLASS @ISA
  );
  $VERSION = '3.35';
  @ISA = ();  # Yup, we're NOT a subclass of Pod::Simple::HTML!
  
  # TODO: nocontents stylesheets. Strike some of the color variations?
  
  use Pod::Simple::HTML ();
  BEGIN {*esc = \&Pod::Simple::HTML::esc }
  use File::Spec ();
  
  use Pod::Simple::Search;
  $SEARCH_CLASS ||= 'Pod::Simple::Search';
  
  BEGIN {
    if(defined &DEBUG) { } # no-op
    elsif( defined &Pod::Simple::DEBUG ) { *DEBUG = \&Pod::Simple::DEBUG }
    else { *DEBUG = sub () {0}; }
  }
  
  $SLEEPY = 1 if !defined $SLEEPY and $^O =~ /mswin|mac/i;
  # flag to occasionally sleep for $SLEEPY - 1 seconds.
  
  $HTML_RENDER_CLASS ||= "Pod::Simple::HTML";
  
  #
  # Methods beginning with "_" are particularly internal and possibly ugly.
  #
  
  Pod::Simple::_accessorize( __PACKAGE__,
   'verbose', # how verbose to be during batch conversion
   'html_render_class', # what class to use to render
   'search_class', # what to use to search for POD documents
   'contents_file', # If set, should be the name of a file (in current directory)
                    # to write the list of all modules to
   'index', # will set $htmlpage->index(...) to this (true or false)
   'progress', # progress object
   'contents_page_start',  'contents_page_end',
  
   'css_flurry', '_css_wad', 'javascript_flurry', '_javascript_wad',
   'no_contents_links', # set to true to suppress automatic adding of << links.
   '_contents',
  );
  
  # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  # Just so we can run from the command line more easily
  sub go {
    @ARGV == 2 or die sprintf(
      "Usage: perl -M%s -e %s:go indirs outdir\n  (or use \"\@INC\" for indirs)\n",
      __PACKAGE__, __PACKAGE__, 
    );
    
    if(defined($ARGV[1]) and length($ARGV[1])) {
      my $d = $ARGV[1];
      -e $d or die "I see no output directory named \"$d\"\nAborting";
      -d $d or die "But \"$d\" isn't a directory!\nAborting";
      -w $d or die "Directory \"$d\" isn't writeable!\nAborting";
    }
    
    __PACKAGE__->batch_convert(@ARGV);
  }
  # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  
  
  sub new {
    my $new = bless {}, ref($_[0]) || $_[0];
    $new->html_render_class($HTML_RENDER_CLASS);
    $new->search_class($SEARCH_CLASS);
    $new->verbose(1 + DEBUG);
    $new->_contents([]);
    
    $new->index(1);
  
    $new->       _css_wad([]);         $new->css_flurry(1);
    $new->_javascript_wad([]);  $new->javascript_flurry(1);
    
    $new->contents_file(
      'index' . ($HTML_EXTENSION || $Pod::Simple::HTML::HTML_EXTENSION)
    );
    
    $new->contents_page_start( join "\n", grep $_,
      $Pod::Simple::HTML::Doctype_decl,
      "<html><head>",
      "<title>Perl Documentation</title>",
      $Pod::Simple::HTML::Content_decl,
      "</head>",
      "\n<body class='contentspage'>\n<h1>Perl Documentation</h1>\n"
    ); # override if you need a different title
    
    
    $new->contents_page_end( sprintf(
      "\n\n<p class='contentsfooty'>Generated by %s v%s under Perl v%s\n<br >At %s GMT, which is %s local time.</p>\n\n</body></html>\n",
      esc(
        ref($new),
        eval {$new->VERSION} || $VERSION,
        $], scalar(gmtime), scalar(localtime), 
    )));
  
    return $new;
  }
  
  # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  
  sub muse {
    my $self = shift;
    if($self->verbose) {
      print 'T+', int(time() - $self->{'_batch_start_time'}), "s: ", @_, "\n";
    }
    return 1;
  }
  
  # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  
  sub batch_convert {
    my($self, $dirs, $outdir) = @_;
    $self ||= __PACKAGE__; # tolerate being called as an optionless function
    $self = $self->new unless ref $self; # tolerate being used as a class method
  
    if(!defined($dirs)  or  $dirs eq ''  or  $dirs eq '@INC' ) {
      $dirs = '';
    } elsif(ref $dirs) {
      # OK, it's an explicit set of dirs to scan, specified as an arrayref.
    } else {
      # OK, it's an explicit set of dirs to scan, specified as a
      #  string like "/thing:/also:/whatever/perl" (":"-delim, as usual)
      #  or, under MSWin, like "c:/thing;d:/also;c:/whatever/perl" (";"-delim!)
      require Config;
      my $ps = quotemeta( $Config::Config{'path_sep'} || ":" );
      $dirs = [ grep length($_), split qr/$ps/, $dirs ];
    }
  
    $outdir = $self->filespecsys->curdir
     unless defined $outdir and length $outdir;
  
    $self->_batch_convert_main($dirs, $outdir);
  }
  
  # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  
  sub _batch_convert_main {
    my($self, $dirs, $outdir) = @_;
    # $dirs is either false, or an arrayref.    
    # $outdir is a pathspec.
    
    $self->{'_batch_start_time'} ||= time();
  
    $self->muse( "= ", scalar(localtime) );
    $self->muse( "Starting batch conversion to \"$outdir\"" );
  
    my $progress = $self->progress;
    if(!$progress and $self->verbose > 0 and $self->verbose() <= 5) {
      require Pod::Simple::Progress;
      $progress = Pod::Simple::Progress->new(
          ($self->verbose  < 2) ? () # Default omission-delay
        : ($self->verbose == 2) ? 1  # Reduce the omission-delay
                                : 0  # Eliminate the omission-delay
      );
      $self->progress($progress);
    }
    
    if($dirs) {
      $self->muse(scalar(@$dirs), " dirs to scan: @$dirs");
    } else {
      $self->muse("Scanning \@INC.  This could take a minute or two.");
    }
    my $mod2path = $self->find_all_pods($dirs ? $dirs : ());
    $self->muse("Done scanning.");
  
    my $total = keys %$mod2path;
    unless($total) {
      $self->muse("No pod found.  Aborting batch conversion.\n");
      return $self;
    }
  
    $progress and $progress->goal($total);
    $self->muse("Now converting pod files to HTML.",
      ($total > 25) ? "  This will take a while more." : ()
    );
  
    $self->_spray_css(        $outdir );
    $self->_spray_javascript( $outdir );
  
    $self->_do_all_batch_conversions($mod2path, $outdir);
  
    $progress and $progress->done(sprintf (
      "Done converting %d files.",  $self->{"__batch_conv_page_count"}
    ));
    return $self->_batch_convert_finish($outdir);
    return $self;
  }
  
  
  sub _do_all_batch_conversions {
    my($self, $mod2path, $outdir) = @_;
    $self->{"__batch_conv_page_count"} = 0;
  
    foreach my $module (sort {lc($a) cmp lc($b)} keys %$mod2path) {
      $self->_do_one_batch_conversion($module, $mod2path, $outdir);
      sleep($SLEEPY - 1) if $SLEEPY;
    }
  
    return;
  }
  
  sub _batch_convert_finish {
    my($self, $outdir) = @_;
    $self->write_contents_file($outdir);
    $self->muse("Done with batch conversion.  $$self{'__batch_conv_page_count'} files done.");
    $self->muse( "= ", scalar(localtime) );
    $self->progress and $self->progress->done("All done!");
    return;
  }
  
  # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  
  sub _do_one_batch_conversion {
    my($self, $module, $mod2path, $outdir, $outfile) = @_;
  
    my $retval;
    my $total    = scalar keys %$mod2path;
    my $infile   = $mod2path->{$module};
    my @namelets = grep m/\S/, split "::", $module;
          # this can stick around in the contents LoL
    my $depth    = scalar @namelets;
    die "Contentless thingie?! $module $infile" unless @namelets; #sanity
      
    $outfile  ||= do {
      my @n = @namelets;
      $n[-1] .= $HTML_EXTENSION || $Pod::Simple::HTML::HTML_EXTENSION;
      $self->filespecsys->catfile( $outdir, @n );
    };
  
    my $progress = $self->progress;
  
    my $page = $self->html_render_class->new;
    if(DEBUG > 5) {
      $self->muse($self->{"__batch_conv_page_count"} + 1, "/$total: ",
        ref($page), " render ($depth) $module => $outfile");
    } elsif(DEBUG > 2) {
      $self->muse($self->{"__batch_conv_page_count"} + 1, "/$total: $module => $outfile")
    }
  
    # Give each class a chance to init the converter:
    $page->batch_mode_page_object_init($self, $module, $infile, $outfile, $depth)
     if $page->can('batch_mode_page_object_init');
    # Init for the index (TOC), too.
    $self->batch_mode_page_object_init($page, $module, $infile, $outfile, $depth)
     if $self->can('batch_mode_page_object_init');
      
    # Now get busy...
    $self->makepath($outdir => \@namelets);
  
    $progress and $progress->reach($self->{"__batch_conv_page_count"}, "Rendering $module");
  
    if( $retval = $page->parse_from_file($infile, $outfile) ) {
      ++ $self->{"__batch_conv_page_count"} ;
      $self->note_for_contents_file( \@namelets, $infile, $outfile );
    } else {
      $self->muse("Odd, parse_from_file(\"$infile\", \"$outfile\") returned false.");
    }
  
    $page->batch_mode_page_object_kill($self, $module, $infile, $outfile, $depth)
     if $page->can('batch_mode_page_object_kill');
    # The following isn't a typo.  Note that it switches $self and $page.
    $self->batch_mode_page_object_kill($page, $module, $infile, $outfile, $depth)
     if $self->can('batch_mode_page_object_kill');
      
    DEBUG > 4 and printf STDERR "%s %sb < $infile %s %sb\n",
       $outfile, -s $outfile, $infile, -s $infile
    ;
  
    undef($page);
    return $retval;
  }
  
  # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  sub filespecsys { $_[0]{'_filespecsys'} || 'File::Spec' }
  
  # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  
  sub note_for_contents_file {
    my($self, $namelets, $infile, $outfile) = @_;
  
    # I think the infile and outfile parts are never used. -- SMB
    # But it's handy to have them around for debugging.
  
    if( $self->contents_file ) {
      my $c = $self->_contents();
      push @$c,
       [ join("::", @$namelets), $infile, $outfile, $namelets ]
       #            0               1         2         3
      ;
      DEBUG > 3 and print STDERR "Noting @$c[-1]\n";
    }
    return;
  }
  
  #_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-
  
  sub write_contents_file {
    my($self, $outdir) = @_;
    my $outfile  = $self->_contents_filespec($outdir) || return;
  
    $self->muse("Preparing list of modules for ToC");
  
    my($toplevel,           # maps  toplevelbit => [all submodules]
       $toplevel_form_freq, # ends up being  'foo' => 'Foo'
      ) = $self->_prep_contents_breakdown;
  
    my $Contents = eval { $self->_wopen($outfile) };
    if( $Contents ) {
      $self->muse( "Writing contents file $outfile" );
    } else {
      warn "Couldn't write-open contents file $outfile: $!\nAbort writing to $outfile at all";
      return;
    }
  
    $self->_write_contents_start(  $Contents, $outfile, );
    $self->_write_contents_middle( $Contents, $outfile, $toplevel, $toplevel_form_freq );
    $self->_write_contents_end(    $Contents, $outfile, );
    return $outfile;
  }
  
  # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  
  sub _write_contents_start {
    my($self, $Contents, $outfile) = @_;
    my $starter = $self->contents_page_start || '';
    
    {
      my $css_wad = $self->_css_wad_to_markup(1);
      if( $css_wad ) {
        $starter =~ s{(</head>)}{\n$css_wad\n$1}i;  # otherwise nevermind
      }
      
      my $javascript_wad = $self->_javascript_wad_to_markup(1);
      if( $javascript_wad ) {
        $starter =~ s{(</head>)}{\n$javascript_wad\n$1}i;   # otherwise nevermind
      }
    }
  
    unless(print $Contents $starter, "<dl class='superindex'>\n" ) {
      warn "Couldn't print to $outfile: $!\nAbort writing to $outfile at all";
      close($Contents);
      return 0;
    }
    return 1;
  }
  
  # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  
  sub _write_contents_middle {
    my($self, $Contents, $outfile, $toplevel2submodules, $toplevel_form_freq) = @_;
  
    foreach my $t (sort keys %$toplevel2submodules) {
      my @downlines = sort {$a->[-1] cmp $b->[-1]}
                            @{ $toplevel2submodules->{$t} };
      
      printf $Contents qq[<dt><a name="%s">%s</a></dt>\n<dd>\n],
        esc( $t, $toplevel_form_freq->{$t} )
      ;
      
      my($path, $name);
      foreach my $e (@downlines) {
        $name = $e->[0];
        $path = join( "/", '.', esc( @{$e->[3]} ) )
          . ($HTML_EXTENSION || $Pod::Simple::HTML::HTML_EXTENSION);
        print $Contents qq{  <a href="$path">}, esc($name), "</a>&nbsp;&nbsp;\n";
      }
      print $Contents "</dd>\n\n";
    }
    return 1;
  }
  
  # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  
  sub _write_contents_end {
    my($self, $Contents, $outfile) = @_;
    unless(
      print $Contents "</dl>\n",
        $self->contents_page_end || '',
    ) {
      warn "Couldn't write to $outfile: $!";
    }
    close($Contents) or warn "Couldn't close $outfile: $!";
    return 1;
  }
  
  # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  
  sub _prep_contents_breakdown {
    my($self) = @_;
    my $contents = $self->_contents;
    my %toplevel; # maps  lctoplevelbit => [all submodules]
    my %toplevel_form_freq; # ends up being  'foo' => 'Foo'
                                 # (mapping anycase forms to most freq form)
    
    foreach my $entry (@$contents) {
      my $toplevel = 
        $entry->[0] =~ m/^perl\w*$/ ? 'perl_core_docs'
            # group all the perlwhatever docs together
        : $entry->[3][0] # normal case
      ;
      ++$toplevel_form_freq{ lc $toplevel }{ $toplevel };
      push @{ $toplevel{ lc $toplevel } }, $entry;
      push @$entry, lc($entry->[0]); # add a sort-order key to the end
    }
  
    foreach my $toplevel (sort keys %toplevel) {
      my $fgroup = $toplevel_form_freq{$toplevel};
      $toplevel_form_freq{$toplevel} =
      (
        sort { $fgroup->{$b} <=> $fgroup->{$a}  or  $a cmp $b }
          keys %$fgroup
        # This hash is extremely unlikely to have more than 4 members, so this
        # sort isn't so very wasteful
      )[0];
    }
  
    return(\%toplevel, \%toplevel_form_freq) if wantarray;
    return \%toplevel;
  }
  
  # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  
  sub _contents_filespec {
    my($self, $outdir) = @_;
    my $outfile = $self->contents_file;
    return unless $outfile;
    return $self->filespecsys->catfile( $outdir, $outfile );
  }
  
  #_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-
  
  sub makepath {
    my($self, $outdir, $namelets) = @_;
    return unless @$namelets > 1;
    for my $i (0 .. ($#$namelets - 1)) {
      my $dir = $self->filespecsys->catdir( $outdir, @$namelets[0 .. $i] );
      if(-e $dir) {
        die "$dir exists but not as a directory!?" unless -d $dir;
        next;
      }
      DEBUG > 3 and print STDERR "  Making $dir\n";
      mkdir $dir, 0777
       or die "Can't mkdir $dir: $!\nAborting"
      ;
    }
    return;
  }
  
  #_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-
  
  sub batch_mode_page_object_init {
    my $self = shift;
    my($page, $module, $infile, $outfile, $depth) = @_;
    
    # TODO: any further options to percolate onto this new object here?
  
    $page->default_title($module);
    $page->index( $self->index );
  
    $page->html_css(        $self->       _css_wad_to_markup($depth) );
    $page->html_javascript( $self->_javascript_wad_to_markup($depth) );
  
    $self->add_header_backlink($page, $module, $infile, $outfile, $depth);
    $self->add_footer_backlink($page, $module, $infile, $outfile, $depth);
  
  
    return $self;
  }
  
  # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  
  sub add_header_backlink {
    my $self = shift;
    return if $self->no_contents_links;
    my($page, $module, $infile, $outfile, $depth) = @_;
    $page->html_header_after_title( join '',
      $page->html_header_after_title || '',
  
      qq[<p class="backlinktop"><b><a name="___top" href="],
      $self->url_up_to_contents($depth),
      qq[" accesskey="1" title="All Documents">&lt;&lt;</a></b></p>\n],
    )
     if $self->contents_file
    ;
    return;
  }
  
  sub add_footer_backlink {
    my $self = shift;
    return if $self->no_contents_links;
    my($page, $module, $infile, $outfile, $depth) = @_;
    $page->html_footer( join '',
      qq[<p class="backlinkbottom"><b><a name="___bottom" href="],
      $self->url_up_to_contents($depth),
      qq[" title="All Documents">&lt;&lt;</a></b></p>\n],
      
      $page->html_footer || '',
    )
     if $self->contents_file
    ;
    return;
  }
  
  sub url_up_to_contents {
    my($self, $depth) = @_;
    --$depth;
    return join '/', ('..') x $depth, esc($self->contents_file);
  }
  
  #_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-
  
  sub find_all_pods {
    my($self, $dirs) = @_;
    # You can override find_all_pods in a subclass if you want to
    #  do extra filtering or whatnot.  But for the moment, we just
    #  pass to modnames2paths:
    return $self->modnames2paths($dirs);
  }
  
  #_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-
  
  sub modnames2paths { # return a hashref mapping modulenames => paths
    my($self, $dirs) = @_;
  
    my $m2p;
    {
      my $search = $self->search_class->new;
      DEBUG and print STDERR "Searching via $search\n";
      $search->verbose(1) if DEBUG > 10;
      $search->progress( $self->progress->copy->goal(0) ) if $self->progress;
      $search->shadows(0);  # don't bother noting shadowed files
      $search->inc(     $dirs ? 0      :  1 );
      $search->survey(  $dirs ? @$dirs : () );
      $m2p = $search->name2path;
      die "What, no name2path?!" unless $m2p;
    }
  
    $self->muse("That's odd... no modules found!") unless keys %$m2p;
    if( DEBUG > 4 ) {
      print STDERR "Modules found (name => path):\n";
      foreach my $m (sort {lc($a) cmp lc($b)} keys %$m2p) {
        print STDERR "  $m  $$m2p{$m}\n";
      }
      print STDERR "(total ",     scalar(keys %$m2p), ")\n\n";
    } elsif( DEBUG ) {
      print STDERR      "Found ", scalar(keys %$m2p), " modules.\n";
    }
    $self->muse( "Found ", scalar(keys %$m2p), " modules." );
    
    # return the Foo::Bar => /whatever/Foo/Bar.pod|pm hashref
    return $m2p;
  }
  
  #===========================================================================
  
  sub _wopen {
    # this is abstracted out so that the daemon class can override it
    my($self, $outpath) = @_;
    require Symbol;
    my $out_fh = Symbol::gensym();
    DEBUG > 5 and print STDERR "Write-opening to $outpath\n";
    return $out_fh if open($out_fh, "> $outpath");
    require Carp;  
    Carp::croak("Can't write-open $outpath: $!");
  }
  
  #==========================================================================
  
  sub add_css {
    my($self, $url, $is_default, $name, $content_type, $media, $_code) = @_;
    return unless $url;
    unless($name) {
      # cook up a reasonable name based on the URL
      $name = $url;
      if( $name !~ m/\?/ and $name =~ m{([^/]+)$}s ) {
        $name = $1;
        $name =~ s/\.css//i;
      }
    }
    $media        ||= 'all';
    $content_type ||= 'text/css';
    
    my $bunch = [$url, $name, $content_type, $media, $_code];
    if($is_default) { unshift @{ $self->_css_wad }, $bunch }
    else            { push    @{ $self->_css_wad }, $bunch }
    return;
  }
  
  # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  
  sub _spray_css {
    my($self, $outdir) = @_;
  
    return unless $self->css_flurry();
    $self->_gen_css_wad();
  
    my $lol = $self->_css_wad;
    foreach my $chunk (@$lol) {
      my $url = $chunk->[0];
      my $outfile;
      if( ref($chunk->[-1]) and $url =~ m{^(_[-a-z0-9_]+\.css$)} ) {
        $outfile = $self->filespecsys->catfile( $outdir, "$1" );
        DEBUG > 5 and print STDERR "Noting $$chunk[0] as a file I'll create.\n";
      } else {
        DEBUG > 5 and print STDERR "OK, noting $$chunk[0] as an external CSS.\n";
        # Requires no further attention.
        next;
      }
      
      #$self->muse( "Writing autogenerated CSS file $outfile" );
      my $Cssout = $self->_wopen($outfile);
      print $Cssout ${$chunk->[-1]}
       or warn "Couldn't print to $outfile: $!\nAbort writing to $outfile at all";
      close($Cssout);
      DEBUG > 5 and print STDERR "Wrote $outfile\n";
    }
  
    return;
  }
  
  # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  
  sub _css_wad_to_markup {
    my($self, $depth) = @_;
    
    my @css  = @{ $self->_css_wad || return '' };
    return '' unless @css;
    
    my $rel = 'stylesheet';
    my $out = '';
  
    --$depth;
    my $uplink = $depth ? ('../' x $depth) : '';
  
    foreach my $chunk (@css) {
      next unless $chunk and @$chunk;
  
      my( $url1, $url2, $title, $type, $media) = (
        $self->_maybe_uplink( $chunk->[0], $uplink ),
        esc(grep !ref($_), @$chunk)
      );
  
      $out .= qq{<link rel="$rel" title="$title" type="$type" href="$url1$url2" media="$media" >\n};
  
      $rel = 'alternate stylesheet'; # alternates = all non-first iterations
    }
    return $out;
  }
  
  # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  sub _maybe_uplink {
    # if the given URL looks relative, return the given uplink string --
    # otherwise return emptystring
    my($self, $url, $uplink) = @_;
    ($url =~ m{^\./} or $url !~ m{[/\:]} )
      ? $uplink
      : ''
      # qualify it, if/as needed
  }
  
  # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  sub _gen_css_wad {
    my $self = $_[0];
    my $css_template = $self->_css_template;
    foreach my $variation (
  
     # Commented out for sake of concision:
     #
     #  011n=black_with_red_on_white
     #  001n=black_with_yellow_on_white
     #  101n=black_with_green_on_white
     #  110=white_with_yellow_on_black
     #  010=white_with_green_on_black
     #  011=white_with_blue_on_black
     #  100=white_with_red_on_black
      '110n=blkbluw',  # black_with_blue_on_white
      '010n=blkmagw',  # black_with_magenta_on_white
      '100n=blkcynw',  # black_with_cyan_on_white
      '101=whtprpk',   # white_with_purple_on_black
      '001=whtnavk',   # white_with_navy_blue_on_black
      '010a=grygrnk',  # grey_with_green_on_black
      '010b=whtgrng',  # white_with_green_on_grey
      '101an=blkgrng', # black_with_green_on_grey
      '101bn=grygrnw', # grey_with_green_on_white
    ) {
  
      my $outname = $variation;
      my($flipmode, @swap) = ( ($4 || ''), $1,$2,$3)
        if $outname =~ s/^([012])([012])([[012])([a-z]*)=?//s;
      @swap = () if '010' eq join '', @swap; # 010 is a swop-no-op!
    
      my $this_css =
        "/* This file is autogenerated.  Do not edit.  $variation */\n\n"
        . $css_template;
  
      # Only look at three-digitty colors, for now at least.
      if( $flipmode =~ m/n/ ) {
        $this_css =~ s/(#[0-9a-fA-F]{3})\b/_color_negate($1)/eg;
        $this_css =~ s/\bthin\b/medium/g;
      }
      $this_css =~ s<#([0-9a-fA-F])([0-9a-fA-F])([0-9a-fA-F])\b>
                    < join '', '#', ($1,$2,$3)[@swap] >eg   if @swap;
  
      if(   $flipmode =~ m/a/)
         { $this_css =~ s/#fff\b/#999/gi } # black -> dark grey
      elsif($flipmode =~ m/b/)
         { $this_css =~ s/#000\b/#666/gi } # white -> light grey
  
      my $name = $outname;    
      $name =~ tr/-_/  /;
      $self->add_css( "_$outname.css", 0, $name, 0, 0, \$this_css);
    }
  
    # Now a few indexless variations:
    foreach my $variation (
        'blkbluw', # black_with_blue_on_white
        'whtpurk', # white_with_purple_on_black
        'whtgrng', # white_with_green_on_grey
        'grygrnw', # grey_with_green_on_white
    ) {
      my $outname = $variation;
      my $this_css = join "\n",
        "/* This file is autogenerated.  Do not edit.  $outname */\n",
        "\@import url(\"./_$variation.css\");",
        ".indexgroup { display: none; }",
        "\n",
      ;
      my $name = $outname;    
      $name =~ tr/-_/  /;
      $self->add_css( "_$outname.css", 0, $name, 0, 0, \$this_css);
    }
  
    return;
  }
  
  sub _color_negate {
    my $x = lc $_[0];
    $x =~ tr[0123456789abcdef]
            [fedcba9876543210];
    return $x;
  }
  
  #===========================================================================
  
  sub add_javascript {
    my($self, $url, $content_type, $_code) = @_;
    return unless $url;
    push  @{ $self->_javascript_wad }, [
      $url, $content_type || 'text/javascript', $_code
    ];
    return;
  }
  
  sub _spray_javascript {
    my($self, $outdir) = @_;
    return unless $self->javascript_flurry();
    $self->_gen_javascript_wad();
  
    my $lol = $self->_javascript_wad;
    foreach my $script (@$lol) {
      my $url = $script->[0];
      my $outfile;
      
      if( ref($script->[-1]) and $url =~ m{^(_[-a-z0-9_]+\.js$)} ) {
        $outfile = $self->filespecsys->catfile( $outdir, "$1" );
        DEBUG > 5 and print STDERR "Noting $$script[0] as a file I'll create.\n";
      } else {
        DEBUG > 5 and print STDERR "OK, noting $$script[0] as an external JavaScript.\n";
        next;
      }
      
      #$self->muse( "Writing JavaScript file $outfile" );
      my $Jsout = $self->_wopen($outfile);
  
      print $Jsout ${$script->[-1]}
       or warn "Couldn't print to $outfile: $!\nAbort writing to $outfile at all";
      close($Jsout);
      DEBUG > 5 and print STDERR "Wrote $outfile\n";
    }
  
    return;
  }
  
  sub _gen_javascript_wad {
    my $self = $_[0];
    my $js_code = $self->_javascript || return;
    $self->add_javascript( "_podly.js", 0, \$js_code);
    return;
  }
  
  sub _javascript_wad_to_markup {
    my($self, $depth) = @_;
    
    my @scripts  = @{ $self->_javascript_wad || return '' };
    return '' unless @scripts;
    
    my $out = '';
  
    --$depth;
    my $uplink = $depth ? ('../' x $depth) : '';
  
    foreach my $s (@scripts) {
      next unless $s and @$s;
  
      my( $url1, $url2, $type, $media) = (
        $self->_maybe_uplink( $s->[0], $uplink ),
        esc(grep !ref($_), @$s)
      );
  
      $out .= qq{<script type="$type" src="$url1$url2"></script>\n};
    }
    return $out;
  }
  
  #===========================================================================
  
  sub _css_template { return $CSS }
  sub _javascript   { return $JAVASCRIPT }
  
  $CSS = <<'EOCSS';
  /* For accessibility reasons, never specify text sizes in px/pt/pc/in/cm/mm */
  
  @media all { .hide { display: none; } }
  
  @media print {
    .noprint, div.indexgroup, .backlinktop, .backlinkbottom { display: none }
  
    * {
      border-color: black !important;
      color: black !important;
      background-color: transparent !important;
      background-image: none !important;
    }
  
    dl.superindex > dd  {
      word-spacing: .6em;
    }
  }
  
  @media aural, braille, embossed {
    div.indexgroup  { display: none; }  /* Too noisy, don't you think? */
    dl.superindex > dt:before { content: "Group ";  }
    dl.superindex > dt:after  { content: " contains:"; }
    .backlinktop    a:before  { content: "Back to contents"; }
    .backlinkbottom a:before  { content: "Back to contents"; }
  }
  
  @media aural {
    dl.superindex > dt  { pause-before: 600ms; }
  }
  
  @media screen, tty, tv, projection {
    .noscreen { display: none; }
  
    a:link    { color: #7070ff; text-decoration: underline; }
    a:visited { color: #e030ff; text-decoration: underline; }
    a:active  { color: #800000; text-decoration: underline; }
    body.contentspage a            { text-decoration: none; }
    a.u { color: #fff !important; text-decoration: none; }
  
    body.pod {
      margin: 0 5px;
      color:            #fff;
      background-color: #000;
    }
  
    body.pod h1, body.pod h2, body.pod h3, body.pod h4  {
      font-family: Tahoma, Verdana, Helvetica, Arial, sans-serif;
      font-weight: normal;
      margin-top: 1.2em;
      margin-bottom: .1em;
      border-top: thin solid transparent;
      /* margin-left: -5px;  border-left: 2px #7070ff solid;  padding-left: 3px; */
    }
    
    body.pod h1  { border-top-color: #0a0; }
    body.pod h2  { border-top-color: #080; }
    body.pod h3  { border-top-color: #040; }
    body.pod h4  { border-top-color: #010; }
  
    p.backlinktop + h1 { border-top: none; margin-top: 0em;  }
    p.backlinktop + h2 { border-top: none; margin-top: 0em;  }
    p.backlinktop + h3 { border-top: none; margin-top: 0em;  }
    p.backlinktop + h4 { border-top: none; margin-top: 0em;  }
  
    body.pod dt {
      font-size: 105%; /* just a wee bit more than normal */
    }
  
    .indexgroup { font-size: 80%; }
  
    .backlinktop,   .backlinkbottom    {
      margin-left:  -5px;
      margin-right: -5px;
      background-color:         #040;
      border-top:    thin solid #050;
      border-bottom: thin solid #050;
    }
    
    .backlinktop a, .backlinkbottom a  {
      text-decoration: none;
      color: #080;
      background-color:  #000;
      border: thin solid #0d0;
    }
    .backlinkbottom { margin-bottom: 0; padding-bottom: 0; }
    .backlinktop    { margin-top:    0; padding-top:    0; }
  
    body.contentspage {
      color:            #fff;
      background-color: #000;
    }
    
    body.contentspage h1  {
      color:            #0d0;
      margin-left: 1em;
      margin-right: 1em;
      text-indent: -.9em;
      font-family: Tahoma, Verdana, Helvetica, Arial, sans-serif;
      font-weight: normal;
      border-top:    thin solid #fff;
      border-bottom: thin solid #fff;
      text-align: center;
    }
  
    dl.superindex > dt  {
      font-family: Tahoma, Verdana, Helvetica, Arial, sans-serif;
      font-weight: normal;
      font-size: 90%;
      margin-top: .45em;
      /* margin-bottom: -.15em; */
    }
    dl.superindex > dd  {
      word-spacing: .6em;    /* most important rule here! */
    }
    dl.superindex > a:link  {
      text-decoration: none;
      color: #fff;
    }
  
    .contentsfooty {
      border-top: thin solid #999;
      font-size: 90%;
    }
    
  }
  
  /* The End */
  
  EOCSS
  
  #==========================================================================
  
  $JAVASCRIPT = <<'EOJAVASCRIPT';
  
  // From http://www.alistapart.com/articles/alternate/
  
  function setActiveStyleSheet(title) {
    var i, a, main;
    for(i=0  ;  (a = document.getElementsByTagName("link")[i])  ;  i++) {
      if(a.getAttribute("rel").indexOf("style") != -1 && a.getAttribute("title")) {
        a.disabled = true;
        if(a.getAttribute("title") == title) a.disabled = false;
      }
    }
  }
  
  function getActiveStyleSheet() {
    var i, a;
    for(i=0  ;  (a = document.getElementsByTagName("link")[i])  ;  i++) {
      if(   a.getAttribute("rel").indexOf("style") != -1
         && a.getAttribute("title")
         && !a.disabled
         ) return a.getAttribute("title");
    }
    return null;
  }
  
  function getPreferredStyleSheet() {
    var i, a;
    for(i=0  ;  (a = document.getElementsByTagName("link")[i])  ;  i++) {
      if(   a.getAttribute("rel").indexOf("style") != -1
         && a.getAttribute("rel").indexOf("alt") == -1
         && a.getAttribute("title")
         ) return a.getAttribute("title");
    }
    return null;
  }
  
  function createCookie(name,value,days) {
    if (days) {
      var date = new Date();
      date.setTime(date.getTime()+(days*24*60*60*1000));
      var expires = "; expires="+date.toGMTString();
    }
    else expires = "";
    document.cookie = name+"="+value+expires+"; path=/";
  }
  
  function readCookie(name) {
    var nameEQ = name + "=";
    var ca = document.cookie.split(';');
    for(var i=0  ;  i < ca.length  ;  i++) {
      var c = ca[i];
      while (c.charAt(0)==' ') c = c.substring(1,c.length);
      if (c.indexOf(nameEQ) == 0) return c.substring(nameEQ.length,c.length);
    }
    return null;
  }
  
  window.onload = function(e) {
    var cookie = readCookie("style");
    var title = cookie ? cookie : getPreferredStyleSheet();
    setActiveStyleSheet(title);
  }
  
  window.onunload = function(e) {
    var title = getActiveStyleSheet();
    createCookie("style", title, 365);
  }
  
  var cookie = readCookie("style");
  var title = cookie ? cookie : getPreferredStyleSheet();
  setActiveStyleSheet(title);
  
  // The End
  
  EOJAVASCRIPT
  
  # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  1;
  __END__
  
  
  =head1 NAME
  
  Pod::Simple::HTMLBatch - convert several Pod files to several HTML files
  
  =head1 SYNOPSIS
  
    perl -MPod::Simple::HTMLBatch -e 'Pod::Simple::HTMLBatch::go' in out
  
  
  =head1 DESCRIPTION
  
  This module is used for running batch-conversions of a lot of HTML
  documents 
  
  This class is NOT a subclass of Pod::Simple::HTML
  (nor of bad old Pod::Html) -- although it uses
  Pod::Simple::HTML for doing the conversion of each document.
  
  The normal use of this class is like so:
  
    use Pod::Simple::HTMLBatch;
    my $batchconv = Pod::Simple::HTMLBatch->new;
    $batchconv->some_option( some_value );
    $batchconv->some_other_option( some_other_value );
    $batchconv->batch_convert( \@search_dirs, $output_dir );
  
  =head2 FROM THE COMMAND LINE
  
  Note that this class also provides
  (but does not export) the function Pod::Simple::HTMLBatch::go.
  This is basically just a shortcut for C<<
  Pod::Simple::HTMLBatch->batch_convert(@ARGV) >>.
  It's meant to be handy for calling from the command line.
  
  However, the shortcut requires that you specify exactly two command-line
  arguments, C<indirs> and C<outdir>.
  
  Example:
  
    % mkdir out_html
    % perl -MPod::Simple::HTMLBatch -e Pod::Simple::HTMLBatch::go @INC out_html
        (to convert the pod from Perl's @INC
         files under the directory ./out_html)
  
  (Note that the command line there contains a literal atsign-I-N-C.  This
  is handled as a special case by batch_convert, in order to save you having
  to enter the odd-looking "" as the first command-line parameter when you
  mean "just use whatever's in @INC".)
  
  Example:
  
    % mkdir ../seekrut
    % chmod og-rx ../seekrut
    % perl -MPod::Simple::HTMLBatch -e Pod::Simple::HTMLBatch::go . ../seekrut
        (to convert the pod under the current dir into HTML
         files under the directory ./seekrut)
  
  Example:
  
    % perl -MPod::Simple::HTMLBatch -e Pod::Simple::HTMLBatch::go happydocs .
        (to convert all pod from happydocs into the current directory)
  
  
  
  =head1 MAIN METHODS
  
  =over
  
  =item $batchconv = Pod::Simple::HTMLBatch->new;
  
  This TODO
  
  
  =item $batchconv->batch_convert( I<indirs>, I<outdir> );
  
  this TODO
  
  =item $batchconv->batch_convert( undef    , ...);
  
  =item $batchconv->batch_convert( q{@INC}, ...);
  
  These two values for I<indirs> specify that the normal Perl @INC
  
  =item $batchconv->batch_convert( \@dirs , ...);
  
  This specifies that the input directories are the items in
  the arrayref C<\@dirs>.
  
  =item $batchconv->batch_convert( "somedir" , ...);
  
  This specifies that the director "somedir" is the input.
  (This can be an absolute or relative path, it doesn't matter.)
  
  A common value you might want would be just "." for the current
  directory:
  
       $batchconv->batch_convert( "." , ...);
  
  
  =item $batchconv->batch_convert( 'somedir:someother:also' , ...);
  
  This specifies that you want the dirs "somedir", "someother", and "also"
  scanned, just as if you'd passed the arrayref
  C<[qw( somedir someother also)]>.  Note that a ":"-separator is normal
  under Unix, but Under MSWin, you'll need C<'somedir;someother;also'>
  instead, since the pathsep on MSWin is ";" instead of ":".  (And
  I<that> is because ":" often comes up in paths, like
  C<"c:/perl/lib">.)
  
  (Exactly what separator character should be used, is gotten from
  C<$Config::Config{'path_sep'}>, via the L<Config> module.)
  
  =item $batchconv->batch_convert( ... , undef );
  
  This specifies that you want the HTML output to go into the current
  directory.
  
  (Note that a missing or undefined value means a different thing in
  the first slot than in the second.  That's so that C<batch_convert()>
  with no arguments (or undef arguments) means "go from @INC, into
  the current directory.)
  
  =item $batchconv->batch_convert( ... , 'somedir' );
  
  This specifies that you want the HTML output to go into the
  directory 'somedir'.
  (This can be an absolute or relative path, it doesn't matter.)
  
  =back
  
  
  Note that you can also call C<batch_convert> as a class method,
  like so:
  
    Pod::Simple::HTMLBatch->batch_convert( ... );
  
  That is just short for this:
  
    Pod::Simple::HTMLBatch-> new-> batch_convert(...);
  
  That is, it runs a conversion with default options, for
  whatever inputdirs and output dir you specify.
  
  
  =head2 ACCESSOR METHODS
  
  The following are all accessor methods -- that is, they don't do anything
  on their own, but just alter the contents of the conversion object,
  which comprises the options for this particular batch conversion.
  
  We show the "put" form of the accessors below (i.e., the syntax you use
  for setting the accessor to a specific value).  But you can also
  call each method with no parameters to get its current value.  For
  example, C<< $self->contents_file() >> returns the current value of
  the contents_file attribute.
  
  =over
  
  
  =item $batchconv->verbose( I<nonnegative_integer> );
  
  This controls how verbose to be during batch conversion, as far as
  notes to STDOUT (or whatever is C<select>'d) about how the conversion
  is going.  If 0, no progress information is printed.
  If 1 (the default value), some progress information is printed.
  Higher values print more information.
  
  
  =item $batchconv->index( I<true-or-false> );
  
  This controls whether or not each HTML page is liable to have a little
  table of contents at the top (which we call an "index" for historical
  reasons).  This is true by default.
  
  
  =item $batchconv->contents_file( I<filename> );
  
  If set, should be the name of a file (in the output directory)
  to write the HTML index to.  The default value is "index.html".
  If you set this to a false value, no contents file will be written.
  
  =item $batchconv->contents_page_start( I<HTML_string> );
  
  This specifies what string should be put at the beginning of
  the contents page.
  The default is a string more or less like this:
  
    <html>
    <head><title>Perl Documentation</title></head>
    <body class='contentspage'>
    <h1>Perl Documentation</h1>
  
  =item $batchconv->contents_page_end( I<HTML_string> );
  
  This specifies what string should be put at the end of the contents page.
  The default is a string more or less like this:
  
    <p class='contentsfooty'>Generated by
    Pod::Simple::HTMLBatch v3.01 under Perl v5.008
    <br >At Fri May 14 22:26:42 2004 GMT,
    which is Fri May 14 14:26:42 2004 local time.</p>
  
  
  
  =item $batchconv->add_css( $url );
  
  TODO
  
  =item $batchconv->add_javascript( $url );
  
  TODO
  
  =item $batchconv->css_flurry( I<true-or-false> );
  
  If true (the default value), we autogenerate some CSS files in the
  output directory, and set our HTML files to use those.
  TODO: continue
  
  =item $batchconv->javascript_flurry( I<true-or-false> );
  
  If true (the default value), we autogenerate a JavaScript in the
  output directory, and set our HTML files to use it.  Currently,
  the JavaScript is used only to get the browser to remember what
  stylesheet it prefers.
  TODO: continue
  
  =item $batchconv->no_contents_links( I<true-or-false> );
  
  TODO
  
  =item $batchconv->html_render_class( I<classname> );
  
  This sets what class is used for rendering the files.
  The default is "Pod::Simple::HTML".  If you set it to something else,
  it should probably be a subclass of Pod::Simple::HTML, and you should
  C<require> or C<use> that class so that's it's loaded before
  Pod::Simple::HTMLBatch tries loading it.
  
  =item $batchconv->search_class( I<classname> );
  
  This sets what class is used for searching for the files.
  The default is "Pod::Simple::Search".  If you set it to something else,
  it should probably be a subclass of Pod::Simple::Search, and you should
  C<require> or C<use> that class so that's it's loaded before
  Pod::Simple::HTMLBatch tries loading it.
  
  =back
  
  
  
  
  =head1 NOTES ON CUSTOMIZATION
  
  TODO
  
    call add_css($someurl) to add stylesheet as alternate
    call add_css($someurl,1) to add as primary stylesheet
  
    call add_javascript
  
    subclass Pod::Simple::HTML and set $batchconv->html_render_class to
      that classname
    and maybe override
      $page->batch_mode_page_object_init($self, $module, $infile, $outfile, $depth)
    or maybe override
      $batchconv->batch_mode_page_object_init($page, $module, $infile, $outfile, $depth)
    subclass Pod::Simple::Search and set $batchconv->search_class to
      that classname
  
  
  =head1 SEE ALSO
  
  L<Pod::Simple>, L<Pod::Simple::HTMLBatch>, L<perlpod>, L<perlpodspec>
  
  =head1 SUPPORT
  
  Questions or discussion about POD and Pod::Simple should be sent to the
  pod-people@perl.org mail list. Send an empty email to
  pod-people-subscribe@perl.org to subscribe.
  
  This module is managed in an open GitHub repository,
  L<https://github.com/perl-pod/pod-simple/>. Feel free to fork and contribute, or
  to clone L<git://github.com/perl-pod/pod-simple.git> and send patches!
  
  Patches against Pod::Simple are welcome. Please send bug reports to
  <bug-pod-simple@rt.cpan.org>.
  
  =head1 COPYRIGHT AND DISCLAIMERS
  
  Copyright (c) 2002 Sean M. Burke.
  
  This library is free software; you can redistribute it and/or modify it
  under the same terms as Perl itself.
  
  This program is distributed in the hope that it will be useful, but
  without any warranty; without even the implied warranty of
  merchantability or fitness for a particular purpose.
  
  =head1 AUTHOR
  
  Pod::Simple was created by Sean M. Burke <sburke@cpan.org>.
  But don't bother him, he's retired.
  
  Pod::Simple is maintained by:
  
  =over
  
  =item * Allison Randal C<allison@perl.org>
  
  =item * Hans Dieter Pearcey C<hdp@cpan.org>
  
  =item * David E. Wheeler C<dwheeler@cpan.org>
  
  =back
  
  =cut
POD_SIMPLE_HTMLBATCH

$fatpacked{"Pod/Simple/HTMLLegacy.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POD_SIMPLE_HTMLLEGACY';
  
  require 5;
  package Pod::Simple::HTMLLegacy;
  use strict;
  
  use vars qw($VERSION);
  use Getopt::Long;
  
  $VERSION = "5.01";
  
  #--------------------------------------------------------------------------
  # 
  # This class is meant to thinly emulate bad old Pod::Html
  #
  # TODO: some basic docs
  
  sub pod2html {
    my @args = (@_);
    
    my( $verbose, $infile, $outfile, $title );
    my $index = 1;
   
    {
      my($help);
  
      my($netscape); # dummy
      local @ARGV = @args;
      GetOptions(
        "help"       => \$help,
        "verbose!"   => \$verbose,
        "infile=s"   => \$infile,
        "outfile=s"  => \$outfile,
        "title=s"    => \$title,
        "index!"     => \$index,
  
        "netscape!"   => \$netscape,
      ) or return bad_opts(@args);
      bad_opts(@args) if @ARGV; # it should be all switches!
      return help_message() if $help;
    }
  
    for($infile, $outfile) { $_ = undef unless defined and length }
    
    if($verbose) {
      warn sprintf "%s version %s\n", __PACKAGE__, $VERSION;
      warn "OK, processed args [@args] ...\n";
      warn sprintf
        " Verbose: %s\n Index: %s\n Infile: %s\n Outfile: %s\n Title: %s\n",
        map defined($_) ? $_ : "(nil)",
         $verbose,     $index,     $infile,     $outfile,     $title,
      ;
      *Pod::Simple::HTML::DEBUG = sub(){1};
    }
    require Pod::Simple::HTML;
    Pod::Simple::HTML->VERSION(3);
    
    die "No such input file as $infile\n"
     if defined $infile and ! -e $infile;
  
    
    my $pod = Pod::Simple::HTML->new;
    $pod->force_title($title) if defined $title;
    $pod->index($index);
    return $pod->parse_from_file($infile, $outfile);
  }
  
  #--------------------------------------------------------------------------
  
  sub bad_opts     { die _help_message();         }
  sub help_message { print STDOUT _help_message() }
  
  #--------------------------------------------------------------------------
  
  sub _help_message {
  
    join '',
  
  "[", __PACKAGE__, " version ", $VERSION, qq~]
  Usage:  pod2html --help --infile=<name> --outfile=<name>
     --verbose --index --noindex
  
  Options:
    --help         - prints this message.
    --[no]index    - generate an index at the top of the resulting html
                     (default behavior).
    --infile       - filename for the pod to convert (input taken from stdin
                     by default).
    --outfile      - filename for the resulting html file (output sent to
                     stdout by default).
    --title        - title that will appear in resulting html file.
    --[no]verbose  - self-explanatory (off by default).
  
  Note that pod2html is DEPRECATED, and this version implements only
   some of the options known to older versions.
  For more information, see 'perldoc pod2html'.
  ~;
  
  }
  
  1;
  __END__
  
  OVER the underpass! UNDER the overpass! Around the FUTURE and BEYOND REPAIR!!
  
POD_SIMPLE_HTMLLEGACY

$fatpacked{"Pod/Simple/LinkSection.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POD_SIMPLE_LINKSECTION';
  
  require 5;
  package Pod::Simple::LinkSection;
    # Based somewhat dimly on Array::Autojoin
  use vars qw($VERSION );
  $VERSION = '3.35';
  
  use strict;
  use Pod::Simple::BlackBox;
  use vars qw($VERSION );
  $VERSION = '3.35';
  
  use overload( # So it'll stringify nice
    '""'   => \&Pod::Simple::BlackBox::stringify_lol,
    'bool' => \&Pod::Simple::BlackBox::stringify_lol,
    # '.='   => \&tack_on,  # grudgingly support
    
    'fallback' => 1,         # turn on cleverness
  );
  
  sub tack_on {
    $_[0] = ['', {}, "$_[0]" ];
    return $_[0][2] .= $_[1];
  }
  
  sub as_string {
    goto &Pod::Simple::BlackBox::stringify_lol;
  }
  sub stringify {
    goto &Pod::Simple::BlackBox::stringify_lol;
  }
  
  sub new {
    my $class = shift;
    $class = ref($class) || $class;
    my $new;
    if(@_ == 1) {
      if (!ref($_[0] || '')) { # most common case: one bare string
        return bless ['', {}, $_[0] ], $class;
      } elsif( ref($_[0] || '') eq 'ARRAY') {
        $new = [ @{ $_[0] } ];
      } else {
        Carp::croak( "$class new() doesn't know to clone $new" );
      }
    } else { # misc stuff
      $new = [ '', {}, @_ ];
    }
  
    # By now it's a treelet:  [ 'foo', {}, ... ]
    foreach my $x (@$new) {
      if(ref($x || '') eq 'ARRAY') {
        $x = $class->new($x); # recurse
      } elsif(ref($x || '') eq 'HASH') {
        $x = { %$x };
      }
       # otherwise leave it.
    }
  
    return bless $new, $class;
  }
  
  # Not much in this class is likely to be link-section specific --
  # but it just so happens that link-sections are about the only treelets
  # that are exposed to the user.
  
  1;
  
  __END__
  
  # TODO: let it be an option whether a given subclass even wants little treelets?
  
  
  __END__
  
  =head1 NAME
  
  Pod::Simple::LinkSection -- represent "section" attributes of L codes
  
  =head1 SYNOPSIS
  
   # a long story
  
  =head1 DESCRIPTION
  
  This class is not of interest to general users.
  
  Pod::Simple uses this class for representing the value of the
  "section" attribute of "L" start-element events.  Most applications
  can just use the normal stringification of objects of this class;
  they stringify to just the text content of the section,
  such as "foo" for
  C<< LZ<><Stuff/foo> >>, and "bar" for 
  C<< LZ<><Stuff/bIZ<><ar>> >>.
  
  However, anyone particularly interested in getting the full value of
  the treelet, can just traverse the content of the treeleet
  @$treelet_object.  To wit:
  
  
    % perl -MData::Dumper -e
      "use base qw(Pod::Simple::Methody);
       sub start_L { print Dumper($_[1]{'section'} ) }
       __PACKAGE__->new->parse_string_document('=head1 L<Foo/bI<ar>baz>>')
      "
  Output:
    $VAR1 = bless( [
                     '',
                     {},
                     'b',
                     bless( [
                              'I',
                              {},
                              'ar'
                            ], 'Pod::Simple::LinkSection' ),
                     'baz'
                   ], 'Pod::Simple::LinkSection' );
  
  But stringify it and you get just the text content:
  
    % perl -MData::Dumper -e
      "use base qw(Pod::Simple::Methody);
       sub start_L { print Dumper( '' . $_[1]{'section'} ) }
       __PACKAGE__->new->parse_string_document('=head1 L<Foo/bI<ar>baz>>')
      "
  Output:
    $VAR1 = 'barbaz';
  
  
  =head1 SEE ALSO
  
  L<Pod::Simple>
  
  =head1 SUPPORT
  
  Questions or discussion about POD and Pod::Simple should be sent to the
  pod-people@perl.org mail list. Send an empty email to
  pod-people-subscribe@perl.org to subscribe.
  
  This module is managed in an open GitHub repository,
  L<https://github.com/perl-pod/pod-simple/>. Feel free to fork and contribute, or
  to clone L<git://github.com/perl-pod/pod-simple.git> and send patches!
  
  Patches against Pod::Simple are welcome. Please send bug reports to
  <bug-pod-simple@rt.cpan.org>.
  
  =head1 COPYRIGHT AND DISCLAIMERS
  
  Copyright (c) 2004 Sean M. Burke.
  
  This library is free software; you can redistribute it and/or modify it
  under the same terms as Perl itself.
  
  This program is distributed in the hope that it will be useful, but
  without any warranty; without even the implied warranty of
  merchantability or fitness for a particular purpose.
  
  =head1 AUTHOR
  
  Pod::Simple was created by Sean M. Burke <sburke@cpan.org>.
  But don't bother him, he's retired.
  
  Pod::Simple is maintained by:
  
  =over
  
  =item * Allison Randal C<allison@perl.org>
  
  =item * Hans Dieter Pearcey C<hdp@cpan.org>
  
  =item * David E. Wheeler C<dwheeler@cpan.org>
  
  =back
  
  =cut
POD_SIMPLE_LINKSECTION

$fatpacked{"Pod/Simple/Methody.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POD_SIMPLE_METHODY';
  
  require 5;
  package Pod::Simple::Methody;
  use strict;
  use Pod::Simple ();
  use vars qw(@ISA $VERSION);
  $VERSION = '3.35';
  @ISA = ('Pod::Simple');
  
  # Yes, we could use named variables, but I want this to be impose
  # as little an additional performance hit as possible.
  
  sub _handle_element_start {
    $_[1] =~ tr/-:./__/;
    ( $_[0]->can( 'start_' . $_[1] )
      || return
    )->(
      $_[0], $_[2]
    );
  }
  
  sub _handle_text {
    ( $_[0]->can( 'handle_text' )
      || return
    )->(
      @_
    );
  }
  
  sub _handle_element_end {
    $_[1] =~ tr/-:./__/;
    ( $_[0]->can( 'end_' . $_[1] )
      || return
    )->(
      $_[0], $_[2]
    );
  }
  
  1;
  
  
  __END__
  
  =head1 NAME
  
  Pod::Simple::Methody -- turn Pod::Simple events into method calls
  
  =head1 SYNOPSIS
  
   require 5;
   use strict;
   package SomePodFormatter;
   use base qw(Pod::Simple::Methody);
  
   sub handle_text {
     my($self, $text) = @_;
     ...
   }
  
   sub start_head1 {
     my($self, $attrs) = @_;
     ...
   }
   sub end_head1 {
     my($self) = @_;
     ...
   }
  
  ...and start_/end_ methods for whatever other events you want to catch.
  
  =head1 DESCRIPTION
  
  This class is of
  interest to people writing Pod formatters based on Pod::Simple.
  
  This class (which is very small -- read the source) overrides
  Pod::Simple's _handle_element_start, _handle_text, and
  _handle_element_end methods so that parser events are turned into method
  calls. (Otherwise, this is a subclass of L<Pod::Simple> and inherits all
  its methods.)
  
  You can use this class as the base class for a Pod formatter/processor.
  
  =head1 METHOD CALLING
  
  When Pod::Simple sees a "=head1 Hi there", for example, it basically does
  this:
  
    $parser->_handle_element_start( "head1", \%attributes );
    $parser->_handle_text( "Hi there" );
    $parser->_handle_element_end( "head1" );
  
  But if you subclass Pod::Simple::Methody, it will instead do this
  when it sees a "=head1 Hi there":
  
    $parser->start_head1( \%attributes ) if $parser->can('start_head1');
    $parser->handle_text( "Hi there" )   if $parser->can('handle_text');
    $parser->end_head1()                 if $parser->can('end_head1');
  
  If Pod::Simple sends an event where the element name has a dash,
  period, or colon, the corresponding method name will have a underscore
  in its place.  For example, "foo.bar:baz" becomes start_foo_bar_baz
  and end_foo_bar_baz.
  
  See the source for Pod::Simple::Text for an example of using this class.
  
  =head1 SEE ALSO
  
  L<Pod::Simple>, L<Pod::Simple::Subclassing>
  
  =head1 SUPPORT
  
  Questions or discussion about POD and Pod::Simple should be sent to the
  pod-people@perl.org mail list. Send an empty email to
  pod-people-subscribe@perl.org to subscribe.
  
  This module is managed in an open GitHub repository,
  L<https://github.com/perl-pod/pod-simple/>. Feel free to fork and contribute, or
  to clone L<git://github.com/perl-pod/pod-simple.git> and send patches!
  
  Patches against Pod::Simple are welcome. Please send bug reports to
  <bug-pod-simple@rt.cpan.org>.
  
  =head1 COPYRIGHT AND DISCLAIMERS
  
  Copyright (c) 2002 Sean M. Burke.
  
  This library is free software; you can redistribute it and/or modify it
  under the same terms as Perl itself.
  
  This program is distributed in the hope that it will be useful, but
  without any warranty; without even the implied warranty of
  merchantability or fitness for a particular purpose.
  
  =head1 AUTHOR
  
  Pod::Simple was created by Sean M. Burke <sburke@cpan.org>.
  But don't bother him, he's retired.
  
  Pod::Simple is maintained by:
  
  =over
  
  =item * Allison Randal C<allison@perl.org>
  
  =item * Hans Dieter Pearcey C<hdp@cpan.org>
  
  =item * David E. Wheeler C<dwheeler@cpan.org>
  
  =back
  
  =cut
POD_SIMPLE_METHODY

$fatpacked{"Pod/Simple/Progress.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POD_SIMPLE_PROGRESS';
  
  require 5;
  package Pod::Simple::Progress;
  $VERSION = '3.35';
  use strict;
  
  # Objects of this class are used for noting progress of an
  #  operation every so often.  Messages delivered more often than that
  #  are suppressed.
  #
  # There's actually nothing in here that's specific to Pod processing;
  #  but it's ad-hoc enough that I'm not willing to give it a name that
  #  implies that it's generally useful, like "IO::Progress" or something.
  #
  # -- sburke
  #
  #--------------------------------------------------------------------------
  
  sub new {
    my($class,$delay) = @_;
    my $self = bless {'quiet_until' => 1},  ref($class) || $class;
    $self->to(*STDOUT{IO});
    $self->delay(defined($delay) ? $delay : 5);
    return $self;
  }
  
  sub copy { 
    my $orig = shift;
    bless {%$orig, 'quiet_until' => 1}, ref($orig);
  }
  #--------------------------------------------------------------------------
  
  sub reach {
    my($self, $point, $note) = @_;
    if( (my $now = time) >= $self->{'quiet_until'}) {
      my $goal;
      my    $to = $self->{'to'};
      print $to join('',
        ($self->{'quiet_until'} == 1) ? () : '... ',
        (defined $point) ? (
          '#',
          ($goal = $self->{'goal'}) ? (
            ' ' x (length($goal) - length($point)),
            $point, '/', $goal,
          ) : $point,
          $note ? ': ' : (),
        ) : (),
        $note || '',
        "\n"
      );
      $self->{'quiet_until'} = $now + $self->{'delay'};
    }
    return $self;
  }
  
  #--------------------------------------------------------------------------
  
  sub done {
    my($self, $note) = @_;
    $self->{'quiet_until'} = 1;
    return $self->reach( undef, $note );
  }
  
  #--------------------------------------------------------------------------
  # Simple accessors:
  
  sub delay {
    return $_[0]{'delay'} if @_ == 1; $_[0]{'delay'} = $_[1]; return $_[0] }
  sub goal {
    return $_[0]{'goal' } if @_ == 1; $_[0]{'goal' } = $_[1]; return $_[0] }
  sub to   {
    return $_[0]{'to'   } if @_ == 1; $_[0]{'to'   } = $_[1]; return $_[0] }
  
  #--------------------------------------------------------------------------
  
  unless(caller) { # Simple self-test:
    my $p = __PACKAGE__->new->goal(5);
    $p->reach(1, "Primus!");
    sleep 1;
    $p->reach(2, "Secundus!");
    sleep 3;
    $p->reach(3, "Tertius!");
    sleep 5;
    $p->reach(4);
    $p->reach(5, "Quintus!");
    sleep 1;
    $p->done("All done");
  }
  
  #--------------------------------------------------------------------------
  1;
  __END__
  
POD_SIMPLE_PROGRESS

$fatpacked{"Pod/Simple/PullParser.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POD_SIMPLE_PULLPARSER';
  require 5;
  package Pod::Simple::PullParser;
  $VERSION = '3.35';
  use Pod::Simple ();
  BEGIN {@ISA = ('Pod::Simple')}
  
  use strict;
  use Carp ();
  
  use Pod::Simple::PullParserStartToken;
  use Pod::Simple::PullParserEndToken;
  use Pod::Simple::PullParserTextToken;
  
  BEGIN { *DEBUG = \&Pod::Simple::DEBUG unless defined &DEBUG }
  
  __PACKAGE__->_accessorize(
    'source_fh',         # the filehandle we're reading from
    'source_scalar_ref', # the scalarref we're reading from
    'source_arrayref',   # the arrayref we're reading from
  );
  
  #@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
  #
  #  And here is how we implement a pull-parser on top of a push-parser...
  
  sub filter {
    my($self, $source) = @_;
    $self = $self->new unless ref $self;
  
    $source = *STDIN{IO} unless defined $source;
    $self->set_source($source);
    $self->output_fh(*STDOUT{IO});
  
    $self->run; # define run() in a subclass if you want to use filter()!
    return $self;
  }
  
  # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  
  sub parse_string_document {
    my $this = shift;
    $this->set_source(\ $_[0]);
    $this->run;
  }
  
  sub parse_file {
    my($this, $filename) = @_;
    $this->set_source($filename);
    $this->run;
  }
  
  # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  #  In case anyone tries to use them:
  
  sub run {
    use Carp ();
    if( __PACKAGE__ eq ref($_[0]) || $_[0]) { # I'm not being subclassed!
      Carp::croak "You can call run() only on subclasses of "
       . __PACKAGE__;
    } else {
      Carp::croak join '',
        "You can't call run() because ",
        ref($_[0]) || $_[0], " didn't define a run() method";
    }
  }
  
  sub parse_lines {
    use Carp ();
    Carp::croak "Use set_source with ", __PACKAGE__,
      " and subclasses, not parse_lines";
  }
  
  sub parse_line {
    use Carp ();
    Carp::croak "Use set_source with ", __PACKAGE__,
      " and subclasses, not parse_line";
  }
  
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  
  sub new {
    my $class = shift;
    my $self = $class->SUPER::new(@_);
    die "Couldn't construct for $class" unless $self;
  
    $self->{'token_buffer'} ||= [];
    $self->{'start_token_class'} ||= 'Pod::Simple::PullParserStartToken';
    $self->{'text_token_class'}  ||= 'Pod::Simple::PullParserTextToken';
    $self->{'end_token_class'}   ||= 'Pod::Simple::PullParserEndToken';
  
    DEBUG > 1 and print STDERR "New pullparser object: $self\n";
  
    return $self;
  }
  
  # ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~
  
  sub get_token {
    my $self = shift;
    DEBUG > 1 and print STDERR "\nget_token starting up on $self.\n";
    DEBUG > 2 and print STDERR " Items in token-buffer (",
     scalar( @{ $self->{'token_buffer'} } ) ,
     ") :\n", map(
       "    " . $_->dump . "\n", @{ $self->{'token_buffer'} }
     ),
     @{ $self->{'token_buffer'} } ? '' : '       (no tokens)',
     "\n"
    ;
  
    until( @{ $self->{'token_buffer'} } ) {
      DEBUG > 3 and print STDERR "I need to get something into my empty token buffer...\n";
      if($self->{'source_dead'}) {
        DEBUG and print STDERR "$self 's source is dead.\n";
        push @{ $self->{'token_buffer'} }, undef;
      } elsif(exists $self->{'source_fh'}) {
        my @lines;
        my $fh = $self->{'source_fh'}
         || Carp::croak('You have to call set_source before you can call get_token');
         
        DEBUG and print STDERR "$self 's source is filehandle $fh.\n";
        # Read those many lines at a time
        for(my $i = Pod::Simple::MANY_LINES; $i--;) {
          DEBUG > 3 and print STDERR " Fetching a line from source filehandle $fh...\n";
          local $/ = $Pod::Simple::NL;
          push @lines, scalar(<$fh>); # readline
          DEBUG > 3 and print STDERR "  Line is: ",
            defined($lines[-1]) ? $lines[-1] : "<undef>\n";
          unless( defined $lines[-1] ) {
            DEBUG and print STDERR "That's it for that source fh!  Killing.\n";
            delete $self->{'source_fh'}; # so it can be GC'd
            last;
          }
           # but pass thru the undef, which will set source_dead to true
  
          # TODO: look to see if $lines[-1] is =encoding, and if so,
          # do horribly magic things
  
        }
        
        if(DEBUG > 8) {
          print STDERR "* I've gotten ", scalar(@lines), " lines:\n";
          foreach my $l (@lines) {
            if(defined $l) {
              print STDERR "  line {$l}\n";
            } else {
              print STDERR "  line undef\n";
            }
          }
          print STDERR "* end of ", scalar(@lines), " lines\n";
        }
  
        $self->SUPER::parse_lines(@lines);
        
      } elsif(exists $self->{'source_arrayref'}) {
        DEBUG and print STDERR "$self 's source is arrayref $self->{'source_arrayref'}, with ",
         scalar(@{$self->{'source_arrayref'}}), " items left in it.\n";
  
        DEBUG > 3 and print STDERR "  Fetching ", Pod::Simple::MANY_LINES, " lines.\n";
        $self->SUPER::parse_lines(
          splice @{ $self->{'source_arrayref'} },
          0,
          Pod::Simple::MANY_LINES
        );
        unless( @{ $self->{'source_arrayref'} } ) {
          DEBUG and print STDERR "That's it for that source arrayref!  Killing.\n";
          $self->SUPER::parse_lines(undef);
          delete $self->{'source_arrayref'}; # so it can be GC'd
        }
         # to make sure that an undef is always sent to signal end-of-stream
  
      } elsif(exists $self->{'source_scalar_ref'}) {
  
        DEBUG and print STDERR "$self 's source is scalarref $self->{'source_scalar_ref'}, with ",
          length(${ $self->{'source_scalar_ref'} }) -
          (pos(${ $self->{'source_scalar_ref'} }) || 0),
          " characters left to parse.\n";
  
        DEBUG > 3 and print STDERR " Fetching a line from source-string...\n";
        if( ${ $self->{'source_scalar_ref'} } =~
          m/([^\n\r]*)((?:\r?\n)?)/g
        ) {
          #print(">> $1\n"),
          $self->SUPER::parse_lines($1)
           if length($1) or length($2)
            or pos(     ${ $self->{'source_scalar_ref'} })
             != length( ${ $self->{'source_scalar_ref'} });
           # I.e., unless it's a zero-length "empty line" at the very
           #  end of "foo\nbar\n" (i.e., between the \n and the EOS).
        } else { # that's the end.  Byebye
          $self->SUPER::parse_lines(undef);
          delete $self->{'source_scalar_ref'};
          DEBUG and print STDERR "That's it for that source scalarref!  Killing.\n";
        }
  
        
      } else {
        die "What source??";
      }
    }
    DEBUG and print STDERR "get_token about to return ",
     Pod::Simple::pretty( @{$self->{'token_buffer'}}
       ? $self->{'token_buffer'}[-1] : undef
     ), "\n";
    return shift @{$self->{'token_buffer'}}; # that's an undef if empty
  }
  
  sub unget_token {
    my $self = shift;
    DEBUG and print STDERR "Ungetting ", scalar(@_), " tokens: ",
     @_ ? "@_\n" : "().\n";
    foreach my $t (@_) {
      Carp::croak "Can't unget that, because it's not a token -- it's undef!"
       unless defined $t;
      Carp::croak "Can't unget $t, because it's not a token -- it's a string!"
       unless ref $t;
      Carp::croak "Can't unget $t, because it's not a token object!"
       unless UNIVERSAL::can($t, 'type');
    }
    
    unshift @{$self->{'token_buffer'}}, @_;
    DEBUG > 1 and print STDERR "Token buffer now has ",
     scalar(@{$self->{'token_buffer'}}), " items in it.\n";
    return;
  }
  
  #@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
  
  # $self->{'source_filename'} = $source;
  
  sub set_source {
    my $self = shift @_;
    return $self->{'source_fh'} unless @_;
    Carp::croak("Cannot assign new source to pull parser; create a new instance, instead")
        if $self->{'source_fh'} || $self->{'source_scalar_ref'} || $self->{'source_arrayref'};
    my $handle;
    if(!defined $_[0]) {
      Carp::croak("Can't use empty-string as a source for set_source");
    } elsif(ref(\( $_[0] )) eq 'GLOB') {
      $self->{'source_filename'} = '' . ($handle = $_[0]);
      DEBUG and print STDERR "$self 's source is glob $_[0]\n";
      # and fall thru   
    } elsif(ref( $_[0] ) eq 'SCALAR') {
      $self->{'source_scalar_ref'} = $_[0];
      DEBUG and print STDERR "$self 's source is scalar ref $_[0]\n";
      return;
    } elsif(ref( $_[0] ) eq 'ARRAY') {
      $self->{'source_arrayref'} = $_[0];
      DEBUG and print STDERR "$self 's source is array ref $_[0]\n";
      return;
    } elsif(ref $_[0]) {
      $self->{'source_filename'} = '' . ($handle = $_[0]);
      DEBUG and print STDERR "$self 's source is fh-obj $_[0]\n";
    } elsif(!length $_[0]) {
      Carp::croak("Can't use empty-string as a source for set_source");
    } else {  # It's a filename!
      DEBUG and print STDERR "$self 's source is filename $_[0]\n";
      {
        local *PODSOURCE;
        open(PODSOURCE, "<$_[0]") || Carp::croak "Can't open $_[0]: $!";
        $handle = *PODSOURCE{IO};
      }
      $self->{'source_filename'} = $_[0];
      DEBUG and print STDERR "  Its name is $_[0].\n";
  
      # TODO: file-discipline things here!
    }
  
    $self->{'source_fh'} = $handle;
    DEBUG and print STDERR "  Its handle is $handle\n";
    return 1;
  }
  
  # ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~
  
  sub get_title_short {  shift->get_short_title(@_)  } # alias
  
  sub get_short_title {
    my $title = shift->get_title(@_);
    $title = $1 if $title =~ m/^(\S{1,60})\s+--?\s+./s;
      # turn "Foo::Bar -- bars for your foo" into "Foo::Bar"
    return $title;
  }
  
  sub get_title       { shift->_get_titled_section(
    'NAME', max_token => 50, desperate => 1, @_)
  }
  sub get_version     { shift->_get_titled_section(
     'VERSION',
      max_token => 400,
      accept_verbatim => 1,
      max_content_length => 3_000,
     @_,
    );
  }
  sub get_description { shift->_get_titled_section(
     'DESCRIPTION',
      max_token => 400,
      max_content_length => 3_000,
     @_,
  ) }
  
  sub get_authors     { shift->get_author(@_) }  # a harmless alias
  
  sub get_author      {
    my $this = shift;
    # Max_token is so high because these are
    #  typically at the end of the document:
    $this->_get_titled_section('AUTHOR' , max_token => 10_000, @_) ||
    $this->_get_titled_section('AUTHORS', max_token => 10_000, @_);
  }
  
  #--------------------------------------------------------------------------
  
  sub _get_titled_section {
    # Based on a get_title originally contributed by Graham Barr
    my($self, $titlename, %options) = (@_);
    
    my $max_token            = delete $options{'max_token'};
    my $desperate_for_title  = delete $options{'desperate'};
    my $accept_verbatim      = delete $options{'accept_verbatim'};
    my $max_content_length   = delete $options{'max_content_length'};
    my $nocase               = delete $options{'nocase'};
    $max_content_length = 120 unless defined $max_content_length;
  
    Carp::croak( "Unknown " . ((1 == keys %options) ? "option: " : "options: ")
      . join " ", map "[$_]", sort keys %options
    )
     if keys %options;
  
    my %content_containers;
    $content_containers{'Para'} = 1;
    if($accept_verbatim) {
      $content_containers{'Verbatim'} = 1;
      $content_containers{'VerbatimFormatted'} = 1;
    }
  
    my $token_count = 0;
    my $title;
    my @to_unget;
    my $state = 0;
    my $depth = 0;
  
    Carp::croak "What kind of titlename is \"$titlename\"?!" unless
     defined $titlename and $titlename =~ m/^[A-Z ]{1,60}$/s; #sanity
    my $titlename_re = quotemeta($titlename);
  
    my $head1_text_content;
    my $para_text_content;
    my $skipX;
  
    while(
      ++$token_count <= ($max_token || 1_000_000)
      and defined(my $token = $self->get_token)
    ) {
      push @to_unget, $token;
  
      if ($state == 0) { # seeking =head1
        if( $token->is_start and $token->tagname eq 'head1' ) {
          DEBUG and print STDERR "  Found head1.  Seeking content...\n";
          ++$state;
          $head1_text_content = '';
        }
      }
  
      elsif($state == 1) { # accumulating text until end of head1
        if( $token->is_text ) {
            unless ($skipX) {
              DEBUG and print STDERR "   Adding \"", $token->text, "\" to head1-content.\n";
              $head1_text_content .= $token->text;
            }
        } elsif( $token->is_tagname('X') ) {
            # We're going to want to ignore X<> stuff.
            $skipX = $token->is_start;
            DEBUG and print STDERR +($skipX ? 'Start' : 'End'), 'ing ignoring of X<> tag';
        } elsif( $token->is_end and $token->tagname eq 'head1' ) {
          DEBUG and print STDERR "  Found end of head1.  Considering content...\n";
          $head1_text_content = uc $head1_text_content if $nocase;
          if($head1_text_content eq $titlename
            or $head1_text_content =~ m/\($titlename_re\)/s
            # We accept "=head1 Nomen Modularis (NAME)" for sake of i18n
          ) {
            DEBUG and print STDERR "  Yup, it was $titlename.  Seeking next para-content...\n";
            ++$state;
          } elsif(
            $desperate_for_title
             # if we're so desperate we'll take the first
             #  =head1's content as a title
            and $head1_text_content =~ m/\S/
            and $head1_text_content !~ m/^[ A-Z]+$/s
            and $head1_text_content !~
              m/\((?:
               NAME | TITLE | VERSION | AUTHORS? | DESCRIPTION | SYNOPSIS
               | COPYRIGHT | LICENSE | NOTES? | FUNCTIONS? | METHODS?
               | CAVEATS? | BUGS? | SEE\ ALSO | SWITCHES | ENVIRONMENT
              )\)/sx
              # avoid accepting things like =head1 Thingy Thongy (DESCRIPTION)
            and ($max_content_length
              ? (length($head1_text_content) <= $max_content_length) # sanity
              : 1)
          ) {
            # Looks good; trim it
            ($title = $head1_text_content) =~ s/\s+$//;
            DEBUG and print STDERR "  It looks titular: \"$title\".\n\n  Using that.\n";
            last;
          } else {
            --$state;
            DEBUG and print STDERR "  Didn't look titular ($head1_text_content).\n",
              "\n  Dropping back to seeking-head1-content mode...\n";
          }
        }
      }
      
      elsif($state == 2) {
        # seeking start of para (which must immediately follow)
        if($token->is_start and $content_containers{ $token->tagname }) {
          DEBUG and print STDERR "  Found start of Para.  Accumulating content...\n";
          $para_text_content = '';
          ++$state;
        } else {
          DEBUG and print
           "  Didn't see an immediately subsequent start-Para.  Reseeking H1\n";
          $state = 0;
        }
      }
      
      elsif($state == 3) {
        # accumulating text until end of Para
        if( $token->is_text ) {
          DEBUG and print STDERR "   Adding \"", $token->text, "\" to para-content.\n";
          $para_text_content .= $token->text;
          # and keep looking
          
        } elsif( $token->is_end and $content_containers{ $token->tagname } ) {
          DEBUG and print STDERR "  Found end of Para.  Considering content: ",
            $para_text_content, "\n";
  
          if( $para_text_content =~ m/\S/
            and ($max_content_length
             ? (length($para_text_content) <= $max_content_length)
             : 1)
          ) {
            # Some minimal sanity constraints, I think.
            DEBUG and print STDERR "  It looks contentworthy, I guess.  Using it.\n";
            $title = $para_text_content;
            last;
          } else {
            DEBUG and print STDERR "  Doesn't look at all contentworthy!\n  Giving up.\n";
            undef $title;
            last;
          }
        }
      }
      
      else {
        die "IMPOSSIBLE STATE $state!\n";  # should never happen
      }
      
    }
    
    # Put it all back!
    $self->unget_token(@to_unget);
    
    if(DEBUG) {
      if(defined $title) { print STDERR "  Returning title <$title>\n" }
      else { print STDERR "Returning title <>\n" }
    }
    
    return '' unless defined $title;
    $title =~ s/^\s+//;
    return $title;
  }
  
  #@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
  #
  #  Methods that actually do work at parse-time:
  
  sub _handle_element_start {
    my $self = shift;   # leaving ($element_name, $attr_hash_r)
    DEBUG > 2 and print STDERR "++ $_[0] (", map("<$_> ", %{$_[1]}), ")\n";
    
    push @{ $self->{'token_buffer'} },
         $self->{'start_token_class'}->new(@_);
    return;
  }
  
  sub _handle_text {
    my $self = shift;   # leaving ($text)
    DEBUG > 2 and print STDERR "== $_[0]\n";
    push @{ $self->{'token_buffer'} },
         $self->{'text_token_class'}->new(@_);
    return;
  }
  
  sub _handle_element_end {
    my $self = shift;   # leaving ($element_name);
    DEBUG > 2 and print STDERR "-- $_[0]\n";
    push @{ $self->{'token_buffer'} }, 
         $self->{'end_token_class'}->new(@_);
    return;
  }
  
  #@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
  
  1;
  
  
  __END__
  
  =head1 NAME
  
  Pod::Simple::PullParser -- a pull-parser interface to parsing Pod
  
  =head1 SYNOPSIS
  
   my $parser = SomePodProcessor->new;
   $parser->set_source( "whatever.pod" );
   $parser->run;
  
  Or:
  
   my $parser = SomePodProcessor->new;
   $parser->set_source( $some_filehandle_object );
   $parser->run;
  
  Or:
  
   my $parser = SomePodProcessor->new;
   $parser->set_source( \$document_source );
   $parser->run;
  
  Or:
  
   my $parser = SomePodProcessor->new;
   $parser->set_source( \@document_lines );
   $parser->run;
  
  And elsewhere:
  
   require 5;
   package SomePodProcessor;
   use strict;
   use base qw(Pod::Simple::PullParser);
  
   sub run {
     my $self = shift;
    Token:
     while(my $token = $self->get_token) {
       ...process each token...
     }
   }
  
  =head1 DESCRIPTION
  
  This class is for using Pod::Simple to build a Pod processor -- but
  one that uses an interface based on a stream of token objects,
  instead of based on events.
  
  This is a subclass of L<Pod::Simple> and inherits all its methods.
  
  A subclass of Pod::Simple::PullParser should define a C<run> method
  that calls C<< $token = $parser->get_token >> to pull tokens.
  
  See the source for Pod::Simple::RTF for an example of a formatter
  that uses Pod::Simple::PullParser.
  
  =head1 METHODS
  
  =over
  
  =item my $token = $parser->get_token
  
  This returns the next token object (which will be of a subclass of
  L<Pod::Simple::PullParserToken>), or undef if the parser-stream has hit
  the end of the document.
  
  =item $parser->unget_token( $token )
  
  =item $parser->unget_token( $token1, $token2, ... )
  
  This restores the token object(s) to the front of the parser stream.
  
  =back
  
  The source has to be set before you can parse anything.  The lowest-level
  way is to call C<set_source>:
  
  =over
  
  =item $parser->set_source( $filename )
  
  =item $parser->set_source( $filehandle_object )
  
  =item $parser->set_source( \$document_source )
  
  =item $parser->set_source( \@document_lines )
  
  =back
  
  Or you can call these methods, which Pod::Simple::PullParser has defined
  to work just like Pod::Simple's same-named methods:
  
  =over
  
  =item $parser->parse_file(...)
  
  =item $parser->parse_string_document(...)
  
  =item $parser->filter(...)
  
  =item $parser->parse_from_file(...)
  
  =back
  
  For those to work, the Pod-processing subclass of
  Pod::Simple::PullParser has to have defined a $parser->run method --
  so it is advised that all Pod::Simple::PullParser subclasses do so.
  See the Synopsis above, or the source for Pod::Simple::RTF.
  
  Authors of formatter subclasses might find these methods useful to
  call on a parser object that you haven't started pulling tokens
  from yet:
  
  =over
  
  =item my $title_string = $parser->get_title
  
  This tries to get the title string out of $parser, by getting some tokens,
  and scanning them for the title, and then ungetting them so that you can
  process the token-stream from the beginning.
  
  For example, suppose you have a document that starts out:
  
    =head1 NAME
  
    Hoo::Boy::Wowza -- Stuff B<wow> yeah!
  
  $parser->get_title on that document will return "Hoo::Boy::Wowza --
  Stuff wow yeah!". If the document starts with:
  
    =head1 Name
  
    Hoo::Boy::W00t -- Stuff B<w00t> yeah!
  
  Then you'll need to pass the C<nocase> option in order to recognize "Name":
  
    $parser->get_title(nocase => 1);
  
  In cases where get_title can't find the title, it will return empty-string
  ("").
  
  =item my $title_string = $parser->get_short_title
  
  This is just like get_title, except that it returns just the modulename, if
  the title seems to be of the form "SomeModuleName -- description".
  
  For example, suppose you have a document that starts out:
  
    =head1 NAME
  
    Hoo::Boy::Wowza -- Stuff B<wow> yeah!
  
  then $parser->get_short_title on that document will return
  "Hoo::Boy::Wowza".
  
  But if the document starts out:
  
    =head1 NAME
  
    Hooboy, stuff B<wow> yeah!
  
  then $parser->get_short_title on that document will return "Hooboy,
  stuff wow yeah!". If the document starts with:
  
    =head1 Name
  
    Hoo::Boy::W00t -- Stuff B<w00t> yeah!
  
  Then you'll need to pass the C<nocase> option in order to recognize "Name":
  
    $parser->get_short_title(nocase => 1);
  
  If the title can't be found, then get_short_title returns empty-string
  ("").
  
  =item $author_name   = $parser->get_author
  
  This works like get_title except that it returns the contents of the
  "=head1 AUTHOR\n\nParagraph...\n" section, assuming that that section
  isn't terribly long. To recognize a "=head1 Author\n\nParagraph\n"
  section, pass the C<nocase> option:
  
    $parser->get_author(nocase => 1);
  
  (This method tolerates "AUTHORS" instead of "AUTHOR" too.)
  
  =item $description_name = $parser->get_description
  
  This works like get_title except that it returns the contents of the
  "=head1 DESCRIPTION\n\nParagraph...\n" section, assuming that that section
  isn't terribly long. To recognize a "=head1 Description\n\nParagraph\n"
  section, pass the C<nocase> option:
  
    $parser->get_description(nocase => 1);
  
  =item $version_block = $parser->get_version
  
  This works like get_title except that it returns the contents of
  the "=head1 VERSION\n\n[BIG BLOCK]\n" block.  Note that this does NOT
  return the module's C<$VERSION>!! To recognize a
  "=head1 Version\n\n[BIG BLOCK]\n" section, pass the C<nocase> option:
  
    $parser->get_version(nocase => 1);
  
  =back
  
  =head1 NOTE
  
  You don't actually I<have> to define a C<run> method.  If you're
  writing a Pod-formatter class, you should define a C<run> just so
  that users can call C<parse_file> etc, but you don't I<have> to.
  
  And if you're not writing a formatter class, but are instead just
  writing a program that does something simple with a Pod::PullParser
  object (and not an object of a subclass), then there's no reason to
  bother subclassing to add a C<run> method.
  
  =head1 SEE ALSO
  
  L<Pod::Simple>
  
  L<Pod::Simple::PullParserToken> -- and its subclasses
  L<Pod::Simple::PullParserStartToken>,
  L<Pod::Simple::PullParserTextToken>, and
  L<Pod::Simple::PullParserEndToken>.
  
  L<HTML::TokeParser>, which inspired this.
  
  =head1 SUPPORT
  
  Questions or discussion about POD and Pod::Simple should be sent to the
  pod-people@perl.org mail list. Send an empty email to
  pod-people-subscribe@perl.org to subscribe.
  
  This module is managed in an open GitHub repository,
  L<https://github.com/perl-pod/pod-simple/>. Feel free to fork and contribute, or
  to clone L<git://github.com/perl-pod/pod-simple.git> and send patches!
  
  Patches against Pod::Simple are welcome. Please send bug reports to
  <bug-pod-simple@rt.cpan.org>.
  
  =head1 COPYRIGHT AND DISCLAIMERS
  
  Copyright (c) 2002 Sean M. Burke.
  
  This library is free software; you can redistribute it and/or modify it
  under the same terms as Perl itself.
  
  This program is distributed in the hope that it will be useful, but
  without any warranty; without even the implied warranty of
  merchantability or fitness for a particular purpose.
  
  =head1 AUTHOR
  
  Pod::Simple was created by Sean M. Burke <sburke@cpan.org>.
  But don't bother him, he's retired.
  
  Pod::Simple is maintained by:
  
  =over
  
  =item * Allison Randal C<allison@perl.org>
  
  =item * Hans Dieter Pearcey C<hdp@cpan.org>
  
  =item * David E. Wheeler C<dwheeler@cpan.org>
  
  =back
  
  =cut
  
  JUNK:
  
  sub _old_get_title {  # some witchery in here
    my $self = $_[0];
    my $title;
    my @to_unget;
  
    while(1) {
      push @to_unget, $self->get_token;
      unless(defined $to_unget[-1]) { # whoops, short doc!
        pop @to_unget;
        last;
      }
  
      DEBUG and print STDERR "-Got token ", $to_unget[-1]->dump, "\n";
  
      (DEBUG and print STDERR "Too much in the buffer.\n"),
       last if @to_unget > 25; # sanity
      
      my $pattern = '';
      if( #$to_unget[-1]->type eq 'end'
          #and $to_unget[-1]->tagname eq 'Para'
          #and
          ($pattern = join('',
           map {;
              ($_->type eq 'start') ? ("<" . $_->tagname .">")
            : ($_->type eq 'end'  ) ? ("</". $_->tagname .">")
            : ($_->type eq 'text' ) ? ($_->text =~ m<^([A-Z]+)$>s ? $1 : 'X')
            : "BLORP"
           } @to_unget
         )) =~ m{<head1>NAME</head1><Para>(X|</?[BCIFLS]>)+</Para>$}s
      ) {
        # Whee, it fits the pattern
        DEBUG and print STDERR "Seems to match =head1 NAME pattern.\n";
        $title = '';
        foreach my $t (reverse @to_unget) {
          last if $t->type eq 'start' and $t->tagname eq 'Para';
          $title = $t->text . $title if $t->type eq 'text';
        }
        undef $title if $title =~ m<^\s*$>; # make sure it's contentful!
        last;
  
      } elsif ($pattern =~ m{<head(\d)>(.+)</head\d>$}
        and !( $1 eq '1' and $2 eq 'NAME' )
      ) {
        # Well, it fits a fallback pattern
        DEBUG and print STDERR "Seems to match NAMEless pattern.\n";
        $title = '';
        foreach my $t (reverse @to_unget) {
          last if $t->type eq 'start' and $t->tagname =~ m/^head\d$/s;
          $title = $t->text . $title if $t->type eq 'text';
        }
        undef $title if $title =~ m<^\s*$>; # make sure it's contentful!
        last;
        
      } else {
        DEBUG and $pattern and print STDERR "Leading pattern: $pattern\n";
      }
    }
    
    # Put it all back:
    $self->unget_token(@to_unget);
    
    if(DEBUG) {
      if(defined $title) { print STDERR "  Returning title <$title>\n" }
      else { print STDERR "Returning title <>\n" }
    }
    
    return '' unless defined $title;
    return $title;
  }
  
POD_SIMPLE_PULLPARSER

$fatpacked{"Pod/Simple/PullParserEndToken.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POD_SIMPLE_PULLPARSERENDTOKEN';
  
  require 5;
  package Pod::Simple::PullParserEndToken;
  use Pod::Simple::PullParserToken ();
  use strict;
  use vars qw(@ISA $VERSION);
  @ISA = ('Pod::Simple::PullParserToken');
  $VERSION = '3.35';
  
  sub new {  # Class->new(tagname);
    my $class = shift;
    return bless ['end', @_], ref($class) || $class;
  }
  
  # Purely accessors:
  
  sub tagname { (@_ == 2) ? ($_[0][1] = $_[1]) : $_[0][1] }
  sub tag { shift->tagname(@_) }
  
  # shortcut:
  sub is_tagname { $_[0][1] eq $_[1] }
  sub is_tag { shift->is_tagname(@_) }
  
  1;
  
  
  __END__
  
  =head1 NAME
  
  Pod::Simple::PullParserEndToken -- end-tokens from Pod::Simple::PullParser
  
  =head1 SYNOPSIS
  
  (See L<Pod::Simple::PullParser>)
  
  =head1 DESCRIPTION
  
  When you do $parser->get_token on a L<Pod::Simple::PullParser>, you might
  get an object of this class.
  
  This is a subclass of L<Pod::Simple::PullParserToken> and inherits all its methods,
  and adds these methods:
  
  =over
  
  =item $token->tagname
  
  This returns the tagname for this end-token object.
  For example, parsing a "=head1 ..." line will give you
  a start-token with the tagname of "head1", token(s) for its
  content, and then an end-token with the tagname of "head1".
  
  =item $token->tagname(I<somestring>)
  
  This changes the tagname for this end-token object.
  You probably won't need to do this.
  
  =item $token->tag(...)
  
  A shortcut for $token->tagname(...)
  
  =item $token->is_tag(I<somestring>) or $token->is_tagname(I<somestring>)
  
  These are shortcuts for C<< $token->tag() eq I<somestring> >>
  
  =back
  
  You're unlikely to ever need to construct an object of this class for
  yourself, but if you want to, call
  C<<
  Pod::Simple::PullParserEndToken->new( I<tagname> )
  >>
  
  =head1 SEE ALSO
  
  L<Pod::Simple::PullParserToken>, L<Pod::Simple>, L<Pod::Simple::Subclassing>
  
  =head1 SUPPORT
  
  Questions or discussion about POD and Pod::Simple should be sent to the
  pod-people@perl.org mail list. Send an empty email to
  pod-people-subscribe@perl.org to subscribe.
  
  This module is managed in an open GitHub repository,
  L<https://github.com/perl-pod/pod-simple/>. Feel free to fork and contribute, or
  to clone L<git://github.com/perl-pod/pod-simple.git> and send patches!
  
  Patches against Pod::Simple are welcome. Please send bug reports to
  <bug-pod-simple@rt.cpan.org>.
  
  =head1 COPYRIGHT AND DISCLAIMERS
  
  Copyright (c) 2002 Sean M. Burke.
  
  This library is free software; you can redistribute it and/or modify it
  under the same terms as Perl itself.
  
  This program is distributed in the hope that it will be useful, but
  without any warranty; without even the implied warranty of
  merchantability or fitness for a particular purpose.
  
  =head1 AUTHOR
  
  Pod::Simple was created by Sean M. Burke <sburke@cpan.org>.
  But don't bother him, he's retired.
  
  Pod::Simple is maintained by:
  
  =over
  
  =item * Allison Randal C<allison@perl.org>
  
  =item * Hans Dieter Pearcey C<hdp@cpan.org>
  
  =item * David E. Wheeler C<dwheeler@cpan.org>
  
  =back
  
  =cut
POD_SIMPLE_PULLPARSERENDTOKEN

$fatpacked{"Pod/Simple/PullParserStartToken.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POD_SIMPLE_PULLPARSERSTARTTOKEN';
  
  require 5;
  package Pod::Simple::PullParserStartToken;
  use Pod::Simple::PullParserToken ();
  use strict;
  use vars qw(@ISA $VERSION);
  @ISA = ('Pod::Simple::PullParserToken');
  $VERSION = '3.35';
  
  sub new {  # Class->new(tagname, optional_attrhash);
    my $class = shift;
    return bless ['start', @_], ref($class) || $class;
  }
  
  # Purely accessors:
  
  sub tagname   { (@_ == 2) ? ($_[0][1] = $_[1]) : $_[0][1] }
  sub tag { shift->tagname(@_) }
  
  sub is_tagname { $_[0][1] eq $_[1] }
  sub is_tag { shift->is_tagname(@_) }
  
  
  sub attr_hash { $_[0][2] ||= {} }
  
  sub attr      {
    if(@_ == 2) {      # Reading: $token->attr('attrname')
      ${$_[0][2] || return undef}{ $_[1] };
    } elsif(@_ > 2) {  # Writing: $token->attr('attrname', 'newval')
      ${$_[0][2] ||= {}}{ $_[1] } = $_[2];
    } else {
      require Carp;
      Carp::croak(
        'usage: $object->attr("val") or $object->attr("key", "newval")');
      return undef;
    }
  }
  
  1;
  
  
  __END__
  
  =head1 NAME
  
  Pod::Simple::PullParserStartToken -- start-tokens from Pod::Simple::PullParser
  
  =head1 SYNOPSIS
  
  (See L<Pod::Simple::PullParser>)
  
  =head1 DESCRIPTION
  
  When you do $parser->get_token on a L<Pod::Simple::PullParser> object, you might
  get an object of this class.
  
  This is a subclass of L<Pod::Simple::PullParserToken> and inherits all its methods,
  and adds these methods:
  
  =over
  
  =item $token->tagname
  
  This returns the tagname for this start-token object.
  For example, parsing a "=head1 ..." line will give you
  a start-token with the tagname of "head1", token(s) for its
  content, and then an end-token with the tagname of "head1".
  
  =item $token->tagname(I<somestring>)
  
  This changes the tagname for this start-token object.
  You probably won't need
  to do this.
  
  =item $token->tag(...)
  
  A shortcut for $token->tagname(...)
  
  =item $token->is_tag(I<somestring>) or $token->is_tagname(I<somestring>)
  
  These are shortcuts for C<< $token->tag() eq I<somestring> >>
  
  =item $token->attr(I<attrname>)
  
  This returns the value of the I<attrname> attribute for this start-token
  object, or undef.
  
  For example, parsing a LZ<><Foo/"Bar"> link will produce a start-token
  with a "to" attribute with the value "Foo", a "type" attribute with the
  value "pod", and a "section" attribute with the value "Bar".
  
  =item $token->attr(I<attrname>, I<newvalue>)
  
  This sets the I<attrname> attribute for this start-token object to
  I<newvalue>.  You probably won't need to do this.
  
  =item $token->attr_hash
  
  This returns the hashref that is the attribute set for this start-token.
  This is useful if (for example) you want to ask what all the attributes
  are -- you can just do C<< keys %{$token->attr_hash} >>
  
  =back
  
  
  You're unlikely to ever need to construct an object of this class for
  yourself, but if you want to, call
  C<<
  Pod::Simple::PullParserStartToken->new( I<tagname>, I<attrhash> )
  >>
  
  =head1 SEE ALSO
  
  L<Pod::Simple::PullParserToken>, L<Pod::Simple>, L<Pod::Simple::Subclassing>
  
  =head1 SEE ALSO
  
  L<Pod::Simple::PullParserToken>, L<Pod::Simple>, L<Pod::Simple::Subclassing>
  
  =head1 SUPPORT
  
  Questions or discussion about POD and Pod::Simple should be sent to the
  pod-people@perl.org mail list. Send an empty email to
  pod-people-subscribe@perl.org to subscribe.
  
  This module is managed in an open GitHub repository,
  L<https://github.com/perl-pod/pod-simple/>. Feel free to fork and contribute, or
  to clone L<git://github.com/perl-pod/pod-simple.git> and send patches!
  
  Patches against Pod::Simple are welcome. Please send bug reports to
  <bug-pod-simple@rt.cpan.org>.
  
  =head1 COPYRIGHT AND DISCLAIMERS
  
  Copyright (c) 2002 Sean M. Burke.
  
  This library is free software; you can redistribute it and/or modify it
  under the same terms as Perl itself.
  
  This program is distributed in the hope that it will be useful, but
  without any warranty; without even the implied warranty of
  merchantability or fitness for a particular purpose.
  
  =head1 AUTHOR
  
  Pod::Simple was created by Sean M. Burke <sburke@cpan.org>.
  But don't bother him, he's retired.
  
  Pod::Simple is maintained by:
  
  =over
  
  =item * Allison Randal C<allison@perl.org>
  
  =item * Hans Dieter Pearcey C<hdp@cpan.org>
  
  =item * David E. Wheeler C<dwheeler@cpan.org>
  
  =back
  
  =cut
POD_SIMPLE_PULLPARSERSTARTTOKEN

$fatpacked{"Pod/Simple/PullParserTextToken.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POD_SIMPLE_PULLPARSERTEXTTOKEN';
  
  require 5;
  package Pod::Simple::PullParserTextToken;
  use Pod::Simple::PullParserToken ();
  use strict;
  use vars qw(@ISA $VERSION);
  @ISA = ('Pod::Simple::PullParserToken');
  $VERSION = '3.35';
  
  sub new {  # Class->new(text);
    my $class = shift;
    return bless ['text', @_], ref($class) || $class;
  }
  
  # Purely accessors:
  
  sub text { (@_ == 2) ? ($_[0][1] = $_[1]) : $_[0][1] }
  
  sub text_r { \ $_[0][1] }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Pod::Simple::PullParserTextToken -- text-tokens from Pod::Simple::PullParser
  
  =head1 SYNOPSIS
  
  (See L<Pod::Simple::PullParser>)
  
  =head1 DESCRIPTION
  
  When you do $parser->get_token on a L<Pod::Simple::PullParser>, you might
  get an object of this class.
  
  This is a subclass of L<Pod::Simple::PullParserToken> and inherits all its methods,
  and adds these methods:
  
  =over
  
  =item $token->text
  
  This returns the text that this token holds.  For example, parsing
  CZ<><foo> will return a C start-token, a text-token, and a C end-token.  And
  if you want to get the "foo" out of the text-token, call C<< $token->text >>
  
  =item $token->text(I<somestring>)
  
  This changes the string that this token holds.  You probably won't need
  to do this.
  
  =item $token->text_r()
  
  This returns a scalar reference to the string that this token holds.
  This can be useful if you don't want to memory-copy the potentially
  large text value (well, as large as a paragraph or a verbatim block)
  as calling $token->text would do.
  
  Or, if you want to alter the value, you can even do things like this:
  
    for ( ${  $token->text_r  } ) {  # Aliases it with $_ !!
  
      s/ The / the /g; # just for example
  
      if( 'A' eq chr(65) ) {  # (if in an ASCII world)
        tr/\xA0/ /;
        tr/\xAD//d;
      }
  
      ...or however you want to alter the value...
      (Note that starting with Perl v5.8, you can use, e.g.,
  
          my $nbsp = chr utf8::unicode_to_native(0xA0);
          s/$nbsp/ /g;
  
      to handle the above regardless if it's an ASCII world or not)
    }
  
  =back
  
  You're unlikely to ever need to construct an object of this class for
  yourself, but if you want to, call
  C<<
  Pod::Simple::PullParserTextToken->new( I<text> )
  >>
  
  =head1 SEE ALSO
  
  L<Pod::Simple::PullParserToken>, L<Pod::Simple>, L<Pod::Simple::Subclassing>
  
  =head1 SUPPORT
  
  Questions or discussion about POD and Pod::Simple should be sent to the
  pod-people@perl.org mail list. Send an empty email to
  pod-people-subscribe@perl.org to subscribe.
  
  This module is managed in an open GitHub repository,
  L<https://github.com/perl-pod/pod-simple/>. Feel free to fork and contribute, or
  to clone L<git://github.com/perl-pod/pod-simple.git> and send patches!
  
  Patches against Pod::Simple are welcome. Please send bug reports to
  <bug-pod-simple@rt.cpan.org>.
  
  =head1 COPYRIGHT AND DISCLAIMERS
  
  Copyright (c) 2002 Sean M. Burke.
  
  This library is free software; you can redistribute it and/or modify it
  under the same terms as Perl itself.
  
  This program is distributed in the hope that it will be useful, but
  without any warranty; without even the implied warranty of
  merchantability or fitness for a particular purpose.
  
  =head1 AUTHOR
  
  Pod::Simple was created by Sean M. Burke <sburke@cpan.org>.
  But don't bother him, he's retired.
  
  Pod::Simple is maintained by:
  
  =over
  
  =item * Allison Randal C<allison@perl.org>
  
  =item * Hans Dieter Pearcey C<hdp@cpan.org>
  
  =item * David E. Wheeler C<dwheeler@cpan.org>
  
  =back
  
  =cut
POD_SIMPLE_PULLPARSERTEXTTOKEN

$fatpacked{"Pod/Simple/PullParserToken.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POD_SIMPLE_PULLPARSERTOKEN';
  
  require 5;
  package Pod::Simple::PullParserToken;
   # Base class for tokens gotten from Pod::Simple::PullParser's $parser->get_token
  @ISA = ();
  $VERSION = '3.35';
  use strict;
  
  sub new {  # Class->new('type', stuff...);  ## Overridden in derived classes anyway
    my $class = shift;
    return bless [@_], ref($class) || $class;
  }
  
  sub type { $_[0][0] }  # Can't change the type of an object
  sub dump { Pod::Simple::pretty( [ @{ $_[0] } ] ) }
  
  sub is_start { $_[0][0] eq 'start' }
  sub is_end   { $_[0][0] eq 'end'   }
  sub is_text  { $_[0][0] eq 'text'  }
  
  1;
  __END__
  
  sub dump { '[' . _esc( @{ $_[0] } ) . ']' }
  
  # JUNK:
  
  sub _esc {
    return '' unless @_;
    my @out;
    foreach my $in (@_) {
      push @out, '"' . $in . '"';
      $out[-1] =~ s/([^- \:\:\.\,\'\>\<\"\/\=\?\+\|\[\]\{\}\_a-zA-Z0-9_\`\~\!\#\%\^\&\*\(\)])/
        sprintf( (ord($1) < 256) ? "\\x%02X" : "\\x{%X}", ord($1))
      /eg;
    }
    return join ', ', @out;
  }
  
  
  __END__
  
  =head1 NAME
  
  Pod::Simple::PullParserToken -- tokens from Pod::Simple::PullParser
  
  =head1 SYNOPSIS
  
  Given a $parser that's an object of class Pod::Simple::PullParser
  (or a subclass)...
  
    while(my $token = $parser->get_token) {
      $DEBUG and print STDERR "Token: ", $token->dump, "\n";
      if($token->is_start) {
        ...access $token->tagname, $token->attr, etc...
  
      } elsif($token->is_text) {
        ...access $token->text, $token->text_r, etc...
  
      } elsif($token->is_end) {
        ...access $token->tagname...
  
      }
    }
  
  (Also see L<Pod::Simple::PullParser>)
  
  =head1 DESCRIPTION
  
  When you do $parser->get_token on a L<Pod::Simple::PullParser>, you should
  get an object of a subclass of Pod::Simple::PullParserToken.
  
  Subclasses will add methods, and will also inherit these methods:
  
  =over
  
  =item $token->type
  
  This returns the type of the token.  This will be either the string
  "start", the string "text", or the string "end".
  
  Once you know what the type of an object is, you then know what
  subclass it belongs to, and therefore what methods it supports.
  
  Yes, you could probably do the same thing with code like
  $token->isa('Pod::Simple::PullParserEndToken'), but that's not so
  pretty as using just $token->type, or even the following shortcuts:
  
  =item $token->is_start
  
  This is a shortcut for C<< $token->type() eq "start" >>
  
  =item $token->is_text
  
  This is a shortcut for C<< $token->type() eq "text" >>
  
  =item $token->is_end
  
  This is a shortcut for C<< $token->type() eq "end" >>
  
  =item $token->dump
  
  This returns a handy stringified value of this object.  This
  is useful for debugging, as in:
  
    while(my $token = $parser->get_token) {
      $DEBUG and print STDERR "Token: ", $token->dump, "\n";
      ...
    }
  
  =back
  
  =head1 SEE ALSO
  
  My subclasses:
  L<Pod::Simple::PullParserStartToken>,
  L<Pod::Simple::PullParserTextToken>, and
  L<Pod::Simple::PullParserEndToken>.
  
  L<Pod::Simple::PullParser> and L<Pod::Simple>
  
  =head1 SUPPORT
  
  Questions or discussion about POD and Pod::Simple should be sent to the
  pod-people@perl.org mail list. Send an empty email to
  pod-people-subscribe@perl.org to subscribe.
  
  This module is managed in an open GitHub repository,
  L<https://github.com/perl-pod/pod-simple/>. Feel free to fork and contribute, or
  to clone L<git://github.com/perl-pod/pod-simple.git> and send patches!
  
  Patches against Pod::Simple are welcome. Please send bug reports to
  <bug-pod-simple@rt.cpan.org>.
  
  =head1 COPYRIGHT AND DISCLAIMERS
  
  Copyright (c) 2002 Sean M. Burke.
  
  This library is free software; you can redistribute it and/or modify it
  under the same terms as Perl itself.
  
  This program is distributed in the hope that it will be useful, but
  without any warranty; without even the implied warranty of
  merchantability or fitness for a particular purpose.
  
  =head1 AUTHOR
  
  Pod::Simple was created by Sean M. Burke <sburke@cpan.org>.
  But don't bother him, he's retired.
  
  Pod::Simple is maintained by:
  
  =over
  
  =item * Allison Randal C<allison@perl.org>
  
  =item * Hans Dieter Pearcey C<hdp@cpan.org>
  
  =item * David E. Wheeler C<dwheeler@cpan.org>
  
  =back
  
  =cut
POD_SIMPLE_PULLPARSERTOKEN

$fatpacked{"Pod/Simple/RTF.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POD_SIMPLE_RTF';
  
  require 5;
  package Pod::Simple::RTF;
  
  #sub DEBUG () {4};
  #sub Pod::Simple::DEBUG () {4};
  #sub Pod::Simple::PullParser::DEBUG () {4};
  
  use strict;
  use vars qw($VERSION @ISA %Escape $WRAP %Tagmap);
  $VERSION = '3.35';
  use Pod::Simple::PullParser ();
  BEGIN {@ISA = ('Pod::Simple::PullParser')}
  
  use Carp ();
  BEGIN { *DEBUG = \&Pod::Simple::DEBUG unless defined &DEBUG }
  
  $WRAP = 1 unless defined $WRAP;
  
  # These are broken for early Perls on EBCDIC; they could be fixed to work
  # better there, but not worth it.  These are part of a larger [...] class, so
  # are just the strings to substitute into it, as opposed to compiled patterns.
  my $cntrl = '[:cntrl:]';
  $cntrl = '\x00-\x1F\x7F' unless eval "qr/[$cntrl]/";
  
  my $not_ascii = '[:^ascii:]';
  $not_ascii = '\x80-\xFF' unless eval "qr/[$not_ascii]/";
  
  
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  
  sub _openclose {
   return map {;
     m/^([-A-Za-z]+)=(\w[^\=]*)$/s or die "what's <$_>?";
     ( $1,  "{\\$2\n",   "/$1",  "}" );
   } @_;
  }
  
  my @_to_accept;
  
  %Tagmap = (
   # 'foo=bar' means ('foo' => '{\bar'."\n", '/foo' => '}')
   _openclose(
    'B=cs18\b',
    'I=cs16\i',
    'C=cs19\f1\lang1024\noproof',
    'F=cs17\i\lang1024\noproof',
  
    'VerbatimI=cs26\i',
    'VerbatimB=cs27\b',
    'VerbatimBI=cs28\b\i',
  
    map {; m/^([-a-z]+)/s && push @_to_accept, $1; $_ }
     qw[
         underline=ul         smallcaps=scaps  shadow=shad
         superscript=super    subscript=sub    strikethrough=strike
         outline=outl         emboss=embo      engrave=impr   
         dotted-underline=uld          dash-underline=uldash
         dot-dash-underline=uldashd    dot-dot-dash-underline=uldashdd     
         double-underline=uldb         thick-underline=ulth
         word-underline=ulw            wave-underline=ulwave
     ]
     # But no double-strikethrough, because MSWord can't agree with the
     #  RTF spec on whether it's supposed to be \strikedl or \striked1 (!!!)
   ),
  
   # Bit of a hack here:
   'L=pod' => '{\cs22\i'."\n",
   'L=url' => '{\cs23\i'."\n",
   'L=man' => '{\cs24\i'."\n",
   '/L' => '}',
  
   'Data'  => "\n",
   '/Data' => "\n",
  
   'Verbatim'  => "\n{\\pard\\li#rtfindent##rtfkeep#\\plain\\s20\\sa180\\f1\\fs18\\lang1024\\noproof\n",
   '/Verbatim' => "\n\\par}\n",
   'VerbatimFormatted'  => "\n{\\pard\\li#rtfindent##rtfkeep#\\plain\\s20\\sa180\\f1\\fs18\\lang1024\\noproof\n",
   '/VerbatimFormatted' => "\n\\par}\n",
   'Para'    => "\n{\\pard\\li#rtfindent#\\sa180\n",
   '/Para'   => "\n\\par}\n",
   'head1'   => "\n{\\pard\\li#rtfindent#\\s31\\keepn\\sb90\\sa180\\f2\\fs#head1_halfpoint_size#\\ul{\n",
   '/head1'  => "\n}\\par}\n",
   'head2'   => "\n{\\pard\\li#rtfindent#\\s32\\keepn\\sb90\\sa180\\f2\\fs#head2_halfpoint_size#\\ul{\n",
   '/head2'  => "\n}\\par}\n",
   'head3'   => "\n{\\pard\\li#rtfindent#\\s33\\keepn\\sb90\\sa180\\f2\\fs#head3_halfpoint_size#\\ul{\n",
   '/head3'  => "\n}\\par}\n",
   'head4'   => "\n{\\pard\\li#rtfindent#\\s34\\keepn\\sb90\\sa180\\f2\\fs#head4_halfpoint_size#\\ul{\n",
   '/head4'  => "\n}\\par}\n",
     # wordpad borks on \tc\tcl1, or I'd put that in =head1 and =head2
  
   'item-bullet'  => "\n{\\pard\\li#rtfindent##rtfitemkeepn#\\sb60\\sa150\\fi-120\n",
   '/item-bullet' => "\n\\par}\n",
   'item-number'  => "\n{\\pard\\li#rtfindent##rtfitemkeepn#\\sb60\\sa150\\fi-120\n",
   '/item-number' => "\n\\par}\n",
   'item-text'    => "\n{\\pard\\li#rtfindent##rtfitemkeepn#\\sb60\\sa150\\fi-120\n",
   '/item-text'   => "\n\\par}\n",
  
   # we don't need any styles for over-* and /over-*
  );
  
  
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  sub new {
    my $new = shift->SUPER::new(@_);
    $new->nix_X_codes(1);
    $new->nbsp_for_S(1);
    $new->accept_targets( 'rtf', 'RTF' );
  
    $new->{'Tagmap'} = {%Tagmap};
  
    $new->accept_codes(@_to_accept);
    $new->accept_codes('VerbatimFormatted');
    DEBUG > 2 and print STDERR "To accept: ", join(' ',@_to_accept), "\n";
    $new->doc_lang(
      (  $ENV{'RTFDEFLANG'} || '') =~ m/^(\d{1,10})$/s ? $1
      : ($ENV{'RTFDEFLANG'} || '') =~ m/^0?x([a-fA-F0-9]{1,10})$/s ? hex($1)
                                        # yes, tolerate hex!
      : ($ENV{'RTFDEFLANG'} || '') =~ m/^([a-fA-F0-9]{4})$/s ? hex($1)
                                        # yes, tolerate even more hex!
      : '1033'
    );
  
    $new->head1_halfpoint_size(32);
    $new->head2_halfpoint_size(28);
    $new->head3_halfpoint_size(25);
    $new->head4_halfpoint_size(22);
    $new->codeblock_halfpoint_size(18);
    $new->header_halfpoint_size(17);
    $new->normal_halfpoint_size(25);
  
    return $new;
  }
  
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  
  __PACKAGE__->_accessorize(
   'doc_lang',
   'head1_halfpoint_size',
   'head2_halfpoint_size',
   'head3_halfpoint_size',
   'head4_halfpoint_size',
   'codeblock_halfpoint_size',
   'header_halfpoint_size',
   'normal_halfpoint_size',
   'no_proofing_exemptions',
  );
  
  
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  sub run {
    my $self = $_[0];
    return $self->do_middle if $self->bare_output;
    return
     $self->do_beginning && $self->do_middle && $self->do_end;
  }
  
  
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  
  sub do_middle {      # the main work
    my $self = $_[0];
    my $fh = $self->{'output_fh'};
    
    my($token, $type, $tagname, $scratch);
    my @stack;
    my @indent_stack;
    $self->{'rtfindent'} = 0 unless defined $self->{'rtfindent'};
    
    while($token = $self->get_token) {
    
      if( ($type = $token->type) eq 'text' ) {
        if( $self->{'rtfverbatim'} ) {
          DEBUG > 1 and print STDERR "  $type " , $token->text, " in verbatim!\n";
          rtf_esc_codely($scratch = $token->text);
          print $fh $scratch;
          next;
        }
  
        DEBUG > 1 and print STDERR "  $type " , $token->text, "\n";
        
        $scratch = $token->text;
        $scratch =~ tr/\t\cb\cc/ /d;
        
        $self->{'no_proofing_exemptions'} or $scratch =~
         s/(?:
             ^
             |
             (?<=[\r\n\t "\[\<\(])
           )   # start on whitespace, sequence-start, or quote
           ( # something looking like a Perl token:
            (?:
             [\$\@\:\<\*\\_]\S+  # either starting with a sigil, etc.
            )
            |
            # or starting alpha, but containing anything strange:
            (?:
             [a-zA-Z'${not_ascii}]+[\$\@\:_<>\(\\\*]\S+
            )
           )
          /\cb$1\cc/xsg
        ;
        
        rtf_esc($scratch);
        $scratch =~
           s/(
              [^\r\n]{65}        # Snare 65 characters from a line
              [^\r\n ]{0,50}     #  and finish any current word
             )
             (\ {1,10})(?![\r\n]) # capture some spaces not at line-end
            /$1$2\n/gx     # and put a NL before those spaces
          if $WRAP;
          # This may wrap at well past the 65th column, but not past the 120th.
        
        print $fh $scratch;
  
      } elsif( $type eq 'start' ) {
        DEBUG > 1 and print STDERR "  +$type ",$token->tagname,
          " (", map("<$_> ", %{$token->attr_hash}), ")\n";
  
        if( ($tagname = $token->tagname) eq 'Verbatim'
            or $tagname eq 'VerbatimFormatted'
        ) {
          ++$self->{'rtfverbatim'};
          my $next = $self->get_token;
          next unless defined $next;
          my $line_count = 1;
          if($next->type eq 'text') {
            my $t = $next->text_r;
            while( $$t =~ m/$/mg ) {
              last if  ++$line_count  > 15; # no point in counting further
            }
            DEBUG > 3 and print STDERR "    verbatim line count: $line_count\n";
          }
          $self->unget_token($next);
          $self->{'rtfkeep'} = ($line_count > 15) ? '' : '\keepn' ;     
  
        } elsif( $tagname =~ m/^item-/s ) {
          my @to_unget;
          my $text_count_here = 0;
          $self->{'rtfitemkeepn'} = '';
          # Some heuristics to stop item-*'s functioning as subheadings
          #  from getting split from the things they're subheadings for.
          #
          # It's not terribly pretty, but it really does make things pretty.
          #
          while(1) {
            push @to_unget, $self->get_token;
            pop(@to_unget), last unless defined $to_unget[-1];
             # Erroneously used to be "unshift" instead of pop!  Adds instead
             # of removes, and operates on the beginning instead of the end!
            
            if($to_unget[-1]->type eq 'text') {
              if( ($text_count_here += length ${$to_unget[-1]->text_r}) > 150 ){
                DEBUG > 1 and print STDERR "    item-* is too long to be keepn'd.\n";
                last;
              }
            } elsif (@to_unget > 1 and
              $to_unget[-2]->type eq 'end' and
              $to_unget[-2]->tagname =~ m/^item-/s
            ) {
              # Bail out here, after setting rtfitemkeepn yea or nay.
              $self->{'rtfitemkeepn'} = '\keepn' if 
                $to_unget[-1]->type eq 'start' and
                $to_unget[-1]->tagname eq 'Para';
  
              DEBUG > 1 and printf STDERR "    item-* before %s(%s) %s keepn'd.\n",
                $to_unget[-1]->type,
                $to_unget[-1]->can('tagname') ? $to_unget[-1]->tagname : '',
                $self->{'rtfitemkeepn'} ? "gets" : "doesn't get";
              last;
            } elsif (@to_unget > 40) {
              DEBUG > 1 and print STDERR "    item-* now has too many tokens (",
                scalar(@to_unget),
                (DEBUG > 4) ? (q<: >, map($_->dump, @to_unget)) : (),
                ") to be keepn'd.\n";
              last; # give up
            }
            # else keep while'ing along
          }
          # Now put it aaaaall back...
          $self->unget_token(@to_unget);
  
        } elsif( $tagname =~ m/^over-/s ) {
          push @stack, $1;
          push @indent_stack,
           int($token->attr('indent') * 4 * $self->normal_halfpoint_size);
          DEBUG and print STDERR "Indenting over $indent_stack[-1] twips.\n";
          $self->{'rtfindent'} += $indent_stack[-1];
          
        } elsif ($tagname eq 'L') {
          $tagname .= '=' . ($token->attr('type') || 'pod');
          
        } elsif ($tagname eq 'Data') {
          my $next = $self->get_token;
          next unless defined $next;
          unless( $next->type eq 'text' ) {
            $self->unget_token($next);
            next;
          }
          DEBUG and print STDERR "    raw text ", $next->text, "\n";
          printf $fh "\n" . $next->text . "\n";
          next;
        }
  
        defined($scratch = $self->{'Tagmap'}{$tagname}) or next;
        $scratch =~ s/\#([^\#]+)\#/${$self}{$1}/g; # interpolate
        print $fh $scratch;
        
        if ($tagname eq 'item-number') {
          print $fh $token->attr('number'), ". \n";
        } elsif ($tagname eq 'item-bullet') {
          print $fh "\\'", ord("_"), "\n";
          #for funky testing: print $fh '', rtf_esc("\x{4E4B}\x{9053}");
        }
  
      } elsif( $type eq 'end' ) {
        DEBUG > 1 and print STDERR "  -$type ",$token->tagname,"\n";
        if( ($tagname = $token->tagname) =~ m/^over-/s ) {
          DEBUG and print STDERR "Indenting back $indent_stack[-1] twips.\n";
          $self->{'rtfindent'} -= pop @indent_stack;
          pop @stack;
        } elsif( $tagname eq 'Verbatim' or $tagname eq 'VerbatimFormatted') {
          --$self->{'rtfverbatim'};
        }
        defined($scratch = $self->{'Tagmap'}{"/$tagname"}) or next;
        $scratch =~ s/\#([^\#]+)\#/${$self}{$1}/g; # interpolate
        print $fh $scratch;
      }
    }
    return 1;
  }
  
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  sub do_beginning {
    my $self = $_[0];
    my $fh = $self->{'output_fh'};
    return print $fh join '',
      $self->doc_init,
      $self->font_table,
      $self->stylesheet,
      $self->color_table,
      $self->doc_info,
      $self->doc_start,
      "\n"
    ;
  }
  
  sub do_end {
    my $self = $_[0];
    my $fh = $self->{'output_fh'};
    return print $fh '}'; # that should do it
  }
  
  ###########################################################################
  
  sub stylesheet {
    return sprintf <<'END',
  {\stylesheet
  {\snext0 Normal;}
  {\*\cs10 \additive Default Paragraph Font;}
  {\*\cs16 \additive \i \sbasedon10 pod-I;}
  {\*\cs17 \additive \i\lang1024\noproof \sbasedon10 pod-F;}
  {\*\cs18 \additive \b \sbasedon10 pod-B;}
  {\*\cs19 \additive \f1\lang1024\noproof\sbasedon10 pod-C;}
  {\s20\ql \li0\ri0\sa180\widctlpar\f1\fs%s\lang1024\noproof\sbasedon0 \snext0 pod-codeblock;}
  {\*\cs21 \additive \lang1024\noproof \sbasedon10 pod-computerese;}
  {\*\cs22 \additive \i\lang1024\noproof\sbasedon10 pod-L-pod;}
  {\*\cs23 \additive \i\lang1024\noproof\sbasedon10 pod-L-url;}
  {\*\cs24 \additive \i\lang1024\noproof\sbasedon10 pod-L-man;}
  
  {\*\cs25 \additive \f1\lang1024\noproof\sbasedon0 pod-codelbock-plain;}
  {\*\cs26 \additive \f1\lang1024\noproof\sbasedon25 pod-codelbock-ital;}
  {\*\cs27 \additive \f1\lang1024\noproof\sbasedon25 pod-codelbock-bold;}
  {\*\cs28 \additive \f1\lang1024\noproof\sbasedon25 pod-codelbock-bold-ital;}
  
  {\s31\ql \keepn\sb90\sa180\f2\fs%s\ul\sbasedon0 \snext0 pod-head1;}
  {\s32\ql \keepn\sb90\sa180\f2\fs%s\ul\sbasedon0 \snext0 pod-head2;}
  {\s33\ql \keepn\sb90\sa180\f2\fs%s\ul\sbasedon0 \snext0 pod-head3;}
  {\s34\ql \keepn\sb90\sa180\f2\fs%s\ul\sbasedon0 \snext0 pod-head4;}
  }
  
  END
  
     $_[0]->codeblock_halfpoint_size(),
     $_[0]->head1_halfpoint_size(),
     $_[0]->head2_halfpoint_size(),
     $_[0]->head3_halfpoint_size(),
     $_[0]->head4_halfpoint_size(),
    ;
  }
  
  ###########################################################################
  # Override these as necessary for further customization
  
  sub font_table {
    return <<'END';  # text font, code font, heading font
  {\fonttbl
  {\f0\froman Times New Roman;}
  {\f1\fmodern Courier New;}
  {\f2\fswiss Arial;}
  }
  
  END
  }
  
  sub doc_init {
     return <<'END';
  {\rtf1\ansi\deff0
  
  END
  }
  
  sub color_table {
     return <<'END';
  {\colortbl;\red255\green0\blue0;\red0\green0\blue255;}
  END
  }
  
  
  sub doc_info {
     my $self = $_[0];
  
     my $class = ref($self) || $self;
  
     my $tag = __PACKAGE__ . ' ' . $VERSION;
     
     unless($class eq __PACKAGE__) {
       $tag = " ($tag)";
       $tag = " v" . $self->VERSION . $tag   if   defined $self->VERSION;
       $tag = $class . $tag;
     }
  
     return sprintf <<'END',
  {\info{\doccomm
  %s
   using %s v%s
   under Perl v%s at %s GMT}
  {\author [see doc]}{\company [see doc]}{\operator [see doc]}
  }
  
  END
  
    # None of the following things should need escaping, I dare say!
      $tag, 
      $ISA[0], $ISA[0]->VERSION(),
      $], scalar(gmtime),
    ;
  }
  
  sub doc_start {
    my $self = $_[0];
    my $title = $self->get_short_title();
    DEBUG and print STDERR "Short Title: <$title>\n";
    $title .= ' ' if length $title;
    
    $title =~ s/ *$/ /s;
    $title =~ s/^ //s;
    $title =~ s/ $/, /s;
     # make sure it ends in a comma and a space, unless it's 0-length
  
    my $is_obviously_module_name;
    $is_obviously_module_name = 1
     if $title =~ m/^\S+$/s and $title =~ m/::/s;
      # catches the most common case, at least
  
    DEBUG and print STDERR "Title0: <$title>\n";
    $title = rtf_esc($title);
    DEBUG and print STDERR "Title1: <$title>\n";
    $title = '\lang1024\noproof ' . $title
     if $is_obviously_module_name;
  
    return sprintf <<'END', 
  \deflang%s\plain\lang%s\widowctrl
  {\header\pard\qr\plain\f2\fs%s
  %s
  p.\chpgn\par}
  \fs%s
  
  END
      ($self->doc_lang) x 2,
      $self->header_halfpoint_size,
      $title,
      $self->normal_halfpoint_size,
    ;
  }
  
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  #-------------------------------------------------------------------------
  
  use integer;
  sub rtf_esc {
    my $x; # scratch
    if(!defined wantarray) { # void context: alter in-place!
      for(@_) {
        s/([F${cntrl}\-\\\{\}${not_ascii}])/$Escape{$1}/g;  # ESCAPER
        s/([^\x00-\xFF])/'\\uc1\\u'.((ord($1)<32768)?ord($1):(ord($1)-65536)).'?'/eg;
      }
      return;
    } elsif(wantarray) {  # return an array
      return map {; ($x = $_) =~
        s/([F${cntrl}\-\\\{\}${not_ascii}])/$Escape{$1}/g;  # ESCAPER
        $x =~ s/([^\x00-\xFF])/'\\uc1\\u'.((ord($1)<32768)?ord($1):(ord($1)-65536)).'?'/eg;
        $x;
      } @_;
    } else { # return a single scalar
      ($x = ((@_ == 1) ? $_[0] : join '', @_)
      ) =~ s/([F${cntrl}\-\\\{\}${not_ascii}])/$Escape{$1}/g;  # ESCAPER
               # Escape \, {, }, -, control chars, and 7f-ff.
      $x =~ s/([^\x00-\xFF])/'\\uc1\\u'.((ord($1)<32768)?ord($1):(ord($1)-65536)).'?'/eg;
      return $x;
    }
  }
  
  sub rtf_esc_codely {
    # Doesn't change "-" to hard-hyphen, nor apply computerese style-smarts.
    # We don't want to change the "-" to hard-hyphen, because we want to
    #  be able to paste this into a file and run it without there being
    #  dire screaming about the mysterious hard-hyphen character (which
    #  looks just like a normal dash character).
    
    my $x; # scratch
    if(!defined wantarray) { # void context: alter in-place!
      for(@_) {
        s/([F${cntrl}\\\{\}${not_ascii}])/$Escape{$1}/g;  # ESCAPER
        s/([^\x00-\xFF])/'\\uc1\\u'.((ord($1)<32768)?ord($1):(ord($1)-65536)).'?'/eg;
      }
      return;
    } elsif(wantarray) {  # return an array
      return map {; ($x = $_) =~
        s/([F${cntrl}\\\{\}${not_ascii}])/$Escape{$1}/g;  # ESCAPER
        $x =~ s/([^\x00-\xFF])/'\\uc1\\u'.((ord($1)<32768)?ord($1):(ord($1)-65536)).'?'/eg;
        $x;
      } @_;
    } else { # return a single scalar
      ($x = ((@_ == 1) ? $_[0] : join '', @_)
      ) =~ s/([F${cntrl}\\\{\}${not_ascii}])/$Escape{$1}/g;  # ESCAPER
               # Escape \, {, }, -, control chars, and 7f-ff.
      $x =~ s/([^\x00-\xFF])/'\\uc1\\u'.((ord($1)<32768)?ord($1):(ord($1)-65536)).'?'/eg;
      return $x;
    }
  }
  
  %Escape = (
    (($] lt 5.007_003) # Broken for non-ASCII on early Perls
     ? (map( (chr($_),chr($_)), # things not apparently needing escaping
         0x20 .. 0x7E ),
        map( (chr($_),sprintf("\\'%02x", $_)), # apparently escapeworthy things
         0x00 .. 0x1F, 0x5c, 0x7b, 0x7d, 0x7f .. 0xFF, 0x46))
     : (map( (chr(utf8::unicode_to_native($_)),chr(utf8::unicode_to_native($_))),
         0x20 .. 0x7E ),
        map( (chr($_),sprintf("\\'%02x", utf8::unicode_to_native($_))),
         0x00 .. 0x1F, 0x5c, 0x7b, 0x7d, 0x7f .. 0xFF, 0x46))),
  
    # We get to escape out 'F' so that we can send RTF files thru the mail
    # without the slightest worry that paragraphs beginning with "From"
    # will get munged.
  
    # And some refinements:
    "\r"  => "\n",
    "\cj"  => "\n",
    "\n"   => "\n\\line ",
  
    "\t"   => "\\tab ",     # Tabs (altho theoretically raw \t's are okay)
    "\f"   => "\n\\page\n", # Formfeed
    "-"    => "\\_",        # Turn plaintext '-' into a non-breaking hyphen
    $Pod::Simple::nbsp => "\\~",        # Latin-1 non-breaking space
    $Pod::Simple::shy => "\\-",        # Latin-1 soft (optional) hyphen
  
    # CRAZY HACKS:
    "\n" => "\\line\n",
    "\r" => "\n",
    "\cb" => "{\n\\cs21\\lang1024\\noproof ",  # \\cf1
    "\cc" => "}",
  );
  1;
  
  __END__
  
  =head1 NAME
  
  Pod::Simple::RTF -- format Pod as RTF
  
  =head1 SYNOPSIS
  
    perl -MPod::Simple::RTF -e \
     "exit Pod::Simple::RTF->filter(shift)->any_errata_seen" \
     thingy.pod > thingy.rtf
  
  =head1 DESCRIPTION
  
  This class is a formatter that takes Pod and renders it as RTF, good for
  viewing/printing in MSWord, WordPad/write.exe, TextEdit, etc.
  
  This is a subclass of L<Pod::Simple> and inherits all its methods.
  
  =head1 FORMAT CONTROL ATTRIBUTES
  
  You can set these attributes on the parser object before you
  call C<parse_file> (or a similar method) on it:
  
  =over
  
  =item $parser->head1_halfpoint_size( I<halfpoint_integer> );
  
  =item $parser->head2_halfpoint_size( I<halfpoint_integer> );
  
  =item $parser->head3_halfpoint_size( I<halfpoint_integer> );
  
  =item $parser->head4_halfpoint_size( I<halfpoint_integer> );
  
  These methods set the size (in half-points, like 52 for 26-point)
  that these heading levels will appear as.
  
  =item $parser->codeblock_halfpoint_size( I<halfpoint_integer> );
  
  This method sets the size (in half-points, like 21 for 10.5-point)
  that codeblocks ("verbatim sections") will appear as.
  
  =item $parser->header_halfpoint_size( I<halfpoint_integer> );
  
  This method sets the size (in half-points, like 15 for 7.5-point)
  that the header on each page will appear in.  The header
  is usually just "I<modulename> p. I<pagenumber>".
  
  =item $parser->normal_halfpoint_size( I<halfpoint_integer> );
  
  This method sets the size (in half-points, like 26 for 13-point)
  that normal paragraphic text will appear in.
  
  =item $parser->no_proofing_exemptions( I<true_or_false> );
  
  Set this value to true if you don't want the formatter to try
  putting a hidden code on all Perl symbols (as best as it can
  notice them) that labels them as being not in English, and
  so not worth spellchecking.
  
  =item $parser->doc_lang( I<microsoft_decimal_language_code> )
  
  This sets the language code to tag this document as being in. By
  default, it is currently the value of the environment variable
  C<RTFDEFLANG>, or if that's not set, then the value
  1033 (for US English).
  
  Setting this appropriately is useful if you want to use the RTF
  to spellcheck, and/or if you want it to hyphenate right.
  
  Here are some notable values:
  
    1033  US English
    2057  UK English
    3081  Australia English
    4105  Canada English
    1034  Spain Spanish
    2058  Mexico Spanish
    1031  Germany German
    1036  France French
    3084  Canada French
    1035  Finnish
    1044  Norwegian (Bokmal)
    2068  Norwegian (Nynorsk)
  
  =back
  
  If you are particularly interested in customizing this module's output
  even more, see the source and/or write to me.
  
  =head1 SEE ALSO
  
  L<Pod::Simple>, L<RTF::Writer>, L<RTF::Cookbook>, L<RTF::Document>,
  L<RTF::Generator>
  
  =head1 SUPPORT
  
  Questions or discussion about POD and Pod::Simple should be sent to the
  pod-people@perl.org mail list. Send an empty email to
  pod-people-subscribe@perl.org to subscribe.
  
  This module is managed in an open GitHub repository,
  L<https://github.com/perl-pod/pod-simple/>. Feel free to fork and contribute, or
  to clone L<git://github.com/perl-pod/pod-simple.git> and send patches!
  
  Patches against Pod::Simple are welcome. Please send bug reports to
  <bug-pod-simple@rt.cpan.org>.
  
  =head1 COPYRIGHT AND DISCLAIMERS
  
  Copyright (c) 2002 Sean M. Burke.
  
  This library is free software; you can redistribute it and/or modify it
  under the same terms as Perl itself.
  
  This program is distributed in the hope that it will be useful, but
  without any warranty; without even the implied warranty of
  merchantability or fitness for a particular purpose.
  
  =head1 AUTHOR
  
  Pod::Simple was created by Sean M. Burke <sburke@cpan.org>.
  But don't bother him, he's retired.
  
  Pod::Simple is maintained by:
  
  =over
  
  =item * Allison Randal C<allison@perl.org>
  
  =item * Hans Dieter Pearcey C<hdp@cpan.org>
  
  =item * David E. Wheeler C<dwheeler@cpan.org>
  
  =back
  
  =cut
POD_SIMPLE_RTF

$fatpacked{"Pod/Simple/Search.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POD_SIMPLE_SEARCH';
  require 5.005;
  package Pod::Simple::Search;
  use strict;
  
  use vars qw($VERSION $MAX_VERSION_WITHIN $SLEEPY);
  $VERSION = '3.35';   ## Current version of this package
  
  BEGIN { *DEBUG = sub () {0} unless defined &DEBUG; }   # set DEBUG level
  use Carp ();
  
  $SLEEPY = 1 if !defined $SLEEPY and $^O =~ /mswin|mac/i;
    # flag to occasionally sleep for $SLEEPY - 1 seconds.
  
  $MAX_VERSION_WITHIN ||= 60;
  my $IS_CASE_INSENSITIVE = -e uc __FILE__ && -e lc __FILE__;
  
  #############################################################################
  
  #use diagnostics;
  use File::Spec ();
  use File::Basename qw( basename dirname );
  use Config ();
  use Cwd qw( cwd );
  
  #==========================================================================
  __PACKAGE__->_accessorize(  # Make my dumb accessor methods
   'callback', 'progress', 'dir_prefix', 'inc', 'laborious', 'limit_glob',
   'limit_re', 'shadows', 'verbose', 'name2path', 'path2name', 'recurse',
   'ciseen'
  );
  #==========================================================================
  
  sub new {
    my $class = shift;
    my $self = bless {}, ref($class) || $class;
    $self->init;
    return $self;
  }
  
  sub init {
    my $self = shift;
    $self->inc(1);
    $self->recurse(1);
    $self->verbose(DEBUG);
    return $self;
  }
  
  #--------------------------------------------------------------------------
  
  sub survey {
    my($self, @search_dirs) = @_;
    $self = $self->new unless ref $self; # tolerate being a class method
  
    $self->_expand_inc( \@search_dirs );
  
    $self->{'_scan_count'} = 0;
    $self->{'_dirs_visited'} = {};
    $self->path2name( {} );
    $self->name2path( {} );
    $self->ciseen( {} );
    $self->limit_re( $self->_limit_glob_to_limit_re ) if $self->{'limit_glob'};
    my $cwd = cwd();
    my $verbose  = $self->verbose;
    local $_; # don't clobber the caller's $_ !
  
    foreach my $try (@search_dirs) {
      unless( File::Spec->file_name_is_absolute($try) ) {
        # make path absolute
        $try = File::Spec->catfile( $cwd ,$try);
      }
      # simplify path
      $try =  File::Spec->canonpath($try);
  
      my $start_in;
      my $modname_prefix;
      if($self->{'dir_prefix'}) {
        $start_in = File::Spec->catdir(
          $try,
          grep length($_), split '[\\/:]+', $self->{'dir_prefix'}
        );
        $modname_prefix = [grep length($_), split m{[:/\\]}, $self->{'dir_prefix'}];
        $verbose and print "Appending \"$self->{'dir_prefix'}\" to $try, ",
          "giving $start_in (= @$modname_prefix)\n";
      } else {
        $start_in = $try;
      }
  
      if( $self->{'_dirs_visited'}{$start_in} ) {
        $verbose and print "Directory '$start_in' already seen, skipping.\n";
        next;
      } else {
        $self->{'_dirs_visited'}{$start_in} = 1;
      }
    
      unless(-e $start_in) {
        $verbose and print "Skipping non-existent $start_in\n";
        next;
      }
  
      my $closure = $self->_make_search_callback;
      
      if(-d $start_in) {
        # Normal case:
        $verbose and print "Beginning excursion under $start_in\n";
        $self->_recurse_dir( $start_in, $closure, $modname_prefix );
        $verbose and print "Back from excursion under $start_in\n\n";
          
      } elsif(-f _) {
        # A excursion consisting of just one file!
        $_ = basename($start_in);
        $verbose and print "Pondering $start_in ($_)\n";
        $closure->($start_in, $_, 0, []);
          
      } else {
        $verbose and print "Skipping mysterious $start_in\n";
      }
    }
    $self->progress and $self->progress->done(
     "Noted $$self{'_scan_count'} Pod files total");
    $self->ciseen( {} );
  
    return unless defined wantarray; # void
    return $self->name2path unless wantarray; # scalar
    return $self->name2path, $self->path2name; # list
  }
  
  #==========================================================================
  sub _make_search_callback {
    my $self = $_[0];
  
    # Put the options in variables, for easy access
    my( $laborious, $verbose, $shadows, $limit_re, $callback, $progress,
        $path2name, $name2path, $recurse, $ciseen) =
      map scalar($self->$_()),
       qw(laborious verbose shadows limit_re callback progress
          path2name name2path recurse ciseen);
    my ($seen, $remember, $files_for);
    if ($IS_CASE_INSENSITIVE) {
        $seen      = sub { $ciseen->{ lc $_[0] } };
        $remember  = sub { $name2path->{ $_[0] } = $ciseen->{ lc $_[0] } = $_[1]; };
        $files_for = sub { my $n = lc $_[0]; grep { lc $path2name->{$_} eq $n } %{ $path2name } };
    } else {
        $seen      = sub { $name2path->{ $_[0] } };
        $remember  = sub { $name2path->{ $_[0] } = $_[1] };
        $files_for = sub { my $n = $_[0]; grep { $path2name->{$_} eq $n } %{ $path2name } };
    }
  
    my($file, $shortname, $isdir, $modname_bits);
    return sub {
      ($file, $shortname, $isdir, $modname_bits) = @_;
  
      if($isdir) { # this never gets called on the startdir itself, just subdirs
  
        unless( $recurse ) {
          $verbose and print "Not recursing into '$file' as per requested.\n";
          return 'PRUNE';
        }
  
        if( $self->{'_dirs_visited'}{$file} ) {
          $verbose and print "Directory '$file' already seen, skipping.\n";
          return 'PRUNE';
        }
  
        print "Looking in dir $file\n" if $verbose;
  
        unless ($laborious) { # $laborious overrides pruning
          if( m/^(\d+\.[\d_]{3,})\z/s
               and do { my $x = $1; $x =~ tr/_//d; $x != $] }
             ) {
            $verbose and print "Perl $] version mismatch on $_, skipping.\n";
            return 'PRUNE';
          }
  
          if( m/^([A-Za-z][a-zA-Z0-9_]*)\z/s ) {
            $verbose and print "$_ is a well-named module subdir.  Looking....\n";
          } else {
            $verbose and print "$_ is a fishy directory name.  Skipping.\n";
            return 'PRUNE';
          }
        } # end unless $laborious
  
        $self->{'_dirs_visited'}{$file} = 1;
        return; # (not pruning);
      }
  
      # Make sure it's a file even worth even considering
      if($laborious) {
        unless(
          m/\.(pod|pm|plx?)\z/i || -x _ and -T _
           # Note that the cheapest operation (the RE) is run first.
        ) {
          $verbose > 1 and print " Brushing off uninteresting $file\n";
          return;
        }
      } else {
        unless( m/^[-_a-zA-Z0-9]+\.(?:pod|pm|plx?)\z/is ) {
          $verbose > 1 and print " Brushing off oddly-named $file\n";
          return;
        }
      }
  
      $verbose and print "Considering item $file\n";
      my $name = $self->_path2modname( $file, $shortname, $modname_bits );
      $verbose > 0.01 and print " Nominating $file as $name\n";
          
      if($limit_re and $name !~ m/$limit_re/i) {
        $verbose and print "Shunning $name as not matching $limit_re\n";
        return;
      }
  
      if( !$shadows and $seen->($name) ) {
        $verbose and print "Not worth considering $file ",
          "-- already saw $name as ",
          join(' ', $files_for->($name)), "\n";
        return;
      }
  
      # Put off until as late as possible the expense of
      #  actually reading the file:
      $progress and $progress->reach($self->{'_scan_count'}, "Scanning $file");
      return unless $self->contains_pod( $file );
      ++ $self->{'_scan_count'};
  
      # Or finally take note of it:
      if ( my $prev = $seen->($name)  ) {
        $verbose and print
         "Duplicate POD found (shadowing?): $name ($file)\n",
         "    Already seen in ", join(' ', $files_for->($name)), "\n";
      } else {
        $remember->($name, $file); # Noting just the first occurrence
      }
      $verbose and print "  Noting $name = $file\n";
      if( $callback ) {
        local $_ = $_; # insulate from changes, just in case
        $callback->($file, $name);
      }
      $path2name->{$file} = $name;
      return;
    }
  }
  
  #==========================================================================
  
  sub _path2modname {
    my($self, $file, $shortname, $modname_bits) = @_;
  
    # this code simplifies the POD name for Perl modules:
    # * remove "site_perl"
    # * remove e.g. "i586-linux" (from 'archname')
    # * remove e.g. 5.00503
    # * remove pod/ if followed by perl*.pod (e.g. in pod/perlfunc.pod)
    # * dig into the file for case-preserved name if not already mixed case
  
    my @m = @$modname_bits;
    my $x;
    my $verbose = $self->verbose;
  
    # Shaving off leading naughty-bits
    while(@m
      and defined($x = lc( $m[0] ))
      and(  $x eq 'site_perl'
         or($x eq 'pod' and @m == 1 and $shortname =~ m{^perl.*\.pod$}s )
         or $x =~ m{\\d+\\.z\\d+([_.]?\\d+)?}  # if looks like a vernum
         or $x eq lc( $Config::Config{'archname'} )
    )) { shift @m }
  
    my $name = join '::', @m, $shortname;
    $self->_simplify_base($name);
  
    # On VMS, case-preserved document names can't be constructed from
    # filenames, so try to extract them from the "=head1 NAME" tag in the
    # file instead.
    if ($^O eq 'VMS' && ($name eq lc($name) || $name eq uc($name))) {
        open PODFILE, "<$file" or die "_path2modname: Can't open $file: $!";
        my $in_pod = 0;
        my $in_name = 0;
        my $line;
        while ($line = <PODFILE>) {
          chomp $line;
          $in_pod = 1 if ($line =~ m/^=\w/);
          $in_pod = 0 if ($line =~ m/^=cut/);
          next unless $in_pod;         # skip non-pod text
          next if ($line =~ m/^\s*\z/);           # and blank lines
          next if ($in_pod && ($line =~ m/^X</)); # and commands
          if ($in_name) {
            if ($line =~ m/(\w+::)?(\w+)/) {
              # substitute case-preserved version of name
              my $podname = $2;
              my $prefix = $1 || '';
              $verbose and print "Attempting case restore of '$name' from '$prefix$podname'\n";
              unless ($name =~ s/$prefix$podname/$prefix$podname/i) {
                $verbose and print "Attempting case restore of '$name' from '$podname'\n";
                $name =~ s/$podname/$podname/i;
              }
              last;
            }
          }
          $in_name = 1 if ($line =~ m/^=head1 NAME/);
      }
      close PODFILE;
    }
  
    return $name;
  }
  
  #==========================================================================
  
  sub _recurse_dir {
    my($self, $startdir, $callback, $modname_bits) = @_;
  
    my $maxdepth = $self->{'fs_recursion_maxdepth'} || 10;
    my $verbose = $self->verbose;
  
    my $here_string = File::Spec->curdir;
    my $up_string   = File::Spec->updir;
    $modname_bits ||= [];
  
    my $recursor;
    $recursor = sub {
      my($dir_long, $dir_bare) = @_;
      if( @$modname_bits >= 10 ) {
        $verbose and print "Too deep! [@$modname_bits]\n";
        return;
      }
  
      unless(-d $dir_long) {
        $verbose > 2 and print "But it's not a dir! $dir_long\n";
        return;
      }
      unless( opendir(INDIR, $dir_long) ) {
        $verbose > 2 and print "Can't opendir $dir_long : $!\n";
        closedir(INDIR);
        return
      }
  
      # Load all items; put no extension before .pod before .pm before .plx?.
      my @items = map { $_->[0] }
        sort { $a->[1] cmp $b->[1] || $b->[2] cmp $a->[2] }
        map {
          (my $t = $_) =~ s/[.]p(m|lx?|od)\z//;
          [$_, $t, lc($1 || 'z') ]
        } readdir(INDIR);
      closedir(INDIR);
  
      push @$modname_bits, $dir_bare unless $dir_bare eq '';
  
      my $i_full;
      foreach my $i (@items) {
        next if $i eq $here_string or $i eq $up_string or $i eq '';
        $i_full = File::Spec->catfile( $dir_long, $i );
  
        if(!-r $i_full) {
          $verbose and print "Skipping unreadable $i_full\n";
         
        } elsif(-f $i_full) {
          $_ = $i;
          $callback->(          $i_full, $i, 0, $modname_bits );
  
        } elsif(-d _) {
          $i =~ s/\.DIR\z//i if $^O eq 'VMS';
          $_ = $i;
          my $rv = $callback->( $i_full, $i, 1, $modname_bits ) || '';
  
          if($rv eq 'PRUNE') {
            $verbose > 1 and print "OK, pruning";
          } else {
            # Otherwise, recurse into it
            $recursor->( File::Spec->catdir($dir_long, $i) , $i);
          }
        } else {
          $verbose > 1 and print "Skipping oddity $i_full\n";
        }
      }
      pop @$modname_bits;
      return;
    };;
  
    local $_;
    $recursor->($startdir, '');
  
    undef $recursor;  # allow it to be GC'd
  
    return;  
  }
  
  
  #==========================================================================
  
  sub run {
    # A function, useful in one-liners
  
    my $self = __PACKAGE__->new;
    $self->limit_glob($ARGV[0]) if @ARGV;
    $self->callback( sub {
      my($file, $name) = @_;
      my $version = '';
       
      # Yes, I know we won't catch the version in like a File/Thing.pm
      #  if we see File/Thing.pod first.  That's just the way the
      #  cookie crumbles.  -- SMB
       
      if($file =~ m/\.pod$/i) {
        # Don't bother looking for $VERSION in .pod files
        DEBUG and print "Not looking for \$VERSION in .pod $file\n";
      } elsif( !open(INPOD, $file) ) {
        DEBUG and print "Couldn't open $file: $!\n";
        close(INPOD);
      } else {
        # Sane case: file is readable
        my $lines = 0;
        while(<INPOD>) {
          last if $lines++ > $MAX_VERSION_WITHIN; # some degree of sanity
          if( s/^\s*\$VERSION\s*=\s*//s and m/\d/ ) {
            DEBUG and print "Found version line (#$lines): $_";
            s/\s*\#.*//s;
            s/\;\s*$//s;
            s/\s+$//s;
            s/\t+/ /s; # nix tabs
            # Optimize the most common cases:
            $_ = "v$1"
              if m{^v?["']?([0-9_]+(\.[0-9_]+)*)["']?$}s
               # like in $VERSION = "3.14159";
               or m{\$Revision:\s*([0-9_]+(?:\.[0-9_]+)*)\s*\$}s
               # like in sprintf("%d.%02d", q$Revision: 4.13 $ =~ /(\d+)\.(\d+)/);
            ;
             
            # Like in sprintf("%d.%s", map {s/_//g; $_} q$Name: release-0_55-public $ =~ /-(\d+)_([\d_]+)/)
            $_ = sprintf("v%d.%s",
              map {s/_//g; $_}
                $1 =~ m/-(\d+)_([\d_]+)/) # snare just the numeric part
             if m{\$Name:\s*([^\$]+)\$}s 
            ;
            $version = $_;
            DEBUG and print "Noting $version as version\n";
            last;
          }
        }
        close(INPOD);
      }
      print "$name\t$version\t$file\n";
      return;
      # End of callback!
    });
  
    $self->survey;
  }
  
  #==========================================================================
  
  sub simplify_name {
    my($self, $str) = @_;
      
    # Remove all path components
    #                             XXX Why not just use basename()? -- SMB
  
    if ($^O eq 'MacOS') { $str =~ s{^.*:+}{}s }
    else                { $str =~ s{^.*/+}{}s }
    
    $self->_simplify_base($str);
    return $str;
  }
  
  #==========================================================================
  
  sub _simplify_base {   # Internal method only
  
    # strip Perl's own extensions
    $_[1] =~ s/\.(pod|pm|plx?)\z//i;
  
    # strip meaningless extensions on Win32 and OS/2
    $_[1] =~ s/\.(bat|exe|cmd)\z//i if $^O =~ /mswin|os2/i;
  
    # strip meaningless extensions on VMS
    $_[1] =~ s/\.(com)\z//i if $^O eq 'VMS';
  
    return;
  }
  
  #==========================================================================
  
  sub _expand_inc {
    my($self, $search_dirs) = @_;
    
    return unless $self->{'inc'};
    my %seen = map { File::Spec->rel2abs($_) => 1 } @{ $search_dirs };
  
    if ($^O eq 'MacOS') {
      push @$search_dirs,
        grep { !$seen{ File::Spec->rel2abs($_) }++ } $self->_mac_whammy(@INC);
    # Any other OSs need custom handling here?
    } else {
      push @$search_dirs,
        grep { !$seen{ File::Spec->rel2abs($_) }++ } @INC;
    }
  
    $self->{'laborious'} = 0;   # Since inc said to use INC
    return;
  }
  
  #==========================================================================
  
  sub _mac_whammy { # Tolerate '.', './some_dir' and '(../)+some_dir' on Mac OS
    my @them;
    (undef,@them) = @_;
    for $_ (@them) {
      if ( $_ eq '.' ) {
        $_ = ':';
      } elsif ( $_ =~ s|^((?:\.\./)+)|':' x (length($1)/3)|e ) {
        $_ = ':'. $_;
      } else {
        $_ =~ s|^\./|:|;
      }
    }
    return @them;
  }
  
  #==========================================================================
  
  sub _limit_glob_to_limit_re {
    my $self = $_[0];
    my $limit_glob = $self->{'limit_glob'} || return;
  
    my $limit_re = '^' . quotemeta($limit_glob) . '$';
    $limit_re =~ s/\\\?/./g;    # glob "?" => "."
    $limit_re =~ s/\\\*/.*?/g;  # glob "*" => ".*?"
    $limit_re =~ s/\.\*\?\$$//s; # final glob "*" => ".*?$" => ""
  
    $self->{'verbose'} and print "Turning limit_glob $limit_glob into re $limit_re\n";
  
    # A common optimization:
    if(!exists($self->{'dir_prefix'})
      and $limit_glob =~ m/^(?:\w+\:\:)+/s  # like "File::*" or "File::Thing*"
      # Optimize for sane and common cases (but not things like "*::File")
    ) {
      $self->{'dir_prefix'} = join "::", $limit_glob =~ m/^(?:\w+::)+/sg;
      $self->{'verbose'} and print " and setting dir_prefix to $self->{'dir_prefix'}\n";
    }
  
    return $limit_re;
  }
  
  #==========================================================================
  
  # contribution mostly from Tim Jenness <t.jenness@jach.hawaii.edu>
  
  sub _actual_filenames {
      my $dir = shift;
      my $fn = lc shift;
      opendir my $dh, $dir or return;
      return map { File::Spec->catdir($dir, $_) }
          grep { lc $_  eq $fn } readdir $dh;
  }
  
  sub find {
    my($self, $pod, @search_dirs) = @_;
    $self = $self->new unless ref $self; # tolerate being a class method
  
    # Check usage
    Carp::carp 'Usage: \$self->find($podname, ...)'
     unless defined $pod and length $pod;
  
    my $verbose = $self->verbose;
  
    # Split on :: and then join the name together using File::Spec
    my @parts = split /::/, $pod;
    $verbose and print "Chomping {$pod} => {@parts}\n";
  
    #@search_dirs = File::Spec->curdir unless @search_dirs;
    
    $self->_expand_inc(\@search_dirs);
    # Add location of binaries such as pod2text:
    push @search_dirs, $Config::Config{'scriptdir'} if $self->inc;
  
    my %seen_dir;
    while (my $dir = shift @search_dirs ) {
      next unless defined $dir and length $dir;
      next if $seen_dir{$dir};
      $seen_dir{$dir} = 1;
      unless(-d $dir) {
        print "Directory $dir does not exist\n" if $verbose;
      }
  
      print "Looking in directory $dir\n" if $verbose;
      my $fullname = File::Spec->catfile( $dir, @parts );
      print "Filename is now $fullname\n" if $verbose;
  
      foreach my $ext ('', '.pod', '.pm', '.pl') {   # possible extensions
        my $fullext = $fullname . $ext;
        if ( -f $fullext and $self->contains_pod($fullext) ) {
          print "FOUND: $fullext\n" if $verbose;
          if (@parts > 1 && lc $parts[0] eq 'pod' && $IS_CASE_INSENSITIVE && $ext eq '.pod') {
            # Well, this file could be for a program (perldoc) but we actually
            # want a module (Pod::Perldoc). So see if there is a .pm with the
            # proper casing.
            my $subdir = dirname $fullext;
            unless (grep { $fullext eq $_  } _actual_filenames $subdir, "$parts[-1].pod") {
              print "# Looking for alternate spelling in $subdir\n" if $verbose;
              # Try the .pm file.
              my $pm = $fullname . '.pm';
              if ( -f $pm and $self->contains_pod($pm) ) {
                # Prefer the .pm if its case matches.
                if (grep { $pm eq $_  } _actual_filenames $subdir, "$parts[-1].pm") {
                  print "FOUND: $fullext\n" if $verbose;
                  return $pm;
                }
              }
            }
          }
          return $fullext;
        }
      }
  
      # Case-insensitively Look for ./pod directories and slip them in.
      for my $subdir ( _actual_filenames($dir, 'pod') ) {
        if (-d $subdir) {
          $verbose and print "Noticing $subdir and looking there...\n";
          unshift @search_dirs, $subdir;
        }
      }
    }
  
    return undef;
  }
  
  #==========================================================================
  
  sub contains_pod {
    my($self, $file) = @_;
    my $verbose = $self->{'verbose'};
  
    # check for one line of POD
    $verbose > 1 and print " Scanning $file for pod...\n";
    unless( open(MAYBEPOD,"<$file") ) {
      print "Error: $file is unreadable: $!\n";
      return undef;
    }
  
    sleep($SLEEPY - 1) if $SLEEPY;
     # avoid totally hogging the processor on OSs with poor process control
    
    local $_;
    while( <MAYBEPOD> ) {
      if(m/^=(head\d|pod|over|item)\b/s) {
        close(MAYBEPOD) || die "Bizarre error closing $file: $!\nAborting";
        chomp;
        $verbose > 1 and print "  Found some pod ($_) in $file\n";
        return 1;
      }
    }
    close(MAYBEPOD) || die "Bizarre error closing $file: $!\nAborting";
    $verbose > 1 and print "  No POD in $file, skipping.\n";
    return 0;
  }
  
  #==========================================================================
  
  sub _accessorize {  # A simple-minded method-maker
    shift;
    no strict 'refs';
    foreach my $attrname (@_) {
      *{caller() . '::' . $attrname} = sub {
        use strict;
        $Carp::CarpLevel = 1,  Carp::croak(
         "Accessor usage: \$obj->$attrname() or \$obj->$attrname(\$new_value)"
        ) unless (@_ == 1 or @_ == 2) and ref $_[0];
  
        # Read access:
        return $_[0]->{$attrname} if @_ == 1;
  
        # Write access:
        $_[0]->{$attrname} = $_[1];
        return $_[0]; # RETURNS MYSELF!
      };
    }
    # Ya know, they say accessories make the ensemble!
    return;
  }
  
  #==========================================================================
  sub _state_as_string {
    my $self = $_[0];
    return '' unless ref $self;
    my @out = "{\n  # State of $self ...\n";
    foreach my $k (sort keys %$self) {
      push @out, "  ", _esc($k), " => ", _esc($self->{$k}), ",\n";
    }
    push @out, "}\n";
    my $x = join '', @out;
    $x =~ s/^/#/mg;
    return $x;
  }
  
  sub _esc {
    my $in = $_[0];
    return 'undef' unless defined $in;
    $in =~
      s<([^\x20\x21\x23\x27-\x3F\x41-\x5B\x5D-\x7E])>
       <'\\x'.(unpack("H2",$1))>eg;
    return qq{"$in"};
  }
  
  #==========================================================================
  
  run() unless caller;  # run if "perl whatever/Search.pm"
  
  1;
  
  #==========================================================================
  
  __END__
  
  
  =head1 NAME
  
  Pod::Simple::Search - find POD documents in directory trees
  
  =head1 SYNOPSIS
  
    use Pod::Simple::Search;
    my $name2path = Pod::Simple::Search->new->limit_glob('LWP::*')->survey;
    print "Looky see what I found: ",
      join(' ', sort keys %$name2path), "\n";
  
    print "LWPUA docs = ",
      Pod::Simple::Search->new->find('LWP::UserAgent') || "?",
      "\n";
  
  =head1 DESCRIPTION
  
  B<Pod::Simple::Search> is a class that you use for running searches
  for Pod files.  An object of this class has several attributes
  (mostly options for controlling search options), and some methods
  for searching based on those attributes.
  
  The way to use this class is to make a new object of this class,
  set any options, and then call one of the search options
  (probably C<survey> or C<find>).  The sections below discuss the
  syntaxes for doing all that.
  
  
  =head1 CONSTRUCTOR
  
  This class provides the one constructor, called C<new>.
  It takes no parameters:
  
    use Pod::Simple::Search;
    my $search = Pod::Simple::Search->new;
  
  =head1 ACCESSORS
  
  This class defines several methods for setting (and, occasionally,
  reading) the contents of an object. With two exceptions (discussed at
  the end of this section), these attributes are just for controlling the
  way searches are carried out.
  
  Note that each of these return C<$self> when you call them as
  C<< $self->I<whatever(value)> >>.  That's so that you can chain
  together set-attribute calls like this:
  
    my $name2path =
      Pod::Simple::Search->new
      -> inc(0) -> verbose(1) -> callback(\&blab)
      ->survey(@there);
  
  ...which works exactly as if you'd done this:
  
    my $search = Pod::Simple::Search->new;
    $search->inc(0);
    $search->verbose(1);
    $search->callback(\&blab);
    my $name2path = $search->survey(@there);
  
  =over
  
  =item $search->inc( I<true-or-false> );
  
  This attribute, if set to a true value, means that searches should
  implicitly add perl's I<@INC> paths. This
  automatically considers paths specified in the C<PERL5LIB> environment
  as this is prepended to I<@INC> by the Perl interpreter itself.
  This attribute's default value is B<TRUE>.  If you want to search
  only specific directories, set $self->inc(0) before calling
  $inc->survey or $inc->find.
  
  
  =item $search->verbose( I<nonnegative-number> );
  
  This attribute, if set to a nonzero positive value, will make searches output
  (via C<warn>) notes about what they're doing as they do it.
  This option may be useful for debugging a pod-related module.
  This attribute's default value is zero, meaning that no C<warn> messages
  are produced.  (Setting verbose to 1 turns on some messages, and setting
  it to 2 turns on even more messages, i.e., makes the following search(es)
  even more verbose than 1 would make them.)
  
  =item $search->limit_glob( I<some-glob-string> );
  
  This option means that you want to limit the results just to items whose
  podnames match the given glob/wildcard expression. For example, you
  might limit your search to just "LWP::*", to search only for modules
  starting with "LWP::*" (but not including the module "LWP" itself); or
  you might limit your search to "LW*" to see only modules whose (full)
  names begin with "LW"; or you might search for "*Find*" to search for
  all modules with "Find" somewhere in their full name. (You can also use
  "?" in a glob expression; so "DB?" will match "DBI" and "DBD".)
  
  
  =item $search->callback( I<\&some_routine> );
  
  This attribute means that every time this search sees a matching
  Pod file, it should call this callback routine.  The routine is called
  with two parameters: the current file's filespec, and its pod name.
  (For example: C<("/etc/perljunk/File/Crunk.pm", "File::Crunk")> would
  be in C<@_>.)
  
  The callback routine's return value is not used for anything.
  
  This attribute's default value is false, meaning that no callback
  is called.
  
  =item $search->laborious( I<true-or-false> );
  
  Unless you set this attribute to a true value, Pod::Search will 
  apply Perl-specific heuristics to find the correct module PODs quickly.
  This attribute's default value is false.  You won't normally need
  to set this to true.
  
  Specifically: Turning on this option will disable the heuristics for
  seeing only files with Perl-like extensions, omitting subdirectories
  that are numeric but do I<not> match the current Perl interpreter's
  version ID, suppressing F<site_perl> as a module hierarchy name, etc.
  
  =item $search->recurse( I<true-or-false> );
  
  Unless you set this attribute to a false value, Pod::Search will
  recurse into subdirectories of the search directories.
  
  =item $search->shadows( I<true-or-false> );
  
  Unless you set this attribute to a true value, Pod::Simple::Search will
  consider only the first file of a given modulename as it looks thru the
  specified directories; that is, with this option off, if
  Pod::Simple::Search has seen a C<somepathdir/Foo/Bar.pm> already in this
  search, then it won't bother looking at a C<somelaterpathdir/Foo/Bar.pm>
  later on in that search, because that file is merely a "shadow". But if
  you turn on C<< $self->shadows(1) >>, then these "shadow" files are
  inspected too, and are noted in the pathname2podname return hash.
  
  This attribute's default value is false; and normally you won't
  need to turn it on.
  
  
  =item $search->limit_re( I<some-regxp> );
  
  Setting this attribute (to a value that's a regexp) means that you want
  to limit the results just to items whose podnames match the given
  regexp. Normally this option is not needed, and the more efficient
  C<limit_glob> attribute is used instead.
  
  
  =item $search->dir_prefix( I<some-string-value> );
  
  Setting this attribute to a string value means that the searches should
  begin in the specified subdirectory name (like "Pod" or "File::Find",
  also expressible as "File/Find"). For example, the search option
  C<< $search->limit_glob("File::Find::R*") >>
  is the same as the combination of the search options
  C<< $search->limit_re("^File::Find::R") -> dir_prefix("File::Find") >>.
  
  Normally you don't need to know about the C<dir_prefix> option, but I
  include it in case it might prove useful for someone somewhere.
  
  (Implementationally, searching with limit_glob ends up setting limit_re
  and usually dir_prefix.)
  
  
  =item $search->progress( I<some-progress-object> );
  
  If you set a value for this attribute, the value is expected
  to be an object (probably of a class that you define) that has a 
  C<reach> method and a C<done> method.  This is meant for reporting
  progress during the search, if you don't want to use a simple
  callback.
  
  Normally you don't need to know about the C<progress> option, but I
  include it in case it might prove useful for someone somewhere.
  
  While a search is in progress, the progress object's C<reach> and
  C<done> methods are called like this:
  
    # Every time a file is being scanned for pod:
    $progress->reach($count, "Scanning $file");   ++$count;
  
    # And then at the end of the search:
    $progress->done("Noted $count Pod files total");
  
  Internally, we often set this to an object of class
  Pod::Simple::Progress.  That class is probably undocumented,
  but you may wish to look at its source.
  
  
  =item $name2path = $self->name2path;
  
  This attribute is not a search parameter, but is used to report the
  result of C<survey> method, as discussed in the next section.
  
  =item $path2name = $self->path2name;
  
  This attribute is not a search parameter, but is used to report the
  result of C<survey> method, as discussed in the next section.
  
  =back
  
  =head1 MAIN SEARCH METHODS
  
  Once you've actually set any options you want (if any), you can go
  ahead and use the following methods to search for Pod files
  in particular ways.
  
  
  =head2 C<< $search->survey( @directories ) >>
  
  The method C<survey> searches for POD documents in a given set of
  files and/or directories.  This runs the search according to the various
  options set by the accessors above.  (For example, if the C<inc> attribute
  is on, as it is by default, then the perl @INC directories are implicitly
  added to the list of directories (if any) that you specify.)
  
  The return value of C<survey> is two hashes:
  
  =over
  
  =item C<name2path>
  
  A hash that maps from each pod-name to the filespec (like
  "Stuff::Thing" => "/whatever/plib/Stuff/Thing.pm")
  
  =item C<path2name>
  
  A hash that maps from each Pod filespec to its pod-name (like
  "/whatever/plib/Stuff/Thing.pm" => "Stuff::Thing")
  
  =back
  
  Besides saving these hashes as the hashref attributes
  C<name2path> and C<path2name>, calling this function also returns
  these hashrefs.  In list context, the return value of
  C<< $search->survey >> is the list C<(\%name2path, \%path2name)>.
  In scalar context, the return value is C<\%name2path>.
  Or you can just call this in void context.
  
  Regardless of calling context, calling C<survey> saves
  its results in its C<name2path> and C<path2name> attributes.
  
  E.g., when searching in F<$HOME/perl5lib>, the file
  F<$HOME/perl5lib/MyModule.pm> would get the POD name I<MyModule>,
  whereas F<$HOME/perl5lib/Myclass/Subclass.pm> would be
  I<Myclass::Subclass>. The name information can be used for POD
  translators.
  
  Only text files containing at least one valid POD command are found.
  
  In verbose mode, a warning is printed if shadows are found (i.e., more
  than one POD file with the same POD name is found, e.g. F<CPAN.pm> in
  different directories).  This usually indicates duplicate occurrences of
  modules in the I<@INC> search path, which is occasionally inadvertent
  (but is often simply a case of a user's path dir having a more recent
  version than the system's general path dirs in general.)
  
  The options to this argument is a list of either directories that are
  searched recursively, or files.  (Usually you wouldn't specify files,
  but just dirs.)  Or you can just specify an empty-list, as in
  $name2path; with the C<inc> option on, as it is by default.
  
  The POD names of files are the plain basenames with any Perl-like
  extension (.pm, .pl, .pod) stripped, and path separators replaced by
  C<::>'s.
  
  Calling Pod::Simple::Search->search(...) is short for
  Pod::Simple::Search->new->search(...).  That is, a throwaway object
  with default attribute values is used.
  
  
  =head2 C<< $search->simplify_name( $str ) >>
  
  The method B<simplify_name> is equivalent to B<basename>, but also
  strips Perl-like extensions (.pm, .pl, .pod) and extensions like
  F<.bat>, F<.cmd> on Win32 and OS/2, or F<.com> on VMS, respectively.
  
  
  =head2 C<< $search->find( $pod ) >>
  
  =head2 C<< $search->find( $pod, @search_dirs ) >>
  
  Returns the location of a Pod file, given a Pod/module/script name
  (like "Foo::Bar" or "perlvar" or "perldoc"), and an idea of
  what files/directories to look in.
  It searches according to the various options set by the accessors above.
  (For example, if the C<inc> attribute is on, as it is by default, then
  the perl @INC directories are implicitly added to the list of
  directories (if any) that you specify.)
  
  This returns the full path of the first occurrence to the file.
  Package names (eg 'A::B') are automatically converted to directory
  names in the selected directory.  Additionally, '.pm', '.pl' and '.pod'
  are automatically appended to the search as required.
  (So, for example, under Unix, "A::B" is converted to "somedir/A/B.pm",
  "somedir/A/B.pod", or "somedir/A/B.pl", as appropriate.)
  
  If no such Pod file is found, this method returns undef.
  
  If any of the given search directories contains a F<pod/> subdirectory,
  then it is searched.  (That's how we manage to find F<perlfunc>,
  for example, which is usually in F<pod/perlfunc> in most Perl dists.)
  
  The C<verbose> and C<inc> attributes influence the behavior of this
  search; notably, C<inc>, if true, adds @INC I<and also
  $Config::Config{'scriptdir'}> to the list of directories to search.
  
  It is common to simply say C<< $filename = Pod::Simple::Search-> new 
  ->find("perlvar") >> so that just the @INC (well, and scriptdir)
  directories are searched.  (This happens because the C<inc>
  attribute is true by default.)
  
  Calling Pod::Simple::Search->find(...) is short for
  Pod::Simple::Search->new->find(...).  That is, a throwaway object
  with default attribute values is used.
  
  
  =head2 C<< $self->contains_pod( $file ) >>
  
  Returns true if the supplied filename (not POD module) contains some Pod
  documentation.
  
  =head1 SUPPORT
  
  Questions or discussion about POD and Pod::Simple should be sent to the
  pod-people@perl.org mail list. Send an empty email to
  pod-people-subscribe@perl.org to subscribe.
  
  This module is managed in an open GitHub repository,
  L<https://github.com/perl-pod/pod-simple/>. Feel free to fork and contribute, or
  to clone L<git://github.com/perl-pod/pod-simple.git> and send patches!
  
  Patches against Pod::Simple are welcome. Please send bug reports to
  <bug-pod-simple@rt.cpan.org>.
  
  =head1 COPYRIGHT AND DISCLAIMERS
  
  Copyright (c) 2002 Sean M. Burke.
  
  This library is free software; you can redistribute it and/or modify it
  under the same terms as Perl itself.
  
  This program is distributed in the hope that it will be useful, but
  without any warranty; without even the implied warranty of
  merchantability or fitness for a particular purpose.
  
  =head1 AUTHOR
  
  Pod::Simple was created by Sean M. Burke <sburke@cpan.org> with code borrowed
  from Marek Rouchal's L<Pod::Find>, which in turn heavily borrowed code from
  Nick Ing-Simmons' C<PodToHtml>.
  
  But don't bother him, he's retired.
  
  Pod::Simple is maintained by:
  
  =over
  
  =item * Allison Randal C<allison@perl.org>
  
  =item * Hans Dieter Pearcey C<hdp@cpan.org>
  
  =item * David E. Wheeler C<dwheeler@cpan.org>
  
  =back
  
  =cut
POD_SIMPLE_SEARCH

$fatpacked{"Pod/Simple/SimpleTree.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POD_SIMPLE_SIMPLETREE';
  
  require 5;
  package Pod::Simple::SimpleTree;
  use strict;
  use Carp ();
  use Pod::Simple ();
  use vars qw( $ATTR_PAD @ISA $VERSION $SORT_ATTRS);
  $VERSION = '3.35';
  BEGIN {
    @ISA = ('Pod::Simple');
    *DEBUG = \&Pod::Simple::DEBUG unless defined &DEBUG;
  }
  
  __PACKAGE__->_accessorize(
    'root',   # root of the tree
  );
  
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  
  sub _handle_element_start { # self, tagname, attrhash
    DEBUG > 2 and print STDERR "Handling $_[1] start-event\n";
    my $x = [$_[1], $_[2]];
    if($_[0]{'_currpos'}) {
      push    @{ $_[0]{'_currpos'}[0] }, $x; # insert in parent's child-list
      unshift @{ $_[0]{'_currpos'} },    $x; # prefix to stack
    } else {
      DEBUG and print STDERR " And oo, it gets to be root!\n";
      $_[0]{'_currpos'} = [   $_[0]{'root'} = $x   ];
        # first event!  set to stack, and set as root.
    }
    DEBUG > 3 and print STDERR "Stack is now: ",
      join(">", map $_->[0], @{$_[0]{'_currpos'}}), "\n";
    return;
  }
  
  sub _handle_element_end { # self, tagname
    DEBUG > 2 and print STDERR "Handling $_[1] end-event\n";
    shift @{$_[0]{'_currpos'}};
    DEBUG > 3 and print STDERR "Stack is now: ",
      join(">", map $_->[0], @{$_[0]{'_currpos'}}), "\n";
    return;
  }
  
  sub _handle_text { # self, text
    DEBUG > 2 and print STDERR "Handling $_[1] text-event\n";
    push @{ $_[0]{'_currpos'}[0] }, $_[1];
    return;
  }
  
  
  # A bit of evil from the black box...  please avert your eyes, kind souls.
  sub _traverse_treelet_bit {
    DEBUG > 2 and print STDERR "Handling $_[1] paragraph event\n";
    my $self = shift;
    push @{ $self->{'_currpos'}[0] }, [@_];
    return;
  }
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  1;
  __END__
  
  =head1 NAME
  
  Pod::Simple::SimpleTree -- parse Pod into a simple parse tree 
  
  =head1 SYNOPSIS
  
    % cat ptest.pod
  
    =head1 PIE
  
    I like B<pie>!
  
    % perl -MPod::Simple::SimpleTree -MData::Dumper -e \
       "print Dumper(Pod::Simple::SimpleTree->new->parse_file(shift)->root)" \
       ptest.pod
  
    $VAR1 = [
              'Document',
              { 'start_line' => 1 },
              [
                'head1',
                { 'start_line' => 1 },
                'PIE'
              ],
              [
                'Para',
                { 'start_line' => 3 },
                'I like ',
                [
                  'B',
                  {},
                  'pie'
                ],
                '!'
              ]
            ];
  
  =head1 DESCRIPTION
  
  This class is of interest to people writing a Pod processor/formatter.
  
  This class takes Pod and parses it, returning a parse tree made just
  of arrayrefs, and hashrefs, and strings.
  
  This is a subclass of L<Pod::Simple> and inherits all its methods.
  
  This class is inspired by XML::Parser's "Tree" parsing-style, although
  it doesn't use exactly the same LoL format.
  
  =head1 METHODS
  
  At the end of the parse, call C<< $parser->root >> to get the
  tree's top node.
  
  =head1 Tree Contents
  
  Every element node in the parse tree is represented by an arrayref of
  the form: C<[ I<elementname>, \%attributes, I<...subnodes...> ]>.
  See the example tree dump in the Synopsis, above.
  
  Every text node in the tree is represented by a simple (non-ref)
  string scalar.  So you can test C<ref($node)> to see whether you have
  an element node or just a text node.
  
  The top node in the tree is C<[ 'Document', \%attributes,
  I<...subnodes...> ]>
  
  
  =head1 SEE ALSO
  
  L<Pod::Simple>
  
  L<perllol>
  
  L<The "Tree" subsubsection in XML::Parser|XML::Parser/"Tree">
  
  =head1 SUPPORT
  
  Questions or discussion about POD and Pod::Simple should be sent to the
  pod-people@perl.org mail list. Send an empty email to
  pod-people-subscribe@perl.org to subscribe.
  
  This module is managed in an open GitHub repository,
  L<https://github.com/perl-pod/pod-simple/>. Feel free to fork and contribute, or
  to clone L<git://github.com/perl-pod/pod-simple.git> and send patches!
  
  Patches against Pod::Simple are welcome. Please send bug reports to
  <bug-pod-simple@rt.cpan.org>.
  
  =head1 COPYRIGHT AND DISCLAIMERS
  
  Copyright (c) 2002 Sean M. Burke.
  
  This library is free software; you can redistribute it and/or modify it
  under the same terms as Perl itself.
  
  This program is distributed in the hope that it will be useful, but
  without any warranty; without even the implied warranty of
  merchantability or fitness for a particular purpose.
  
  =head1 AUTHOR
  
  Pod::Simple was created by Sean M. Burke <sburke@cpan.org>.
  But don't bother him, he's retired.
  
  Pod::Simple is maintained by:
  
  =over
  
  =item * Allison Randal C<allison@perl.org>
  
  =item * Hans Dieter Pearcey C<hdp@cpan.org>
  
  =item * David E. Wheeler C<dwheeler@cpan.org>
  
  =back
  
  =cut
POD_SIMPLE_SIMPLETREE

$fatpacked{"Pod/Simple/Text.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POD_SIMPLE_TEXT';
  
  require 5;
  package Pod::Simple::Text;
  use strict;
  use Carp ();
  use Pod::Simple::Methody ();
  use Pod::Simple ();
  use vars qw( @ISA $VERSION $FREAKYMODE);
  $VERSION = '3.35';
  @ISA = ('Pod::Simple::Methody');
  BEGIN { *DEBUG = defined(&Pod::Simple::DEBUG)
            ? \&Pod::Simple::DEBUG
            : sub() {0}
        }
  
  use Text::Wrap 98.112902 ();
  $Text::Wrap::huge = 'overflow';
  
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  
  sub new {
    my $self = shift;
    my $new = $self->SUPER::new(@_);
    $new->{'output_fh'} ||= *STDOUT{IO};
    $new->accept_target_as_text(qw( text plaintext plain ));
    $new->nix_X_codes(1);
    $new->nbsp_for_S(1);
    $new->{'Thispara'} = '';
    $new->{'Indent'} = 0;
    $new->{'Indentstring'} = '   ';
    return $new;
  }
  
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  
  sub handle_text {  $_[0]{'Thispara'} .= $_[1] }
  
  sub start_Para  {  $_[0]{'Thispara'} = '' }
  sub start_head1 {  $_[0]{'Thispara'} = '' }
  sub start_head2 {  $_[0]{'Thispara'} = '' }
  sub start_head3 {  $_[0]{'Thispara'} = '' }
  sub start_head4 {  $_[0]{'Thispara'} = '' }
  
  sub start_Verbatim    { $_[0]{'Thispara'} = ''   }
  sub start_item_bullet { $_[0]{'Thispara'} = $FREAKYMODE ? '' : '* ' }
  sub start_item_number { $_[0]{'Thispara'} = $FREAKYMODE ? '' : "$_[1]{'number'}. "  }
  sub start_item_text   { $_[0]{'Thispara'} = ''   }
  
  sub start_over_bullet  { ++$_[0]{'Indent'} }
  sub start_over_number  { ++$_[0]{'Indent'} }
  sub start_over_text    { ++$_[0]{'Indent'} }
  sub start_over_block   { ++$_[0]{'Indent'} }
  
  sub   end_over_bullet  { --$_[0]{'Indent'} }
  sub   end_over_number  { --$_[0]{'Indent'} }
  sub   end_over_text    { --$_[0]{'Indent'} }
  sub   end_over_block   { --$_[0]{'Indent'} }
  
  
  # . . . . . Now the actual formatters:
  
  sub end_head1       { $_[0]->emit_par(-4) }
  sub end_head2       { $_[0]->emit_par(-3) }
  sub end_head3       { $_[0]->emit_par(-2) }
  sub end_head4       { $_[0]->emit_par(-1) }
  sub end_Para        { $_[0]->emit_par( 0) }
  sub end_item_bullet { $_[0]->emit_par( 0) }
  sub end_item_number { $_[0]->emit_par( 0) }
  sub end_item_text   { $_[0]->emit_par(-2) }
  sub start_L         { $_[0]{'Link'} = $_[1] if $_[1]->{type} eq 'url' }
  sub end_L           {
      if (my $link = delete $_[0]{'Link'}) {
          # Append the URL to the output unless it's already present.
          $_[0]{'Thispara'} .= " <$link->{to}>"
              unless $_[0]{'Thispara'} =~ /\b\Q$link->{to}/;
      }
  }
  
  sub emit_par {
    my($self, $tweak_indent) = splice(@_,0,2);
    my $indent = ' ' x ( 2 * $self->{'Indent'} + 4 + ($tweak_indent||0) );
     # Yes, 'STRING' x NEGATIVE gives '', same as 'STRING' x 0
  
    $self->{'Thispara'} =~ s/$Pod::Simple::shy//g;
    my $out = Text::Wrap::wrap($indent, $indent, $self->{'Thispara'} .= "\n");
    $out =~ s/$Pod::Simple::nbsp/ /g;
    print {$self->{'output_fh'}} $out, "\n";
    $self->{'Thispara'} = '';
    
    return;
  }
  
  # . . . . . . . . . . And then off by its lonesome:
  
  sub end_Verbatim  {
    my $self = shift;
    $self->{'Thispara'} =~ s/$Pod::Simple::nbsp/ /g;
    $self->{'Thispara'} =~ s/$Pod::Simple::shy//g;
  
    my $i = ' ' x ( 2 * $self->{'Indent'} + 4);
    #my $i = ' ' x (4 + $self->{'Indent'});
    
    $self->{'Thispara'} =~ s/^/$i/mg;
    
    print { $self->{'output_fh'} }   '', 
      $self->{'Thispara'},
      "\n\n"
    ;
    $self->{'Thispara'} = '';
    return;
  }
  
  #@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
  1;
  
  
  __END__
  
  =head1 NAME
  
  Pod::Simple::Text -- format Pod as plaintext
  
  =head1 SYNOPSIS
  
    perl -MPod::Simple::Text -e \
     "exit Pod::Simple::Text->filter(shift)->any_errata_seen" \
     thingy.pod
  
  =head1 DESCRIPTION
  
  This class is a formatter that takes Pod and renders it as
  wrapped plaintext.
  
  Its wrapping is done by L<Text::Wrap>, so you can change
  C<$Text::Wrap::columns> as you like.
  
  This is a subclass of L<Pod::Simple> and inherits all its methods.
  
  =head1 SEE ALSO
  
  L<Pod::Simple>, L<Pod::Simple::TextContent>, L<Pod::Text>
  
  =head1 SUPPORT
  
  Questions or discussion about POD and Pod::Simple should be sent to the
  pod-people@perl.org mail list. Send an empty email to
  pod-people-subscribe@perl.org to subscribe.
  
  This module is managed in an open GitHub repository,
  L<https://github.com/perl-pod/pod-simple/>. Feel free to fork and contribute, or
  to clone L<git://github.com/perl-pod/pod-simple.git> and send patches!
  
  Patches against Pod::Simple are welcome. Please send bug reports to
  <bug-pod-simple@rt.cpan.org>.
  
  =head1 COPYRIGHT AND DISCLAIMERS
  
  Copyright (c) 2002 Sean M. Burke.
  
  This library is free software; you can redistribute it and/or modify it
  under the same terms as Perl itself.
  
  This program is distributed in the hope that it will be useful, but
  without any warranty; without even the implied warranty of
  merchantability or fitness for a particular purpose.
  
  =head1 AUTHOR
  
  Pod::Simple was created by Sean M. Burke <sburke@cpan.org>.
  But don't bother him, he's retired.
  
  Pod::Simple is maintained by:
  
  =over
  
  =item * Allison Randal C<allison@perl.org>
  
  =item * Hans Dieter Pearcey C<hdp@cpan.org>
  
  =item * David E. Wheeler C<dwheeler@cpan.org>
  
  =back
  
  =cut
POD_SIMPLE_TEXT

$fatpacked{"Pod/Simple/TextContent.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POD_SIMPLE_TEXTCONTENT';
  
  
  require 5;
  package Pod::Simple::TextContent;
  use strict;
  use Carp ();
  use Pod::Simple ();
  use vars qw( @ISA $VERSION );
  $VERSION = '3.35';
  @ISA = ('Pod::Simple');
  
  sub new {
    my $self = shift;
    my $new = $self->SUPER::new(@_);
    $new->{'output_fh'} ||= *STDOUT{IO};
    $new->nix_X_codes(1);
    return $new;
  }
  
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  
  sub _handle_element_start {
    print {$_[0]{'output_fh'}} "\n"  unless $_[1] =~ m/^[A-Z]$/s;
    return;
  }
  
  sub _handle_text {
    $_[1] =~ s/$Pod::Simple::shy//g;
    $_[1] =~ s/$Pod::Simple::nbsp/ /g;
    print {$_[0]{'output_fh'}} $_[1];
    return;
  }
  
  sub _handle_element_end {
    print {$_[0]{'output_fh'}} "\n"  unless $_[1] =~ m/^[A-Z]$/s;
    return;
  }
  
  #@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
  1;
  
  
  __END__
  
  =head1 NAME
  
  Pod::Simple::TextContent -- get the text content of Pod
  
  =head1 SYNOPSIS
  
   TODO
  
    perl -MPod::Simple::TextContent -e \
     "exit Pod::Simple::TextContent->filter(shift)->any_errata_seen" \
     thingy.pod
  
  =head1 DESCRIPTION
  
  This class is that parses Pod and dumps just the text content.  It is
  mainly meant for use by the Pod::Simple test suite, but you may find
  some other use for it.
  
  This is a subclass of L<Pod::Simple> and inherits all its methods.
  
  =head1 SEE ALSO
  
  L<Pod::Simple>, L<Pod::Simple::Text>, L<Pod::Spell>
  
  =head1 SUPPORT
  
  Questions or discussion about POD and Pod::Simple should be sent to the
  pod-people@perl.org mail list. Send an empty email to
  pod-people-subscribe@perl.org to subscribe.
  
  This module is managed in an open GitHub repository,
  L<https://github.com/perl-pod/pod-simple/>. Feel free to fork and contribute, or
  to clone L<git://github.com/perl-pod/pod-simple.git> and send patches!
  
  Patches against Pod::Simple are welcome. Please send bug reports to
  <bug-pod-simple@rt.cpan.org>.
  
  =head1 COPYRIGHT AND DISCLAIMERS
  
  Copyright (c) 2002 Sean M. Burke.
  
  This library is free software; you can redistribute it and/or modify it
  under the same terms as Perl itself.
  
  This program is distributed in the hope that it will be useful, but
  without any warranty; without even the implied warranty of
  merchantability or fitness for a particular purpose.
  
  =head1 AUTHOR
  
  Pod::Simple was created by Sean M. Burke <sburke@cpan.org>.
  But don't bother him, he's retired.
  
  Pod::Simple is maintained by:
  
  =over
  
  =item * Allison Randal C<allison@perl.org>
  
  =item * Hans Dieter Pearcey C<hdp@cpan.org>
  
  =item * David E. Wheeler C<dwheeler@cpan.org>
  
  =back
  
  =cut
POD_SIMPLE_TEXTCONTENT

$fatpacked{"Pod/Simple/TiedOutFH.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POD_SIMPLE_TIEDOUTFH';
  
  use strict;
  package Pod::Simple::TiedOutFH;
  use Symbol ('gensym');
  use Carp ();
  use vars qw($VERSION );
  $VERSION = '3.35';
  
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  
  sub handle_on { # some horrible frightening things are encapsulated in here
    my $class = shift;
    $class = ref($class) || $class;
    
    Carp::croak "Usage: ${class}->handle_on(\$somescalar)" unless @_;
    
    my $x = (defined($_[0]) and ref($_[0]))
      ? $_[0]
      : ( \( $_[0] ) )[0]
    ;
    $$x = '' unless defined $$x;
    
    #Pod::Simple::DEBUG and print STDERR "New $class handle on $x = \"$$x\"\n";
    
    my $new = gensym();
    tie *$new, $class, $x;
    return $new;
  }
  
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  
  sub TIEHANDLE {  # Ties to just a scalar ref
    my($class, $scalar_ref) = @_;
    $$scalar_ref = '' unless defined $$scalar_ref;
    return bless \$scalar_ref,  ref($class) || $class;
  }
  
  sub PRINT {
    my $it = shift;
    foreach my $x (@_) { $$$it .= $x }
  
    #Pod::Simple::DEBUG > 10 and print STDERR " appended to $$it = \"$$$it\"\n";
  
    return 1;
  }
  
  sub FETCH {
    return ${$_[0]};
  }
  
  sub PRINTF {
    my $it = shift;
    my $format = shift;
    $$$it .= sprintf $format, @_;
    return 1;
  }
  
  sub FILENO { ${ $_[0] } + 100 } # just to produce SOME number
  
  sub CLOSE { 1 }
  
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  1;
  __END__
  
  Chole
  
   * 1 large red onion
   * 2 tomatillos
   * 4 or 5 roma tomatoes (optionally with the pulp discarded)
   * 1 tablespoons chopped ginger root (or more, to taste)
   * 2 tablespoons canola oil (or vegetable oil)
   
   * 1 tablespoon garam masala
   * 1/2 teaspoon red chili powder, or to taste
   * Salt, to taste (probably quite a bit)
   * 2 (15-ounce) cans chick peas or garbanzo beans, drained and rinsed
   * juice of one smallish lime
   * a dash of balsamic vinegar (to taste)
   * cooked rice, preferably long-grain white rice (whether plain,
      basmati rice, jasmine rice, or even a mild pilaf)
  
  In a blender or food processor, puree the onions, tomatoes, tomatillos,
  and ginger root.  You can even do it with a Braun hand "mixer", if you
  chop things finer to start with, and work at it.
  
  In a saucepan set over moderate heat, warm the oil until hot.
  
  Add the puree and the balsamic vinegar, and cook, stirring occasionally,
  for 20 to 40 minutes. (Cooking it longer will make it sweeter.)
  
  Add the Garam Masala, chili powder, and cook, stirring occasionally, for
  5 minutes.
  
  Add the salt and chick peas and cook, stirring, until heated through.
  
  Stir in the lime juice, and optionally one or two teaspoons of tahini.
  You can let it simmer longer, depending on how much softer you want the
  garbanzos to get.
  
  Serve over rice, like a curry.
  
  Yields 5 to 7 servings.
  
  
POD_SIMPLE_TIEDOUTFH

$fatpacked{"Pod/Simple/Transcode.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POD_SIMPLE_TRANSCODE';
  
  require 5;
  package Pod::Simple::Transcode;
  use strict;
  use vars qw($VERSION @ISA);
  $VERSION = '3.35';
  
  BEGIN {
    if(defined &DEBUG) {;} # Okay
    elsif( defined &Pod::Simple::DEBUG ) { *DEBUG = \&Pod::Simple::DEBUG; }
    else { *DEBUG = sub () {0}; }
  }
  
  foreach my $class (
    'Pod::Simple::TranscodeSmart',
    'Pod::Simple::TranscodeDumb',
    '',
  ) {
    $class or die "Couldn't load any encoding classes";
    DEBUG and print STDERR "About to try loading $class...\n";
    eval "require $class;";
    if($@) {
      DEBUG and print STDERR "Couldn't load $class: $@\n";
    } else {
      DEBUG and print STDERR "OK, loaded $class.\n";
      @ISA = ($class);
      last;
    }
  }
  
  sub _blorp { return; } # just to avoid any "empty class" warning
  
  1;
  __END__
  
  
POD_SIMPLE_TRANSCODE

$fatpacked{"Pod/Simple/TranscodeDumb.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POD_SIMPLE_TRANSCODEDUMB';
  
  require 5;
  ## This module is to be use()'d only by Pod::Simple::Transcode
  
  package Pod::Simple::TranscodeDumb;
  use strict;
  use vars qw($VERSION %Supported);
  $VERSION = '3.35';
  # This module basically pretends it knows how to transcode, except
  #  only for null-transcodings!  We use this when Encode isn't
  #  available.
  
  %Supported = (
    'ascii'       => 1,
    'ascii-ctrl'  => 1,
    'iso-8859-1'  => 1,
    'cp1252'      => 1,
    'null'        => 1,
    'latin1'      => 1,
    'latin-1'     => 1,
    %Supported,
  );
  
  sub is_dumb  {1}
  sub is_smart {0}
  
  sub all_encodings {
    return sort keys %Supported;
  }
  
  sub encoding_is_available {
    return exists $Supported{lc $_[1]};
  }
  
  sub encmodver {
    return __PACKAGE__ . " v" .($VERSION || '?');
  }
  
  sub make_transcoder {
      my ($e) = $_[1];
      die "WHAT ENCODING!?!?" unless $e;
      # No-op for all but CP1252.
      return sub {;} if $e !~ /^cp-?1252$/i;
  
      # Replace CP1252 nerbles with their ASCII equivalents.
      return sub {
          # Copied from Encode::ZapCP1252.
          my %ascii_for = (
              # http://en.wikipedia.org/wiki/Windows-1252
              "\x80" => 'e',    # EURO SIGN
              "\x82" => ',',    # SINGLE LOW-9 QUOTATION MARK
              "\x83" => 'f',    # LATIN SMALL LETTER F WITH HOOK
              "\x84" => ',,',   # DOUBLE LOW-9 QUOTATION MARK
              "\x85" => '...',  # HORIZONTAL ELLIPSIS
              "\x86" => '+',    # DAGGER
              "\x87" => '++',   # DOUBLE DAGGER
              "\x88" => '^',    # MODIFIER LETTER CIRCUMFLEX ACCENT
              "\x89" => '%',    # PER MILLE SIGN
              "\x8a" => 'S',    # LATIN CAPITAL LETTER S WITH CARON
              "\x8b" => '<',    # SINGLE LEFT-POINTING ANGLE QUOTATION MARK
              "\x8c" => 'OE',   # LATIN CAPITAL LIGATURE OE
              "\x8e" => 'Z',    # LATIN CAPITAL LETTER Z WITH CARON
              "\x91" => "'",    # LEFT SINGLE QUOTATION MARK
              "\x92" => "'",    # RIGHT SINGLE QUOTATION MARK
              "\x93" => '"',    # LEFT DOUBLE QUOTATION MARK
              "\x94" => '"',    # RIGHT DOUBLE QUOTATION MARK
              "\x95" => '*',    # BULLET
              "\x96" => '-',    # EN DASH
              "\x97" => '--',   # EM DASH
              "\x98" => '~',    # SMALL TILDE
              "\x99" => '(tm)', # TRADE MARK SIGN
              "\x9a" => 's',    # LATIN SMALL LETTER S WITH CARON
              "\x9b" => '>',    # SINGLE RIGHT-POINTING ANGLE QUOTATION MARK
              "\x9c" => 'oe',   # LATIN SMALL LIGATURE OE
              "\x9e" => 'z',    # LATIN SMALL LETTER Z WITH CARON
              "\x9f" => 'Y',    # LATIN CAPITAL LETTER Y WITH DIAERESIS
          );
  
          s{([\x80-\x9f])}{$ascii_for{$1} || $1}emxsg for @_;
    };
  }
  
  
  1;
  
  
POD_SIMPLE_TRANSCODEDUMB

$fatpacked{"Pod/Simple/TranscodeSmart.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POD_SIMPLE_TRANSCODESMART';
  
  require 5;
  use 5.008;
  ## Anything before 5.8.0 is GIMPY!
  ## This module is to be use()'d only by Pod::Simple::Transcode
  
  package Pod::Simple::TranscodeSmart;
  use strict;
  use Pod::Simple;
  require Encode;
  use vars qw($VERSION );
  $VERSION = '3.35';
  
  sub is_dumb  {0}
  sub is_smart {1}
  
  sub all_encodings {
    return Encode::->encodings(':all');
  }
  
  sub encoding_is_available {
    return Encode::resolve_alias($_[1]);
  }
  
  sub encmodver {
    return "Encode.pm v" .($Encode::VERSION || '?');
  }
  
  sub make_transcoder {
    my $e = Encode::find_encoding($_[1]);
    die "WHAT ENCODING!?!?" unless $e;
    my $x;
    return sub {
      foreach $x (@_) {
        $x = $e->decode($x) unless Encode::is_utf8($x);
      }
      return;
    };
  }
  
  
  1;
  
  
POD_SIMPLE_TRANSCODESMART

$fatpacked{"Pod/Simple/XHTML.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POD_SIMPLE_XHTML';
  =pod
  
  =head1 NAME
  
  Pod::Simple::XHTML -- format Pod as validating XHTML
  
  =head1 SYNOPSIS
  
    use Pod::Simple::XHTML;
  
    my $parser = Pod::Simple::XHTML->new();
  
    ...
  
    $parser->parse_file('path/to/file.pod');
  
  =head1 DESCRIPTION
  
  This class is a formatter that takes Pod and renders it as XHTML
  validating HTML.
  
  This is a subclass of L<Pod::Simple::Methody> and inherits all its
  methods. The implementation is entirely different than
  L<Pod::Simple::HTML>, but it largely preserves the same interface.
  
  =head2 Minimal code
  
    use Pod::Simple::XHTML;
    my $psx = Pod::Simple::XHTML->new;
    $psx->output_string(\my $html);
    $psx->parse_file('path/to/Module/Name.pm');
    open my $out, '>', 'out.html' or die "Cannot open 'out.html': $!\n";
    print $out $html;
  
  You can also control the character encoding and entities. For example, if
  you're sure that the POD is properly encoded (using the C<=encoding> command),
  you can prevent high-bit characters from being encoded as HTML entities and
  declare the output character set as UTF-8 before parsing, like so:
  
    $psx->html_charset('UTF-8');
    $psx->html_encode_chars(q{&<>'"});
  
  =cut
  
  package Pod::Simple::XHTML;
  use strict;
  use vars qw( $VERSION @ISA $HAS_HTML_ENTITIES );
  $VERSION = '3.35';
  use Pod::Simple::Methody ();
  @ISA = ('Pod::Simple::Methody');
  
  BEGIN {
    $HAS_HTML_ENTITIES = eval "require HTML::Entities; 1";
  }
  
  my %entities = (
    q{>} => 'gt',
    q{<} => 'lt',
    q{'} => '#39',
    q{"} => 'quot',
    q{&} => 'amp',
  );
  
  sub encode_entities {
    my $self = shift;
    my $ents = $self->html_encode_chars;
    return HTML::Entities::encode_entities( $_[0], $ents ) if $HAS_HTML_ENTITIES;
    if (defined $ents) {
        $ents =~ s,(?<!\\)([]/]),\\$1,g;
        $ents =~ s,(?<!\\)\\\z,\\\\,;
    } else {
        $ents = join '', keys %entities;
    }
    my $str = $_[0];
    $str =~ s/([$ents])/'&' . ($entities{$1} || sprintf '#x%X', ord $1) . ';'/ge;
    return $str;
  }
  
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  
  =head1 METHODS
  
  Pod::Simple::XHTML offers a number of methods that modify the format of
  the HTML output. Call these after creating the parser object, but before
  the call to C<parse_file>:
  
    my $parser = Pod::PseudoPod::HTML->new();
    $parser->set_optional_param("value");
    $parser->parse_file($file);
  
  =head2 perldoc_url_prefix
  
  In turning L<Foo::Bar> into http://whatever/Foo%3a%3aBar, what
  to put before the "Foo%3a%3aBar". The default value is
  "http://search.cpan.org/perldoc?".
  
  =head2 perldoc_url_postfix
  
  What to put after "Foo%3a%3aBar" in the URL. This option is not set by
  default.
  
  =head2 man_url_prefix
  
  In turning C<< L<crontab(5)> >> into http://whatever/man/1/crontab, what
  to put before the "1/crontab". The default value is
  "http://man.he.net/man".
  
  =head2 man_url_postfix
  
  What to put after "1/crontab" in the URL. This option is not set by default.
  
  =head2 title_prefix, title_postfix
  
  What to put before and after the title in the head. The values should
  already be &-escaped.
  
  =head2 html_css
  
    $parser->html_css('path/to/style.css');
  
  The URL or relative path of a CSS file to include. This option is not
  set by default.
  
  =head2 html_javascript
  
  The URL or relative path of a JavaScript file to pull in. This option is
  not set by default.
  
  =head2 html_doctype
  
  A document type tag for the file. This option is not set by default.
  
  =head2 html_charset
  
  The character set to declare in the Content-Type meta tag created by default
  for C<html_header_tags>. Note that this option will be ignored if the value of
  C<html_header_tags> is changed. Defaults to "ISO-8859-1".
  
  =head2 html_header_tags
  
  Additional arbitrary HTML tags for the header of the document. The
  default value is just a content type header tag:
  
    <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
  
  Add additional meta tags here, or blocks of inline CSS or JavaScript
  (wrapped in the appropriate tags).
  
  =head3 html_encode_chars
  
  A string containing all characters that should be encoded as HTML entities,
  specified using the regular expression character class syntax (what you find
  within brackets in regular expressions). This value will be passed as the
  second argument to the C<encode_entities> function of L<HTML::Entities>. If
  L<HTML::Entities> is not installed, then any characters other than C<&<>"'>
  will be encoded numerically.
  
  =head2 html_h_level
  
  This is the level of HTML "Hn" element to which a Pod "head1" corresponds.  For
  example, if C<html_h_level> is set to 2, a head1 will produce an H2, a head2
  will produce an H3, and so on.
  
  =head2 default_title
  
  Set a default title for the page if no title can be determined from the
  content. The value of this string should already be &-escaped.
  
  =head2 force_title
  
  Force a title for the page (don't try to determine it from the content).
  The value of this string should already be &-escaped.
  
  =head2 html_header, html_footer
  
  Set the HTML output at the beginning and end of each file. The default
  header includes a title, a doctype tag (if C<html_doctype> is set), a
  content tag (customized by C<html_header_tags>), a tag for a CSS file
  (if C<html_css> is set), and a tag for a Javascript file (if
  C<html_javascript> is set). The default footer simply closes the C<html>
  and C<body> tags.
  
  The options listed above customize parts of the default header, but
  setting C<html_header> or C<html_footer> completely overrides the
  built-in header or footer. These may be useful if you want to use
  template tags instead of literal HTML headers and footers or are
  integrating converted POD pages in a larger website.
  
  If you want no headers or footers output in the HTML, set these options
  to the empty string.
  
  =head2 index
  
  Whether to add a table-of-contents at the top of each page (called an
  index for the sake of tradition).
  
  =head2 anchor_items
  
  Whether to anchor every definition C<=item> directive. This needs to be
  enabled if you want to be able to link to specific C<=item> directives, which
  are output as C<< <dt> >> elements. Disabled by default.
  
  =head2 backlink
  
  Whether to turn every =head1 directive into a link pointing to the top 
  of the page (specifically, the opening body tag).
  
  =cut
  
  __PACKAGE__->_accessorize(
   'perldoc_url_prefix',
   'perldoc_url_postfix',
   'man_url_prefix',
   'man_url_postfix',
   'title_prefix',  'title_postfix',
   'html_css',
   'html_javascript',
   'html_doctype',
   'html_charset',
   'html_encode_chars',
   'html_h_level',
   'title', # Used internally for the title extracted from the content
   'default_title',
   'force_title',
   'html_header',
   'html_footer',
   'index',
   'anchor_items',
   'backlink',
   'batch_mode', # whether we're in batch mode
   'batch_mode_current_level',
      # When in batch mode, how deep the current module is: 1 for "LWP",
      #  2 for "LWP::Procotol", 3 for "LWP::Protocol::GHTTP", etc
  );
  
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  
  =head1 SUBCLASSING
  
  If the standard options aren't enough, you may want to subclass
  Pod::Simple::XHMTL. These are the most likely candidates for methods
  you'll want to override when subclassing.
  
  =cut
  
  sub new {
    my $self = shift;
    my $new = $self->SUPER::new(@_);
    $new->{'output_fh'} ||= *STDOUT{IO};
    $new->perldoc_url_prefix('http://search.cpan.org/perldoc?');
    $new->man_url_prefix('http://man.he.net/man');
    $new->html_charset('ISO-8859-1');
    $new->nix_X_codes(1);
    $new->{'scratch'} = '';
    $new->{'to_index'} = [];
    $new->{'output'} = [];
    $new->{'saved'} = [];
    $new->{'ids'} = { '_podtop_' => 1 }; # used in <body>
    $new->{'in_li'} = [];
  
    $new->{'__region_targets'}  = [];
    $new->{'__literal_targets'} = {};
    $new->accept_targets_as_html( 'html', 'HTML' );
  
    return $new;
  }
  
  sub html_header_tags {
      my $self = shift;
      return $self->{html_header_tags} = shift if @_;
      return $self->{html_header_tags}
          ||= '<meta http-equiv="Content-Type" content="text/html; charset='
              . $self->html_charset . '" />';
  }
  
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  
  =head2 handle_text
  
  This method handles the body of text within any element: it's the body
  of a paragraph, or everything between a "=begin" tag and the
  corresponding "=end" tag, or the text within an L entity, etc. You would
  want to override this if you are adding a custom element type that does
  more than just display formatted text. Perhaps adding a way to generate
  HTML tables from an extended version of POD.
  
  So, let's say you want to add a custom element called 'foo'. In your
  subclass's C<new> method, after calling C<SUPER::new> you'd call:
  
    $new->accept_targets_as_text( 'foo' );
  
  Then override the C<start_for> method in the subclass to check for when
  "$flags->{'target'}" is equal to 'foo' and set a flag that marks that
  you're in a foo block (maybe "$self->{'in_foo'} = 1"). Then override the
  C<handle_text> method to check for the flag, and pass $text to your
  custom subroutine to construct the HTML output for 'foo' elements,
  something like:
  
    sub handle_text {
        my ($self, $text) = @_;
        if ($self->{'in_foo'}) {
            $self->{'scratch'} .= build_foo_html($text);
            return;
        }
        $self->SUPER::handle_text($text);
    }
  
  =head2 handle_code
  
  This method handles the body of text that is marked up to be code.
  You might for instance override this to plug in a syntax highlighter.
  The base implementation just escapes the text.
  
  The callback methods C<start_code> and C<end_code> emits the C<code> tags
  before and after C<handle_code> is invoked, so you might want to override these
  together with C<handle_code> if this wrapping isn't suitable.
  
  Note that the code might be broken into multiple segments if there are
  nested formatting codes inside a C<< CE<lt>...> >> sequence.  In between the
  calls to C<handle_code> other markup tags might have been emitted in that
  case.  The same is true for verbatim sections if the C<codes_in_verbatim>
  option is turned on.
  
  =head2 accept_targets_as_html
  
  This method behaves like C<accept_targets_as_text>, but also marks the region
  as one whose content should be emitted literally, without HTML entity escaping
  or wrapping in a C<div> element.
  
  =cut
  
  sub __in_literal_xhtml_region {
      return unless @{ $_[0]{__region_targets} };
      my $target = $_[0]{__region_targets}[-1];
      return $_[0]{__literal_targets}{ $target };
  }
  
  sub accept_targets_as_html {
      my ($self, @targets) = @_;
      $self->accept_targets(@targets);
      $self->{__literal_targets}{$_} = 1 for @targets;
  }
  
  sub handle_text {
      # escape special characters in HTML (<, >, &, etc)
      my $text = $_[0]->__in_literal_xhtml_region
          ? $_[1]
          : $_[0]->encode_entities( $_[1] );
  
      if ($_[0]{'in_code'} && @{$_[0]{'in_code'}}) {
          # Intentionally use the raw text in $_[1], even if we're not in a
          # literal xhtml region, since handle_code calls encode_entities.
          $_[0]->handle_code( $_[1], $_[0]{'in_code'}[-1] );
      } else {
          if ($_[0]->{in_for}) {
              my $newlines = $_[0]->__in_literal_xhtml_region ? "\n\n" : '';
              if ($_[0]->{started_for}) {
                  if ($text =~ /\S/) {
                      delete $_[0]->{started_for};
                      $_[0]{'scratch'} .= $text . $newlines;
                  }
                  # Otherwise, append nothing until we have something to append.
              } else {
                  # The parser sometimes preserves newlines and sometimes doesn't!
                  $text =~ s/\n\z//;
                  $_[0]{'scratch'} .= $text . $newlines;
              }
          } else {
              # Just plain text.
              $_[0]{'scratch'} .= $text;
          }
      }
  
      $_[0]{htext} .= $text if $_[0]{'in_head'};
  }
  
  sub start_code {
      $_[0]{'scratch'} .= '<code>';
  }
  
  sub end_code {
      $_[0]{'scratch'} .= '</code>';
  }
  
  sub handle_code {
      $_[0]{'scratch'} .= $_[0]->encode_entities( $_[1] );
  }
  
  sub start_Para {
      $_[0]{'scratch'} .= '<p>';
  }
  
  sub start_Verbatim {
      $_[0]{'scratch'} = '<pre>';
      push(@{$_[0]{'in_code'}}, 'Verbatim');
      $_[0]->start_code($_[0]{'in_code'}[-1]);
  }
  
  sub start_head1 {  $_[0]{'in_head'} = 1; $_[0]{htext} = ''; }
  sub start_head2 {  $_[0]{'in_head'} = 2; $_[0]{htext} = ''; }
  sub start_head3 {  $_[0]{'in_head'} = 3; $_[0]{htext} = ''; }
  sub start_head4 {  $_[0]{'in_head'} = 4; $_[0]{htext} = ''; }
  
  sub start_item_number {
      $_[0]{'scratch'} = "</li>\n" if ($_[0]{'in_li'}->[-1] && pop @{$_[0]{'in_li'}});
      $_[0]{'scratch'} .= '<li><p>';
      push @{$_[0]{'in_li'}}, 1;
  }
  
  sub start_item_bullet {
      $_[0]{'scratch'} = "</li>\n" if ($_[0]{'in_li'}->[-1] && pop @{$_[0]{'in_li'}});
      $_[0]{'scratch'} .= '<li><p>';
      push @{$_[0]{'in_li'}}, 1;
  }
  
  sub start_item_text   {
      # see end_item_text
  }
  
  sub start_over_bullet { $_[0]{'scratch'} = '<ul>'; push @{$_[0]{'in_li'}}, 0; $_[0]->emit }
  sub start_over_block  { $_[0]{'scratch'} = '<ul>'; $_[0]->emit }
  sub start_over_number { $_[0]{'scratch'} = '<ol>'; push @{$_[0]{'in_li'}}, 0; $_[0]->emit }
  sub start_over_text   {
      $_[0]{'scratch'} = '<dl>';
      $_[0]{'dl_level'}++;
      $_[0]{'in_dd'} ||= [];
      $_[0]->emit
  }
  
  sub end_over_block  { $_[0]{'scratch'} .= '</ul>'; $_[0]->emit }
  
  sub end_over_number   {
      $_[0]{'scratch'} = "</li>\n" if ( pop @{$_[0]{'in_li'}} );
      $_[0]{'scratch'} .= '</ol>';
      pop @{$_[0]{'in_li'}};
      $_[0]->emit;
  }
  
  sub end_over_bullet   {
      $_[0]{'scratch'} = "</li>\n" if ( pop @{$_[0]{'in_li'}} );
      $_[0]{'scratch'} .= '</ul>';
      pop @{$_[0]{'in_li'}};
      $_[0]->emit;
  }
  
  sub end_over_text   {
      if ($_[0]{'in_dd'}[ $_[0]{'dl_level'} ]) {
          $_[0]{'scratch'} = "</dd>\n";
          $_[0]{'in_dd'}[ $_[0]{'dl_level'} ] = 0;
      }
      $_[0]{'scratch'} .= '</dl>';
      $_[0]{'dl_level'}--;
      $_[0]->emit;
  }
  
  # . . . . . Now the actual formatters:
  
  sub end_Para     { $_[0]{'scratch'} .= '</p>'; $_[0]->emit }
  sub end_Verbatim {
      $_[0]->end_code(pop(@{$_[0]->{'in_code'}}));
      $_[0]{'scratch'} .= '</pre>';
      $_[0]->emit;
  }
  
  sub _end_head {
      my $h = delete $_[0]{in_head};
  
      my $add = $_[0]->html_h_level;
      $add = 1 unless defined $add;
      $h += $add - 1;
  
      my $id = $_[0]->idify($_[0]{htext});
      my $text = $_[0]{scratch};
      $_[0]{'scratch'} = $_[0]->backlink && ($h - $add == 0)
                           # backlinks enabled && =head1
                           ? qq{<a href="#_podtop_"><h$h id="$id">$text</h$h></a>}
                           : qq{<h$h id="$id">$text</h$h>};
      $_[0]->emit;
      push @{ $_[0]{'to_index'} }, [$h, $id, delete $_[0]{'htext'}];
  }
  
  sub end_head1       { shift->_end_head(@_); }
  sub end_head2       { shift->_end_head(@_); }
  sub end_head3       { shift->_end_head(@_); }
  sub end_head4       { shift->_end_head(@_); }
  
  sub end_item_bullet { $_[0]{'scratch'} .= '</p>'; $_[0]->emit }
  sub end_item_number { $_[0]{'scratch'} .= '</p>'; $_[0]->emit }
  
  sub end_item_text   {
      # idify and anchor =item content if wanted
      my $dt_id = $_[0]{'anchor_items'} 
                   ? ' id="'. $_[0]->idify($_[0]{'scratch'}) .'"'
                   : '';
  
      # reset scratch
      my $text = $_[0]{scratch};
      $_[0]{'scratch'} = '';
  
      if ($_[0]{'in_dd'}[ $_[0]{'dl_level'} ]) {
          $_[0]{'scratch'} = "</dd>\n";
          $_[0]{'in_dd'}[ $_[0]{'dl_level'} ] = 0;
      }
  
      $_[0]{'scratch'} .= qq{<dt$dt_id>$text</dt>\n<dd>};
      $_[0]{'in_dd'}[ $_[0]{'dl_level'} ] = 1;
      $_[0]->emit;
  }
  
  # This handles =begin and =for blocks of all kinds.
  sub start_for {
    my ($self, $flags) = @_;
  
    push @{ $self->{__region_targets} }, $flags->{target_matching};
    $self->{started_for} = 1;
    $self->{in_for} = 1;
  
    unless ($self->__in_literal_xhtml_region) {
      $self->{scratch} .= '<div';
      $self->{scratch} .= qq( class="$flags->{target}") if $flags->{target};
      $self->{scratch} .= ">\n\n";
    }
  }
  
  sub end_for {
    my ($self) = @_;
    delete $self->{started_for};
    delete $self->{in_for};
  
    if ($self->__in_literal_xhtml_region) {
      # Remove trailine newlines.
      $self->{'scratch'} =~ s/\s+\z//s;
    } else {
      $self->{'scratch'} .= '</div>';
    }
  
    pop @{ $self->{__region_targets} };
    $self->emit;
  }
  
  sub start_Document {
    my ($self) = @_;
    if (defined $self->html_header) {
      $self->{'scratch'} .= $self->html_header;
      $self->emit unless $self->html_header eq "";
    } else {
      my ($doctype, $title, $metatags, $bodyid);
      $doctype = $self->html_doctype || '';
      $title = $self->force_title || $self->title || $self->default_title || '';
      $metatags = $self->html_header_tags || '';
      if (my $css = $self->html_css) {
          if ($css !~ /<link/) {
              # this is required to be compatible with Pod::Simple::BatchHTML
              $metatags .= '<link rel="stylesheet" href="'
                  . $self->encode_entities($css) . '" type="text/css" />';
          } else {
              $metatags .= $css;
          }
      }
      if ($self->html_javascript) {
        $metatags .= qq{\n<script type="text/javascript" src="} .
                      $self->html_javascript . '"></script>';
      }
      $bodyid = $self->backlink ? ' id="_podtop_"' : '';
      $self->{'scratch'} .= <<"HTML";
  $doctype
  <html>
  <head>
  <title>$title</title>
  $metatags
  </head>
  <body$bodyid>
  HTML
      $self->emit;
    }
  }
  
  sub end_Document   {
    my ($self) = @_;
    my $to_index = $self->{'to_index'};
    if ($self->index && @{ $to_index } ) {
        my @out;
        my $level  = 0;
        my $indent = -1;
        my $space  = '';
        my $id     = ' id="index"';
  
        for my $h (@{ $to_index }, [0]) {
            my $target_level = $h->[0];
            # Get to target_level by opening or closing ULs
            if ($level == $target_level) {
                $out[-1] .= '</li>';
            } elsif ($level > $target_level) {
                $out[-1] .= '</li>' if $out[-1] =~ /^\s+<li>/;
                while ($level > $target_level) {
                    --$level;
                    push @out, ('  ' x --$indent) . '</li>' if @out && $out[-1] =~ m{^\s+<\/ul};
                    push @out, ('  ' x --$indent) . '</ul>';
                }
                push @out, ('  ' x --$indent) . '</li>' if $level;
            } else {
                while ($level < $target_level) {
                    ++$level;
                    push @out, ('  ' x ++$indent) . '<li>' if @out && $out[-1]=~ /^\s*<ul/;
                    push @out, ('  ' x ++$indent) . "<ul$id>";
                    $id = '';
                }
                ++$indent;
            }
  
            next unless $level;
            $space = '  '  x $indent;
            push @out, sprintf '%s<li><a href="#%s">%s</a>',
                $space, $h->[1], $h->[2];
        }
        # Splice the index in between the HTML headers and the first element.
        my $offset = defined $self->html_header ? $self->html_header eq '' ? 0 : 1 : 1;
        splice @{ $self->{'output'} }, $offset, 0, join "\n", @out;
    }
  
    if (defined $self->html_footer) {
      $self->{'scratch'} .= $self->html_footer;
      $self->emit unless $self->html_footer eq "";
    } else {
      $self->{'scratch'} .= "</body>\n</html>";
      $self->emit;
    }
  
    if ($self->index) {
        print {$self->{'output_fh'}} join ("\n\n", @{ $self->{'output'} }), "\n\n";
        @{$self->{'output'}} = ();
    }
  
  }
  
  # Handling code tags
  sub start_B { $_[0]{'scratch'} .= '<b>' }
  sub end_B   { $_[0]{'scratch'} .= '</b>' }
  
  sub start_C { push(@{$_[0]{'in_code'}}, 'C'); $_[0]->start_code($_[0]{'in_code'}[-1]); }
  sub end_C   { $_[0]->end_code(pop(@{$_[0]{'in_code'}})); }
  
  sub start_F { $_[0]{'scratch'} .= '<i>' }
  sub end_F   { $_[0]{'scratch'} .= '</i>' }
  
  sub start_I { $_[0]{'scratch'} .= '<i>' }
  sub end_I   { $_[0]{'scratch'} .= '</i>' }
  
  sub start_L {
    my ($self, $flags) = @_;
      my ($type, $to, $section) = @{$flags}{'type', 'to', 'section'};
      my $url = $self->encode_entities(
          $type eq 'url' ? $to
              : $type eq 'pod' ? $self->resolve_pod_page_link($to, $section)
              : $type eq 'man' ? $self->resolve_man_page_link($to, $section)
              :                  undef
      );
  
      # If it's an unknown type, use an attribute-less <a> like HTML.pm.
      $self->{'scratch'} .= '<a' . ($url ? ' href="'. $url . '">' : '>');
  }
  
  sub end_L   { $_[0]{'scratch'} .= '</a>' }
  
  sub start_S { $_[0]{'scratch'} .= '<span style="white-space: nowrap;">' }
  sub end_S   { $_[0]{'scratch'} .= '</span>' }
  
  sub emit {
    my($self) = @_;
    if ($self->index) {
        push @{ $self->{'output'} }, $self->{'scratch'};
    } else {
        print {$self->{'output_fh'}} $self->{'scratch'}, "\n\n";
    }
    $self->{'scratch'} = '';
    return;
  }
  
  =head2 resolve_pod_page_link
  
    my $url = $pod->resolve_pod_page_link('Net::Ping', 'INSTALL');
    my $url = $pod->resolve_pod_page_link('perlpodspec');
    my $url = $pod->resolve_pod_page_link(undef, 'SYNOPSIS');
  
  Resolves a POD link target (typically a module or POD file name) and section
  name to a URL. The resulting link will be returned for the above examples as:
  
    http://search.cpan.org/perldoc?Net::Ping#INSTALL
    http://search.cpan.org/perldoc?perlpodspec
    #SYNOPSIS
  
  Note that when there is only a section argument the URL will simply be a link
  to a section in the current document.
  
  =cut
  
  sub resolve_pod_page_link {
      my ($self, $to, $section) = @_;
      return undef unless defined $to || defined $section;
      if (defined $section) {
          $section = '#' . $self->idify($self->encode_entities($section), 1);
          return $section unless defined $to;
      } else {
          $section = ''
      }
  
      return ($self->perldoc_url_prefix || '')
          . $self->encode_entities($to) . $section
          . ($self->perldoc_url_postfix || '');
  }
  
  =head2 resolve_man_page_link
  
    my $url = $pod->resolve_man_page_link('crontab(5)', 'EXAMPLE CRON FILE');
    my $url = $pod->resolve_man_page_link('crontab');
  
  Resolves a man page link target and numeric section to a URL. The resulting
  link will be returned for the above examples as:
  
      http://man.he.net/man5/crontab
      http://man.he.net/man1/crontab
  
  Note that the first argument is required. The section number will be parsed
  from it, and if it's missing will default to 1. The second argument is
  currently ignored, as L<man.he.net|http://man.he.net> does not currently
  include linkable IDs or anchor names in its pages. Subclass to link to a
  different man page HTTP server.
  
  =cut
  
  sub resolve_man_page_link {
      my ($self, $to, $section) = @_;
      return undef unless defined $to;
      my ($page, $part) = $to =~ /^([^(]+)(?:[(](\d+)[)])?$/;
      return undef unless $page;
      return ($self->man_url_prefix || '')
          . ($part || 1) . "/" . $self->encode_entities($page)
          . ($self->man_url_postfix || '');
  
  }
  
  =head2 idify
  
    my $id   = $pod->idify($text);
    my $hash = $pod->idify($text, 1);
  
  This method turns an arbitrary string into a valid XHTML ID attribute value.
  The rules enforced, following
  L<http://webdesign.about.com/od/htmltags/a/aa031707.htm>, are:
  
  =over
  
  =item *
  
  The id must start with a letter (a-z or A-Z)
  
  =item *
  
  All subsequent characters can be letters, numbers (0-9), hyphens (-),
  underscores (_), colons (:), and periods (.).
  
  =item *
  
  The final character can't be a hyphen, colon, or period. URLs ending with these
  characters, while allowed by XHTML, can be awkward to extract from plain text.
  
  =item *
  
  Each id must be unique within the document.
  
  =back
  
  In addition, the returned value will be unique within the context of the
  Pod::Simple::XHTML object unless a second argument is passed a true value. ID
  attributes should always be unique within a single XHTML document, but pass
  the true value if you are creating not an ID but a URL hash to point to
  an ID (i.e., if you need to put the "#foo" in C<< <a href="#foo">foo</a> >>.
  
  =cut
  
  sub idify {
      my ($self, $t, $not_unique) = @_;
      for ($t) {
          s/<[^>]+>//g;            # Strip HTML.
          s/&[^;]+;//g;            # Strip entities.
          s/^\s+//; s/\s+$//;      # Strip white space.
          s/^([^a-zA-Z]+)$/pod$1/; # Prepend "pod" if no valid chars.
          s/^[^a-zA-Z]+//;         # First char must be a letter.
          s/[^-a-zA-Z0-9_:.]+/-/g; # All other chars must be valid.
          s/[-:.]+$//;             # Strip trailing punctuation.
      }
      return $t if $not_unique;
      my $i = '';
      $i++ while $self->{ids}{"$t$i"}++;
      return "$t$i";
  }
  
  =head2 batch_mode_page_object_init
  
    $pod->batch_mode_page_object_init($batchconvobj, $module, $infile, $outfile, $depth);
  
  Called by L<Pod::Simple::HTMLBatch> so that the class has a chance to
  initialize the converter. Internally it sets the C<batch_mode> property to
  true and sets C<batch_mode_current_level()>, but Pod::Simple::XHTML does not
  currently use those features. Subclasses might, though.
  
  =cut
  
  sub batch_mode_page_object_init {
    my ($self, $batchconvobj, $module, $infile, $outfile, $depth) = @_;
    $self->batch_mode(1);
    $self->batch_mode_current_level($depth);
    return $self;
  }
  
  sub html_header_after_title {
  }
  
  
  1;
  
  __END__
  
  =head1 SEE ALSO
  
  L<Pod::Simple>, L<Pod::Simple::Text>, L<Pod::Spell>
  
  =head1 SUPPORT
  
  Questions or discussion about POD and Pod::Simple should be sent to the
  pod-people@perl.org mail list. Send an empty email to
  pod-people-subscribe@perl.org to subscribe.
  
  This module is managed in an open GitHub repository,
  L<https://github.com/perl-pod/pod-simple/>. Feel free to fork and contribute, or
  to clone L<git://github.com/perl-pod/pod-simple.git> and send patches!
  
  Patches against Pod::Simple are welcome. Please send bug reports to
  <bug-pod-simple@rt.cpan.org>.
  
  =head1 COPYRIGHT AND DISCLAIMERS
  
  Copyright (c) 2003-2005 Allison Randal.
  
  This library is free software; you can redistribute it and/or modify it
  under the same terms as Perl itself.
  
  This program is distributed in the hope that it will be useful, but
  without any warranty; without even the implied warranty of
  merchantability or fitness for a particular purpose.
  
  =head1 ACKNOWLEDGEMENTS
  
  Thanks to L<Hurricane Electric|http://he.net/> for permission to use its
  L<Linux man pages online|http://man.he.net/> site for man page links.
  
  Thanks to L<search.cpan.org|http://search.cpan.org/> for permission to use the
  site for Perl module links.
  
  =head1 AUTHOR
  
  Pod::Simpele::XHTML was created by Allison Randal <allison@perl.org>.
  
  Pod::Simple was created by Sean M. Burke <sburke@cpan.org>.
  But don't bother him, he's retired.
  
  Pod::Simple is maintained by:
  
  =over
  
  =item * Allison Randal C<allison@perl.org>
  
  =item * Hans Dieter Pearcey C<hdp@cpan.org>
  
  =item * David E. Wheeler C<dwheeler@cpan.org>
  
  =back
  
  =cut
POD_SIMPLE_XHTML

$fatpacked{"Pod/Simple/XMLOutStream.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POD_SIMPLE_XMLOUTSTREAM';
  
  require 5;
  package Pod::Simple::XMLOutStream;
  use strict;
  use Carp ();
  use Pod::Simple ();
  use vars qw( $ATTR_PAD @ISA $VERSION $SORT_ATTRS);
  $VERSION = '3.35';
  BEGIN {
    @ISA = ('Pod::Simple');
    *DEBUG = \&Pod::Simple::DEBUG unless defined &DEBUG;
  }
  
  $ATTR_PAD = "\n" unless defined $ATTR_PAD;
   # Don't mess with this unless you know what you're doing.
  
  $SORT_ATTRS = 0 unless defined $SORT_ATTRS;
  
  sub new {
    my $self = shift;
    my $new = $self->SUPER::new(@_);
    $new->{'output_fh'} ||= *STDOUT{IO};
    $new->keep_encoding_directive(1);
    #$new->accept_codes('VerbatimFormatted');
    return $new;
  }
  
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  
  sub _handle_element_start {
    # ($self, $element_name, $attr_hash_r)
    my $fh = $_[0]{'output_fh'};
    my($key, $value);
    DEBUG and print STDERR "++ $_[1]\n";
    print $fh "<", $_[1];
    if($SORT_ATTRS) {
      foreach my $key (sort keys %{$_[2]}) {
        unless($key =~ m/^~/s) {
          next if $key eq 'start_line' and $_[0]{'hide_line_numbers'};
          _xml_escape($value = $_[2]{$key});
          print $fh $ATTR_PAD, $key, '="', $value, '"';
        }
      }
    } else { # faster
      while(($key,$value) = each %{$_[2]}) {
        unless($key =~ m/^~/s) {
          next if $key eq 'start_line' and $_[0]{'hide_line_numbers'};
          _xml_escape($value);
          print $fh $ATTR_PAD, $key, '="', $value, '"';
        }
      }
    }
    print $fh ">";
    return;
  }
  
  sub _handle_text {
    DEBUG and print STDERR "== \"$_[1]\"\n";
    if(length $_[1]) {
      my $text = $_[1];
      _xml_escape($text);
      print {$_[0]{'output_fh'}} $text;
    }
    return;
  }
  
  sub _handle_element_end {
    DEBUG and print STDERR "-- $_[1]\n";
    print {$_[0]{'output_fh'}} "</", $_[1], ">";
    return;
  }
  
  # . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  #@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
  
  sub _xml_escape {
    foreach my $x (@_) {
      # Escape things very cautiously:
      if ($] ge 5.007_003) {
        $x =~ s/([^-\n\t !\#\$\%\(\)\*\+,\.\~\/\:\;=\?\@\[\\\]\^_\`\{\|\}abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789])/'&#'.(utf8::native_to_unicode(ord($1))).';'/eg;
      } else { # Is broken for non-ASCII platforms on early perls
        $x =~ s/([^-\n\t !\#\$\%\(\)\*\+,\.\~\/\:\;=\?\@\[\\\]\^_\`\{\|\}abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789])/'&#'.(ord($1)).';'/eg;
      }
      # Yes, stipulate the list without a range, so that this can work right on
      #  all charsets that this module happens to run under.
    }
    return;
  }
  
  #@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
  1;
  
  __END__
  
  =head1 NAME
  
  Pod::Simple::XMLOutStream -- turn Pod into XML
  
  =head1 SYNOPSIS
  
    perl -MPod::Simple::XMLOutStream -e \
     "exit Pod::Simple::XMLOutStream->filter(shift)->any_errata_seen" \
     thingy.pod
  
  =head1 DESCRIPTION
  
  Pod::Simple::XMLOutStream is a subclass of L<Pod::Simple> that parses
  Pod and turns it into XML.
  
  Pod::Simple::XMLOutStream inherits methods from
  L<Pod::Simple>.
  
  
  =head1 SEE ALSO
  
  L<Pod::Simple::DumpAsXML> is rather like this class; see its
  documentation for a discussion of the differences.
  
  L<Pod::Simple>, L<Pod::Simple::DumpAsXML>, L<Pod::SAX>
  
  L<Pod::Simple::Subclassing>
  
  The older (and possibly obsolete) libraries L<Pod::PXML>, L<Pod::XML>
  
  
  =head1 ABOUT EXTENDING POD
  
  TODO: An example or two of =extend, then point to Pod::Simple::Subclassing
  
  =head1 SEE ALSO
  
  L<Pod::Simple>, L<Pod::Simple::Text>, L<Pod::Spell>
  
  =head1 SUPPORT
  
  Questions or discussion about POD and Pod::Simple should be sent to the
  pod-people@perl.org mail list. Send an empty email to
  pod-people-subscribe@perl.org to subscribe.
  
  This module is managed in an open GitHub repository,
  L<https://github.com/perl-pod/pod-simple/>. Feel free to fork and contribute, or
  to clone L<git://github.com/perl-pod/pod-simple.git> and send patches!
  
  Patches against Pod::Simple are welcome. Please send bug reports to
  <bug-pod-simple@rt.cpan.org>.
  
  =head1 COPYRIGHT AND DISCLAIMERS
  
  Copyright (c) 2002-2004 Sean M. Burke.
  
  This library is free software; you can redistribute it and/or modify it
  under the same terms as Perl itself.
  
  This program is distributed in the hope that it will be useful, but
  without any warranty; without even the implied warranty of
  merchantability or fitness for a particular purpose.
  
  =head1 AUTHOR
  
  Pod::Simple was created by Sean M. Burke <sburke@cpan.org>.
  But don't bother him, he's retired.
  
  Pod::Simple is maintained by:
  
  =over
  
  =item * Allison Randal C<allison@perl.org>
  
  =item * Hans Dieter Pearcey C<hdp@cpan.org>
  
  =item * David E. Wheeler C<dwheeler@cpan.org>
  
  =back
  
  =cut
POD_SIMPLE_XMLOUTSTREAM

$fatpacked{"Pod/Text.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POD_TEXT';
  # Convert POD data to formatted text.
  #
  # This module converts POD to formatted text.  It replaces the old Pod::Text
  # module that came with versions of Perl prior to 5.6.0 and attempts to match
  # its output except for some specific circumstances where other decisions
  # seemed to produce better output.  It uses Pod::Parser and is designed to be
  # very easy to subclass.
  #
  # Perl core hackers, please note that this module is also separately
  # maintained outside of the Perl core as part of the podlators.  Please send
  # me any patches at the address above in addition to sending them to the
  # standard Perl mailing lists.
  #
  # Copyright 1999, 2000, 2001, 2002, 2004, 2006, 2008, 2009, 2012, 2013, 2014,
  #     2015, 2016 Russ Allbery <rra@cpan.org>
  #
  # This program is free software; you may redistribute it and/or modify it
  # under the same terms as Perl itself.
  
  ##############################################################################
  # Modules and declarations
  ##############################################################################
  
  package Pod::Text;
  
  use 5.006;
  use strict;
  use warnings;
  
  use vars qw(@ISA @EXPORT %ESCAPES $VERSION);
  
  use Carp qw(carp croak);
  use Encode qw(encode);
  use Exporter ();
  use Pod::Simple ();
  
  @ISA = qw(Pod::Simple Exporter);
  
  # We have to export pod2text for backward compatibility.
  @EXPORT = qw(pod2text);
  
  $VERSION = '4.09';
  
  # Ensure that $Pod::Simple::nbsp and $Pod::Simple::shy are available.  Code
  # taken from Pod::Simple 3.32, but was only added in 3.30.
  my ($NBSP, $SHY);
  if ($Pod::Simple::VERSION ge 3.30) {
      $NBSP = $Pod::Simple::nbsp;
      $SHY  = $Pod::Simple::shy;
  } else {
      if ($] ge 5.007_003) {
          $NBSP = chr utf8::unicode_to_native(0xA0);
          $SHY  = chr utf8::unicode_to_native(0xAD);
      } elsif (Pod::Simple::ASCII) {
          $NBSP = "\xA0";
          $SHY  = "\xAD";
      } else {
          $NBSP = "\x41";
          $SHY  = "\xCA";
      }
  }
  
  ##############################################################################
  # Initialization
  ##############################################################################
  
  # This function handles code blocks.  It's registered as a callback to
  # Pod::Simple and therefore doesn't work as a regular method call, but all it
  # does is call output_code with the line.
  sub handle_code {
      my ($line, $number, $parser) = @_;
      $parser->output_code ($line . "\n");
  }
  
  # Initialize the object and set various Pod::Simple options that we need.
  # Here, we also process any additional options passed to the constructor or
  # set up defaults if none were given.  Note that all internal object keys are
  # in all-caps, reserving all lower-case object keys for Pod::Simple and user
  # arguments.
  sub new {
      my $class = shift;
      my $self = $class->SUPER::new;
  
      # Tell Pod::Simple to handle S<> by automatically inserting &nbsp;.
      $self->nbsp_for_S (1);
  
      # Tell Pod::Simple to keep whitespace whenever possible.
      if ($self->can ('preserve_whitespace')) {
          $self->preserve_whitespace (1);
      } else {
          $self->fullstop_space_harden (1);
      }
  
      # The =for and =begin targets that we accept.
      $self->accept_targets (qw/text TEXT/);
  
      # Ensure that contiguous blocks of code are merged together.  Otherwise,
      # some of the guesswork heuristics don't work right.
      $self->merge_text (1);
  
      # Pod::Simple doesn't do anything useful with our arguments, but we want
      # to put them in our object as hash keys and values.  This could cause
      # problems if we ever clash with Pod::Simple's own internal class
      # variables.
      my %opts = @_;
      my @opts = map { ("opt_$_", $opts{$_}) } keys %opts;
      %$self = (%$self, @opts);
  
      # Send errors to stderr if requested.
      if ($$self{opt_stderr} and not $$self{opt_errors}) {
          $$self{opt_errors} = 'stderr';
      }
      delete $$self{opt_stderr};
  
      # Validate the errors parameter and act on it.
      if (not defined $$self{opt_errors}) {
          $$self{opt_errors} = 'pod';
      }
      if ($$self{opt_errors} eq 'stderr' || $$self{opt_errors} eq 'die') {
          $self->no_errata_section (1);
          $self->complain_stderr (1);
          if ($$self{opt_errors} eq 'die') {
              $$self{complain_die} = 1;
          }
      } elsif ($$self{opt_errors} eq 'pod') {
          $self->no_errata_section (0);
          $self->complain_stderr (0);
      } elsif ($$self{opt_errors} eq 'none') {
          $self->no_whining (1);
      } else {
          croak (qq(Invalid errors setting: "$$self{errors}"));
      }
      delete $$self{errors};
  
      # Initialize various things from our parameters.
      $$self{opt_alt}      = 0  unless defined $$self{opt_alt};
      $$self{opt_indent}   = 4  unless defined $$self{opt_indent};
      $$self{opt_margin}   = 0  unless defined $$self{opt_margin};
      $$self{opt_loose}    = 0  unless defined $$self{opt_loose};
      $$self{opt_sentence} = 0  unless defined $$self{opt_sentence};
      $$self{opt_width}    = 76 unless defined $$self{opt_width};
  
      # Figure out what quotes we'll be using for C<> text.
      $$self{opt_quotes} ||= '"';
      if ($$self{opt_quotes} eq 'none') {
          $$self{LQUOTE} = $$self{RQUOTE} = '';
      } elsif (length ($$self{opt_quotes}) == 1) {
          $$self{LQUOTE} = $$self{RQUOTE} = $$self{opt_quotes};
      } elsif (length ($$self{opt_quotes}) % 2 == 0) {
          my $length = length ($$self{opt_quotes}) / 2;
          $$self{LQUOTE} = substr ($$self{opt_quotes}, 0, $length);
          $$self{RQUOTE} = substr ($$self{opt_quotes}, $length);
      } else {
          croak qq(Invalid quote specification "$$self{opt_quotes}");
      }
  
      # If requested, do something with the non-POD text.
      $self->code_handler (\&handle_code) if $$self{opt_code};
  
      # Return the created object.
      return $self;
  }
  
  ##############################################################################
  # Core parsing
  ##############################################################################
  
  # This is the glue that connects the code below with Pod::Simple itself.  The
  # goal is to convert the event stream coming from the POD parser into method
  # calls to handlers once the complete content of a tag has been seen.  Each
  # paragraph or POD command will have textual content associated with it, and
  # as soon as all of a paragraph or POD command has been seen, that content
  # will be passed in to the corresponding method for handling that type of
  # object.  The exceptions are handlers for lists, which have opening tag
  # handlers and closing tag handlers that will be called right away.
  #
  # The internal hash key PENDING is used to store the contents of a tag until
  # all of it has been seen.  It holds a stack of open tags, each one
  # represented by a tuple of the attributes hash for the tag and the contents
  # of the tag.
  
  # Add a block of text to the contents of the current node, formatting it
  # according to the current formatting instructions as we do.
  sub _handle_text {
      my ($self, $text) = @_;
      my $tag = $$self{PENDING}[-1];
      $$tag[1] .= $text;
  }
  
  # Given an element name, get the corresponding method name.
  sub method_for_element {
      my ($self, $element) = @_;
      $element =~ tr/-/_/;
      $element =~ tr/A-Z/a-z/;
      $element =~ tr/_a-z0-9//cd;
      return $element;
  }
  
  # Handle the start of a new element.  If cmd_element is defined, assume that
  # we need to collect the entire tree for this element before passing it to the
  # element method, and create a new tree into which we'll collect blocks of
  # text and nested elements.  Otherwise, if start_element is defined, call it.
  sub _handle_element_start {
      my ($self, $element, $attrs) = @_;
      my $method = $self->method_for_element ($element);
  
      # If we have a command handler, we need to accumulate the contents of the
      # tag before calling it.
      if ($self->can ("cmd_$method")) {
          push (@{ $$self{PENDING} }, [ $attrs, '' ]);
      } elsif ($self->can ("start_$method")) {
          my $method = 'start_' . $method;
          $self->$method ($attrs, '');
      }
  }
  
  # Handle the end of an element.  If we had a cmd_ method for this element,
  # this is where we pass along the text that we've accumulated.  Otherwise, if
  # we have an end_ method for the element, call that.
  sub _handle_element_end {
      my ($self, $element) = @_;
      my $method = $self->method_for_element ($element);
  
      # If we have a command handler, pull off the pending text and pass it to
      # the handler along with the saved attribute hash.
      if ($self->can ("cmd_$method")) {
          my $tag = pop @{ $$self{PENDING} };
          my $method = 'cmd_' . $method;
          my $text = $self->$method (@$tag);
          if (defined $text) {
              if (@{ $$self{PENDING} } > 1) {
                  $$self{PENDING}[-1][1] .= $text;
              } else {
                  $self->output ($text);
              }
          }
      } elsif ($self->can ("end_$method")) {
          my $method = 'end_' . $method;
          $self->$method ();
      }
  }
  
  ##############################################################################
  # Output formatting
  ##############################################################################
  
  # Wrap a line, indenting by the current left margin.  We can't use Text::Wrap
  # because it plays games with tabs.  We can't use formline, even though we'd
  # really like to, because it screws up non-printing characters.  So we have to
  # do the wrapping ourselves.
  sub wrap {
      my $self = shift;
      local $_ = shift;
      my $output = '';
      my $spaces = ' ' x $$self{MARGIN};
      my $width = $$self{opt_width} - $$self{MARGIN};
      while (length > $width) {
          if (s/^([^\n]{0,$width})\s+// || s/^([^\n]{$width})//) {
              $output .= $spaces . $1 . "\n";
          } else {
              last;
          }
      }
      $output .= $spaces . $_;
      $output =~ s/\s+$/\n\n/;
      return $output;
  }
  
  # Reformat a paragraph of text for the current margin.  Takes the text to
  # reformat and returns the formatted text.
  sub reformat {
      my $self = shift;
      local $_ = shift;
  
      # If we're trying to preserve two spaces after sentences, do some munging
      # to support that.  Otherwise, smash all repeated whitespace.
      if ($$self{opt_sentence}) {
          s/ +$//mg;
          s/\.\n/. \n/g;
          s/\n/ /g;
          s/   +/  /g;
      } else {
          s/\s+/ /g;
      }
      return $self->wrap ($_);
  }
  
  # Output text to the output device.  Replace non-breaking spaces with spaces
  # and soft hyphens with nothing, and then try to fix the output encoding if
  # necessary to match the input encoding unless UTF-8 output is forced.  This
  # preserves the traditional pass-through behavior of Pod::Text.
  sub output {
      my ($self, @text) = @_;
      my $text = join ('', @text);
      if ($NBSP) {
          $text =~ s/$NBSP/ /g;
      }
      if ($SHY) {
          $text =~ s/$SHY//g;
      }
      unless ($$self{opt_utf8}) {
          my $encoding = $$self{encoding} || '';
          if ($encoding && $encoding ne $$self{ENCODING}) {
              $$self{ENCODING} = $encoding;
              eval { binmode ($$self{output_fh}, ":encoding($encoding)") };
          }
      }
      if ($$self{ENCODE}) {
          print { $$self{output_fh} } encode ('UTF-8', $text);
      } else {
          print { $$self{output_fh} } $text;
      }
  }
  
  # Output a block of code (something that isn't part of the POD text).  Called
  # by preprocess_paragraph only if we were given the code option.  Exists here
  # only so that it can be overridden by subclasses.
  sub output_code { $_[0]->output ($_[1]) }
  
  ##############################################################################
  # Document initialization
  ##############################################################################
  
  # Set up various things that have to be initialized on a per-document basis.
  sub start_document {
      my ($self, $attrs) = @_;
      if ($$attrs{contentless} && !$$self{ALWAYS_EMIT_SOMETHING}) {
          $$self{CONTENTLESS} = 1;
      } else {
          delete $$self{CONTENTLESS};
      }
      my $margin = $$self{opt_indent} + $$self{opt_margin};
  
      # Initialize a few per-document variables.
      $$self{INDENTS} = [];       # Stack of indentations.
      $$self{MARGIN}  = $margin;  # Default left margin.
      $$self{PENDING} = [[]];     # Pending output.
  
      # We have to redo encoding handling for each document.
      $$self{ENCODING} = '';
  
      # When UTF-8 output is set, check whether our output file handle already
      # has a PerlIO encoding layer set.  If it does not, we'll need to encode
      # our output before printing it (handled in the output() sub).  Wrap the
      # check in an eval to handle versions of Perl without PerlIO.
      $$self{ENCODE} = 0;
      if ($$self{opt_utf8}) {
          $$self{ENCODE} = 1;
          eval {
              my @options = (output => 1, details => 1);
              my $flag = (PerlIO::get_layers ($$self{output_fh}, @options))[-1];
              if ($flag & PerlIO::F_UTF8 ()) {
                  $$self{ENCODE} = 0;
                  $$self{ENCODING} = 'UTF-8';
              }
          };
      }
  
      return '';
  }
  
  # Handle the end of the document.  The only thing we do is handle dying on POD
  # errors, since Pod::Parser currently doesn't.
  sub end_document {
      my ($self) = @_;
      if ($$self{complain_die} && $self->errors_seen) {
          croak ("POD document had syntax errors");
      }
  }
  
  ##############################################################################
  # Text blocks
  ##############################################################################
  
  # Intended for subclasses to override, this method returns text with any
  # non-printing formatting codes stripped out so that length() correctly
  # returns the length of the text.  For basic Pod::Text, it does nothing.
  sub strip_format {
      my ($self, $string) = @_;
      return $string;
  }
  
  # This method is called whenever an =item command is complete (in other words,
  # we've seen its associated paragraph or know for certain that it doesn't have
  # one).  It gets the paragraph associated with the item as an argument.  If
  # that argument is empty, just output the item tag; if it contains a newline,
  # output the item tag followed by the newline.  Otherwise, see if there's
  # enough room for us to output the item tag in the margin of the text or if we
  # have to put it on a separate line.
  sub item {
      my ($self, $text) = @_;
      my $tag = $$self{ITEM};
      unless (defined $tag) {
          carp "Item called without tag";
          return;
      }
      undef $$self{ITEM};
  
      # Calculate the indentation and margin.  $fits is set to true if the tag
      # will fit into the margin of the paragraph given our indentation level.
      my $indent = $$self{INDENTS}[-1];
      $indent = $$self{opt_indent} unless defined $indent;
      my $margin = ' ' x $$self{opt_margin};
      my $tag_length = length ($self->strip_format ($tag));
      my $fits = ($$self{MARGIN} - $indent >= $tag_length + 1);
  
      # If the tag doesn't fit, or if we have no associated text, print out the
      # tag separately.  Otherwise, put the tag in the margin of the paragraph.
      if (!$text || $text =~ /^\s+$/ || !$fits) {
          my $realindent = $$self{MARGIN};
          $$self{MARGIN} = $indent;
          my $output = $self->reformat ($tag);
          $output =~ s/^$margin /$margin:/ if ($$self{opt_alt} && $indent > 0);
          $output =~ s/\n*$/\n/;
  
          # If the text is just whitespace, we have an empty item paragraph;
          # this can result from =over/=item/=back without any intermixed
          # paragraphs.  Insert some whitespace to keep the =item from merging
          # into the next paragraph.
          $output .= "\n" if $text && $text =~ /^\s*$/;
  
          $self->output ($output);
          $$self{MARGIN} = $realindent;
          $self->output ($self->reformat ($text)) if ($text && $text =~ /\S/);
      } else {
          my $space = ' ' x $indent;
          $space =~ s/^$margin /$margin:/ if $$self{opt_alt};
          $text = $self->reformat ($text);
          $text =~ s/^$margin /$margin:/ if ($$self{opt_alt} && $indent > 0);
          my $tagspace = ' ' x $tag_length;
          $text =~ s/^($space)$tagspace/$1$tag/ or warn "Bizarre space in item";
          $self->output ($text);
      }
  }
  
  # Handle a basic block of text.  The only tricky thing here is that if there
  # is a pending item tag, we need to format this as an item paragraph.
  sub cmd_para {
      my ($self, $attrs, $text) = @_;
      $text =~ s/\s+$/\n/;
      if (defined $$self{ITEM}) {
          $self->item ($text . "\n");
      } else {
          $self->output ($self->reformat ($text . "\n"));
      }
      return '';
  }
  
  # Handle a verbatim paragraph.  Just print it out, but indent it according to
  # our margin.
  sub cmd_verbatim {
      my ($self, $attrs, $text) = @_;
      $self->item if defined $$self{ITEM};
      return if $text =~ /^\s*$/;
      $text =~ s/^(\n*)([ \t]*\S+)/$1 . (' ' x $$self{MARGIN}) . $2/gme;
      $text =~ s/\s*$/\n\n/;
      $self->output ($text);
      return '';
  }
  
  # Handle literal text (produced by =for and similar constructs).  Just output
  # it with the minimum of changes.
  sub cmd_data {
      my ($self, $attrs, $text) = @_;
      $text =~ s/^\n+//;
      $text =~ s/\n{0,2}$/\n/;
      $self->output ($text);
      return '';
  }
  
  ##############################################################################
  # Headings
  ##############################################################################
  
  # The common code for handling all headers.  Takes the header text, the
  # indentation, and the surrounding marker for the alt formatting method.
  sub heading {
      my ($self, $text, $indent, $marker) = @_;
      $self->item ("\n\n") if defined $$self{ITEM};
      $text =~ s/\s+$//;
      if ($$self{opt_alt}) {
          my $closemark = reverse (split (//, $marker));
          my $margin = ' ' x $$self{opt_margin};
          $self->output ("\n" . "$margin$marker $text $closemark" . "\n\n");
      } else {
          $text .= "\n" if $$self{opt_loose};
          my $margin = ' ' x ($$self{opt_margin} + $indent);
          $self->output ($margin . $text . "\n");
      }
      return '';
  }
  
  # First level heading.
  sub cmd_head1 {
      my ($self, $attrs, $text) = @_;
      $self->heading ($text, 0, '====');
  }
  
  # Second level heading.
  sub cmd_head2 {
      my ($self, $attrs, $text) = @_;
      $self->heading ($text, $$self{opt_indent} / 2, '==  ');
  }
  
  # Third level heading.
  sub cmd_head3 {
      my ($self, $attrs, $text) = @_;
      $self->heading ($text, $$self{opt_indent} * 2 / 3 + 0.5, '=   ');
  }
  
  # Fourth level heading.
  sub cmd_head4 {
      my ($self, $attrs, $text) = @_;
      $self->heading ($text, $$self{opt_indent} * 3 / 4 + 0.5, '-   ');
  }
  
  ##############################################################################
  # List handling
  ##############################################################################
  
  # Handle the beginning of an =over block.  Takes the type of the block as the
  # first argument, and then the attr hash.  This is called by the handlers for
  # the four different types of lists (bullet, number, text, and block).
  sub over_common_start {
      my ($self, $attrs) = @_;
      $self->item ("\n\n") if defined $$self{ITEM};
  
      # Find the indentation level.
      my $indent = $$attrs{indent};
      unless (defined ($indent) && $indent =~ /^\s*[-+]?\d{1,4}\s*$/) {
          $indent = $$self{opt_indent};
      }
  
      # Add this to our stack of indents and increase our current margin.
      push (@{ $$self{INDENTS} }, $$self{MARGIN});
      $$self{MARGIN} += ($indent + 0);
      return '';
  }
  
  # End an =over block.  Takes no options other than the class pointer.  Output
  # any pending items and then pop one level of indentation.
  sub over_common_end {
      my ($self) = @_;
      $self->item ("\n\n") if defined $$self{ITEM};
      $$self{MARGIN} = pop @{ $$self{INDENTS} };
      return '';
  }
  
  # Dispatch the start and end calls as appropriate.
  sub start_over_bullet { $_[0]->over_common_start ($_[1]) }
  sub start_over_number { $_[0]->over_common_start ($_[1]) }
  sub start_over_text   { $_[0]->over_common_start ($_[1]) }
  sub start_over_block  { $_[0]->over_common_start ($_[1]) }
  sub end_over_bullet { $_[0]->over_common_end }
  sub end_over_number { $_[0]->over_common_end }
  sub end_over_text   { $_[0]->over_common_end }
  sub end_over_block  { $_[0]->over_common_end }
  
  # The common handler for all item commands.  Takes the type of the item, the
  # attributes, and then the text of the item.
  sub item_common {
      my ($self, $type, $attrs, $text) = @_;
      $self->item if defined $$self{ITEM};
  
      # Clean up the text.  We want to end up with two variables, one ($text)
      # which contains any body text after taking out the item portion, and
      # another ($item) which contains the actual item text.  Note the use of
      # the internal Pod::Simple attribute here; that's a potential land mine.
      $text =~ s/\s+$//;
      my ($item, $index);
      if ($type eq 'bullet') {
          $item = '*';
      } elsif ($type eq 'number') {
          $item = $$attrs{'~orig_content'};
      } else {
          $item = $text;
          $item =~ s/\s*\n\s*/ /g;
          $text = '';
      }
      $$self{ITEM} = $item;
  
      # If body text for this item was included, go ahead and output that now.
      if ($text) {
          $text =~ s/\s*$/\n/;
          $self->item ($text);
      }
      return '';
  }
  
  # Dispatch the item commands to the appropriate place.
  sub cmd_item_bullet { my $self = shift; $self->item_common ('bullet', @_) }
  sub cmd_item_number { my $self = shift; $self->item_common ('number', @_) }
  sub cmd_item_text   { my $self = shift; $self->item_common ('text',   @_) }
  sub cmd_item_block  { my $self = shift; $self->item_common ('block',  @_) }
  
  ##############################################################################
  # Formatting codes
  ##############################################################################
  
  # The simple ones.
  sub cmd_b { return $_[0]{alt} ? "``$_[2]''" : $_[2] }
  sub cmd_f { return $_[0]{alt} ? "\"$_[2]\"" : $_[2] }
  sub cmd_i { return '*' . $_[2] . '*' }
  sub cmd_x { return '' }
  
  # Apply a whole bunch of messy heuristics to not quote things that don't
  # benefit from being quoted.  These originally come from Barrie Slaymaker and
  # largely duplicate code in Pod::Man.
  sub cmd_c {
      my ($self, $attrs, $text) = @_;
  
      # A regex that matches the portion of a variable reference that's the
      # array or hash index, separated out just because we want to use it in
      # several places in the following regex.
      my $index = '(?: \[.*\] | \{.*\} )?';
  
      # Check for things that we don't want to quote, and if we find any of
      # them, return the string with just a font change and no quoting.
      $text =~ m{
        ^\s*
        (?:
           ( [\'\`\"] ) .* \1                             # already quoted
         | \` .* \'                                       # `quoted'
         | \$+ [\#^]? \S $index                           # special ($^Foo, $")
         | [\$\@%&*]+ \#? [:\'\w]+ $index                 # plain var or func
         | [\$\@%&*]* [:\'\w]+ (?: -> )? \(\s*[^\s,]\s*\) # 0/1-arg func call
         | [+-]? ( \d[\d.]* | \.\d+ ) (?: [eE][+-]?\d+ )? # a number
         | 0x [a-fA-F\d]+                                 # a hex constant
        )
        \s*\z
       }xo && return $text;
  
      # If we didn't return, go ahead and quote the text.
      return $$self{opt_alt}
          ? "``$text''"
          : "$$self{LQUOTE}$text$$self{RQUOTE}";
  }
  
  # Links reduce to the text that we're given, wrapped in angle brackets if it's
  # a URL.
  sub cmd_l {
      my ($self, $attrs, $text) = @_;
      if ($$attrs{type} eq 'url') {
          if (not defined($$attrs{to}) or $$attrs{to} eq $text) {
              return "<$text>";
          } elsif ($$self{opt_nourls}) {
              return $text;
          } else {
              return "$text <$$attrs{to}>";
          }
      } else {
          return $text;
      }
  }
  
  ##############################################################################
  # Backwards compatibility
  ##############################################################################
  
  # The old Pod::Text module did everything in a pod2text() function.  This
  # tries to provide the same interface for legacy applications.
  sub pod2text {
      my @args;
  
      # This is really ugly; I hate doing option parsing in the middle of a
      # module.  But the old Pod::Text module supported passing flags to its
      # entry function, so handle -a and -<number>.
      while ($_[0] =~ /^-/) {
          my $flag = shift;
          if    ($flag eq '-a')       { push (@args, alt => 1)    }
          elsif ($flag =~ /^-(\d+)$/) { push (@args, width => $1) }
          else {
              unshift (@_, $flag);
              last;
          }
      }
  
      # Now that we know what arguments we're using, create the parser.
      my $parser = Pod::Text->new (@args);
  
      # If two arguments were given, the second argument is going to be a file
      # handle.  That means we want to call parse_from_filehandle(), which means
      # we need to turn the first argument into a file handle.  Magic open will
      # handle the <&STDIN case automagically.
      if (defined $_[1]) {
          my @fhs = @_;
          local *IN;
          unless (open (IN, $fhs[0])) {
              croak ("Can't open $fhs[0] for reading: $!\n");
              return;
          }
          $fhs[0] = \*IN;
          $parser->output_fh ($fhs[1]);
          my $retval = $parser->parse_file ($fhs[0]);
          my $fh = $parser->output_fh ();
          close $fh;
          return $retval;
      } else {
          $parser->output_fh (\*STDOUT);
          return $parser->parse_file (@_);
      }
  }
  
  # Reset the underlying Pod::Simple object between calls to parse_from_file so
  # that the same object can be reused to convert multiple pages.
  sub parse_from_file {
      my $self = shift;
      $self->reinit;
  
      # Fake the old cutting option to Pod::Parser.  This fiddings with internal
      # Pod::Simple state and is quite ugly; we need a better approach.
      if (ref ($_[0]) eq 'HASH') {
          my $opts = shift @_;
          if (defined ($$opts{-cutting}) && !$$opts{-cutting}) {
              $$self{in_pod} = 1;
              $$self{last_was_blank} = 1;
          }
      }
  
      # Do the work.
      my $retval = $self->Pod::Simple::parse_from_file (@_);
  
      # Flush output, since Pod::Simple doesn't do this.  Ideally we should also
      # close the file descriptor if we had to open one, but we can't easily
      # figure this out.
      my $fh = $self->output_fh ();
      my $oldfh = select $fh;
      my $oldflush = $|;
      $| = 1;
      print $fh '';
      $| = $oldflush;
      select $oldfh;
      return $retval;
  }
  
  # Pod::Simple failed to provide this backward compatibility function, so
  # implement it ourselves.  File handles are one of the inputs that
  # parse_from_file supports.
  sub parse_from_filehandle {
      my $self = shift;
      $self->parse_from_file (@_);
  }
  
  # Pod::Simple's parse_file doesn't set output_fh.  Wrap the call and do so
  # ourself unless it was already set by the caller, since our documentation has
  # always said that this should work.
  sub parse_file {
      my ($self, $in) = @_;
      unless (defined $$self{output_fh}) {
          $self->output_fh (\*STDOUT);
      }
      return $self->SUPER::parse_file ($in);
  }
  
  # Do the same for parse_lines, just to be polite.  Pod::Simple's man page
  # implies that the caller is responsible for setting this, but I don't see any
  # reason not to set a default.
  sub parse_lines {
      my ($self, @lines) = @_;
      unless (defined $$self{output_fh}) {
          $self->output_fh (\*STDOUT);
      }
      return $self->SUPER::parse_lines (@lines);
  }
  
  # Likewise for parse_string_document.
  sub parse_string_document {
      my ($self, $doc) = @_;
      unless (defined $$self{output_fh}) {
          $self->output_fh (\*STDOUT);
      }
      return $self->SUPER::parse_string_document ($doc);
  }
  
  ##############################################################################
  # Module return value and documentation
  ##############################################################################
  
  1;
  __END__
  
  =for stopwords
  alt stderr Allbery Sean Burke's Christiansen UTF-8 pre-Unicode utf8 nourls
  parsers
  
  =head1 NAME
  
  Pod::Text - Convert POD data to formatted text
  
  =head1 SYNOPSIS
  
      use Pod::Text;
      my $parser = Pod::Text->new (sentence => 0, width => 78);
  
      # Read POD from STDIN and write to STDOUT.
      $parser->parse_from_filehandle;
  
      # Read POD from file.pod and write to file.txt.
      $parser->parse_from_file ('file.pod', 'file.txt');
  
  =head1 DESCRIPTION
  
  Pod::Text is a module that can convert documentation in the POD format
  (the preferred language for documenting Perl) into formatted text.  It
  uses no special formatting controls or codes whatsoever, and its output is
  therefore suitable for nearly any device.
  
  As a derived class from Pod::Simple, Pod::Text supports the same methods and
  interfaces.  See L<Pod::Simple> for all the details; briefly, one creates a
  new parser with C<< Pod::Text->new() >> and then normally calls parse_file().
  
  new() can take options, in the form of key/value pairs, that control the
  behavior of the parser.  The currently recognized options are:
  
  =over 4
  
  =item alt
  
  If set to a true value, selects an alternate output format that, among other
  things, uses a different heading style and marks C<=item> entries with a
  colon in the left margin.  Defaults to false.
  
  =item code
  
  If set to a true value, the non-POD parts of the input file will be included
  in the output.  Useful for viewing code documented with POD blocks with the
  POD rendered and the code left intact.
  
  =item errors
  
  How to report errors.  C<die> says to throw an exception on any POD
  formatting error.  C<stderr> says to report errors on standard error, but
  not to throw an exception.  C<pod> says to include a POD ERRORS section
  in the resulting documentation summarizing the errors.  C<none> ignores
  POD errors entirely, as much as possible.
  
  The default is C<pod>.
  
  =item indent
  
  The number of spaces to indent regular text, and the default indentation for
  C<=over> blocks.  Defaults to 4.
  
  =item loose
  
  If set to a true value, a blank line is printed after a C<=head1> heading.
  If set to false (the default), no blank line is printed after C<=head1>,
  although one is still printed after C<=head2>.  This is the default because
  it's the expected formatting for manual pages; if you're formatting
  arbitrary text documents, setting this to true may result in more pleasing
  output.
  
  =item margin
  
  The width of the left margin in spaces.  Defaults to 0.  This is the margin
  for all text, including headings, not the amount by which regular text is
  indented; for the latter, see the I<indent> option.  To set the right
  margin, see the I<width> option.
  
  =item nourls
  
  Normally, LZ<><> formatting codes with a URL but anchor text are formatted
  to show both the anchor text and the URL.  In other words:
  
      L<foo|http://example.com/>
  
  is formatted as:
  
      foo <http://example.com/>
  
  This option, if set to a true value, suppresses the URL when anchor text
  is given, so this example would be formatted as just C<foo>.  This can
  produce less cluttered output in cases where the URLs are not particularly
  important.
  
  =item quotes
  
  Sets the quote marks used to surround CE<lt>> text.  If the value is a
  single character, it is used as both the left and right quote.  Otherwise,
  it is split in half, and the first half of the string is used as the left
  quote and the second is used as the right quote.
  
  This may also be set to the special value C<none>, in which case no quote
  marks are added around CE<lt>> text.
  
  =item sentence
  
  If set to a true value, Pod::Text will assume that each sentence ends in two
  spaces, and will try to preserve that spacing.  If set to false, all
  consecutive whitespace in non-verbatim paragraphs is compressed into a
  single space.  Defaults to true.
  
  =item stderr
  
  Send error messages about invalid POD to standard error instead of
  appending a POD ERRORS section to the generated output.  This is
  equivalent to setting C<errors> to C<stderr> if C<errors> is not already
  set.  It is supported for backward compatibility.
  
  =item utf8
  
  By default, Pod::Text uses the same output encoding as the input encoding
  of the POD source (provided that Perl was built with PerlIO; otherwise, it
  doesn't encode its output).  If this option is given, the output encoding
  is forced to UTF-8.
  
  Be aware that, when using this option, the input encoding of your POD
  source should be properly declared unless it's US-ASCII.  Pod::Simple will
  attempt to guess the encoding and may be successful if it's Latin-1 or
  UTF-8, but it will produce warnings.  Use the C<=encoding> command to
  declare the encoding.  See L<perlpod(1)> for more information.
  
  =item width
  
  The column at which to wrap text on the right-hand side.  Defaults to 76.
  
  =back
  
  The standard Pod::Simple method parse_file() takes one argument naming the
  POD file to read from.  By default, the output is sent to C<STDOUT>, but
  this can be changed with the output_fh() method.
  
  The standard Pod::Simple method parse_from_file() takes up to two
  arguments, the first being the input file to read POD from and the second
  being the file to write the formatted output to.
  
  You can also call parse_lines() to parse an array of lines or
  parse_string_document() to parse a document already in memory.  As with
  parse_file(), parse_lines() and parse_string_document() default to sending
  their output to C<STDOUT> unless changed with the output_fh() method.
  
  To put the output from any parse method into a string instead of a file
  handle, call the output_string() method instead of output_fh().
  
  See L<Pod::Simple> for more specific details on the methods available to
  all derived parsers.
  
  =head1 DIAGNOSTICS
  
  =over 4
  
  =item Bizarre space in item
  
  =item Item called without tag
  
  (W) Something has gone wrong in internal C<=item> processing.  These
  messages indicate a bug in Pod::Text; you should never see them.
  
  =item Can't open %s for reading: %s
  
  (F) Pod::Text was invoked via the compatibility mode pod2text() interface
  and the input file it was given could not be opened.
  
  =item Invalid errors setting "%s"
  
  (F) The C<errors> parameter to the constructor was set to an unknown value.
  
  =item Invalid quote specification "%s"
  
  (F) The quote specification given (the C<quotes> option to the
  constructor) was invalid.  A quote specification must be either one
  character long or an even number (greater than one) characters long.
  
  =item POD document had syntax errors
  
  (F) The POD document being formatted had syntax errors and the C<errors>
  option was set to C<die>.
  
  =back
  
  =head1 BUGS
  
  Encoding handling assumes that PerlIO is available and does not work
  properly if it isn't.  The C<utf8> option is therefore not supported
  unless Perl is built with PerlIO support.
  
  =head1 CAVEATS
  
  If Pod::Text is given the C<utf8> option, the encoding of its output file
  handle will be forced to UTF-8 if possible, overriding any existing
  encoding.  This will be done even if the file handle is not created by
  Pod::Text and was passed in from outside.  This maintains consistency
  regardless of PERL_UNICODE and other settings.
  
  If the C<utf8> option is not given, the encoding of its output file handle
  will be forced to the detected encoding of the input POD, which preserves
  whatever the input text is.  This ensures backward compatibility with
  earlier, pre-Unicode versions of this module, without large numbers of
  Perl warnings.
  
  This is not ideal, but it seems to be the best compromise.  If it doesn't
  work for you, please let me know the details of how it broke.
  
  =head1 NOTES
  
  This is a replacement for an earlier Pod::Text module written by Tom
  Christiansen.  It has a revamped interface, since it now uses Pod::Simple,
  but an interface roughly compatible with the old Pod::Text::pod2text()
  function is still available.  Please change to the new calling convention,
  though.
  
  The original Pod::Text contained code to do formatting via termcap
  sequences, although it wasn't turned on by default and it was problematic to
  get it to work at all.  This rewrite doesn't even try to do that, but a
  subclass of it does.  Look for L<Pod::Text::Termcap>.
  
  =head1 SEE ALSO
  
  L<Pod::Simple>, L<Pod::Text::Termcap>, L<perlpod(1)>, L<pod2text(1)>
  
  The current version of this module is always available from its web site at
  L<http://www.eyrie.org/~eagle/software/podlators/>.  It is also part of the
  Perl core distribution as of 5.6.0.
  
  =head1 AUTHOR
  
  Russ Allbery <rra@cpan.org>, based I<very> heavily on the original
  Pod::Text by Tom Christiansen <tchrist@mox.perl.com> and its conversion to
  Pod::Parser by Brad Appleton <bradapp@enteract.com>.  Sean Burke's initial
  conversion of Pod::Man to use Pod::Simple provided much-needed guidance on
  how to use Pod::Simple.
  
  =head1 COPYRIGHT AND LICENSE
  
  Copyright 1999, 2000, 2001, 2002, 2004, 2006, 2008, 2009, 2012, 2013, 2014,
  2015, 2016 Russ Allbery <rra@cpan.org>
  
  This program is free software; you may redistribute it and/or modify it
  under the same terms as Perl itself.
  
  =cut
POD_TEXT

$fatpacked{"Pod/Text/Color.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POD_TEXT_COLOR';
  # Pod::Text::Color -- Convert POD data to formatted color ASCII text
  #
  # This is just a basic proof of concept.  It should later be modified to make
  # better use of color, take options changing what colors are used for what
  # text, and the like.
  #
  # Copyright 1999, 2001, 2004, 2006, 2008, 2009, 2014
  #     Russ Allbery <rra@cpan.org>
  #
  # This program is free software; you may redistribute it and/or modify it
  # under the same terms as Perl itself.
  
  ##############################################################################
  # Modules and declarations
  ##############################################################################
  
  package Pod::Text::Color;
  
  use 5.006;
  use strict;
  use warnings;
  
  use Pod::Text ();
  use Term::ANSIColor qw(colored);
  
  use vars qw(@ISA $VERSION);
  
  @ISA = qw(Pod::Text);
  
  $VERSION = '4.09';
  
  ##############################################################################
  # Overrides
  ##############################################################################
  
  # Make level one headings bold.
  sub cmd_head1 {
      my ($self, $attrs, $text) = @_;
      $text =~ s/\s+$//;
      $self->SUPER::cmd_head1 ($attrs, colored ($text, 'bold'));
  }
  
  # Make level two headings bold.
  sub cmd_head2 {
      my ($self, $attrs, $text) = @_;
      $text =~ s/\s+$//;
      $self->SUPER::cmd_head2 ($attrs, colored ($text, 'bold'));
  }
  
  # Fix the various formatting codes.
  sub cmd_b { return colored ($_[2], 'bold')   }
  sub cmd_f { return colored ($_[2], 'cyan')   }
  sub cmd_i { return colored ($_[2], 'yellow') }
  
  # Output any included code in green.
  sub output_code {
      my ($self, $code) = @_;
      $code = colored ($code, 'green');
      $self->output ($code);
  }
  
  # Strip all of the formatting from a provided string, returning the stripped
  # version.  We will eventually want to use colorstrip() from Term::ANSIColor,
  # but it's fairly new so avoid the tight dependency.
  sub strip_format {
      my ($self, $text) = @_;
      $text =~ s/\e\[[\d;]*m//g;
      return $text;
  }
  
  # We unfortunately have to override the wrapping code here, since the normal
  # wrapping code gets really confused by all the escape sequences.
  sub wrap {
      my $self = shift;
      local $_ = shift;
      my $output = '';
      my $spaces = ' ' x $$self{MARGIN};
      my $width = $$self{opt_width} - $$self{MARGIN};
  
      # We have to do $shortchar and $longchar in variables because the
      # construct ${char}{0,$width} didn't do the right thing until Perl 5.8.x.
      my $char = '(?:(?:\e\[[\d;]+m)*[^\n])';
      my $shortchar = $char . "{0,$width}";
      my $longchar = $char . "{$width}";
      while (length > $width) {
          if (s/^($shortchar)\s+// || s/^($longchar)//) {
              $output .= $spaces . $1 . "\n";
          } else {
              last;
          }
      }
      $output .= $spaces . $_;
      $output =~ s/\s+$/\n\n/;
      $output;
  }
  
  ##############################################################################
  # Module return value and documentation
  ##############################################################################
  
  1;
  __END__
  
  =head1 NAME
  
  Pod::Text::Color - Convert POD data to formatted color ASCII text
  
  =for stopwords
  Allbery
  
  =head1 SYNOPSIS
  
      use Pod::Text::Color;
      my $parser = Pod::Text::Color->new (sentence => 0, width => 78);
  
      # Read POD from STDIN and write to STDOUT.
      $parser->parse_from_filehandle;
  
      # Read POD from file.pod and write to file.txt.
      $parser->parse_from_file ('file.pod', 'file.txt');
  
  =head1 DESCRIPTION
  
  Pod::Text::Color is a simple subclass of Pod::Text that highlights output
  text using ANSI color escape sequences.  Apart from the color, it in all
  ways functions like Pod::Text.  See L<Pod::Text> for details and available
  options.
  
  Term::ANSIColor is used to get colors and therefore must be installed to use
  this module.
  
  =head1 BUGS
  
  This is just a basic proof of concept.  It should be seriously expanded to
  support configurable coloration via options passed to the constructor, and
  B<pod2text> should be taught about those.
  
  =head1 SEE ALSO
  
  L<Pod::Text>, L<Pod::Simple>
  
  The current version of this module is always available from its web site at
  L<http://www.eyrie.org/~eagle/software/podlators/>.  It is also part of the
  Perl core distribution as of 5.6.0.
  
  =head1 AUTHOR
  
  Russ Allbery <rra@cpan.org>.
  
  =head1 COPYRIGHT AND LICENSE
  
  Copyright 1999, 2001, 2004, 2006, 2008, 2009 Russ Allbery <rra@cpan.org>.
  
  This program is free software; you may redistribute it and/or modify it
  under the same terms as Perl itself.
  
  =cut
POD_TEXT_COLOR

$fatpacked{"Pod/Text/Overstrike.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POD_TEXT_OVERSTRIKE';
  # Pod::Text::Overstrike -- Convert POD data to formatted overstrike text
  #
  # This was written because the output from:
  #
  #     pod2text Text.pm > plain.txt; less plain.txt
  #
  # is not as rich as the output from
  #
  #     pod2man Text.pm | nroff -man > fancy.txt; less fancy.txt
  #
  # and because both Pod::Text::Color and Pod::Text::Termcap are not device
  # independent.
  #
  # Created by Joe Smith <Joe.Smith@inwap.com> 30-Nov-2000
  #   (based on Pod::Text::Color by Russ Allbery <rra@cpan.org>)
  # Copyright 2000 Joe Smith <Joe.Smith@inwap.com>.
  # Copyright 2001, 2004, 2008, 2014 Russ Allbery <rra@cpan.org>.
  #
  # This program is free software; you may redistribute it and/or modify it
  # under the same terms as Perl itself.
  
  ##############################################################################
  # Modules and declarations
  ##############################################################################
  
  package Pod::Text::Overstrike;
  
  use 5.006;
  use strict;
  use warnings;
  
  use vars qw(@ISA $VERSION);
  
  use Pod::Text ();
  
  @ISA = qw(Pod::Text);
  
  $VERSION = '4.09';
  
  ##############################################################################
  # Overrides
  ##############################################################################
  
  # Make level one headings bold, overridding any existing formatting.
  sub cmd_head1 {
      my ($self, $attrs, $text) = @_;
      $text =~ s/\s+$//;
      $text = $self->strip_format ($text);
      $text =~ s/(.)/$1\b$1/g;
      return $self->SUPER::cmd_head1 ($attrs, $text);
  }
  
  # Make level two headings bold, overriding any existing formatting.
  sub cmd_head2 {
      my ($self, $attrs, $text) = @_;
      $text =~ s/\s+$//;
      $text = $self->strip_format ($text);
      $text =~ s/(.)/$1\b$1/g;
      return $self->SUPER::cmd_head2 ($attrs, $text);
  }
  
  # Make level three headings underscored, overriding any existing formatting.
  sub cmd_head3 {
      my ($self, $attrs, $text) = @_;
      $text =~ s/\s+$//;
      $text = $self->strip_format ($text);
      $text =~ s/(.)/_\b$1/g;
      return $self->SUPER::cmd_head3 ($attrs, $text);
  }
  
  # Level four headings look like level three headings.
  sub cmd_head4 {
      my ($self, $attrs, $text) = @_;
      $text =~ s/\s+$//;
      $text = $self->strip_format ($text);
      $text =~ s/(.)/_\b$1/g;
      return $self->SUPER::cmd_head4 ($attrs, $text);
  }
  
  # The common code for handling all headers.  We have to override to avoid
  # interpolating twice and because we don't want to honor alt.
  sub heading {
      my ($self, $text, $indent, $marker) = @_;
      $self->item ("\n\n") if defined $$self{ITEM};
      $text .= "\n" if $$self{opt_loose};
      my $margin = ' ' x ($$self{opt_margin} + $indent);
      $self->output ($margin . $text . "\n");
      return '';
  }
  
  # Fix the various formatting codes.
  sub cmd_b { local $_ = $_[0]->strip_format ($_[2]); s/(.)/$1\b$1/g; $_ }
  sub cmd_f { local $_ = $_[0]->strip_format ($_[2]); s/(.)/_\b$1/g; $_ }
  sub cmd_i { local $_ = $_[0]->strip_format ($_[2]); s/(.)/_\b$1/g; $_ }
  
  # Output any included code in bold.
  sub output_code {
      my ($self, $code) = @_;
      $code =~ s/(.)/$1\b$1/g;
      $self->output ($code);
  }
  
  # Strip all of the formatting from a provided string, returning the stripped
  # version.
  sub strip_format {
      my ($self, $text) = @_;
      $text =~ s/(.)[\b]\1/$1/g;
      $text =~ s/_[\b]//g;
      return $text;
  }
  
  # We unfortunately have to override the wrapping code here, since the normal
  # wrapping code gets really confused by all the backspaces.
  sub wrap {
      my $self = shift;
      local $_ = shift;
      my $output = '';
      my $spaces = ' ' x $$self{MARGIN};
      my $width = $$self{opt_width} - $$self{MARGIN};
      while (length > $width) {
          # This regex represents a single character, that's possibly underlined
          # or in bold (in which case, it's three characters; the character, a
          # backspace, and a character).  Use [^\n] rather than . to protect
          # against odd settings of $*.
          my $char = '(?:[^\n][\b])?[^\n]';
          if (s/^((?>$char){0,$width})(?:\Z|\s+)//) {
              $output .= $spaces . $1 . "\n";
          } else {
              last;
          }
      }
      $output .= $spaces . $_;
      $output =~ s/\s+$/\n\n/;
      return $output;
  }
  
  ##############################################################################
  # Module return value and documentation
  ##############################################################################
  
  1;
  __END__
  
  =head1 NAME
  
  =for stopwords
  overstrike
  
  Pod::Text::Overstrike - Convert POD data to formatted overstrike text
  
  =for stopwords
  overstruck Overstruck Allbery terminal's
  
  =head1 SYNOPSIS
  
      use Pod::Text::Overstrike;
      my $parser = Pod::Text::Overstrike->new (sentence => 0, width => 78);
  
      # Read POD from STDIN and write to STDOUT.
      $parser->parse_from_filehandle;
  
      # Read POD from file.pod and write to file.txt.
      $parser->parse_from_file ('file.pod', 'file.txt');
  
  =head1 DESCRIPTION
  
  Pod::Text::Overstrike is a simple subclass of Pod::Text that highlights
  output text using overstrike sequences, in a manner similar to nroff.
  Characters in bold text are overstruck (character, backspace, character)
  and characters in underlined text are converted to overstruck underscores
  (underscore, backspace, character).  This format was originally designed
  for hard-copy terminals and/or line printers, yet is readable on soft-copy
  (CRT) terminals.
  
  Overstruck text is best viewed by page-at-a-time programs that take
  advantage of the terminal's B<stand-out> and I<underline> capabilities, such
  as the less program on Unix.
  
  Apart from the overstrike, it in all ways functions like Pod::Text.  See
  L<Pod::Text> for details and available options.
  
  =head1 BUGS
  
  Currently, the outermost formatting instruction wins, so for example
  underlined text inside a region of bold text is displayed as simply bold.
  There may be some better approach possible.
  
  =head1 SEE ALSO
  
  L<Pod::Text>, L<Pod::Simple>
  
  The current version of this module is always available from its web site at
  L<http://www.eyrie.org/~eagle/software/podlators/>.  It is also part of the
  Perl core distribution as of 5.6.0.
  
  =head1 AUTHOR
  
  Joe Smith <Joe.Smith@inwap.com>, using the framework created by Russ Allbery
  <rra@cpan.org>.
  
  =head1 COPYRIGHT AND LICENSE
  
  Copyright 2000 by Joe Smith <Joe.Smith@inwap.com>.
  Copyright 2001, 2004, 2008 by Russ Allbery <rra@cpan.org>.
  
  This program is free software; you may redistribute it and/or modify it
  under the same terms as Perl itself.
  
  =cut
POD_TEXT_OVERSTRIKE

$fatpacked{"Pod/Text/Termcap.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POD_TEXT_TERMCAP';
  # Pod::Text::Termcap -- Convert POD data to ASCII text with format escapes.
  #
  # This is a simple subclass of Pod::Text that overrides a few key methods to
  # output the right termcap escape sequences for formatted text on the current
  # terminal type.
  #
  # Copyright 1999, 2001, 2002, 2004, 2006, 2008, 2009, 2014, 2015
  #     Russ Allbery <rra@cpan.org>
  #
  # This program is free software; you may redistribute it and/or modify it
  # under the same terms as Perl itself.
  
  ##############################################################################
  # Modules and declarations
  ##############################################################################
  
  package Pod::Text::Termcap;
  
  use 5.006;
  use strict;
  use warnings;
  
  use Pod::Text ();
  use POSIX ();
  use Term::Cap;
  
  use vars qw(@ISA $VERSION);
  
  @ISA = qw(Pod::Text);
  
  $VERSION = '4.09';
  
  ##############################################################################
  # Overrides
  ##############################################################################
  
  # In the initialization method, grab our terminal characteristics as well as
  # do all the stuff we normally do.
  sub new {
      my ($self, @args) = @_;
      my ($ospeed, $term, $termios);
      $self = $self->SUPER::new (@args);
  
      # $ENV{HOME} is usually not set on Windows.  The default Term::Cap path
      # may not work on Solaris.
      unless (exists $ENV{TERMPATH}) {
          my $home = exists $ENV{HOME} ? "$ENV{HOME}/.termcap:" : '';
          $ENV{TERMPATH} =
            "${home}/etc/termcap:/usr/share/misc/termcap:/usr/share/lib/termcap";
      }
  
      # Fall back on a hard-coded terminal speed if POSIX::Termios isn't
      # available (such as on VMS).
      eval { $termios = POSIX::Termios->new };
      if ($@) {
          $ospeed = 9600;
      } else {
          $termios->getattr;
          $ospeed = $termios->getospeed || 9600;
      }
  
      # Fall back on the ANSI escape sequences if Term::Cap doesn't work.
      eval { $term = Tgetent Term::Cap { TERM => undef, OSPEED => $ospeed } };
      $$self{BOLD} = $$term{_md} || "\e[1m";
      $$self{UNDL} = $$term{_us} || "\e[4m";
      $$self{NORM} = $$term{_me} || "\e[m";
  
      unless (defined $$self{width}) {
          $$self{opt_width} = $ENV{COLUMNS} || $$term{_co} || 80;
          $$self{opt_width} -= 2;
      }
  
      return $self;
  }
  
  # Make level one headings bold.
  sub cmd_head1 {
      my ($self, $attrs, $text) = @_;
      $text =~ s/\s+$//;
      $self->SUPER::cmd_head1 ($attrs, "$$self{BOLD}$text$$self{NORM}");
  }
  
  # Make level two headings bold.
  sub cmd_head2 {
      my ($self, $attrs, $text) = @_;
      $text =~ s/\s+$//;
      $self->SUPER::cmd_head2 ($attrs, "$$self{BOLD}$text$$self{NORM}");
  }
  
  # Fix up B<> and I<>.  Note that we intentionally don't do F<>.
  sub cmd_b { my $self = shift; return "$$self{BOLD}$_[1]$$self{NORM}" }
  sub cmd_i { my $self = shift; return "$$self{UNDL}$_[1]$$self{NORM}" }
  
  # Output any included code in bold.
  sub output_code {
      my ($self, $code) = @_;
      $self->output ($$self{BOLD} . $code . $$self{NORM});
  }
  
  # Strip all of the formatting from a provided string, returning the stripped
  # version.
  sub strip_format {
      my ($self, $text) = @_;
      $text =~ s/\Q$$self{BOLD}//g;
      $text =~ s/\Q$$self{UNDL}//g;
      $text =~ s/\Q$$self{NORM}//g;
      return $text;
  }
  
  # Override the wrapping code to ignore the special sequences.
  sub wrap {
      my $self = shift;
      local $_ = shift;
      my $output = '';
      my $spaces = ' ' x $$self{MARGIN};
      my $width = $$self{opt_width} - $$self{MARGIN};
  
      # $codes matches a single special sequence.  $char matches any number of
      # special sequences preceding a single character other than a newline.
      # We have to do $shortchar and $longchar in variables because the
      # construct ${char}{0,$width} didn't do the right thing until Perl 5.8.x.
      my $codes = "(?:\Q$$self{BOLD}\E|\Q$$self{UNDL}\E|\Q$$self{NORM}\E)";
      my $char = "(?:$codes*[^\\n])";
      my $shortchar = $char . "{0,$width}";
      my $longchar = $char . "{$width}";
      while (length > $width) {
          if (s/^($shortchar)\s+// || s/^($longchar)//) {
              $output .= $spaces . $1 . "\n";
          } else {
              last;
          }
      }
      $output .= $spaces . $_;
      $output =~ s/\s+$/\n\n/;
      return $output;
  }
  
  ##############################################################################
  # Module return value and documentation
  ##############################################################################
  
  1;
  __END__
  
  =head1 NAME
  
  Pod::Text::Termcap - Convert POD data to ASCII text with format escapes
  
  =for stopwords
  ECMA-48 VT100 Allbery Solaris TERMPATH
  
  =head1 SYNOPSIS
  
      use Pod::Text::Termcap;
      my $parser = Pod::Text::Termcap->new (sentence => 0, width => 78);
  
      # Read POD from STDIN and write to STDOUT.
      $parser->parse_from_filehandle;
  
      # Read POD from file.pod and write to file.txt.
      $parser->parse_from_file ('file.pod', 'file.txt');
  
  =head1 DESCRIPTION
  
  Pod::Text::Termcap is a simple subclass of Pod::Text that highlights output
  text using the correct termcap escape sequences for the current terminal.
  Apart from the format codes, it in all ways functions like Pod::Text.  See
  L<Pod::Text> for details and available options.
  
  =head1 ENVIRONMENT
  
  This module sets the TERMPATH environment variable globally to:
  
      $HOME/.termcap:/etc/termcap:/usr/share/misc/termcap:/usr/share/lib/termcap
  
  if it isn't already set.  (The first entry is omitted if the HOME
  environment variable isn't set.)  This is a (very old) workaround for
  problems finding termcap information on older versions of Solaris, and is
  not good module behavior.  Please do not rely on this behavior; it may be
  dropped in a future release.
  
  =head1 NOTES
  
  This module uses Term::Cap to retrieve the formatting escape sequences for
  the current terminal, and falls back on the ECMA-48 (the same in this
  regard as ANSI X3.64 and ISO 6429, the escape codes also used by DEC VT100
  terminals) if the bold, underline, and reset codes aren't set in the
  termcap information.
  
  =head1 SEE ALSO
  
  L<Pod::Text>, L<Pod::Simple>, L<Term::Cap>
  
  The current version of this module is always available from its web site at
  L<http://www.eyrie.org/~eagle/software/podlators/>.  It is also part of the
  Perl core distribution as of 5.6.0.
  
  =head1 AUTHOR
  
  Russ Allbery <rra@cpan.org>.
  
  =head1 COPYRIGHT AND LICENSE
  
  Copyright 1999, 2001, 2002, 2004, 2006, 2008, 2009, 2014, 2015 Russ Allbery
  <rra@cpan.org>
  
  This program is free software; you may redistribute it and/or modify it
  under the same terms as Perl itself.
  
  =cut
POD_TEXT_TERMCAP

$fatpacked{"Pod/Usage.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POD_USAGE';
  #############################################################################
  # Pod/Usage.pm -- print usage messages for the running script.
  #
  # Copyright (c) 1996-2000 by Bradford Appleton. All rights reserved.
  # Copyright (c) 2001-2016 by Marek Rouchal.
  # This file is part of "Pod-Usage". Pod-Usage is free software;
  # you can redistribute it and/or modify it under the same terms
  # as Perl itself.
  #############################################################################
  
  package Pod::Usage;
  use strict;
  
  use vars qw($VERSION @ISA @EXPORT);
  $VERSION = '1.69';  ## Current version of this package
  require  5.006;    ## requires this Perl version or later
  
  #use diagnostics;
  use Carp;
  use Config;
  use Exporter;
  use File::Spec;
  
  @EXPORT = qw(&pod2usage);
  BEGIN {
      $Pod::Usage::Formatter ||= 'Pod::Text';
      eval "require $Pod::Usage::Formatter";
      die $@ if $@;
      @ISA = ( $Pod::Usage::Formatter );
  }
  
  our $MAX_HEADING_LEVEL = 3;
  
  ##---------------------------------------------------------------------------
  
  ##---------------------------------
  ## Function definitions begin here
  ##---------------------------------
  
  sub pod2usage {
      local($_) = shift;
      my %opts;
      ## Collect arguments
      if (@_ > 0) {
          ## Too many arguments - assume that this is a hash and
          ## the user forgot to pass a reference to it.
          %opts = ($_, @_);
      }
      elsif (!defined $_) {
        $_ = '';
      }
      elsif (ref $_) {
          ## User passed a ref to a hash
          %opts = %{$_}  if (ref($_) eq 'HASH');
      }
      elsif (/^[-+]?\d+$/) {
          ## User passed in the exit value to use
          $opts{'-exitval'} =  $_;
      }
      else {
          ## User passed in a message to print before issuing usage.
          $_  and  $opts{'-message'} = $_;
      }
  
      ## Need this for backward compatibility since we formerly used
      ## options that were all uppercase words rather than ones that
      ## looked like Unix command-line options.
      ## to be uppercase keywords)
      %opts = map {
          my ($key, $val) = ($_, $opts{$_});
          $key =~ s/^(?=\w)/-/;
          $key =~ /^-msg/i   and  $key = '-message';
          $key =~ /^-exit/i  and  $key = '-exitval';
          lc($key) => $val;
      } (keys %opts);
  
      ## Now determine default -exitval and -verbose values to use
      if ((! defined $opts{'-exitval'}) && (! defined $opts{'-verbose'})) {
          $opts{'-exitval'} = 2;
          $opts{'-verbose'} = 0;
      }
      elsif (! defined $opts{'-exitval'}) {
          $opts{'-exitval'} = ($opts{'-verbose'} > 0) ? 1 : 2;
      }
      elsif (! defined $opts{'-verbose'}) {
          $opts{'-verbose'} = (lc($opts{'-exitval'}) eq 'noexit' ||
                               $opts{'-exitval'} < 2);
      }
  
      ## Default the output file
      $opts{'-output'} = (lc($opts{'-exitval'}) eq 'noexit' ||
                          $opts{'-exitval'} < 2) ? \*STDOUT : \*STDERR
              unless (defined $opts{'-output'});
      ## Default the input file
      $opts{'-input'} = $0  unless (defined $opts{'-input'});
  
      ## Look up input file in path if it doesn't exist.
      unless ((ref $opts{'-input'}) || (-e $opts{'-input'})) {
          my $basename = $opts{'-input'};
          my $pathsep = ($^O =~ /^(?:dos|os2|MSWin32)$/i) ? ';'
                              : (($^O eq 'MacOS' || $^O eq 'VMS') ? ',' :  ':');
          my $pathspec = $opts{'-pathlist'} || $ENV{PATH} || $ENV{PERL5LIB};
  
          my @paths = (ref $pathspec) ? @$pathspec : split($pathsep, $pathspec);
          for my $dirname (@paths) {
              $_ = File::Spec->catfile($dirname, $basename)  if length;
              last if (-e $_) && ($opts{'-input'} = $_);
          }
      }
  
      ## Now create a pod reader and constrain it to the desired sections.
      my $parser = new Pod::Usage(USAGE_OPTIONS => \%opts);
      if ($opts{'-verbose'} == 0) {
          $parser->select('(?:SYNOPSIS|USAGE)\s*');
      }
      elsif ($opts{'-verbose'} == 1) {
          my $opt_re = '(?i)' .
                       '(?:OPTIONS|ARGUMENTS)' .
                       '(?:\s*(?:AND|\/)\s*(?:OPTIONS|ARGUMENTS))?';
          $parser->select( '(?:SYNOPSIS|USAGE)\s*', $opt_re, "DESCRIPTION/$opt_re" );
      }
      elsif ($opts{'-verbose'} >= 2 && $opts{'-verbose'} != 99) {
          $parser->select('.*');
      }
      elsif ($opts{'-verbose'} == 99) {
          my $sections = $opts{'-sections'};
          $parser->select( (ref $sections) ? @$sections : $sections );
          $opts{'-verbose'} = 1;
      }
  
      ## Check for perldoc
      my $progpath = $opts{'-perldoc'} ? $opts{'-perldoc'} :
          File::Spec->catfile($Config{scriptdirexp} 
  	|| $Config{scriptdir}, 'perldoc');
  
      my $version = sprintf("%vd",$^V);
      if ($Config{versiononly} and $Config{startperl} =~ /\Q$version\E$/ ) {
        $progpath .= $version;
      }
      $opts{'-noperldoc'} = 1 unless -e $progpath;
  
      ## Now translate the pod document and then exit with the desired status
      if (      !$opts{'-noperldoc'}
           and  $opts{'-verbose'} >= 2
           and  !ref($opts{'-input'})
           and  $opts{'-output'} == \*STDOUT )
      {
         ## spit out the entire PODs. Might as well invoke perldoc
         print { $opts{'-output'} } ($opts{'-message'}, "\n") if($opts{'-message'});
         if(defined $opts{-input} && $opts{-input} =~ /^\s*(\S.*?)\s*$/) {
           # the perldocs back to 5.005 should all have -F
  	 # without -F there are warnings in -T scripts
  	 my $f = $1;
           my @perldoc_cmd = ($progpath);
  	 if ($opts{'-perldocopt'}) {
             $opts{'-perldocopt'} =~ s/^\s+|\s+$//g;
  	   push @perldoc_cmd, split(/\s+/, $opts{'-perldocopt'});
  	 }
  	 push @perldoc_cmd, ('-F', $f);
           unshift @perldoc_cmd, $opts{'-perlcmd'} if $opts{'-perlcmd'};
           system(@perldoc_cmd);
           if($?) {
             # RT16091: fall back to more if perldoc failed
             system(($Config{pager} || $ENV{PAGER} || '/bin/more'), $1);
           }
         } else {
           croak "Unspecified input file or insecure argument.\n";
         }
      }
      else {
         $parser->parse_from_file($opts{'-input'}, $opts{'-output'});
      }
  
      exit($opts{'-exitval'})  unless (lc($opts{'-exitval'}) eq 'noexit');
  }
  
  ##---------------------------------------------------------------------------
  
  ##-------------------------------
  ## Method definitions begin here
  ##-------------------------------
  
  sub new {
      my $this = shift;
      my $class = ref($this) || $this;
      my %params = @_;
      my $self = {%params};
      bless $self, $class;
      if ($self->can('initialize')) {
          $self->initialize();
      } else {
          # pass through options to Pod::Text
          my %opts;
         	for (qw(alt code indent loose margin quotes sentence stderr utf8 width)) {
              my $val = $params{USAGE_OPTIONS}{"-$_"};
              $opts{$_} = $val if defined $val;
          }
          $self = $self->SUPER::new(%opts);
          %$self = (%$self, %params);
      }
      return $self;
  }
  
  # This subroutine was copied in whole-cloth from Pod::Select 1.60 in order to
  # allow the ejection of Pod::Select from the core without breaking Pod::Usage.
  # -- rjbs, 2013-03-18
  sub _compile_section_spec {
      my ($section_spec) = @_;
      my (@regexs, $negated);
  
      ## Compile the spec into a list of regexs
      local $_ = $section_spec;
      s{\\\\}{\001}g;  ## handle escaped backward slashes
      s{\\/}{\002}g;   ## handle escaped forward slashes
  
      ## Parse the regexs for the heading titles
      @regexs = split(/\//, $_, $MAX_HEADING_LEVEL);
  
      ## Set default regex for ommitted levels
      for (my $i = 0; $i < $MAX_HEADING_LEVEL; ++$i) {
          $regexs[$i]  = '.*'  unless ((defined $regexs[$i])
                                       && (length $regexs[$i]));
      }
      ## Modify the regexs as needed and validate their syntax
      my $bad_regexs = 0;
      for (@regexs) {
          $_ .= '.+'  if ($_ eq '!');
          s{\001}{\\\\}g;       ## restore escaped backward slashes
          s{\002}{\\/}g;        ## restore escaped forward slashes
          $negated = s/^\!//;   ## check for negation
          eval "m{$_}";         ## check regex syntax
          if ($@) {
              ++$bad_regexs;
              carp qq{Bad regular expression /$_/ in "$section_spec": $@\n};
          }
          else {
              ## Add the forward and rear anchors (and put the negator back)
              $_ = '^' . $_  unless (/^\^/);
              $_ = $_ . '$'  unless (/\$$/);
              $_ = '!' . $_  if ($negated);
          }
      }
      return  (! $bad_regexs) ? [ @regexs ] : undef;
  }
  
  sub select {
      my ($self, @sections) = @_;
      if ($ISA[0]->can('select')) {
          $self->SUPER::select(@sections);
      } else {
          # we're using Pod::Simple - need to mimic the behavior of Pod::Select
          my $add = ($sections[0] eq '+') ? shift(@sections) : '';
          ## Reset the set of sections to use
          unless (@sections) {
            delete $self->{USAGE_SELECT} unless ($add);
            return;
          }
          $self->{USAGE_SELECT} = []
            unless ($add && $self->{USAGE_SELECT});
          my $sref = $self->{USAGE_SELECT};
          ## Compile each spec
          for my $spec (@sections) {
            my $cs = _compile_section_spec($spec);
            if ( defined $cs ) {
              ## Store them in our sections array
              push(@$sref, $cs);
            } else {
              carp qq{Ignoring section spec "$spec"!\n};
            }
          }
      }
  }
  
  # Override Pod::Text->seq_i to return just "arg", not "*arg*".
  sub seq_i { return $_[1] }
  # Override Pod::Text->cmd_i to return just "arg", not "*arg*".
  # newer version based on Pod::Simple
  sub cmd_i { return $_[2] }
  
  # This overrides the Pod::Text method to do something very akin to what
  # Pod::Select did as well as the work done below by preprocess_paragraph.
  # Note that the below is very, very specific to Pod::Text and Pod::Simple.
  sub _handle_element_end {
      my ($self, $element) = @_;
      if ($element eq 'head1') {
          $self->{USAGE_HEADINGS} = [ $$self{PENDING}[-1][1] ];
          if ($self->{USAGE_OPTIONS}->{-verbose} < 2) {
              $$self{PENDING}[-1][1] =~ s/^\s*SYNOPSIS\s*$/USAGE/;
          }
      } elsif ($element =~ /^head(\d+)$/ && $1) { # avoid 0
          my $idx = $1 - 1;
          $self->{USAGE_HEADINGS} = [] unless($self->{USAGE_HEADINGS});
          $self->{USAGE_HEADINGS}->[$idx] = $$self{PENDING}[-1][1];
          # we have to get rid of the lower headings
          splice(@{$self->{USAGE_HEADINGS}},$idx+1);
      }
      if ($element =~ /^head\d+$/) {
          $$self{USAGE_SKIPPING} = 1;
          if (!$$self{USAGE_SELECT} || !@{ $$self{USAGE_SELECT} }) {
              $$self{USAGE_SKIPPING} = 0;
          } else {
              my @headings = @{$$self{USAGE_HEADINGS}};
              for my $section_spec ( @{$$self{USAGE_SELECT}} ) {
                  my $match = 1;
                  for (my $i = 0; $i < $MAX_HEADING_LEVEL; ++$i) {
                      $headings[$i] = '' unless defined $headings[$i];
                      my $regex   = $section_spec->[$i];
                      my $negated = ($regex =~ s/^\!//);
                      $match  &= ($negated ? ($headings[$i] !~ /${regex}/)
                                           : ($headings[$i] =~ /${regex}/));
                      last unless ($match);
                  } # end heading levels
                  if ($match) {
                    $$self{USAGE_SKIPPING} = 0;
                    last;
                  }
              } # end sections
          }
  
          # Try to do some lowercasing instead of all-caps in headings, and use
          # a colon to end all headings.
          if($self->{USAGE_OPTIONS}->{-verbose} < 2) {
              local $_ = $$self{PENDING}[-1][1];
              s{([A-Z])([A-Z]+)}{((length($2) > 2) ? $1 : lc($1)) . lc($2)}ge;
              s/\s*$/:/  unless (/:\s*$/);
              $_ .= "\n";
              $$self{PENDING}[-1][1] = $_;
          }
      }
      if ($$self{USAGE_SKIPPING} && $element !~ m/^over-|^[BCFILSZ]$/) {
          pop @{ $$self{PENDING} };
      } else {
          $self->SUPER::_handle_element_end($element);
      }
  }
  
  # required for Pod::Simple API
  sub start_document {
      my $self = shift;
      $self->SUPER::start_document();
      my $msg = $self->{USAGE_OPTIONS}->{-message}  or  return 1;
      my $out_fh = $self->output_fh();
      print $out_fh "$msg\n";
  }
  
  # required for old Pod::Parser API
  sub begin_pod {
      my $self = shift;
      $self->SUPER::begin_pod();  ## Have to call superclass
      my $msg = $self->{USAGE_OPTIONS}->{-message}  or  return 1;
      my $out_fh = $self->output_handle();
      print $out_fh "$msg\n";
  }
  
  sub preprocess_paragraph {
      my $self = shift;
      local $_ = shift;
      my $line = shift;
      ## See if this is a heading and we aren't printing the entire manpage.
      if (($self->{USAGE_OPTIONS}->{-verbose} < 2) && /^=head/) {
          ## Change the title of the SYNOPSIS section to USAGE
          s/^=head1\s+SYNOPSIS\s*$/=head1 USAGE/;
          ## Try to do some lowercasing instead of all-caps in headings
          s{([A-Z])([A-Z]+)}{((length($2) > 2) ? $1 : lc($1)) . lc($2)}ge;
          ## Use a colon to end all headings
          s/\s*$/:/  unless (/:\s*$/);
          $_ .= "\n";
      }
      return  $self->SUPER::preprocess_paragraph($_);
  }
  
  1; # keep require happy
  
  __END__
  
  =head1 NAME
  
  Pod::Usage - print a usage message from embedded pod documentation
  
  =head1 SYNOPSIS
  
    use Pod::Usage
  
    my $message_text  = "This text precedes the usage message.";
    my $exit_status   = 2;          ## The exit status to use
    my $verbose_level = 0;          ## The verbose level to use
    my $filehandle    = \*STDERR;   ## The filehandle to write to
  
    pod2usage($message_text);
  
    pod2usage($exit_status);
  
    pod2usage( { -message => $message_text ,
                 -exitval => $exit_status  ,  
                 -verbose => $verbose_level,  
                 -output  => $filehandle } );
  
    pod2usage(   -msg     => $message_text ,
                 -exitval => $exit_status  ,  
                 -verbose => $verbose_level,  
                 -output  => $filehandle );
  
    pod2usage(   -verbose => 2,
                 -noperldoc => 1  );
  
    pod2usage(   -verbose => 2,
                 -perlcmd => $path_to_perl,
                 -perldoc => $path_to_perldoc,
                 -perldocopt => $perldoc_options );
  
  =head1 ARGUMENTS
  
  B<pod2usage> should be given either a single argument, or a list of
  arguments corresponding to an associative array (a "hash"). When a single
  argument is given, it should correspond to exactly one of the following:
  
  =over 4
  
  =item *
  
  A string containing the text of a message to print I<before> printing
  the usage message
  
  =item *
  
  A numeric value corresponding to the desired exit status
  
  =item *
  
  A reference to a hash
  
  =back
  
  If more than one argument is given then the entire argument list is
  assumed to be a hash.  If a hash is supplied (either as a reference or
  as a list) it should contain one or more elements with the following
  keys:
  
  =over 4
  
  =item C<-message> I<string>
  
  =item C<-msg> I<string>
  
  The text of a message to print immediately prior to printing the
  program's usage message. 
  
  =item C<-exitval> I<value>
  
  The desired exit status to pass to the B<exit()> function.
  This should be an integer, or else the string "NOEXIT" to
  indicate that control should simply be returned without
  terminating the invoking process.
  
  =item C<-verbose> I<value>
  
  The desired level of "verboseness" to use when printing the usage message.
  If the value is 0, then only the "SYNOPSIS" section of the pod documentation
  is printed. If the value is 1, then the "SYNOPSIS" section, along with any
  section entitled "OPTIONS", "ARGUMENTS", or "OPTIONS AND ARGUMENTS" is
  printed. If the corresponding value is 2 or more then the entire manpage is
  printed, using L<perldoc> if available; otherwise L<Pod::Text> is used for
  the formatting. For better readability, the all-capital headings are
  downcased, e.g. C<SYNOPSIS> =E<gt> C<Synopsis>.
  
  The special verbosity level 99 requires to also specify the -sections
  parameter; then these sections are extracted and printed.
  
  =item C<-sections> I<spec>
  
  There are two ways to specify the selection. Either a string (scalar) 
  representing a selection regexp for sections to be printed when -verbose
  is set to 99, e.g.
  
    "NAME|SYNOPSIS|DESCRIPTION|VERSION"
  
  With the above regexp all content following (and including) any of the
  given C<=head1> headings will be shown. It is possible to restrict the 
  output to particular subsections only, e.g.:
  
    "DESCRIPTION/Algorithm"
  
  This will output only the C<=head2 Algorithm> heading and content within
  the C<=head1 DESCRIPTION> section. The regexp binding is stronger than the
  section separator, such that e.g.:
  
    "DESCRIPTION|OPTIONS|ENVIORNMENT/Caveats"
  
  will print any C<=head2 Caveats> section (only) within any of the three
  C<=head1> sections.
  
  Alternatively, an array reference of section specifications can be used:
  
    pod2usage(-verbose => 99, -sections => [
      qw(DESCRIPTION DESCRIPTION/Introduction) ] );
  
  This will print only the content of C<=head1 DESCRIPTION> and the 
  C<=head2 Introduction> sections, but no other C<=head2>, and no other
  C<=head1> either.
  
  =item C<-output> I<handle>
  
  A reference to a filehandle, or the pathname of a file to which the
  usage message should be written. The default is C<\*STDERR> unless the
  exit value is less than 2 (in which case the default is C<\*STDOUT>).
  
  =item C<-input> I<handle>
  
  A reference to a filehandle, or the pathname of a file from which the
  invoking script's pod documentation should be read.  It defaults to the
  file indicated by C<$0> (C<$PROGRAM_NAME> for users of F<English.pm>).
  
  If you are calling B<pod2usage()> from a module and want to display
  that module's POD, you can use this:
  
    use Pod::Find qw(pod_where);
    pod2usage( -input => pod_where({-inc => 1}, __PACKAGE__) );
  
  =item C<-pathlist> I<string>
  
  A list of directory paths. If the input file does not exist, then it
  will be searched for in the given directory list (in the order the
  directories appear in the list). It defaults to the list of directories
  implied by C<$ENV{PATH}>. The list may be specified either by a reference
  to an array, or by a string of directory paths which use the same path
  separator as C<$ENV{PATH}> on your system (e.g., C<:> for Unix, C<;> for
  MSWin32 and DOS).
  
  =item C<-noperldoc>
  
  By default, Pod::Usage will call L<perldoc> when -verbose >= 2 is
  specified. This does not work well e.g. if the script was packed
  with L<PAR>. The -noperldoc option suppresses the external call to
  L<perldoc> and uses the simple text formatter (L<Pod::Text>) to 
  output the POD.
  
  =item C<-perlcmd>
  
  By default, Pod::Usage will call L<perldoc> when -verbose >= 2 is
  specified. In case of special or unusual Perl installations,
  the -perlcmd option may be used to supply the path to a L<perl> executable
  which should run L<perldoc>.
  
  =item C<-perldoc> I<path-to-perldoc>
  
  By default, Pod::Usage will call L<perldoc> when -verbose >= 2 is
  specified. In case L<perldoc> is not installed where the L<perl> interpreter
  thinks it is (see L<Config>), the -perldoc option may be used to supply
  the correct path to L<perldoc>.
  
  =item C<-perldocopt> I<string>
  
  By default, Pod::Usage will call L<perldoc> when -verbose >= 2 is specified.
  The -perldocopt option may be used to supply options to L<perldoc>. The
  string may contain several, space-separated options.
  
  =back
  
  =head2 Formatting base class
  
  The default text formatter is L<Pod::Text>. The base class for Pod::Usage can
  be defined by pre-setting C<$Pod::Usage::Formatter> I<before>
  loading Pod::Usage, e.g.:
  
      BEGIN { $Pod::Usage::Formatter = 'Pod::Text::Termcap'; }
      use Pod::Usage qw(pod2usage);
  
  Pod::Usage uses L<Pod::Simple>'s _handle_element_end() method to implement
  the section selection, and in case of verbosity < 2 it down-cases the
  all-caps headings to first capital letter and rest lowercase, and adds
  a colon/newline at the end of the headings, for better readability. Same for
  verbosity = 99.
  
  =head2 Pass-through options
  
  The following options are passed through to the underlying text formatter.
  See the manual pages of these modules for more information.
  
    alt code indent loose margin quotes sentence stderr utf8 width
  
  =head1 DESCRIPTION
  
  B<pod2usage> will print a usage message for the invoking script (using
  its embedded pod documentation) and then exit the script with the
  desired exit status. The usage message printed may have any one of three
  levels of "verboseness": If the verbose level is 0, then only a synopsis
  is printed. If the verbose level is 1, then the synopsis is printed
  along with a description (if present) of the command line options and
  arguments. If the verbose level is 2, then the entire manual page is
  printed.
  
  Unless they are explicitly specified, the default values for the exit
  status, verbose level, and output stream to use are determined as
  follows:
  
  =over 4
  
  =item *
  
  If neither the exit status nor the verbose level is specified, then the
  default is to use an exit status of 2 with a verbose level of 0.
  
  =item *
  
  If an exit status I<is> specified but the verbose level is I<not>, then the
  verbose level will default to 1 if the exit status is less than 2 and
  will default to 0 otherwise.
  
  =item *
  
  If an exit status is I<not> specified but verbose level I<is> given, then
  the exit status will default to 2 if the verbose level is 0 and will
  default to 1 otherwise.
  
  =item *
  
  If the exit status used is less than 2, then output is printed on
  C<STDOUT>.  Otherwise output is printed on C<STDERR>.
  
  =back
  
  Although the above may seem a bit confusing at first, it generally does
  "the right thing" in most situations.  This determination of the default
  values to use is based upon the following typical Unix conventions:
  
  =over 4
  
  =item *
  
  An exit status of 0 implies "success". For example, B<diff(1)> exits
  with a status of 0 if the two files have the same contents.
  
  =item *
  
  An exit status of 1 implies possibly abnormal, but non-defective, program
  termination.  For example, B<grep(1)> exits with a status of 1 if
  it did I<not> find a matching line for the given regular expression.
  
  =item *
  
  An exit status of 2 or more implies a fatal error. For example, B<ls(1)>
  exits with a status of 2 if you specify an illegal (unknown) option on
  the command line.
  
  =item *
  
  Usage messages issued as a result of bad command-line syntax should go
  to C<STDERR>.  However, usage messages issued due to an explicit request
  to print usage (like specifying B<-help> on the command line) should go
  to C<STDOUT>, just in case the user wants to pipe the output to a pager
  (such as B<more(1)>).
  
  =item *
  
  If program usage has been explicitly requested by the user, it is often
  desirable to exit with a status of 1 (as opposed to 0) after issuing
  the user-requested usage message.  It is also desirable to give a
  more verbose description of program usage in this case.
  
  =back
  
  B<pod2usage> doesn't force the above conventions upon you, but it will
  use them by default if you don't expressly tell it to do otherwise.  The
  ability of B<pod2usage()> to accept a single number or a string makes it
  convenient to use as an innocent looking error message handling function:
  
      use strict;
      use Pod::Usage;
      use Getopt::Long;
  
      ## Parse options
      my %opt;
      GetOptions(\%opt, "help|?", "man", "flag1")  ||  pod2usage(2);
      pod2usage(1)  if ($opt{help});
      pod2usage(-exitval => 0, -verbose => 2)  if ($opt{man});
  
      ## Check for too many filenames
      pod2usage("$0: Too many files given.\n")  if (@ARGV > 1);
  
  Some user's however may feel that the above "economy of expression" is
  not particularly readable nor consistent and may instead choose to do
  something more like the following:
  
      use strict;
      use Pod::Usage qw(pod2usage);
      use Getopt::Long qw(GetOptions);
  
      ## Parse options
      my %opt;
      GetOptions(\%opt, "help|?", "man", "flag1")  ||
        pod2usage(-verbose => 0);
  
      pod2usage(-verbose => 1)  if ($opt{help});
      pod2usage(-verbose => 2)  if ($opt{man});
  
      ## Check for too many filenames
      pod2usage(-verbose => 2, -message => "$0: Too many files given.\n")
        if (@ARGV > 1);
  
  
  As with all things in Perl, I<there's more than one way to do it>, and
  B<pod2usage()> adheres to this philosophy.  If you are interested in
  seeing a number of different ways to invoke B<pod2usage> (although by no
  means exhaustive), please refer to L<"EXAMPLES">.
  
  =head2 Scripts
  
  The Pod::Usage distribution comes with a script pod2usage which offers
  a command line interface to the functionality of Pod::Usage. See
  L<pod2usage>.
  
  
  =head1 EXAMPLES
  
  Each of the following invocations of C<pod2usage()> will print just the
  "SYNOPSIS" section to C<STDERR> and will exit with a status of 2:
  
      pod2usage();
  
      pod2usage(2);
  
      pod2usage(-verbose => 0);
  
      pod2usage(-exitval => 2);
  
      pod2usage({-exitval => 2, -output => \*STDERR});
  
      pod2usage({-verbose => 0, -output  => \*STDERR});
  
      pod2usage(-exitval => 2, -verbose => 0);
  
      pod2usage(-exitval => 2, -verbose => 0, -output => \*STDERR);
  
  Each of the following invocations of C<pod2usage()> will print a message
  of "Syntax error." (followed by a newline) to C<STDERR>, immediately
  followed by just the "SYNOPSIS" section (also printed to C<STDERR>) and
  will exit with a status of 2:
  
      pod2usage("Syntax error.");
  
      pod2usage(-message => "Syntax error.", -verbose => 0);
  
      pod2usage(-msg  => "Syntax error.", -exitval => 2);
  
      pod2usage({-msg => "Syntax error.", -exitval => 2, -output => \*STDERR});
  
      pod2usage({-msg => "Syntax error.", -verbose => 0, -output => \*STDERR});
  
      pod2usage(-msg  => "Syntax error.", -exitval => 2, -verbose => 0);
  
      pod2usage(-message => "Syntax error.",
                -exitval => 2,
                -verbose => 0,
                -output  => \*STDERR);
  
  Each of the following invocations of C<pod2usage()> will print the
  "SYNOPSIS" section and any "OPTIONS" and/or "ARGUMENTS" sections to
  C<STDOUT> and will exit with a status of 1:
  
      pod2usage(1);
  
      pod2usage(-verbose => 1);
  
      pod2usage(-exitval => 1);
  
      pod2usage({-exitval => 1, -output => \*STDOUT});
  
      pod2usage({-verbose => 1, -output => \*STDOUT});
  
      pod2usage(-exitval => 1, -verbose => 1);
  
      pod2usage(-exitval => 1, -verbose => 1, -output => \*STDOUT});
  
  Each of the following invocations of C<pod2usage()> will print the
  entire manual page to C<STDOUT> and will exit with a status of 1:
  
      pod2usage(-verbose  => 2);
  
      pod2usage({-verbose => 2, -output => \*STDOUT});
  
      pod2usage(-exitval  => 1, -verbose => 2);
  
      pod2usage({-exitval => 1, -verbose => 2, -output => \*STDOUT});
  
  =head2 Recommended Use
  
  Most scripts should print some type of usage message to C<STDERR> when a
  command line syntax error is detected. They should also provide an
  option (usually C<-H> or C<-help>) to print a (possibly more verbose)
  usage message to C<STDOUT>. Some scripts may even wish to go so far as to
  provide a means of printing their complete documentation to C<STDOUT>
  (perhaps by allowing a C<-man> option). The following complete example
  uses B<Pod::Usage> in combination with B<Getopt::Long> to do all of these
  things:
  
      use strict;
      use Getopt::Long qw(GetOptions);
      use Pod::Usage qw(pod2usage);
  
      my $man = 0;
      my $help = 0;
      ## Parse options and print usage if there is a syntax error,
      ## or if usage was explicitly requested.
      GetOptions('help|?' => \$help, man => \$man) or pod2usage(2);
      pod2usage(1) if $help;
      pod2usage(-verbose => 2) if $man;
  
      ## If no arguments were given, then allow STDIN to be used only
      ## if it's not connected to a terminal (otherwise print usage)
      pod2usage("$0: No files given.")  if ((@ARGV == 0) && (-t STDIN));
  
      __END__
  
      =head1 NAME
  
      sample - Using GetOpt::Long and Pod::Usage
  
      =head1 SYNOPSIS
  
      sample [options] [file ...]
  
       Options:
         -help            brief help message
         -man             full documentation
  
      =head1 OPTIONS
  
      =over 4
  
      =item B<-help>
  
      Print a brief help message and exits.
  
      =item B<-man>
  
      Prints the manual page and exits.
  
      =back
  
      =head1 DESCRIPTION
  
      B<This program> will read the given input file(s) and do something
      useful with the contents thereof.
  
      =cut
  
  =head1 CAVEATS
  
  By default, B<pod2usage()> will use C<$0> as the path to the pod input
  file.  Unfortunately, not all systems on which Perl runs will set C<$0>
  properly (although if C<$0> isn't found, B<pod2usage()> will search
  C<$ENV{PATH}> or else the list specified by the C<-pathlist> option).
  If this is the case for your system, you may need to explicitly specify
  the path to the pod docs for the invoking script using something
  similar to the following:
  
      pod2usage(-exitval => 2, -input => "/path/to/your/pod/docs");
  
  In the pathological case that a script is called via a relative path
  I<and> the script itself changes the current working directory
  (see L<perlfunc/chdir>) I<before> calling pod2usage, Pod::Usage will
  fail even on robust platforms. Don't do that. Or use L<FindBin> to locate
  the script:
  
      use FindBin;
      pod2usage(-input => $FindBin::Bin . "/" . $FindBin::Script);
  
  =head1 AUTHOR
  
  Please report bugs using L<http://rt.cpan.org>.
  
  Marek Rouchal E<lt>marekr@cpan.orgE<gt>
  
  Brad Appleton E<lt>bradapp@enteract.comE<gt>
  
  Based on code for B<Pod::Text::pod2text()> written by
  Tom Christiansen E<lt>tchrist@mox.perl.comE<gt>
  
  =head1 ACKNOWLEDGMENTS
  
  rjbs for refactoring Pod::Usage to not use Pod::Parser any more.
  
  Steven McDougall E<lt>swmcd@world.std.comE<gt> for his help and patience
  with re-writing this manpage.
  
  =head1 SEE ALSO
  
  B<Pod::Usage> is now a standalone distribution, depending on
  L<Pod::Text> which in turn depends on L<Pod::Simple>.
  
  L<Pod::Perldoc>, L<Getopt::Long>, L<Pod::Find>, L<FindBin>,
  L<Pod::Text>, L<Pod::Text::Termcap>, L<Pod::Simple>
  
  =cut
  
POD_USAGE

$fatpacked{"Test/Mojo.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST_MOJO';
  package Test::Mojo;
  use Mojo::Base -base;
  
  # "Amy: He knows when you are sleeping.
  #  Professor: He knows when you're on the can.
  #  Leela: He'll hunt you down and blast your ass from here to Pakistan.
  #  Zoidberg: Oh.
  #  Hermes: You'd better not breathe, you'd better not move.
  #  Bender: You're better off dead, I'm telling you, dude.
  #  Fry: Santa Claus is gunning you down!"
  use Mojo::IOLoop;
  use Mojo::JSON 'j';
  use Mojo::JSON::Pointer;
  use Mojo::Server;
  use Mojo::UserAgent;
  use Mojo::Util qw(decode encode);
  use Test::More ();
  
  has [qw(message success tx)];
  has ua => sub { Mojo::UserAgent->new->ioloop(Mojo::IOLoop->singleton) };
  
  # Silent or loud tests
  $ENV{MOJO_LOG_LEVEL} ||= $ENV{HARNESS_IS_VERBOSE} ? 'debug' : 'fatal';
  
  sub app {
    my ($self, $app) = @_;
    return $self->ua->server->app unless $app;
    $self->ua->server->app($app);
    return $self;
  }
  
  sub content_is {
    my ($self, $value, $desc) = @_;
    return $self->_test('is', $self->tx->res->text,
      $value, _desc($desc, 'exact match for content'));
  }
  
  sub content_isnt {
    my ($self, $value, $desc) = @_;
    return $self->_test('isnt', $self->tx->res->text,
      $value, _desc($desc, 'no match for content'));
  }
  
  sub content_like {
    my ($self, $regex, $desc) = @_;
    return $self->_test('like', $self->tx->res->text,
      $regex, _desc($desc, 'content is similar'));
  }
  
  sub content_type_is {
    my ($self, $type, $desc) = @_;
    $desc = _desc($desc, "Content-Type: $type");
    return $self->_test('is', $self->tx->res->headers->content_type, $type,
      $desc);
  }
  
  sub content_type_isnt {
    my ($self, $type, $desc) = @_;
    $desc = _desc($desc, "not Content-Type: $type");
    return $self->_test('isnt', $self->tx->res->headers->content_type, $type,
      $desc);
  }
  
  sub content_type_like {
    my ($self, $regex, $desc) = @_;
    $desc = _desc($desc, 'Content-Type is similar');
    return $self->_test('like', $self->tx->res->headers->content_type, $regex,
      $desc);
  }
  
  sub content_type_unlike {
    my ($self, $regex, $desc) = @_;
    $desc = _desc($desc, 'Content-Type is not similar');
    return $self->_test('unlike', $self->tx->res->headers->content_type, $regex,
      $desc);
  }
  
  sub content_unlike {
    my ($self, $regex, $desc) = @_;
    return $self->_test('unlike', $self->tx->res->text,
      $regex, _desc($desc, 'content is not similar'));
  }
  
  sub delete_ok { shift->_build_ok(DELETE => @_) }
  
  sub element_count_is {
    my ($self, $selector, $count, $desc) = @_;
    my $size = $self->tx->res->dom->find($selector)->size;
    return $self->_test('is', $size, $count,
      _desc($desc, qq{element count for selector "$selector"}));
  }
  
  sub element_exists {
    my ($self, $selector, $desc) = @_;
    $desc = _desc($desc, qq{element for selector "$selector" exists});
    return $self->_test('ok', $self->tx->res->dom->at($selector), $desc);
  }
  
  sub element_exists_not {
    my ($self, $selector, $desc) = @_;
    $desc = _desc($desc, qq{no element for selector "$selector"});
    return $self->_test('ok', !$self->tx->res->dom->at($selector), $desc);
  }
  
  sub finish_ok {
    my $self = shift;
    $self->tx->finish(@_) if $self->tx->is_websocket;
    Mojo::IOLoop->one_tick while !$self->{finished};
    return $self->_test('ok', 1, 'closed WebSocket');
  }
  
  sub finished_ok {
    my ($self, $code) = @_;
    Mojo::IOLoop->one_tick while !$self->{finished};
    Test::More::diag "WebSocket closed with status $self->{finished}[0]"
      unless my $ok = $self->{finished}[0] == $code;
    return $self->_test('ok', $ok, "WebSocket closed with status $code");
  }
  
  sub get_ok  { shift->_build_ok(GET  => @_) }
  sub head_ok { shift->_build_ok(HEAD => @_) }
  
  sub header_is {
    my ($self, $name, $value, $desc) = @_;
    $desc = _desc($desc, "$name: " . ($value // ''));
    return $self->_test('is', $self->tx->res->headers->header($name), $value,
      $desc);
  }
  
  sub header_isnt {
    my ($self, $name, $value, $desc) = @_;
    $desc = _desc($desc, "not $name: " . ($value // ''));
    return $self->_test('isnt', $self->tx->res->headers->header($name), $value,
      $desc);
  }
  
  sub header_like {
    my ($self, $name, $regex, $desc) = @_;
    $desc = _desc($desc, "$name is similar");
    return $self->_test('like', $self->tx->res->headers->header($name), $regex,
      $desc);
  }
  
  sub header_unlike {
    my ($self, $name, $regex, $desc) = @_;
    $desc = _desc($desc, "$name is not similar");
    return $self->_test('unlike', $self->tx->res->headers->header($name),
      $regex, $desc);
  }
  
  sub json_has {
    my ($self, $p, $desc) = @_;
    $desc = _desc($desc, qq{has value for JSON Pointer "$p"});
    return $self->_test('ok',
      !!Mojo::JSON::Pointer->new($self->tx->res->json)->contains($p), $desc);
  }
  
  sub json_hasnt {
    my ($self, $p, $desc) = @_;
    $desc = _desc($desc, qq{has no value for JSON Pointer "$p"});
    return $self->_test('ok',
      !Mojo::JSON::Pointer->new($self->tx->res->json)->contains($p), $desc);
  }
  
  sub json_is {
    my $self = shift;
    my ($p, $data) = @_ > 1 ? (shift, shift) : ('', shift);
    my $desc = _desc(shift, qq{exact match for JSON Pointer "$p"});
    return $self->_test('is_deeply', $self->tx->res->json($p), $data, $desc);
  }
  
  sub json_like {
    my ($self, $p, $regex, $desc) = @_;
    return $self->_test('like', $self->tx->res->json($p),
      $regex, _desc($desc, qq{similar match for JSON Pointer "$p"}));
  }
  
  sub json_message_has {
    my ($self, $p, $desc) = @_;
    $desc = _desc($desc, qq{has value for JSON Pointer "$p"});
    return $self->_test('ok', $self->_json(contains => $p), $desc);
  }
  
  sub json_message_hasnt {
    my ($self, $p, $desc) = @_;
    $desc = _desc($desc, qq{has no value for JSON Pointer "$p"});
    return $self->_test('ok', !$self->_json(contains => $p), $desc);
  }
  
  sub json_message_is {
    my $self = shift;
    my ($p, $data) = @_ > 1 ? (shift, shift) : ('', shift);
    my $desc = _desc(shift, qq{exact match for JSON Pointer "$p"});
    return $self->_test('is_deeply', $self->_json(get => $p), $data, $desc);
  }
  
  sub json_message_like {
    my ($self, $p, $regex, $desc) = @_;
    return $self->_test('like', $self->_json(get => $p),
      $regex, _desc($desc, qq{similar match for JSON Pointer "$p"}));
  }
  
  sub json_message_unlike {
    my ($self, $p, $regex, $desc) = @_;
    return $self->_test('unlike', $self->_json(get => $p),
      $regex, _desc($desc, qq{no similar match for JSON Pointer "$p"}));
  }
  
  sub json_unlike {
    my ($self, $p, $regex, $desc) = @_;
    return $self->_test('unlike', $self->tx->res->json($p),
      $regex, _desc($desc, qq{no similar match for JSON Pointer "$p"}));
  }
  
  sub message_is {
    my ($self, $value, $desc) = @_;
    return $self->_message('is', $value, _desc($desc, 'exact match for message'));
  }
  
  sub message_isnt {
    my ($self, $value, $desc) = @_;
    return $self->_message('isnt', $value, _desc($desc, 'no match for message'));
  }
  
  sub message_like {
    my ($self, $regex, $desc) = @_;
    return $self->_message('like', $regex, _desc($desc, 'message is similar'));
  }
  
  sub message_ok {
    my ($self, $desc) = @_;
    return $self->_test('ok', !!$self->_wait, _desc($desc, 'message received'));
  }
  
  sub message_unlike {
    my ($self, $regex, $desc) = @_;
    return $self->_message('unlike', $regex,
      _desc($desc, 'message is not similar'));
  }
  
  sub new {
    my $self = shift->SUPER::new;
  
    return $self unless my $app = shift;
  
    my @args = @_ ? {config => {config_override => 1, %{shift()}}} : ();
    return $self->app(
      ref $app ? $app : Mojo::Server->new->build_app($app, @args));
  }
  
  sub options_ok { shift->_build_ok(OPTIONS => @_) }
  
  sub or {
    my ($self, $cb) = @_;
    $self->$cb unless $self->success;
    return $self;
  }
  
  sub patch_ok { shift->_build_ok(PATCH => @_) }
  sub post_ok  { shift->_build_ok(POST  => @_) }
  sub put_ok   { shift->_build_ok(PUT   => @_) }
  
  sub request_ok { shift->_request_ok($_[0], $_[0]->req->url->to_string) }
  
  sub reset_session {
    my $self = shift;
    $self->ua->cookie_jar->empty;
    return $self->tx(undef);
  }
  
  sub send_ok {
    my ($self, $msg, $desc) = @_;
  
    $desc = _desc($desc, 'send message');
    return $self->_test('ok', 0, $desc) unless $self->tx->is_websocket;
  
    $self->tx->send($msg => sub { Mojo::IOLoop->stop });
    Mojo::IOLoop->start;
    return $self->_test('ok', 1, $desc);
  }
  
  sub status_is {
    my ($self, $status, $desc) = @_;
    $desc = _desc($desc, "$status " . $self->tx->res->default_message($status));
    return $self->_test('is', $self->tx->res->code, $status, $desc);
  }
  
  sub status_isnt {
    my ($self, $status, $desc) = @_;
    return $self->_test('isnt', $self->tx->res->code,
      $status,
      _desc($desc, "not $status " . $self->tx->res->default_message($status)));
  }
  
  sub text_is {
    my ($self, $selector, $value, $desc) = @_;
    return $self->_test('is', $self->_text($selector),
      $value, _desc($desc, qq{exact match for selector "$selector"}));
  }
  
  sub text_isnt {
    my ($self, $selector, $value, $desc) = @_;
    return $self->_test('isnt', $self->_text($selector),
      $value, _desc($desc, qq{no match for selector "$selector"}));
  }
  
  sub text_like {
    my ($self, $selector, $regex, $desc) = @_;
    return $self->_test('like', $self->_text($selector),
      $regex, _desc($desc, qq{similar match for selector "$selector"}));
  }
  
  sub text_unlike {
    my ($self, $selector, $regex, $desc) = @_;
    return $self->_test('unlike', $self->_text($selector),
      $regex, _desc($desc, qq{no similar match for selector "$selector"}));
  }
  
  sub websocket_ok {
    my $self = shift;
    return $self->_request_ok($self->ua->build_websocket_tx(@_), $_[0]);
  }
  
  sub _build_ok {
    my ($self, $method, $url) = (shift, shift, shift);
    local $Test::Builder::Level = $Test::Builder::Level + 1;
    return $self->_request_ok($self->ua->build_tx($method, $url, @_), $url);
  }
  
  sub _desc { encode 'UTF-8', shift || shift }
  
  sub _json {
    my ($self, $method, $p) = @_;
    return Mojo::JSON::Pointer->new(j(@{$self->message // []}[1]))->$method($p);
  }
  
  sub _message {
    my ($self, $name, $value, $desc) = @_;
    local $Test::Builder::Level = $Test::Builder::Level + 1;
    my ($type, $msg) = @{$self->message // []};
  
    # Type check
    if (ref $value eq 'HASH') {
      my $expect = exists $value->{text} ? 'text' : 'binary';
      $value = $value->{$expect};
      $msg = '' unless ($type // '') eq $expect;
    }
  
    # Decode text frame if there is no type check
    else { $msg = decode 'UTF-8', $msg if ($type // '') eq 'text' }
  
    return $self->_test($name, $msg // '', $value, $desc);
  }
  
  sub _request_ok {
    my ($self, $tx, $url) = @_;
  
    local $Test::Builder::Level = $Test::Builder::Level + 1;
  
    # Establish WebSocket connection
    if ($tx->req->is_handshake) {
      @$self{qw(finished messages)} = (undef, []);
      $self->ua->start(
        $tx => sub {
          my ($ua, $tx) = @_;
          $self->{finished} = [] unless $self->tx($tx)->tx->is_websocket;
          $tx->on(finish => sub { shift; $self->{finished} = [@_] });
          $tx->on(binary => sub { push @{$self->{messages}}, [binary => pop] });
          $tx->on(text   => sub { push @{$self->{messages}}, [text   => pop] });
          Mojo::IOLoop->stop;
        }
      );
      Mojo::IOLoop->start;
  
      my $desc = _desc("WebSocket handshake with $url");
      return $self->_test('ok', $self->tx->is_websocket, $desc);
    }
  
    # Perform request
    $self->tx($self->ua->start($tx));
    my $err = $self->tx->error;
    Test::More::diag $err->{message}
      if !(my $ok = !$err->{message} || $err->{code}) && $err;
    return $self->_test('ok', $ok, _desc("@{[uc $tx->req->method]} $url"));
  }
  
  sub _test {
    my ($self, $name, @args) = @_;
    local $Test::Builder::Level = $Test::Builder::Level + 2;
    return $self->success(!!Test::More->can($name)->(@args));
  }
  
  sub _text {
    return '' unless my $e = shift->tx->res->dom->at(shift);
    return $e->text;
  }
  
  sub _wait {
    my $self = shift;
    Mojo::IOLoop->one_tick while !$self->{finished} && !@{$self->{messages}};
    return $self->message(shift @{$self->{messages}})->message;
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Test::Mojo - Testing Mojo
  
  =head1 SYNOPSIS
  
    use Test::More;
    use Test::Mojo;
  
    my $t = Test::Mojo->new('MyApp');
  
    # HTML/XML
    $t->get_ok('/welcome')->status_is(200)->text_is('div#message' => 'Hello!');
  
    # JSON
    $t->post_ok('/search.json' => form => {q => 'Perl'})
      ->status_is(200)
      ->header_is('Server' => 'Mojolicious (Perl)')
      ->header_isnt('X-Bender' => 'Bite my shiny metal ass!')
      ->json_is('/results/4/title' => 'Perl rocks!')
      ->json_like('/results/7/title' => qr/Perl/);
  
    # WebSocket
    $t->websocket_ok('/echo')
      ->send_ok('hello')
      ->message_ok
      ->message_is('echo: hello')
      ->finish_ok;
  
    done_testing();
  
  =head1 DESCRIPTION
  
  L<Test::Mojo> is a test user agent based on L<Mojo::UserAgent>, it is usually
  used together with L<Test::More> to test L<Mojolicious> applications. Just run
  your tests with the command L<Mojolicious::Command::test> or L<prove>.
  
    $ ./script/my_app test
    $ ./script/my_app test -v t/foo.t
    $ prove -l -v t/foo.t
  
  If it is not already defined, the C<MOJO_LOG_LEVEL> environment variable will
  be set to C<debug> or C<fatal>, depending on the value of the
  C<HARNESS_IS_VERBOSE> environment variable.
  
  =head1 ATTRIBUTES
  
  L<Test::Mojo> implements the following attributes.
  
  =head2 message
  
    my $msg = $t->message;
    $t      = $t->message([text => $bytes]);
  
  Current WebSocket message represented as an array reference containing the
  frame type and payload.
  
    # More specific tests
    use Mojo::JSON 'decode_json';
    my $hash = decode_json $t->message->[1];
    is ref $hash, 'HASH', 'right reference';
    is $hash->{foo}, 'bar', 'right value';
  
    # Test custom message
    $t->message([binary => $bytes])
      ->json_message_has('/foo/bar')
      ->json_message_hasnt('/bar')
      ->json_message_is('/foo/baz' => {yada => [1, 2, 3]});
  
  =head2 success
  
    my $bool = $t->success;
    $t       = $t->success($bool);
  
  True if the last test was successful.
  
    # Build custom tests
    my $location_is = sub {
      my ($t, $value, $desc) = @_;
      $desc ||= "Location: $value";
      local $Test::Builder::Level = $Test::Builder::Level + 1;
      return $t->success(is($t->tx->res->headers->location, $value, $desc));
    };
    $t->get_ok('/')
      ->status_is(302)
      ->$location_is('http://mojolicious.org')
      ->or(sub { diag 'Must have been Joel!' });
  
  =head2 tx
  
    my $tx = $t->tx;
    $t     = $t->tx(Mojo::Transaction::HTTP->new);
  
  Current transaction, usually a L<Mojo::Transaction::HTTP> or
  L<Mojo::Transaction::WebSocket> object.
  
    # More specific tests
    is $t->tx->res->json->{foo}, 'bar', 'right value';
    ok $t->tx->res->content->is_multipart, 'multipart content';
    is $t->tx->previous->res->code, 302, 'right status';
  
  =head2 ua
  
    my $ua = $t->ua;
    $t     = $t->ua(Mojo::UserAgent->new);
  
  User agent used for testing, defaults to a L<Mojo::UserAgent> object.
  
    # Allow redirects
    $t->ua->max_redirects(10);
    $t->get_ok('/redirect')->status_is(200)->content_like(qr/redirected/);
  
    # Switch protocol from HTTP to HTTPS
    $t->ua->server->url('https');
    $t->get_ok('/secure')->status_is(200)->content_like(qr/secure/);
  
    # Use absolute URL for request with Basic authentication
    my $url = $t->ua->server->url->userinfo('sri:secr3t')->path('/secrets.json');
    $t->post_ok($url => json => {limit => 10})
      ->status_is(200)
      ->json_is('/1/content', 'Mojo rocks!');
  
    # Customize all transactions (including followed redirects)
    $t->ua->on(start => sub {
      my ($ua, $tx) = @_;
      $tx->req->headers->accept_language('en-US');
    });
    $t->get_ok('/hello')->status_is(200)->content_like(qr/Howdy/);
  
  =head1 METHODS
  
  L<Test::Mojo> inherits all methods from L<Mojo::Base> and implements the
  following new ones.
  
  =head2 app
  
    my $app = $t->app;
    $t      = $t->app(Mojolicious->new);
  
  Access application with L<Mojo::UserAgent::Server/"app">.
  
    # Change log level
    $t->app->log->level('fatal');
  
    # Test application directly
    is $t->app->defaults->{foo}, 'bar', 'right value';
    ok $t->app->routes->find('echo')->is_websocket, 'WebSocket route';
    my $c = $t->app->build_controller;
    ok $c->render(template => 'foo'), 'rendering was successful';
    is $c->res->status, 200, 'right status';
    is $c->res->body, 'Foo!', 'right content';
  
    # Change application behavior
    $t->app->hook(before_dispatch => sub {
      my $c = shift;
      $c->render(text => 'This request did not reach the router.')
        if $c->req->url->path->contains('/user');
    });
    $t->get_ok('/user')->status_is(200)->content_like(qr/not reach the router/);
  
    # Extract additional information
    my $stash;
    $t->app->hook(after_dispatch => sub { $stash = shift->stash });
    $t->get_ok('/hello')->status_is(200);
    is $stash->{foo}, 'bar', 'right value';
  
  =head2 content_is
  
    $t = $t->content_is('working!');
    $t = $t->content_is('working!', 'right content');
  
  Check response content for exact match after retrieving it from
  L<Mojo::Message/"text">.
  
  =head2 content_isnt
  
    $t = $t->content_isnt('working!');
    $t = $t->content_isnt('working!', 'different content');
  
  Opposite of L</"content_is">.
  
  =head2 content_like
  
    $t = $t->content_like(qr/working!/);
    $t = $t->content_like(qr/working!/, 'right content');
  
  Check response content for similar match after retrieving it from
  L<Mojo::Message/"text">.
  
  =head2 content_type_is
  
    $t = $t->content_type_is('text/html');
    $t = $t->content_type_is('text/html', 'right content type');
  
  Check response C<Content-Type> header for exact match.
  
  =head2 content_type_isnt
  
    $t = $t->content_type_isnt('text/html');
    $t = $t->content_type_isnt('text/html', 'different content type');
  
  Opposite of L</"content_type_is">.
  
  =head2 content_type_like
  
    $t = $t->content_type_like(qr/text/);
    $t = $t->content_type_like(qr/text/, 'right content type');
  
  Check response C<Content-Type> header for similar match.
  
  =head2 content_type_unlike
  
    $t = $t->content_type_unlike(qr/text/);
    $t = $t->content_type_unlike(qr/text/, 'different content type');
  
  Opposite of L</"content_type_like">.
  
  =head2 content_unlike
  
    $t = $t->content_unlike(qr/working!/);
    $t = $t->content_unlike(qr/working!/, 'different content');
  
  Opposite of L</"content_like">.
  
  =head2 delete_ok
  
    $t = $t->delete_ok('http://example.com/foo');
    $t = $t->delete_ok('/foo');
    $t = $t->delete_ok('/foo' => {Accept => '*/*'} => 'Content!');
    $t = $t->delete_ok('/foo' => {Accept => '*/*'} => form => {a => 'b'});
    $t = $t->delete_ok('/foo' => {Accept => '*/*'} => json => {a => 'b'});
  
  Perform a C<DELETE> request and check for transport errors, takes the same
  arguments as L<Mojo::UserAgent/"delete">, except for the callback.
  
  =head2 element_count_is
  
    $t = $t->element_count_is('div.foo[x=y]', 5);
    $t = $t->element_count_is('html body div', 30, 'thirty elements');
  
  Checks the number of HTML/XML elements matched by the CSS selector with
  L<Mojo::DOM/"find">.
  
  =head2 element_exists
  
    $t = $t->element_exists('div.foo[x=y]');
    $t = $t->element_exists('html head title', 'has a title');
  
  Checks for existence of the CSS selectors first matching HTML/XML element with
  L<Mojo::DOM/"at">.
  
    # Check attribute values
    $t->get_ok('/login')
      ->element_exists('label[for=email]')
      ->element_exists('input[name=email][type=text][value*="example.com"]')
      ->element_exists('label[for=pass]')
      ->element_exists('input[name=pass][type=password]')
      ->element_exists('input[type=submit][value]');
  
  =head2 element_exists_not
  
    $t = $t->element_exists_not('div.foo[x=y]');
    $t = $t->element_exists_not('html head title', 'has no title');
  
  Opposite of L</"element_exists">.
  
  =head2 finish_ok
  
    $t = $t->finish_ok;
    $t = $t->finish_ok(1000);
    $t = $t->finish_ok(1003 => 'Cannot accept data!');
  
  Close WebSocket connection gracefully.
  
  =head2 finished_ok
  
    $t = $t->finished_ok(1000);
  
  Wait for WebSocket connection to be closed gracefully and check status.
  
  =head2 get_ok
  
    $t = $t->get_ok('http://example.com/foo');
    $t = $t->get_ok('/foo');
    $t = $t->get_ok('/foo' => {Accept => '*/*'} => 'Content!');
    $t = $t->get_ok('/foo' => {Accept => '*/*'} => form => {a => 'b'});
    $t = $t->get_ok('/foo' => {Accept => '*/*'} => json => {a => 'b'});
  
  Perform a C<GET> request and check for transport errors, takes the same
  arguments as L<Mojo::UserAgent/"get">, except for the callback.
  
    # Run tests against remote host
    $t->get_ok('http://mojolicious.org/perldoc')->status_is(200);
  
    # Use relative URL for request with Basic authentication
    $t->get_ok('//sri:secr3t@/secrets.json')
      ->status_is(200)
      ->json_is('/1/content', 'Mojo rocks!');
  
    # Run additional tests on the transaction
    $t->get_ok('/foo')->status_is(200);
    is $t->tx->res->dom->at('input')->val, 'whatever', 'right value';
  
  =head2 head_ok
  
    $t = $t->head_ok('http://example.com/foo');
    $t = $t->head_ok('/foo');
    $t = $t->head_ok('/foo' => {Accept => '*/*'} => 'Content!');
    $t = $t->head_ok('/foo' => {Accept => '*/*'} => form => {a => 'b'});
    $t = $t->head_ok('/foo' => {Accept => '*/*'} => json => {a => 'b'});
  
  Perform a C<HEAD> request and check for transport errors, takes the same
  arguments as L<Mojo::UserAgent/"head">, except for the callback.
  
  =head2 header_is
  
    $t = $t->header_is(ETag => '"abc321"');
    $t = $t->header_is(ETag => '"abc321"', 'right header');
  
  Check response header for exact match.
  
  =head2 header_isnt
  
    $t = $t->header_isnt(Etag => '"abc321"');
    $t = $t->header_isnt(ETag => '"abc321"', 'different header');
  
  Opposite of L</"header_is">.
  
  =head2 header_like
  
    $t = $t->header_like(ETag => qr/abc/);
    $t = $t->header_like(ETag => qr/abc/, 'right header');
  
  Check response header for similar match.
  
  =head2 header_unlike
  
    $t = $t->header_unlike(ETag => qr/abc/);
    $t = $t->header_unlike(ETag => qr/abc/, 'different header');
  
  Opposite of L</"header_like">.
  
  =head2 json_has
  
    $t = $t->json_has('/foo');
    $t = $t->json_has('/minibar', 'has a minibar');
  
  Check if JSON response contains a value that can be identified using the given
  JSON Pointer with L<Mojo::JSON::Pointer>.
  
  =head2 json_hasnt
  
    $t = $t->json_hasnt('/foo');
    $t = $t->json_hasnt('/minibar', 'no minibar');
  
  Opposite of L</"json_has">.
  
  =head2 json_is
  
    $t = $t->json_is({foo => [1, 2, 3]});
    $t = $t->json_is('/foo' => [1, 2, 3]);
    $t = $t->json_is('/foo/1' => 2, 'right value');
  
  Check the value extracted from JSON response using the given JSON Pointer with
  L<Mojo::JSON::Pointer>, which defaults to the root value if it is omitted.
  
  =head2 json_like
  
    $t = $t->json_like('/foo/1' => qr/^\d+$/);
    $t = $t->json_like('/foo/1' => qr/^\d+$/, 'right value');
  
  Check the value extracted from JSON response using the given JSON Pointer with
  L<Mojo::JSON::Pointer> for similar match.
  
  =head2 json_message_has
  
    $t = $t->json_message_has('/foo');
    $t = $t->json_message_has('/minibar', 'has a minibar');
  
  Check if JSON WebSocket message contains a value that can be identified using
  the given JSON Pointer with L<Mojo::JSON::Pointer>.
  
  =head2 json_message_hasnt
  
    $t = $t->json_message_hasnt('/foo');
    $t = $t->json_message_hasnt('/minibar', 'no minibar');
  
  Opposite of L</"json_message_has">.
  
  =head2 json_message_is
  
    $t = $t->json_message_is({foo => [1, 2, 3]});
    $t = $t->json_message_is('/foo' => [1, 2, 3]);
    $t = $t->json_message_is('/foo/1' => 2, 'right value');
  
  Check the value extracted from JSON WebSocket message using the given JSON
  Pointer with L<Mojo::JSON::Pointer>, which defaults to the root value if it is
  omitted.
  
  =head2 json_message_like
  
    $t = $t->json_message_like('/foo/1' => qr/^\d+$/);
    $t = $t->json_message_like('/foo/1' => qr/^\d+$/, 'right value');
  
  Check the value extracted from JSON WebSocket message using the given JSON
  Pointer with L<Mojo::JSON::Pointer> for similar match.
  
  =head2 json_message_unlike
  
    $t = $t->json_message_unlike('/foo/1' => qr/^\d+$/);
    $t = $t->json_message_unlike('/foo/1' => qr/^\d+$/, 'different value');
  
  Opposite of L</"json_message_like">.
  
  =head2 json_unlike
  
    $t = $t->json_unlike('/foo/1' => qr/^\d+$/);
    $t = $t->json_unlike('/foo/1' => qr/^\d+$/, 'different value');
  
  Opposite of L</"json_like">.
  
  =head2 message_is
  
    $t = $t->message_is({binary => $bytes});
    $t = $t->message_is({text   => $bytes});
    $t = $t->message_is('working!');
    $t = $t->message_is('working!', 'right message');
  
  Check WebSocket message for exact match.
  
  =head2 message_isnt
  
    $t = $t->message_isnt({binary => $bytes});
    $t = $t->message_isnt({text   => $bytes});
    $t = $t->message_isnt('working!');
    $t = $t->message_isnt('working!', 'different message');
  
  Opposite of L</"message_is">.
  
  =head2 message_like
  
    $t = $t->message_like({binary => qr/$bytes/});
    $t = $t->message_like({text   => qr/$bytes/});
    $t = $t->message_like(qr/working!/);
    $t = $t->message_like(qr/working!/, 'right message');
  
  Check WebSocket message for similar match.
  
  =head2 message_ok
  
    $t = $t->message_ok;
    $t = $t->message_ok('got a message');
  
  Wait for next WebSocket message to arrive.
  
    # Wait for message and perform multiple tests on it
    $t->websocket_ok('/time')
      ->message_ok
      ->message_like(qr/\d+/)
      ->message_unlike(qr/\w+/)
      ->finish_ok;
  
  =head2 message_unlike
  
    $t = $t->message_unlike({binary => qr/$bytes/});
    $t = $t->message_unlike({text   => qr/$bytes/});
    $t = $t->message_unlike(qr/working!/);
    $t = $t->message_unlike(qr/working!/, 'different message');
  
  Opposite of L</"message_like">.
  
  =head2 new
  
    my $t = Test::Mojo->new;
    my $t = Test::Mojo->new('MyApp');
    my $t = Test::Mojo->new(MyApp => {foo => 'bar', baz => 23});
    my $t = Test::Mojo->new(MyApp->new);
  
  Construct a new L<Test::Mojo> object. In addition to a class name, you can pass
  along a hash reference with configuration values that will be used to
  instantiate the application. The special configuration value C<config_override>
  will be set in L<Mojo/"config"> as well, which is used to disable configuration
  plugins like L<Mojolicious::Plugin::Config> and
  L<Mojolicious::Plugin::JSONConfig> for tests.
  
  =head2 options_ok
  
    $t = $t->options_ok('http://example.com/foo');
    $t = $t->options_ok('/foo');
    $t = $t->options_ok('/foo' => {Accept => '*/*'} => 'Content!');
    $t = $t->options_ok('/foo' => {Accept => '*/*'} => form => {a => 'b'});
    $t = $t->options_ok('/foo' => {Accept => '*/*'} => json => {a => 'b'});
  
  Perform a C<OPTIONS> request and check for transport errors, takes the same
  arguments as L<Mojo::UserAgent/"options">, except for the callback.
  
  =head2 or
  
    $t = $t->or(sub {...});
  
  Execute callback if the value of L</"success"> is false.
  
    # Diagnostics
    $t->get_ok('/bad')->or(sub { diag 'Must have been Glen!' })
      ->status_is(200)->or(sub { diag $t->tx->res->dom->at('title')->text });
  
  =head2 patch_ok
  
    $t = $t->patch_ok('http://example.com/foo');
    $t = $t->patch_ok('/foo');
    $t = $t->patch_ok('/foo' => {Accept => '*/*'} => 'Content!');
    $t = $t->patch_ok('/foo' => {Accept => '*/*'} => form => {a => 'b'});
    $t = $t->patch_ok('/foo' => {Accept => '*/*'} => json => {a => 'b'});
  
  Perform a C<PATCH> request and check for transport errors, takes the same
  arguments as L<Mojo::UserAgent/"patch">, except for the callback.
  
  =head2 post_ok
  
    $t = $t->post_ok('http://example.com/foo');
    $t = $t->post_ok('/foo');
    $t = $t->post_ok('/foo' => {Accept => '*/*'} => 'Content!');
    $t = $t->post_ok('/foo' => {Accept => '*/*'} => form => {a => 'b'});
    $t = $t->post_ok('/foo' => {Accept => '*/*'} => json => {a => 'b'});
  
  Perform a C<POST> request and check for transport errors, takes the same
  arguments as L<Mojo::UserAgent/"post">, except for the callback.
  
    # Test file upload
    my $upload = {foo => {content => 'bar', filename => 'baz.txt'}};
    $t->post_ok('/upload' => form => $upload)->status_is(200);
  
    # Test JSON API
    $t->post_ok('/hello.json' => json => {hello => 'world'})
      ->status_is(200)
      ->json_is({bye => 'world'});
  
  =head2 put_ok
  
    $t = $t->put_ok('http://example.com/foo');
    $t = $t->put_ok('/foo');
    $t = $t->put_ok('/foo' => {Accept => '*/*'} => 'Content!');
    $t = $t->put_ok('/foo' => {Accept => '*/*'} => form => {a => 'b'});
    $t = $t->put_ok('/foo' => {Accept => '*/*'} => json => {a => 'b'});
  
  Perform a C<PUT> request and check for transport errors, takes the same
  arguments as L<Mojo::UserAgent/"put">, except for the callback.
  
  =head2 request_ok
  
    $t = $t->request_ok(Mojo::Transaction::HTTP->new);
  
  Perform request and check for transport errors.
  
    # Request with custom method
    my $tx = $t->ua->build_tx(FOO => '/test.json' => json => {foo => 1});
    $t->request_ok($tx)->status_is(200)->json_is({success => 1});
  
    # Request with custom cookie
    my $tx = $t->ua->build_tx(GET => '/account');
    $tx->req->cookies({name => 'user', value => 'sri'});
    $t->request_ok($tx)->status_is(200)->text_is('head > title' => 'Hello sri');
  
    # Custom WebSocket handshake
    my $tx = $t->ua->build_websocket_tx('/foo');
    $tx->req->headers->remove('User-Agent');
    $t->request_ok($tx)->message_ok->message_is('bar')->finish_ok;
  
  =head2 reset_session
  
    $t = $t->reset_session;
  
  Reset user agent session.
  
  =head2 send_ok
  
    $t = $t->send_ok({binary => $bytes});
    $t = $t->send_ok({text   => $bytes});
    $t = $t->send_ok({json   => {test => [1, 2, 3]}});
    $t = $t->send_ok([$fin, $rsv1, $rsv2, $rsv3, $op, $payload]);
    $t = $t->send_ok($chars);
    $t = $t->send_ok($chars, 'sent successfully');
  
  Send message or frame via WebSocket.
  
    # Send JSON object as "Text" message
    $t->websocket_ok('/echo.json')
      ->send_ok({json => {test => 'I  Mojolicious!'}})
      ->message_ok
      ->json_message_is('/test' => 'I  Mojolicious!')
      ->finish_ok;
  
  =head2 status_is
  
    $t = $t->status_is(200);
    $t = $t->status_is(200, 'right status');
  
  Check response status for exact match.
  
  =head2 status_isnt
  
    $t = $t->status_isnt(200);
    $t = $t->status_isnt(200, 'different status');
  
  Opposite of L</"status_is">.
  
  =head2 text_is
  
    $t = $t->text_is('div.foo[x=y]' => 'Hello!');
    $t = $t->text_is('html head title' => 'Hello!', 'right title');
  
  Checks text content of the CSS selectors first matching HTML/XML element for
  exact match with L<Mojo::DOM/"at">.
  
  =head2 text_isnt
  
    $t = $t->text_isnt('div.foo[x=y]' => 'Hello!');
    $t = $t->text_isnt('html head title' => 'Hello!', 'different title');
  
  Opposite of L</"text_is">.
  
  =head2 text_like
  
    $t = $t->text_like('div.foo[x=y]' => qr/Hello/);
    $t = $t->text_like('html head title' => qr/Hello/, 'right title');
  
  Checks text content of the CSS selectors first matching HTML/XML element for
  similar match with L<Mojo::DOM/"at">.
  
  =head2 text_unlike
  
    $t = $t->text_unlike('div.foo[x=y]' => qr/Hello/);
    $t = $t->text_unlike('html head title' => qr/Hello/, 'different title');
  
  Opposite of L</"text_like">.
  
  =head2 websocket_ok
  
    $t = $t->websocket_ok('http://example.com/echo');
    $t = $t->websocket_ok('/echo');
    $t = $t->websocket_ok('/echo' => {DNT => 1} => ['v1.proto']);
  
  Open a WebSocket connection with transparent handshake, takes the same
  arguments as L<Mojo::UserAgent/"websocket">, except for the callback.
  
    # WebSocket with permessage-deflate compression
    $t->websocket_ok('/' => {'Sec-WebSocket-Extensions' => 'permessage-deflate'})
      ->send_ok('y' x 50000)
      ->message_ok
      ->message_is('z' x 50000)
      ->finish_ok;
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<http://mojolicious.org>.
  
  =cut
TEST_MOJO

$fatpacked{"Time/Local.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TIME_LOCAL';
  package Time::Local;
  
  use strict;
  
  use Carp ();
  use Exporter;
  
  our $VERSION = '1.25';
  
  use parent 'Exporter';
  
  our @EXPORT    = qw( timegm timelocal );
  our @EXPORT_OK = qw( timegm_nocheck timelocal_nocheck );
  
  my @MonthDays = ( 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 );
  
  # Determine breakpoint for rolling century
  my $ThisYear    = ( localtime() )[5];
  my $Breakpoint  = ( $ThisYear + 50 ) % 100;
  my $NextCentury = $ThisYear - $ThisYear % 100;
  $NextCentury += 100 if $Breakpoint < 50;
  my $Century = $NextCentury - 100;
  my $SecOff  = 0;
  
  my ( %Options, %Cheat );
  
  use constant SECS_PER_MINUTE => 60;
  use constant SECS_PER_HOUR   => 3600;
  use constant SECS_PER_DAY    => 86400;
  
  my $MaxDay;
  if ( $] < 5.012000 ) {
      require Config;
      ## no critic (Variables::ProhibitPackageVars)
  
      my $MaxInt;
      if ( $^O eq 'MacOS' ) {
  
          # time_t is unsigned...
          $MaxInt = ( 1 << ( 8 * $Config::Config{ivsize} ) )
              - 1;    ## no critic qw(ProhibitPackageVars)
      }
      else {
          $MaxInt
              = ( ( 1 << ( 8 * $Config::Config{ivsize} - 2 ) ) - 1 ) * 2
              + 1;    ## no critic qw(ProhibitPackageVars)
      }
  
      $MaxDay = int( ( $MaxInt - ( SECS_PER_DAY / 2 ) ) / SECS_PER_DAY ) - 1;
  }
  else {
      # recent localtime()'s limit is the year 2**31
      $MaxDay = 365 * ( 2**31 );
  }
  
  # Determine the EPOC day for this machine
  my $Epoc = 0;
  if ( $^O eq 'vos' ) {
  
      # work around posix-977 -- VOS doesn't handle dates in the range
      # 1970-1980.
      $Epoc = _daygm( 0, 0, 0, 1, 0, 70, 4, 0 );
  }
  elsif ( $^O eq 'MacOS' ) {
      $MaxDay *= 2 if $^O eq 'MacOS';    # time_t unsigned ... quick hack?
            # MacOS time() is seconds since 1 Jan 1904, localtime
            # so we need to calculate an offset to apply later
      $Epoc   = 693901;
      $SecOff = timelocal( localtime(0) ) - timelocal( gmtime(0) );
      $Epoc += _daygm( gmtime(0) );
  }
  else {
      $Epoc = _daygm( gmtime(0) );
  }
  
  %Cheat = ();    # clear the cache as epoc has changed
  
  sub _daygm {
  
      # This is written in such a byzantine way in order to avoid
      # lexical variables and sub calls, for speed
      return $_[3] + (
          $Cheat{ pack( 'ss', @_[ 4, 5 ] ) } ||= do {
              my $month = ( $_[4] + 10 ) % 12;
              my $year  = $_[5] + 1900 - int( $month / 10 );
  
              ( ( 365 * $year )
                  + int( $year / 4 )
                      - int( $year / 100 )
                      + int( $year / 400 )
                      + int( ( ( $month * 306 ) + 5 ) / 10 ) ) - $Epoc;
              }
      );
  }
  
  sub _timegm {
      my $sec
          = $SecOff + $_[0]
          + ( SECS_PER_MINUTE * $_[1] )
          + ( SECS_PER_HOUR * $_[2] );
  
      return $sec + ( SECS_PER_DAY * &_daygm );
  }
  
  sub timegm {
      my ( $sec, $min, $hour, $mday, $month, $year ) = @_;
  
      if ( $year >= 1000 ) {
          $year -= 1900;
      }
      elsif ( $year < 100 and $year >= 0 ) {
          $year += ( $year > $Breakpoint ) ? $Century : $NextCentury;
      }
  
      unless ( $Options{no_range_check} ) {
          Carp::croak("Month '$month' out of range 0..11")
              if $month > 11
              or $month < 0;
  
          my $md = $MonthDays[$month];
          ++$md
              if $month == 1 && _is_leap_year( $year + 1900 );
  
          Carp::croak("Day '$mday' out of range 1..$md")
              if $mday > $md or $mday < 1;
          Carp::croak("Hour '$hour' out of range 0..23")
              if $hour > 23 or $hour < 0;
          Carp::croak("Minute '$min' out of range 0..59")
              if $min > 59 or $min < 0;
          Carp::croak("Second '$sec' out of range 0..59")
              if $sec >= 60 or $sec < 0;
      }
  
      my $days = _daygm( undef, undef, undef, $mday, $month, $year );
  
      unless ( $Options{no_range_check} or abs($days) < $MaxDay ) {
          my $msg = q{};
          $msg .= "Day too big - $days > $MaxDay\n" if $days > $MaxDay;
  
          $year += 1900;
          $msg
              .= "Cannot handle date ($sec, $min, $hour, $mday, $month, $year)";
  
          Carp::croak($msg);
      }
  
      return
            $sec + $SecOff
          + ( SECS_PER_MINUTE * $min )
          + ( SECS_PER_HOUR * $hour )
          + ( SECS_PER_DAY * $days );
  }
  
  sub _is_leap_year {
      return 0 if $_[0] % 4;
      return 1 if $_[0] % 100;
      return 0 if $_[0] % 400;
  
      return 1;
  }
  
  sub timegm_nocheck {
      local $Options{no_range_check} = 1;
      return &timegm;
  }
  
  sub timelocal {
      my $ref_t         = &timegm;
      my $loc_for_ref_t = _timegm( localtime($ref_t) );
  
      my $zone_off = $loc_for_ref_t - $ref_t
          or return $loc_for_ref_t;
  
      # Adjust for timezone
      my $loc_t = $ref_t - $zone_off;
  
      # Are we close to a DST change or are we done
      my $dst_off = $ref_t - _timegm( localtime($loc_t) );
  
      # If this evaluates to true, it means that the value in $loc_t is
      # the _second_ hour after a DST change where the local time moves
      # backward.
      if (
          !$dst_off
          && ( ( $ref_t - SECS_PER_HOUR )
              - _timegm( localtime( $loc_t - SECS_PER_HOUR ) ) < 0 )
          ) {
          return $loc_t - SECS_PER_HOUR;
      }
  
      # Adjust for DST change
      $loc_t += $dst_off;
  
      return $loc_t if $dst_off > 0;
  
      # If the original date was a non-extent gap in a forward DST jump,
      # we should now have the wrong answer - undo the DST adjustment
      my ( $s, $m, $h ) = localtime($loc_t);
      $loc_t -= $dst_off if $s != $_[0] || $m != $_[1] || $h != $_[2];
  
      return $loc_t;
  }
  
  sub timelocal_nocheck {
      local $Options{no_range_check} = 1;
      return &timelocal;
  }
  
  1;
  
  # ABSTRACT: Efficiently compute time from local and GMT time
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Time::Local - Efficiently compute time from local and GMT time
  
  =head1 VERSION
  
  version 1.25
  
  =head1 SYNOPSIS
  
      use Time::Local;
  
      my $time = timelocal( $sec, $min, $hour, $mday, $mon, $year );
      my $time = timegm( $sec, $min, $hour, $mday, $mon, $year );
  
  =head1 DESCRIPTION
  
  This module provides functions that are the inverse of built-in perl functions
  C<localtime()> and C<gmtime()>. They accept a date as a six-element array, and
  return the corresponding C<time(2)> value in seconds since the system epoch
  (Midnight, January 1, 1970 GMT on Unix, for example). This value can be
  positive or negative, though POSIX only requires support for positive values,
  so dates before the system's epoch may not work on all operating systems.
  
  It is worth drawing particular attention to the expected ranges for the values
  provided. The value for the day of the month is the actual day (i.e. 1..31),
  while the month is the number of months since January (0..11). This is
  consistent with the values returned from C<localtime()> and C<gmtime()>.
  
  =head1 FUNCTIONS
  
  =head2 C<timelocal()> and C<timegm()>
  
  This module exports two functions by default, C<timelocal()> and C<timegm()>.
  
  The C<timelocal()> and C<timegm()> functions perform range checking on the
  input $sec, $min, $hour, $mday, and $mon values by default.
  
  =head2 C<timelocal_nocheck()> and C<timegm_nocheck()>
  
  If you are working with data you know to be valid, you can speed your code up
  by using the "nocheck" variants, C<timelocal_nocheck()> and
  C<timegm_nocheck()>. These variants must be explicitly imported.
  
      use Time::Local 'timelocal_nocheck';
  
      # The 365th day of 1999
      print scalar localtime timelocal_nocheck( 0, 0, 0, 365, 0, 99 );
  
  If you supply data which is not valid (month 27, second 1,000) the results
  will be unpredictable (so don't do that).
  
  =head2 Year Value Interpretation
  
  Strictly speaking, the year should be specified in a form consistent with
  C<localtime()>, i.e. the offset from 1900. In order to make the interpretation
  of the year easier for humans, however, who are more accustomed to seeing
  years as two-digit or four-digit values, the following conventions are
  followed:
  
  =over 4
  
  =item *
  
  Years greater than 999 are interpreted as being the actual year, rather than
  the offset from 1900. Thus, 1964 would indicate the year Martin Luther King
  won the Nobel prize, not the year 3864.
  
  =item *
  
  Years in the range 100..999 are interpreted as offset from 1900, so that 112
  indicates 2012. This rule also applies to years less than zero (but see note
  below regarding date range).
  
  =item *
  
  Years in the range 0..99 are interpreted as shorthand for years in the rolling
  "current century," defined as 50 years on either side of the current
  year. Thus, today, in 1999, 0 would refer to 2000, and 45 to 2045, but 55
  would refer to 1955. Twenty years from now, 55 would instead refer to
  2055. This is messy, but matches the way people currently think about two
  digit dates. Whenever possible, use an absolute four digit year instead.
  
  =back
  
  The scheme above allows interpretation of a wide range of dates, particularly
  if 4-digit years are used.
  
  =head2 Limits of time_t
  
  On perl versions older than 5.12.0, the range of dates that can be actually be
  handled depends on the size of C<time_t> (usually a signed integer) on the
  given platform. Currently, this is 32 bits for most systems, yielding an
  approximate range from Dec 1901 to Jan 2038.
  
  Both C<timelocal()> and C<timegm()> croak if given dates outside the supported
  range.
  
  As of version 5.12.0, perl has stopped using the underlying time library of
  the operating system it's running on and has its own implementation of those
  routines with a safe range of at least +/ 2**52 (about 142 million years).
  
  =head2 Ambiguous Local Times (DST)
  
  Because of DST changes, there are many time zones where the same local time
  occurs for two different GMT times on the same day. For example, in the
  "Europe/Paris" time zone, the local time of 2001-10-28 02:30:00 can represent
  either 2001-10-28 00:30:00 GMT, B<or> 2001-10-28 01:30:00 GMT.
  
  When given an ambiguous local time, the timelocal() function should always
  return the epoch for the I<earlier> of the two possible GMT times.
  
  =head2 Non-Existent Local Times (DST)
  
  When a DST change causes a locale clock to skip one hour forward, there will
  be an hour's worth of local times that don't exist. Again, for the
  "Europe/Paris" time zone, the local clock jumped from 2001-03-25 01:59:59 to
  2001-03-25 03:00:00.
  
  If the C<timelocal()> function is given a non-existent local time, it will
  simply return an epoch value for the time one hour later.
  
  =head2 Negative Epoch Values
  
  On perl version 5.12.0 and newer, negative epoch values are fully supported.
  
  On older versions of perl, negative epoch (C<time_t>) values, which are not
  officially supported by the POSIX standards, are known not to work on some
  systems. These include MacOS (pre-OSX) and Win32.
  
  On systems which do support negative epoch values, this module should be able
  to cope with dates before the start of the epoch, down the minimum value of
  time_t for the system.
  
  =head1 IMPLEMENTATION
  
  These routines are quite efficient and yet are always guaranteed to agree with
  C<localtime()> and C<gmtime()>. We manage this by caching the start times of
  any months we've seen before. If we know the start time of the month, we can
  always calculate any time within the month.  The start times are calculated
  using a mathematical formula. Unlike other algorithms that do multiple calls
  to C<gmtime()>.
  
  The C<timelocal()> function is implemented using the same cache. We just
  assume that we're translating a GMT time, and then fudge it when we're done
  for the timezone and daylight savings arguments. Note that the timezone is
  evaluated for each date because countries occasionally change their official
  timezones. Assuming that C<localtime()> corrects for these changes, this
  routine will also be correct.
  
  =head1 AUTHORS EMERITUS
  
  This module is based on a Perl 4 library, timelocal.pl, that was
  included with Perl 4.036, and was most likely written by Tom
  Christiansen.
  
  The current version was written by Graham Barr.
  
  =head1 BUGS
  
  The whole scheme for interpreting two-digit years can be considered a bug.
  
  Bugs may be submitted through L<https://github.com/houseabsolute/Time-Local/issues>.
  
  There is a mailing list available for users of this distribution,
  L<mailto:datetime@perl.org>.
  
  I am also usually active on IRC as 'autarch' on C<irc://irc.perl.org>.
  
  =head1 AUTHOR
  
  Dave Rolsky <autarch@urth.org>
  
  =head1 CONTRIBUTORS
  
  =for stopwords Florian Ragwitz J. Nick Koston Unknown
  
  =over 4
  
  =item *
  
  Florian Ragwitz <rafl@debian.org>
  
  =item *
  
  J. Nick Koston <nick@cpanel.net>
  
  =item *
  
  Unknown <unknown@example.com>
  
  =back
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 1997 - 2016 by Graham Barr & Dave Rolsky.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
TIME_LOCAL

$fatpacked{"Try/Tiny.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TRY_TINY';
  package Try::Tiny; # git description: v0.27-8-g8dc27c7
  use 5.006;
  # ABSTRACT: Minimal try/catch with proper preservation of $@
  
  our $VERSION = '0.28';
  
  use strict;
  use warnings;
  
  use Exporter 5.57 'import';
  our @EXPORT = our @EXPORT_OK = qw(try catch finally);
  
  use Carp;
  $Carp::Internal{+__PACKAGE__}++;
  
  BEGIN {
    my $su = $INC{'Sub/Util.pm'} && defined &Sub::Util::set_subname;
    my $sn = $INC{'Sub/Name.pm'} && eval { Sub::Name->VERSION(0.08) };
    unless ($su || $sn) {
      $su = eval { require Sub::Util; } && defined &Sub::Util::set_subname;
      unless ($su) {
        $sn = eval { require Sub::Name; Sub::Name->VERSION(0.08) };
      }
    }
  
    *_subname = $su ? \&Sub::Util::set_subname
              : $sn ? \&Sub::Name::subname
              : sub { $_[1] };
    *_HAS_SUBNAME = ($su || $sn) ? sub(){1} : sub(){0};
  }
  
  my %_finally_guards;
  
  # Need to prototype as @ not $$ because of the way Perl evaluates the prototype.
  # Keeping it at $$ means you only ever get 1 sub because we need to eval in a list
  # context & not a scalar one
  
  sub try (&;@) {
    my ( $try, @code_refs ) = @_;
  
    # we need to save this here, the eval block will be in scalar context due
    # to $failed
    my $wantarray = wantarray;
  
    # work around perl bug by explicitly initializing these, due to the likelyhood
    # this will be used in global destruction (perl rt#119311)
    my ( $catch, @finally ) = ();
  
    # find labeled blocks in the argument list.
    # catch and finally tag the blocks by blessing a scalar reference to them.
    foreach my $code_ref (@code_refs) {
  
      if ( ref($code_ref) eq 'Try::Tiny::Catch' ) {
        croak 'A try() may not be followed by multiple catch() blocks'
          if $catch;
        $catch = ${$code_ref};
      } elsif ( ref($code_ref) eq 'Try::Tiny::Finally' ) {
        push @finally, ${$code_ref};
      } else {
        croak(
          'try() encountered an unexpected argument ('
        . ( defined $code_ref ? $code_ref : 'undef' )
        . ') - perhaps a missing semi-colon before or'
        );
      }
    }
  
    # FIXME consider using local $SIG{__DIE__} to accumulate all errors. It's
    # not perfect, but we could provide a list of additional errors for
    # $catch->();
  
    # name the blocks if we have Sub::Name installed
    my $caller = caller;
    _subname("${caller}::try {...} " => $try)
      if _HAS_SUBNAME;
  
    # set up scope guards to invoke the finally blocks at the end.
    # this should really be a function scope lexical variable instead of
    # file scope + local but that causes issues with perls < 5.20 due to
    # perl rt#119311
    local $_finally_guards{guards} = [
      map { Try::Tiny::ScopeGuard->_new($_) }
      @finally
    ];
  
    # save the value of $@ so we can set $@ back to it in the beginning of the eval
    # and restore $@ after the eval finishes
    my $prev_error = $@;
  
    my ( @ret, $error );
  
    # failed will be true if the eval dies, because 1 will not be returned
    # from the eval body
    my $failed = not eval {
      $@ = $prev_error;
  
      # evaluate the try block in the correct context
      if ( $wantarray ) {
        @ret = $try->();
      } elsif ( defined $wantarray ) {
        $ret[0] = $try->();
      } else {
        $try->();
      };
  
      return 1; # properly set $failed to false
    };
  
    # preserve the current error and reset the original value of $@
    $error = $@;
    $@ = $prev_error;
  
    # at this point $failed contains a true value if the eval died, even if some
    # destructor overwrote $@ as the eval was unwinding.
    if ( $failed ) {
      # pass $error to the finally blocks
      push @$_, $error for @{$_finally_guards{guards}};
  
      # if we got an error, invoke the catch block.
      if ( $catch ) {
        # This works like given($error), but is backwards compatible and
        # sets $_ in the dynamic scope for the body of C<$catch>
        for ($error) {
          return $catch->($error);
        }
  
        # in case when() was used without an explicit return, the C<for>
        # loop will be aborted and there's no useful return value
      }
  
      return;
    } else {
      # no failure, $@ is back to what it was, everything is fine
      return $wantarray ? @ret : $ret[0];
    }
  }
  
  sub catch (&;@) {
    my ( $block, @rest ) = @_;
  
    croak 'Useless bare catch()' unless wantarray;
  
    my $caller = caller;
    _subname("${caller}::catch {...} " => $block)
      if _HAS_SUBNAME;
    return (
      bless(\$block, 'Try::Tiny::Catch'),
      @rest,
    );
  }
  
  sub finally (&;@) {
    my ( $block, @rest ) = @_;
  
    croak 'Useless bare finally()' unless wantarray;
  
    my $caller = caller;
    _subname("${caller}::finally {...} " => $block)
      if _HAS_SUBNAME;
    return (
      bless(\$block, 'Try::Tiny::Finally'),
      @rest,
    );
  }
  
  {
    package # hide from PAUSE
      Try::Tiny::ScopeGuard;
  
    use constant UNSTABLE_DOLLARAT => ("$]" < '5.013002') ? 1 : 0;
  
    sub _new {
      shift;
      bless [ @_ ];
    }
  
    sub DESTROY {
      my ($code, @args) = @{ $_[0] };
  
      local $@ if UNSTABLE_DOLLARAT;
      eval {
        $code->(@args);
        1;
      } or do {
        warn
          "Execution of finally() block $code resulted in an exception, which "
        . '*CAN NOT BE PROPAGATED* due to fundamental limitations of Perl. '
        . 'Your program will continue as if this event never took place. '
        . "Original exception text follows:\n\n"
        . (defined $@ ? $@ : '$@ left undefined...')
        . "\n"
        ;
      }
    }
  }
  
  __PACKAGE__
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Try::Tiny - Minimal try/catch with proper preservation of $@
  
  =head1 VERSION
  
  version 0.28
  
  =head1 SYNOPSIS
  
  You can use Try::Tiny's C<try> and C<catch> to expect and handle exceptional
  conditions, avoiding quirks in Perl and common mistakes:
  
    # handle errors with a catch handler
    try {
      die "foo";
    } catch {
      warn "caught error: $_"; # not $@
    };
  
  You can also use it like a standalone C<eval> to catch and ignore any error
  conditions.  Obviously, this is an extreme measure not to be undertaken
  lightly:
  
    # just silence errors
    try {
      die "foo";
    };
  
  =head1 DESCRIPTION
  
  This module provides bare bones C<try>/C<catch>/C<finally> statements that are designed to
  minimize common mistakes with eval blocks, and NOTHING else.
  
  This is unlike L<TryCatch> which provides a nice syntax and avoids adding
  another call stack layer, and supports calling C<return> from the C<try> block to
  return from the parent subroutine. These extra features come at a cost of a few
  dependencies, namely L<Devel::Declare> and L<Scope::Upper> which are
  occasionally problematic, and the additional catch filtering uses L<Moose>
  type constraints which may not be desirable either.
  
  The main focus of this module is to provide simple and reliable error handling
  for those having a hard time installing L<TryCatch>, but who still want to
  write correct C<eval> blocks without 5 lines of boilerplate each time.
  
  It's designed to work as correctly as possible in light of the various
  pathological edge cases (see L</BACKGROUND>) and to be compatible with any style
  of error values (simple strings, references, objects, overloaded objects, etc).
  
  If the C<try> block dies, it returns the value of the last statement executed in
  the C<catch> block, if there is one. Otherwise, it returns C<undef> in scalar
  context or the empty list in list context. The following examples all
  assign C<"bar"> to C<$x>:
  
    my $x = try { die "foo" } catch { "bar" };
    my $x = try { die "foo" } || "bar";
    my $x = (try { die "foo" }) // "bar";
  
    my $x = eval { die "foo" } || "bar";
  
  You can add C<finally> blocks, yielding the following:
  
    my $x;
    try { die 'foo' } finally { $x = 'bar' };
    try { die 'foo' } catch { warn "Got a die: $_" } finally { $x = 'bar' };
  
  C<finally> blocks are always executed making them suitable for cleanup code
  which cannot be handled using local.  You can add as many C<finally> blocks to a
  given C<try> block as you like.
  
  Note that adding a C<finally> block without a preceding C<catch> block
  suppresses any errors. This behaviour is consistent with using a standalone
  C<eval>, but it is not consistent with C<try>/C<finally> patterns found in
  other programming languages, such as Java, Python, Javascript or C#. If you
  learnt the C<try>/C<finally> pattern from one of these languages, watch out for
  this.
  
  =head1 EXPORTS
  
  All functions are exported by default using L<Exporter>.
  
  If you need to rename the C<try>, C<catch> or C<finally> keyword consider using
  L<Sub::Import> to get L<Sub::Exporter>'s flexibility.
  
  =over 4
  
  =item try (&;@)
  
  Takes one mandatory C<try> subroutine, an optional C<catch> subroutine and C<finally>
  subroutine.
  
  The mandatory subroutine is evaluated in the context of an C<eval> block.
  
  If no error occurred the value from the first block is returned, preserving
  list/scalar context.
  
  If there was an error and the second subroutine was given it will be invoked
  with the error in C<$_> (localized) and as that block's first and only
  argument.
  
  C<$@> does B<not> contain the error. Inside the C<catch> block it has the same
  value it had before the C<try> block was executed.
  
  Note that the error may be false, but if that happens the C<catch> block will
  still be invoked.
  
  Once all execution is finished then the C<finally> block, if given, will execute.
  
  =item catch (&;@)
  
  Intended to be used in the second argument position of C<try>.
  
  Returns a reference to the subroutine it was given but blessed as
  C<Try::Tiny::Catch> which allows try to decode correctly what to do
  with this code reference.
  
    catch { ... }
  
  Inside the C<catch> block the caught error is stored in C<$_>, while previous
  value of C<$@> is still available for use.  This value may or may not be
  meaningful depending on what happened before the C<try>, but it might be a good
  idea to preserve it in an error stack.
  
  For code that captures C<$@> when throwing new errors (i.e.
  L<Class::Throwable>), you'll need to do:
  
    local $@ = $_;
  
  =item finally (&;@)
  
    try     { ... }
    catch   { ... }
    finally { ... };
  
  Or
  
    try     { ... }
    finally { ... };
  
  Or even
  
    try     { ... }
    finally { ... }
    catch   { ... };
  
  Intended to be the second or third element of C<try>. C<finally> blocks are always
  executed in the event of a successful C<try> or if C<catch> is run. This allows
  you to locate cleanup code which cannot be done via C<local()> e.g. closing a file
  handle.
  
  When invoked, the C<finally> block is passed the error that was caught.  If no
  error was caught, it is passed nothing.  (Note that the C<finally> block does not
  localize C<$_> with the error, since unlike in a C<catch> block, there is no way
  to know if C<$_ == undef> implies that there were no errors.) In other words,
  the following code does just what you would expect:
  
    try {
      die_sometimes();
    } catch {
      # ...code run in case of error
    } finally {
      if (@_) {
        print "The try block died with: @_\n";
      } else {
        print "The try block ran without error.\n";
      }
    };
  
  B<You must always do your own error handling in the C<finally> block>. C<Try::Tiny> will
  not do anything about handling possible errors coming from code located in these
  blocks.
  
  Furthermore B<exceptions in C<finally> blocks are not trappable and are unable
  to influence the execution of your program>. This is due to limitation of
  C<DESTROY>-based scope guards, which C<finally> is implemented on top of. This
  may change in a future version of Try::Tiny.
  
  In the same way C<catch()> blesses the code reference this subroutine does the same
  except it bless them as C<Try::Tiny::Finally>.
  
  =back
  
  =head1 BACKGROUND
  
  There are a number of issues with C<eval>.
  
  =head2 Clobbering $@
  
  When you run an C<eval> block and it succeeds, C<$@> will be cleared, potentially
  clobbering an error that is currently being caught.
  
  This causes action at a distance, clearing previous errors your caller may have
  not yet handled.
  
  C<$@> must be properly localized before invoking C<eval> in order to avoid this
  issue.
  
  More specifically, C<$@> is clobbered at the beginning of the C<eval>, which
  also makes it impossible to capture the previous error before you die (for
  instance when making exception objects with error stacks).
  
  For this reason C<try> will actually set C<$@> to its previous value (the one
  available before entering the C<try> block) in the beginning of the C<eval>
  block.
  
  =head2 Localizing $@ silently masks errors
  
  Inside an C<eval> block, C<die> behaves sort of like:
  
    sub die {
      $@ = $_[0];
      return_undef_from_eval();
    }
  
  This means that if you were polite and localized C<$@> you can't die in that
  scope, or your error will be discarded (printing "Something's wrong" instead).
  
  The workaround is very ugly:
  
    my $error = do {
      local $@;
      eval { ... };
      $@;
    };
  
    ...
    die $error;
  
  =head2 $@ might not be a true value
  
  This code is wrong:
  
    if ( $@ ) {
      ...
    }
  
  because due to the previous caveats it may have been unset.
  
  C<$@> could also be an overloaded error object that evaluates to false, but
  that's asking for trouble anyway.
  
  The classic failure mode is:
  
    sub Object::DESTROY {
      eval { ... }
    }
  
    eval {
      my $obj = Object->new;
  
      die "foo";
    };
  
    if ( $@ ) {
  
    }
  
  In this case since C<Object::DESTROY> is not localizing C<$@> but still uses
  C<eval>, it will set C<$@> to C<"">.
  
  The destructor is called when the stack is unwound, after C<die> sets C<$@> to
  C<"foo at Foo.pm line 42\n">, so by the time C<if ( $@ )> is evaluated it has
  been cleared by C<eval> in the destructor.
  
  The workaround for this is even uglier than the previous ones. Even though we
  can't save the value of C<$@> from code that doesn't localize, we can at least
  be sure the C<eval> was aborted due to an error:
  
    my $failed = not eval {
      ...
  
      return 1;
    };
  
  This is because an C<eval> that caught a C<die> will always return a false
  value.
  
  =head1 SHINY SYNTAX
  
  Using Perl 5.10 you can use L<perlsyn/"Switch statements">.
  
  =for stopwords topicalizer
  
  The C<catch> block is invoked in a topicalizer context (like a C<given> block),
  but note that you can't return a useful value from C<catch> using the C<when>
  blocks without an explicit C<return>.
  
  This is somewhat similar to Perl 6's C<CATCH> blocks. You can use it to
  concisely match errors:
  
    try {
      require Foo;
    } catch {
      when (/^Can't locate .*?\.pm in \@INC/) { } # ignore
      default { die $_ }
    };
  
  =head1 CAVEATS
  
  =over 4
  
  =item *
  
  C<@_> is not available within the C<try> block, so you need to copy your
  argument list. In case you want to work with argument values directly via C<@_>
  aliasing (i.e. allow C<$_[1] = "foo">), you need to pass C<@_> by reference:
  
    sub foo {
      my ( $self, @args ) = @_;
      try { $self->bar(@args) }
    }
  
  or
  
    sub bar_in_place {
      my $self = shift;
      my $args = \@_;
      try { $_ = $self->bar($_) for @$args }
    }
  
  =item *
  
  C<return> returns from the C<try> block, not from the parent sub (note that
  this is also how C<eval> works, but not how L<TryCatch> works):
  
    sub parent_sub {
      try {
        die;
      }
      catch {
        return;
      };
  
      say "this text WILL be displayed, even though an exception is thrown";
    }
  
  Instead, you should capture the return value:
  
    sub parent_sub {
      my $success = try {
        die;
        1;
      };
      return unless $success;
  
      say "This text WILL NEVER appear!";
    }
    # OR
    sub parent_sub_with_catch {
      my $success = try {
        die;
        1;
      }
      catch {
        # do something with $_
        return undef; #see note
      };
      return unless $success;
  
      say "This text WILL NEVER appear!";
    }
  
  Note that if you have a C<catch> block, it must return C<undef> for this to work,
  since if a C<catch> block exists, its return value is returned in place of C<undef>
  when an exception is thrown.
  
  =item *
  
  C<try> introduces another caller stack frame. L<Sub::Uplevel> is not used. L<Carp>
  will not report this when using full stack traces, though, because
  C<%Carp::Internal> is used. This lack of magic is considered a feature.
  
  =for stopwords unhygienically
  
  =item *
  
  The value of C<$_> in the C<catch> block is not guaranteed to be the value of
  the exception thrown (C<$@>) in the C<try> block.  There is no safe way to
  ensure this, since C<eval> may be used unhygienically in destructors.  The only
  guarantee is that the C<catch> will be called if an exception is thrown.
  
  =item *
  
  The return value of the C<catch> block is not ignored, so if testing the result
  of the expression for truth on success, be sure to return a false value from
  the C<catch> block:
  
    my $obj = try {
      MightFail->new;
    } catch {
      ...
  
      return; # avoid returning a true value;
    };
  
    return unless $obj;
  
  =item *
  
  C<$SIG{__DIE__}> is still in effect.
  
  Though it can be argued that C<$SIG{__DIE__}> should be disabled inside of
  C<eval> blocks, since it isn't people have grown to rely on it. Therefore in
  the interests of compatibility, C<try> does not disable C<$SIG{__DIE__}> for
  the scope of the error throwing code.
  
  =item *
  
  Lexical C<$_> may override the one set by C<catch>.
  
  For example Perl 5.10's C<given> form uses a lexical C<$_>, creating some
  confusing behavior:
  
    given ($foo) {
      when (...) {
        try {
          ...
        } catch {
          warn $_; # will print $foo, not the error
          warn $_[0]; # instead, get the error like this
        }
      }
    }
  
  Note that this behavior was changed once again in L<Perl5 version 18
  |https://metacpan.org/module/perldelta#given-now-aliases-the-global-_>.
  However, since the entirety of lexical C<$_> is now L<considered experimental
  |https://metacpan.org/module/perldelta#Lexical-_-is-now-experimental>, it
  is unclear whether the new version 18 behavior is final.
  
  =back
  
  =head1 SEE ALSO
  
  =over 4
  
  =item L<TryCatch>
  
  Much more feature complete, more convenient semantics, but at the cost of
  implementation complexity.
  
  =item L<autodie>
  
  Automatic error throwing for builtin functions and more. Also designed to
  work well with C<given>/C<when>.
  
  =item L<Throwable>
  
  A lightweight role for rolling your own exception classes.
  
  =item L<Error>
  
  Exception object implementation with a C<try> statement. Does not localize
  C<$@>.
  
  =item L<Exception::Class::TryCatch>
  
  Provides a C<catch> statement, but properly calling C<eval> is your
  responsibility.
  
  The C<try> keyword pushes C<$@> onto an error stack, avoiding some of the
  issues with C<$@>, but you still need to localize to prevent clobbering.
  
  =back
  
  =head1 LIGHTNING TALK
  
  I gave a lightning talk about this module, you can see the slides (Firefox
  only):
  
  L<http://web.archive.org/web/20100628040134/http://nothingmuch.woobling.org/talks/takahashi.xul>
  
  Or read the source:
  
  L<http://web.archive.org/web/20100305133605/http://nothingmuch.woobling.org/talks/yapc_asia_2009/try_tiny.yml>
  
  =head1 SUPPORT
  
  Bugs may be submitted through L<the RT bug tracker|https://rt.cpan.org/Public/Dist/Display.html?Name=Try-Tiny>
  (or L<bug-Try-Tiny@rt.cpan.org|mailto:bug-Try-Tiny@rt.cpan.org>).
  
  =head1 AUTHORS
  
  =over 4
  
  =item *
  
   ' (Yuval Kogman) <nothingmuch@woobling.org>
  
  =item *
  
  Jesse Luehrs <doy@tozt.net>
  
  =back
  
  =head1 CONTRIBUTORS
  
  =for stopwords Karen Etheridge Peter Rabbitson Ricardo Signes Mark Fowler Graham Knop Lukas Mai Dagfinn Ilmari Mannsker Paul Howarth Rudolf Leermakers anaxagoras awalker chromatic Alex cm-perl Andrew Yates David Lowe Glenn Hans Dieter Pearcey Jonathan Yu Marc Mims Stosberg Pali
  
  =over 4
  
  =item *
  
  Karen Etheridge <ether@cpan.org>
  
  =item *
  
  Peter Rabbitson <ribasushi@cpan.org>
  
  =item *
  
  Ricardo Signes <rjbs@cpan.org>
  
  =item *
  
  Mark Fowler <mark@twoshortplanks.com>
  
  =item *
  
  Graham Knop <haarg@haarg.org>
  
  =item *
  
  Lukas Mai <l.mai@web.de>
  
  =item *
  
  Dagfinn Ilmari Mannsker <ilmari@ilmari.org>
  
  =item *
  
  Paul Howarth <paul@city-fan.org>
  
  =item *
  
  Rudolf Leermakers <rudolf@hatsuseno.org>
  
  =item *
  
  anaxagoras <walkeraj@gmail.com>
  
  =item *
  
  awalker <awalker@sourcefire.com>
  
  =item *
  
  chromatic <chromatic@wgz.org>
  
  =item *
  
  Alex <alex@koban.(none)>
  
  =item *
  
  cm-perl <cm-perl@users.noreply.github.com>
  
  =item *
  
  Andrew Yates <ayates@haddock.local>
  
  =item *
  
  David Lowe <davidl@lokku.com>
  
  =item *
  
  Glenn Fowler <cebjyre@cpan.org>
  
  =item *
  
  Hans Dieter Pearcey <hdp@weftsoar.net>
  
  =item *
  
  Jonathan Yu <JAWNSY@cpan.org>
  
  =item *
  
  Marc Mims <marc@questright.com>
  
  =item *
  
  Mark Stosberg <mark@stosberg.com>
  
  =item *
  
  Pali <pali@cpan.org>
  
  =back
  
  =head1 COPYRIGHT AND LICENCE
  
  This software is Copyright (c) 2009 by  ' (Yuval Kogman).
  
  This is free software, licensed under:
  
    The MIT (X11) License
  
  =cut
TRY_TINY

$fatpacked{"base.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'BASE';
  use 5.008;
  package base;
  
  use strict 'vars';
  use vars qw($VERSION);
  $VERSION = '2.23';
  $VERSION =~ tr/_//d;
  
  # constant.pm is slow
  sub SUCCESS () { 1 }
  
  sub PUBLIC     () { 2**0  }
  sub PRIVATE    () { 2**1  }
  sub INHERITED  () { 2**2  }
  sub PROTECTED  () { 2**3  }
  
  
  my $Fattr = \%fields::attr;
  
  sub has_fields {
      my($base) = shift;
      my $fglob = ${"$base\::"}{FIELDS};
      return( ($fglob && 'GLOB' eq ref($fglob) && *$fglob{HASH}) ? 1 : 0 );
  }
  
  sub has_attr {
      my($proto) = shift;
      my($class) = ref $proto || $proto;
      return exists $Fattr->{$class};
  }
  
  sub get_attr {
      $Fattr->{$_[0]} = [1] unless $Fattr->{$_[0]};
      return $Fattr->{$_[0]};
  }
  
  if ($] < 5.009) {
      *get_fields = sub {
          # Shut up a possible typo warning.
          () = \%{$_[0].'::FIELDS'};
          my $f = \%{$_[0].'::FIELDS'};
  
          # should be centralized in fields? perhaps
          # fields::mk_FIELDS_be_OK. Peh. As long as %{ $package . '::FIELDS' }
          # is used here anyway, it doesn't matter.
          bless $f, 'pseudohash' if (ref($f) ne 'pseudohash');
  
          return $f;
      }
  }
  else {
      *get_fields = sub {
          # Shut up a possible typo warning.
          () = \%{$_[0].'::FIELDS'};
          return \%{$_[0].'::FIELDS'};
      }
  }
  
  if ($] < 5.008) {
      *_module_to_filename = sub {
          (my $fn = $_[0]) =~ s!::!/!g;
          $fn .= '.pm';
          return $fn;
      }
  }
  else {
      *_module_to_filename = sub {
          (my $fn = $_[0]) =~ s!::!/!g;
          $fn .= '.pm';
          utf8::encode($fn);
          return $fn;
      }
  }
  
  
  sub import {
      my $class = shift;
  
      return SUCCESS unless @_;
  
      # List of base classes from which we will inherit %FIELDS.
      my $fields_base;
  
      my $inheritor = caller(0);
  
      my @bases;
      foreach my $base (@_) {
          if ( $inheritor eq $base ) {
              warn "Class '$inheritor' tried to inherit from itself\n";
          }
  
          next if grep $_->isa($base), ($inheritor, @bases);
  
          # Following blocks help isolate $SIG{__DIE__} changes
          {
              my $sigdie;
              {
                  local $SIG{__DIE__};
                  my $fn = _module_to_filename($base);
                  eval { require $fn };
                  # Only ignore "Can't locate" errors from our eval require.
                  # Other fatal errors (syntax etc) must be reported.
                  #
                  # changing the check here is fragile - if the check
                  # here isn't catching every error you want, you should
                  # probably be using parent.pm, which doesn't try to
                  # guess whether require is needed or failed,
                  # see [perl #118561]
                  die if $@ && $@ !~ /^Can't locate \Q$fn\E .*? at .* line [0-9]+(?:, <[^>]*> (?:line|chunk) [0-9]+)?\.\n\z/s
                            || $@ =~ /Compilation failed in require at .* line [0-9]+(?:, <[^>]*> (?:line|chunk) [0-9]+)?\.\n\z/;
                  unless (%{"$base\::"}) {
                      require Carp;
                      local $" = " ";
                      Carp::croak(<<ERROR);
  Base class package "$base" is empty.
      (Perhaps you need to 'use' the module which defines that package first,
      or make that module available in \@INC (\@INC contains: @INC).
  ERROR
                  }
                  $sigdie = $SIG{__DIE__} || undef;
              }
              # Make sure a global $SIG{__DIE__} makes it out of the localization.
              $SIG{__DIE__} = $sigdie if defined $sigdie;
          }
          push @bases, $base;
  
          if ( has_fields($base) || has_attr($base) ) {
              # No multiple fields inheritance *suck*
              if ($fields_base) {
                  require Carp;
                  Carp::croak("Can't multiply inherit fields");
              } else {
                  $fields_base = $base;
              }
          }
      }
      # Save this until the end so it's all or nothing if the above loop croaks.
      push @{"$inheritor\::ISA"}, @bases;
  
      if( defined $fields_base ) {
          inherit_fields($inheritor, $fields_base);
      }
  }
  
  
  sub inherit_fields {
      my($derived, $base) = @_;
  
      return SUCCESS unless $base;
  
      my $battr = get_attr($base);
      my $dattr = get_attr($derived);
      my $dfields = get_fields($derived);
      my $bfields = get_fields($base);
  
      $dattr->[0] = @$battr;
  
      if( keys %$dfields ) {
          warn <<"END";
  $derived is inheriting from $base but already has its own fields!
  This will cause problems.  Be sure you use base BEFORE declaring fields.
  END
  
      }
  
      # Iterate through the base's fields adding all the non-private
      # ones to the derived class.  Hang on to the original attribute
      # (Public, Private, etc...) and add Inherited.
      # This is all too complicated to do efficiently with add_fields().
      while (my($k,$v) = each %$bfields) {
          my $fno;
          if ($fno = $dfields->{$k} and $fno != $v) {
              require Carp;
              Carp::croak ("Inherited fields can't override existing fields");
          }
  
          if( $battr->[$v] & PRIVATE ) {
              $dattr->[$v] = PRIVATE | INHERITED;
          }
          else {
              $dattr->[$v] = INHERITED | $battr->[$v];
              $dfields->{$k} = $v;
          }
      }
  
      foreach my $idx (1..$#{$battr}) {
          next if defined $dattr->[$idx];
          $dattr->[$idx] = $battr->[$idx] & INHERITED;
      }
  }
  
  
  1;
  
  __END__
  
  =head1 NAME
  
  base - Establish an ISA relationship with base classes at compile time
  
  =head1 SYNOPSIS
  
      package Baz;
      use base qw(Foo Bar);
  
  =head1 DESCRIPTION
  
  Unless you are using the C<fields> pragma, consider this module discouraged
  in favor of the lighter-weight C<parent>.
  
  Allows you to both load one or more modules, while setting up inheritance from
  those modules at the same time.  Roughly similar in effect to
  
      package Baz;
      BEGIN {
          require Foo;
          require Bar;
          push @ISA, qw(Foo Bar);
      }
  
  When C<base> tries to C<require> a module, it will not die if it cannot find
  the module's file, but will die on any other error.  After all this, should
  your base class be empty, containing no symbols, C<base> will die. This is
  useful for inheriting from classes in the same file as yourself but where
  the filename does not match the base module name, like so:
  
          # in Bar.pm
          package Foo;
          sub exclaim { "I can have such a thing?!" }
  
          package Bar;
          use base "Foo";
  
  There is no F<Foo.pm>, but because C<Foo> defines a symbol (the C<exclaim>
  subroutine), C<base> will not die when the C<require> fails to load F<Foo.pm>.
  
  C<base> will also initialize the fields if one of the base classes has it.
  Multiple inheritance of fields is B<NOT> supported, if two or more base classes
  each have inheritable fields the 'base' pragma will croak. See L<fields>
  for a description of this feature.
  
  The base class' C<import> method is B<not> called.
  
  
  =head1 DIAGNOSTICS
  
  =over 4
  
  =item Base class package "%s" is empty.
  
  base.pm was unable to require the base package, because it was not
  found in your path.
  
  =item Class 'Foo' tried to inherit from itself
  
  Attempting to inherit from yourself generates a warning.
  
      package Foo;
      use base 'Foo';
  
  =back
  
  =head1 HISTORY
  
  This module was introduced with Perl 5.004_04.
  
  =head1 CAVEATS
  
  Due to the limitations of the implementation, you must use
  base I<before> you declare any of your own fields.
  
  
  =head1 SEE ALSO
  
  L<fields>
  
  =cut
BASE

$fatpacked{"fields.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'FIELDS';
  use 5.008;
  package fields;
  
  require 5.005;
  use strict;
  no strict 'refs';
  unless( eval q{require warnings::register; warnings::register->import; 1} ) {
      *warnings::warnif = sub { 
          require Carp;
          Carp::carp(@_);
      }
  }
  use vars qw(%attr $VERSION);
  
  $VERSION = '2.23';
  $VERSION =~ tr/_//d;
  
  # constant.pm is slow
  sub PUBLIC     () { 2**0  }
  sub PRIVATE    () { 2**1  }
  sub INHERITED  () { 2**2  }
  sub PROTECTED  () { 2**3  }
  
  
  # The %attr hash holds the attributes of the currently assigned fields
  # per class.  The hash is indexed by class names and the hash value is
  # an array reference.  The first element in the array is the lowest field
  # number not belonging to a base class.  The remaining elements' indices
  # are the field numbers.  The values are integer bit masks, or undef
  # in the case of base class private fields (which occupy a slot but are
  # otherwise irrelevant to the class).
  
  sub import {
      my $class = shift;
      return unless @_;
      my $package = caller(0);
      # avoid possible typo warnings
      %{"$package\::FIELDS"} = () unless %{"$package\::FIELDS"};
      my $fields = \%{"$package\::FIELDS"};
      my $fattr = ($attr{$package} ||= [1]);
      my $next = @$fattr;
  
      # Quiet pseudo-hash deprecation warning for uses of fields::new.
      bless \%{"$package\::FIELDS"}, 'pseudohash';
  
      if ($next > $fattr->[0]
          and ($fields->{$_[0]} || 0) >= $fattr->[0])
      {
          # There are already fields not belonging to base classes.
          # Looks like a possible module reload...
          $next = $fattr->[0];
      }
      foreach my $f (@_) {
          my $fno = $fields->{$f};
  
          # Allow the module to be reloaded so long as field positions
          # have not changed.
          if ($fno and $fno != $next) {
              require Carp;
              if ($fno < $fattr->[0]) {
                if ($] < 5.006001) {
                  warn("Hides field '$f' in base class") if $^W;
                } else {
                  warnings::warnif("Hides field '$f' in base class") ;
                }
              } else {
                  Carp::croak("Field name '$f' already in use");
              }
          }
          $fields->{$f} = $next;
          $fattr->[$next] = ($f =~ /^_/) ? PRIVATE : PUBLIC;
          $next += 1;
      }
      if (@$fattr > $next) {
          # Well, we gave them the benefit of the doubt by guessing the
          # module was reloaded, but they appear to be declaring fields
          # in more than one place.  We can't be sure (without some extra
          # bookkeeping) that the rest of the fields will be declared or
          # have the same positions, so punt.
          require Carp;
          Carp::croak ("Reloaded module must declare all fields at once");
      }
  }
  
  sub inherit {
      require base;
      goto &base::inherit_fields;
  }
  
  sub _dump  # sometimes useful for debugging
  {
      for my $pkg (sort keys %attr) {
          print "\n$pkg";
          if (@{"$pkg\::ISA"}) {
              print " (", join(", ", @{"$pkg\::ISA"}), ")";
          }
          print "\n";
          my $fields = \%{"$pkg\::FIELDS"};
          for my $f (sort {$fields->{$a} <=> $fields->{$b}} keys %$fields) {
              my $no = $fields->{$f};
              print "   $no: $f";
              my $fattr = $attr{$pkg}[$no];
              if (defined $fattr) {
                  my @a;
                  push(@a, "public")    if $fattr & PUBLIC;
                  push(@a, "private")   if $fattr & PRIVATE;
                  push(@a, "inherited") if $fattr & INHERITED;
                  print "\t(", join(", ", @a), ")";
              }
              print "\n";
          }
      }
  }
  
  if ($] < 5.009) {
    *new = sub {
      my $class = shift;
      $class = ref $class if ref $class;
      return bless [\%{$class . "::FIELDS"}], $class;
    }
  } else {
    *new = sub {
      my $class = shift;
      $class = ref $class if ref $class;
      require Hash::Util;
      my $self = bless {}, $class;
  
      # The lock_keys() prototype won't work since we require Hash::Util :(
      &Hash::Util::lock_keys(\%$self, _accessible_keys($class));
      return $self;
    }
  }
  
  sub _accessible_keys {
      my ($class) = @_;
      return (
          keys %{$class.'::FIELDS'},
          map(_accessible_keys($_), @{$class.'::ISA'}),
      );
  }
  
  sub phash {
      die "Pseudo-hashes have been removed from Perl" if $] >= 5.009;
      my $h;
      my $v;
      if (@_) {
         if (ref $_[0] eq 'ARRAY') {
             my $a = shift;
             @$h{@$a} = 1 .. @$a;
             if (@_) {
                 $v = shift;
                 unless (! @_ and ref $v eq 'ARRAY') {
                     require Carp;
                     Carp::croak ("Expected at most two array refs\n");
                 }
             }
         }
         else {
             if (@_ % 2) {
                 require Carp;
                 Carp::croak ("Odd number of elements initializing pseudo-hash\n");
             }
             my $i = 0;
             @$h{grep ++$i % 2, @_} = 1 .. @_ / 2;
             $i = 0;
             $v = [grep $i++ % 2, @_];
         }
      }
      else {
         $h = {};
         $v = [];
      }
      [ $h, @$v ];
  
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  fields - compile-time class fields
  
  =head1 SYNOPSIS
  
      {
          package Foo;
          use fields qw(foo bar _Foo_private);
          sub new {
              my Foo $self = shift;
              unless (ref $self) {
                  $self = fields::new($self);
                  $self->{_Foo_private} = "this is Foo's secret";
              }
              $self->{foo} = 10;
              $self->{bar} = 20;
              return $self;
          }
      }
  
      my $var = Foo->new;
      $var->{foo} = 42;
  
      # this will generate a run-time error
      $var->{zap} = 42;
  
      # this will generate a compile-time error
      my Foo $foo = Foo->new;
      $foo->{zap} = 24;
  
      # subclassing
      {
          package Bar;
          use base 'Foo';
          use fields qw(baz _Bar_private);        # not shared with Foo
          sub new {
              my $class = shift;
              my $self = fields::new($class);
              $self->SUPER::new();                # init base fields
              $self->{baz} = 10;                  # init own fields
              $self->{_Bar_private} = "this is Bar's secret";
              return $self;
          }
      }
  
  =head1 DESCRIPTION
  
  The C<fields> pragma enables compile-time and run-time verified class
  fields.
  
  NOTE: The current implementation keeps the declared fields in the %FIELDS
  hash of the calling package, but this may change in future versions.
  Do B<not> update the %FIELDS hash directly, because it must be created
  at compile-time for it to be fully useful, as is done by this pragma.
  
  If a typed lexical variable (C<my Class
  $var>) holding a reference is used to access a
  hash element and a package with the same name as the type has
  declared class fields using this pragma, then the hash key is
  verified at compile time.  If the variables are not typed, access is
  only checked at run time.
  
  The related C<base> pragma will combine fields from base classes and any
  fields declared using the C<fields> pragma.  This enables field
  inheritance to work properly.  Inherited fields can be overridden but
  will generate a warning if warnings are enabled.
  
  B<Only valid for Perl 5.8.x and earlier:> Field names that start with an
  underscore character are made private to the class and are not visible
  to subclasses.
  
  Also, B<in Perl 5.8.x and earlier>, this pragma uses pseudo-hashes, the
  effect being that you can have objects with named fields which are as
  compact and as fast arrays to access, as long as the objects are
  accessed through properly typed variables.
  
  The following functions are supported:
  
  =over 4
  
  =item new
  
  fields::new() creates and blesses a hash comprised of the fields declared
  using the C<fields> pragma into the specified class.  It is the
  recommended way to construct a fields-based object.
  
  This makes it possible to write a constructor like this:
  
      package Critter::Sounds;
      use fields qw(cat dog bird);
  
      sub new {
          my $self = shift;
          $self = fields::new($self) unless ref $self;
          $self->{cat} = 'meow';                      # scalar element
          @$self{'dog','bird'} = ('bark','tweet');    # slice
          return $self;
      }
  
  =item phash
  
  B<This function only works in Perl 5.8.x and earlier.>  Pseudo-hashes
  were removed from Perl as of 5.10.  Consider using restricted hashes or
  fields::new() instead (which itself uses restricted hashes under 5.10+).
  See L<Hash::Util>.  Using fields::phash() under 5.10 or higher will
  cause an error.
  
  fields::phash() can be used to create and initialize a plain (unblessed)
  pseudo-hash.  This function should always be used instead of creating
  pseudo-hashes directly.
  
  If the first argument is a reference to an array, the pseudo-hash will
  be created with keys from that array.  If a second argument is supplied,
  it must also be a reference to an array whose elements will be used as
  the values.  If the second array contains less elements than the first,
  the trailing elements of the pseudo-hash will not be initialized.
  This makes it particularly useful for creating a pseudo-hash from
  subroutine arguments:
  
      sub dogtag {
         my $tag = fields::phash([qw(name rank ser_num)], [@_]);
      }
  
  fields::phash() also accepts a list of key-value pairs that will
  be used to construct the pseudo hash.  Examples:
  
      my $tag = fields::phash(name => "Joe",
                              rank => "captain",
                              ser_num => 42);
  
      my $pseudohash = fields::phash(%args);
  
  =back
  
  =head1 SEE ALSO
  
  L<base>, L<Hash::Util>
  
  =cut
FIELDS

$fatpacked{"i686-linux-gnu-thread-multi-64int/Cwd.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'I686-LINUX-GNU-THREAD-MULTI-64INT_CWD';
  package Cwd;
  use strict;
  use Exporter;
  use vars qw(@ISA @EXPORT @EXPORT_OK $VERSION);
  
  $VERSION = '3.62';
  my $xs_version = $VERSION;
  $VERSION =~ tr/_//d;
  
  @ISA = qw/ Exporter /;
  @EXPORT = qw(cwd getcwd fastcwd fastgetcwd);
  push @EXPORT, qw(getdcwd) if $^O eq 'MSWin32';
  @EXPORT_OK = qw(chdir abs_path fast_abs_path realpath fast_realpath);
  
  # sys_cwd may keep the builtin command
  
  # All the functionality of this module may provided by builtins,
  # there is no sense to process the rest of the file.
  # The best choice may be to have this in BEGIN, but how to return from BEGIN?
  
  if ($^O eq 'os2') {
      local $^W = 0;
  
      *cwd                = defined &sys_cwd ? \&sys_cwd : \&_os2_cwd;
      *getcwd             = \&cwd;
      *fastgetcwd         = \&cwd;
      *fastcwd            = \&cwd;
  
      *fast_abs_path      = \&sys_abspath if defined &sys_abspath;
      *abs_path           = \&fast_abs_path;
      *realpath           = \&fast_abs_path;
      *fast_realpath      = \&fast_abs_path;
  
      return 1;
  }
  
  # Need to look up the feature settings on VMS.  The preferred way is to use the
  # VMS::Feature module, but that may not be available to dual life modules.
  
  my $use_vms_feature;
  BEGIN {
      if ($^O eq 'VMS') {
          if (eval { local $SIG{__DIE__}; require VMS::Feature; }) {
              $use_vms_feature = 1;
          }
      }
  }
  
  # Need to look up the UNIX report mode.  This may become a dynamic mode
  # in the future.
  sub _vms_unix_rpt {
      my $unix_rpt;
      if ($use_vms_feature) {
          $unix_rpt = VMS::Feature::current("filename_unix_report");
      } else {
          my $env_unix_rpt = $ENV{'DECC$FILENAME_UNIX_REPORT'} || '';
          $unix_rpt = $env_unix_rpt =~ /^[ET1]/i; 
      }
      return $unix_rpt;
  }
  
  # Need to look up the EFS character set mode.  This may become a dynamic
  # mode in the future.
  sub _vms_efs {
      my $efs;
      if ($use_vms_feature) {
          $efs = VMS::Feature::current("efs_charset");
      } else {
          my $env_efs = $ENV{'DECC$EFS_CHARSET'} || '';
          $efs = $env_efs =~ /^[ET1]/i; 
      }
      return $efs;
  }
  
  
  # If loading the XS stuff doesn't work, we can fall back to pure perl
  if(! defined &getcwd && defined &DynaLoader::boot_DynaLoader) {
    eval {#eval is questionable since we are handling potential errors like
          #"Cwd object version 3.48 does not match bootstrap parameter 3.50
          #at lib/DynaLoader.pm line 216." by having this eval
      if ( $] >= 5.006 ) {
        require XSLoader;
        XSLoader::load( __PACKAGE__, $xs_version);
      } else {
        require DynaLoader;
        push @ISA, 'DynaLoader';
        __PACKAGE__->bootstrap( $xs_version );
      }
    };
  }
  
  # Big nasty table of function aliases
  my %METHOD_MAP =
    (
     VMS =>
     {
      cwd			=> '_vms_cwd',
      getcwd		=> '_vms_cwd',
      fastcwd		=> '_vms_cwd',
      fastgetcwd		=> '_vms_cwd',
      abs_path		=> '_vms_abs_path',
      fast_abs_path	=> '_vms_abs_path',
     },
  
     MSWin32 =>
     {
      # We assume that &_NT_cwd is defined as an XSUB or in the core.
      cwd			=> '_NT_cwd',
      getcwd		=> '_NT_cwd',
      fastcwd		=> '_NT_cwd',
      fastgetcwd		=> '_NT_cwd',
      abs_path		=> 'fast_abs_path',
      realpath		=> 'fast_abs_path',
     },
  
     dos => 
     {
      cwd			=> '_dos_cwd',
      getcwd		=> '_dos_cwd',
      fastgetcwd		=> '_dos_cwd',
      fastcwd		=> '_dos_cwd',
      abs_path		=> 'fast_abs_path',
     },
  
     # QNX4.  QNX6 has a $os of 'nto'.
     qnx =>
     {
      cwd			=> '_qnx_cwd',
      getcwd		=> '_qnx_cwd',
      fastgetcwd		=> '_qnx_cwd',
      fastcwd		=> '_qnx_cwd',
      abs_path		=> '_qnx_abs_path',
      fast_abs_path	=> '_qnx_abs_path',
     },
  
     cygwin =>
     {
      getcwd		=> 'cwd',
      fastgetcwd		=> 'cwd',
      fastcwd		=> 'cwd',
      abs_path		=> 'fast_abs_path',
      realpath		=> 'fast_abs_path',
     },
  
     epoc =>
     {
      cwd			=> '_epoc_cwd',
      getcwd	        => '_epoc_cwd',
      fastgetcwd		=> '_epoc_cwd',
      fastcwd		=> '_epoc_cwd',
      abs_path		=> 'fast_abs_path',
     },
  
     MacOS =>
     {
      getcwd		=> 'cwd',
      fastgetcwd		=> 'cwd',
      fastcwd		=> 'cwd',
      abs_path		=> 'fast_abs_path',
     },
  
     amigaos =>
     {
      getcwd              => '_backtick_pwd',
      fastgetcwd          => '_backtick_pwd',
      fastcwd             => '_backtick_pwd',
      abs_path            => 'fast_abs_path',
     }
    );
  
  $METHOD_MAP{NT} = $METHOD_MAP{MSWin32};
  
  
  # Find the pwd command in the expected locations.  We assume these
  # are safe.  This prevents _backtick_pwd() consulting $ENV{PATH}
  # so everything works under taint mode.
  my $pwd_cmd;
  if($^O ne 'MSWin32') {
      foreach my $try ('/bin/pwd',
  		     '/usr/bin/pwd',
  		     '/QOpenSys/bin/pwd', # OS/400 PASE.
  		    ) {
  	if( -x $try ) {
  	    $pwd_cmd = $try;
  	    last;
  	}
      }
  }
  
  # Android has a built-in pwd. Using $pwd_cmd will DTRT if
  # this perl was compiled with -Dd_useshellcmds, which is the
  # default for Android, but the block below is needed for the
  # miniperl running on the host when cross-compiling, and
  # potentially for native builds with -Ud_useshellcmds.
  if ($^O =~ /android/) {
      # If targetsh is executable, then we're either a full
      # perl, or a miniperl for a native build.
      if (-x $Config::Config{targetsh}) {
          $pwd_cmd = "$Config::Config{targetsh} -c pwd"
      }
      else {
          my $sh = $Config::Config{sh} || (-x '/system/bin/sh' ? '/system/bin/sh' : 'sh');
          $pwd_cmd = "$sh -c pwd"
      }
  }
  
  my $found_pwd_cmd = defined($pwd_cmd);
  unless ($pwd_cmd) {
      # Isn't this wrong?  _backtick_pwd() will fail if someone has
      # pwd in their path but it is not /bin/pwd or /usr/bin/pwd?
      # See [perl #16774]. --jhi
      $pwd_cmd = 'pwd';
  }
  
  # Lazy-load Carp
  sub _carp  { require Carp; Carp::carp(@_)  }
  sub _croak { require Carp; Carp::croak(@_) }
  
  # The 'natural and safe form' for UNIX (pwd may be setuid root)
  sub _backtick_pwd {
  
      # Localize %ENV entries in a way that won't create new hash keys.
      # Under AmigaOS we don't want to localize as it stops perl from
      # finding 'sh' in the PATH.
      my @localize = grep exists $ENV{$_}, qw(PATH IFS CDPATH ENV BASH_ENV) if $^O ne "amigaos";
      local @ENV{@localize} if @localize;
      
      my $cwd = `$pwd_cmd`;
      # Belt-and-suspenders in case someone said "undef $/".
      local $/ = "\n";
      # `pwd` may fail e.g. if the disk is full
      chomp($cwd) if defined $cwd;
      $cwd;
  }
  
  # Since some ports may predefine cwd internally (e.g., NT)
  # we take care not to override an existing definition for cwd().
  
  unless ($METHOD_MAP{$^O}{cwd} or defined &cwd) {
      # The pwd command is not available in some chroot(2)'ed environments
      my $sep = $Config::Config{path_sep} || ':';
      my $os = $^O;  # Protect $^O from tainting
  
  
      # Try again to find a pwd, this time searching the whole PATH.
      if (defined $ENV{PATH} and $os ne 'MSWin32') {  # no pwd on Windows
  	my @candidates = split($sep, $ENV{PATH});
  	while (!$found_pwd_cmd and @candidates) {
  	    my $candidate = shift @candidates;
  	    $found_pwd_cmd = 1 if -x "$candidate/pwd";
  	}
      }
  
      # MacOS has some special magic to make `pwd` work.
      if( $os eq 'MacOS' || $found_pwd_cmd )
      {
  	*cwd = \&_backtick_pwd;
      }
      else {
  	*cwd = \&getcwd;
      }
  }
  
  if ($^O eq 'cygwin') {
    # We need to make sure cwd() is called with no args, because it's
    # got an arg-less prototype and will die if args are present.
    local $^W = 0;
    my $orig_cwd = \&cwd;
    *cwd = sub { &$orig_cwd() }
  }
  
  
  # set a reasonable (and very safe) default for fastgetcwd, in case it
  # isn't redefined later (20001212 rspier)
  *fastgetcwd = \&cwd;
  
  # A non-XS version of getcwd() - also used to bootstrap the perl build
  # process, when miniperl is running and no XS loading happens.
  sub _perl_getcwd
  {
      abs_path('.');
  }
  
  # By John Bazik
  #
  # Usage: $cwd = &fastcwd;
  #
  # This is a faster version of getcwd.  It's also more dangerous because
  # you might chdir out of a directory that you can't chdir back into.
      
  sub fastcwd_ {
      my($odev, $oino, $cdev, $cino, $tdev, $tino);
      my(@path, $path);
      local(*DIR);
  
      my($orig_cdev, $orig_cino) = stat('.');
      ($cdev, $cino) = ($orig_cdev, $orig_cino);
      for (;;) {
  	my $direntry;
  	($odev, $oino) = ($cdev, $cino);
  	CORE::chdir('..') || return undef;
  	($cdev, $cino) = stat('.');
  	last if $odev == $cdev && $oino == $cino;
  	opendir(DIR, '.') || return undef;
  	for (;;) {
  	    $direntry = readdir(DIR);
  	    last unless defined $direntry;
  	    next if $direntry eq '.';
  	    next if $direntry eq '..';
  
  	    ($tdev, $tino) = lstat($direntry);
  	    last unless $tdev != $odev || $tino != $oino;
  	}
  	closedir(DIR);
  	return undef unless defined $direntry; # should never happen
  	unshift(@path, $direntry);
      }
      $path = '/' . join('/', @path);
      if ($^O eq 'apollo') { $path = "/".$path; }
      # At this point $path may be tainted (if tainting) and chdir would fail.
      # Untaint it then check that we landed where we started.
      $path =~ /^(.*)\z/s		# untaint
  	&& CORE::chdir($1) or return undef;
      ($cdev, $cino) = stat('.');
      die "Unstable directory path, current directory changed unexpectedly"
  	if $cdev != $orig_cdev || $cino != $orig_cino;
      $path;
  }
  if (not defined &fastcwd) { *fastcwd = \&fastcwd_ }
  
  
  # Keeps track of current working directory in PWD environment var
  # Usage:
  #	use Cwd 'chdir';
  #	chdir $newdir;
  
  my $chdir_init = 0;
  
  sub chdir_init {
      if ($ENV{'PWD'} and $^O ne 'os2' and $^O ne 'dos' and $^O ne 'MSWin32') {
  	my($dd,$di) = stat('.');
  	my($pd,$pi) = stat($ENV{'PWD'});
  	if (!defined $dd or !defined $pd or $di != $pi or $dd != $pd) {
  	    $ENV{'PWD'} = cwd();
  	}
      }
      else {
  	my $wd = cwd();
  	$wd = Win32::GetFullPathName($wd) if $^O eq 'MSWin32';
  	$ENV{'PWD'} = $wd;
      }
      # Strip an automounter prefix (where /tmp_mnt/foo/bar == /foo/bar)
      if ($^O ne 'MSWin32' and $ENV{'PWD'} =~ m|(/[^/]+(/[^/]+/[^/]+))(.*)|s) {
  	my($pd,$pi) = stat($2);
  	my($dd,$di) = stat($1);
  	if (defined $pd and defined $dd and $di == $pi and $dd == $pd) {
  	    $ENV{'PWD'}="$2$3";
  	}
      }
      $chdir_init = 1;
  }
  
  sub chdir {
      my $newdir = @_ ? shift : '';	# allow for no arg (chdir to HOME dir)
      if ($^O eq "cygwin") {
        $newdir =~ s|\A///+|//|;
        $newdir =~ s|(?<=[^/])//+|/|g;
      }
      elsif ($^O ne 'MSWin32') {
        $newdir =~ s|///*|/|g;
      }
      chdir_init() unless $chdir_init;
      my $newpwd;
      if ($^O eq 'MSWin32') {
  	# get the full path name *before* the chdir()
  	$newpwd = Win32::GetFullPathName($newdir);
      }
  
      return 0 unless CORE::chdir $newdir;
  
      if ($^O eq 'VMS') {
  	return $ENV{'PWD'} = $ENV{'DEFAULT'}
      }
      elsif ($^O eq 'MacOS') {
  	return $ENV{'PWD'} = cwd();
      }
      elsif ($^O eq 'MSWin32') {
  	$ENV{'PWD'} = $newpwd;
  	return 1;
      }
  
      if (ref $newdir eq 'GLOB') { # in case a file/dir handle is passed in
  	$ENV{'PWD'} = cwd();
      } elsif ($newdir =~ m#^/#s) {
  	$ENV{'PWD'} = $newdir;
      } else {
  	my @curdir = split(m#/#,$ENV{'PWD'});
  	@curdir = ('') unless @curdir;
  	my $component;
  	foreach $component (split(m#/#, $newdir)) {
  	    next if $component eq '.';
  	    pop(@curdir),next if $component eq '..';
  	    push(@curdir,$component);
  	}
  	$ENV{'PWD'} = join('/',@curdir) || '/';
      }
      1;
  }
  
  
  sub _perl_abs_path
  {
      my $start = @_ ? shift : '.';
      my($dotdots, $cwd, @pst, @cst, $dir, @tst);
  
      unless (@cst = stat( $start ))
      {
  	_carp("stat($start): $!");
  	return '';
      }
  
      unless (-d _) {
          # Make sure we can be invoked on plain files, not just directories.
          # NOTE that this routine assumes that '/' is the only directory separator.
  	
          my ($dir, $file) = $start =~ m{^(.*)/(.+)$}
  	    or return cwd() . '/' . $start;
  	
  	# Can't use "-l _" here, because the previous stat was a stat(), not an lstat().
  	if (-l $start) {
  	    my $link_target = readlink($start);
  	    die "Can't resolve link $start: $!" unless defined $link_target;
  	    
  	    require File::Spec;
              $link_target = $dir . '/' . $link_target
                  unless File::Spec->file_name_is_absolute($link_target);
  	    
  	    return abs_path($link_target);
  	}
  	
  	return $dir ? abs_path($dir) . "/$file" : "/$file";
      }
  
      $cwd = '';
      $dotdots = $start;
      do
      {
  	$dotdots .= '/..';
  	@pst = @cst;
  	local *PARENT;
  	unless (opendir(PARENT, $dotdots))
  	{
  	    # probably a permissions issue.  Try the native command.
  	    require File::Spec;
  	    return File::Spec->rel2abs( $start, _backtick_pwd() );
  	}
  	unless (@cst = stat($dotdots))
  	{
  	    _carp("stat($dotdots): $!");
  	    closedir(PARENT);
  	    return '';
  	}
  	if ($pst[0] == $cst[0] && $pst[1] == $cst[1])
  	{
  	    $dir = undef;
  	}
  	else
  	{
  	    do
  	    {
  		unless (defined ($dir = readdir(PARENT)))
  	        {
  		    _carp("readdir($dotdots): $!");
  		    closedir(PARENT);
  		    return '';
  		}
  		$tst[0] = $pst[0]+1 unless (@tst = lstat("$dotdots/$dir"))
  	    }
  	    while ($dir eq '.' || $dir eq '..' || $tst[0] != $pst[0] ||
  		   $tst[1] != $pst[1]);
  	}
  	$cwd = (defined $dir ? "$dir" : "" ) . "/$cwd" ;
  	closedir(PARENT);
      } while (defined $dir);
      chop($cwd) unless $cwd eq '/'; # drop the trailing /
      $cwd;
  }
  
  
  my $Curdir;
  sub fast_abs_path {
      local $ENV{PWD} = $ENV{PWD} || ''; # Guard against clobberage
      my $cwd = getcwd();
      require File::Spec;
      my $path = @_ ? shift : ($Curdir ||= File::Spec->curdir);
  
      # Detaint else we'll explode in taint mode.  This is safe because
      # we're not doing anything dangerous with it.
      ($path) = $path =~ /(.*)/s;
      ($cwd)  = $cwd  =~ /(.*)/s;
  
      unless (-e $path) {
   	_croak("$path: No such file or directory");
      }
  
      unless (-d _) {
          # Make sure we can be invoked on plain files, not just directories.
  	
  	my ($vol, $dir, $file) = File::Spec->splitpath($path);
  	return File::Spec->catfile($cwd, $path) unless length $dir;
  
  	if (-l $path) {
  	    my $link_target = readlink($path);
  	    die "Can't resolve link $path: $!" unless defined $link_target;
  	    
  	    $link_target = File::Spec->catpath($vol, $dir, $link_target)
                  unless File::Spec->file_name_is_absolute($link_target);
  	    
  	    return fast_abs_path($link_target);
  	}
  	
  	return $dir eq File::Spec->rootdir
  	  ? File::Spec->catpath($vol, $dir, $file)
  	  : fast_abs_path(File::Spec->catpath($vol, $dir, '')) . '/' . $file;
      }
  
      if (!CORE::chdir($path)) {
   	_croak("Cannot chdir to $path: $!");
      }
      my $realpath = getcwd();
      if (! ((-d $cwd) && (CORE::chdir($cwd)))) {
   	_croak("Cannot chdir back to $cwd: $!");
      }
      $realpath;
  }
  
  # added function alias to follow principle of least surprise
  # based on previous aliasing.  --tchrist 27-Jan-00
  *fast_realpath = \&fast_abs_path;
  
  
  # --- PORTING SECTION ---
  
  # VMS: $ENV{'DEFAULT'} points to default directory at all times
  # 06-Mar-1996  Charles Bailey  bailey@newman.upenn.edu
  # Note: Use of Cwd::chdir() causes the logical name PWD to be defined
  #   in the process logical name table as the default device and directory
  #   seen by Perl. This may not be the same as the default device
  #   and directory seen by DCL after Perl exits, since the effects
  #   the CRTL chdir() function persist only until Perl exits.
  
  sub _vms_cwd {
      return $ENV{'DEFAULT'};
  }
  
  sub _vms_abs_path {
      return $ENV{'DEFAULT'} unless @_;
      my $path = shift;
  
      my $efs = _vms_efs;
      my $unix_rpt = _vms_unix_rpt;
  
      if (defined &VMS::Filespec::vmsrealpath) {
          my $path_unix = 0;
          my $path_vms = 0;
  
          $path_unix = 1 if ($path =~ m#(?<=\^)/#);
          $path_unix = 1 if ($path =~ /^\.\.?$/);
          $path_vms = 1 if ($path =~ m#[\[<\]]#);
          $path_vms = 1 if ($path =~ /^--?$/);
  
          my $unix_mode = $path_unix;
          if ($efs) {
              # In case of a tie, the Unix report mode decides.
              if ($path_vms == $path_unix) {
                  $unix_mode = $unix_rpt;
              } else {
                  $unix_mode = 0 if $path_vms;
              }
          }
  
          if ($unix_mode) {
              # Unix format
              return VMS::Filespec::unixrealpath($path);
          }
  
  	# VMS format
  
  	my $new_path = VMS::Filespec::vmsrealpath($path);
  
  	# Perl expects directories to be in directory format
  	$new_path = VMS::Filespec::pathify($new_path) if -d $path;
  	return $new_path;
      }
  
      # Fallback to older algorithm if correct ones are not
      # available.
  
      if (-l $path) {
          my $link_target = readlink($path);
          die "Can't resolve link $path: $!" unless defined $link_target;
  
          return _vms_abs_path($link_target);
      }
  
      # may need to turn foo.dir into [.foo]
      my $pathified = VMS::Filespec::pathify($path);
      $path = $pathified if defined $pathified;
  	
      return VMS::Filespec::rmsexpand($path);
  }
  
  sub _os2_cwd {
      my $pwd = `cmd /c cd`;
      chomp $pwd;
      $pwd =~ s:\\:/:g ;
      $ENV{'PWD'} = $pwd;
      return $pwd;
  }
  
  sub _win32_cwd_simple {
      my $pwd = `cd`;
      chomp $pwd;
      $pwd =~ s:\\:/:g ;
      $ENV{'PWD'} = $pwd;
      return $pwd;
  }
  
  sub _win32_cwd {
      my $pwd;
      $pwd = Win32::GetCwd();
      $pwd =~ s:\\:/:g ;
      $ENV{'PWD'} = $pwd;
      return $pwd;
  }
  
  *_NT_cwd = defined &Win32::GetCwd ? \&_win32_cwd : \&_win32_cwd_simple;
  
  sub _dos_cwd {
      my $pwd;
      if (!defined &Dos::GetCwd) {
          chomp($pwd = `command /c cd`);
          $pwd =~ s:\\:/:g ;
      } else {
          $pwd = Dos::GetCwd();
      }
      $ENV{'PWD'} = $pwd;
      return $pwd;
  }
  
  sub _qnx_cwd {
  	local $ENV{PATH} = '';
  	local $ENV{CDPATH} = '';
  	local $ENV{ENV} = '';
      my $pwd = `/usr/bin/fullpath -t`;
      chomp $pwd;
      $ENV{'PWD'} = $pwd;
      return $pwd;
  }
  
  sub _qnx_abs_path {
  	local $ENV{PATH} = '';
  	local $ENV{CDPATH} = '';
  	local $ENV{ENV} = '';
      my $path = @_ ? shift : '.';
      local *REALPATH;
  
      defined( open(REALPATH, '-|') || exec '/usr/bin/fullpath', '-t', $path ) or
        die "Can't open /usr/bin/fullpath: $!";
      my $realpath = <REALPATH>;
      close REALPATH;
      chomp $realpath;
      return $realpath;
  }
  
  sub _epoc_cwd {
      return $ENV{'PWD'} = EPOC::getcwd();
  }
  
  
  # Now that all the base-level functions are set up, alias the
  # user-level functions to the right places
  
  if (exists $METHOD_MAP{$^O}) {
    my $map = $METHOD_MAP{$^O};
    foreach my $name (keys %$map) {
      local $^W = 0;  # assignments trigger 'subroutine redefined' warning
      no strict 'refs';
      *{$name} = \&{$map->{$name}};
    }
  }
  
  # In case the XS version doesn't load.
  *abs_path = \&_perl_abs_path unless defined &abs_path;
  *getcwd = \&_perl_getcwd unless defined &getcwd;
  
  # added function alias for those of us more
  # used to the libc function.  --tchrist 27-Jan-00
  *realpath = \&abs_path;
  
  1;
  __END__
  
  =head1 NAME
  
  Cwd - get pathname of current working directory
  
  =head1 SYNOPSIS
  
      use Cwd;
      my $dir = getcwd;
  
      use Cwd 'abs_path';
      my $abs_path = abs_path($file);
  
  =head1 DESCRIPTION
  
  This module provides functions for determining the pathname of the
  current working directory.  It is recommended that getcwd (or another
  *cwd() function) be used in I<all> code to ensure portability.
  
  By default, it exports the functions cwd(), getcwd(), fastcwd(), and
  fastgetcwd() (and, on Win32, getdcwd()) into the caller's namespace.  
  
  
  =head2 getcwd and friends
  
  Each of these functions are called without arguments and return the
  absolute path of the current working directory.
  
  =over 4
  
  =item getcwd
  
      my $cwd = getcwd();
  
  Returns the current working directory.
  
  Exposes the POSIX function getcwd(3) or re-implements it if it's not
  available.
  
  =item cwd
  
      my $cwd = cwd();
  
  The cwd() is the most natural form for the current architecture.  For
  most systems it is identical to `pwd` (but without the trailing line
  terminator).
  
  =item fastcwd
  
      my $cwd = fastcwd();
  
  A more dangerous version of getcwd(), but potentially faster.
  
  It might conceivably chdir() you out of a directory that it can't
  chdir() you back into.  If fastcwd encounters a problem it will return
  undef but will probably leave you in a different directory.  For a
  measure of extra security, if everything appears to have worked, the
  fastcwd() function will check that it leaves you in the same directory
  that it started in.  If it has changed it will C<die> with the message
  "Unstable directory path, current directory changed
  unexpectedly".  That should never happen.
  
  =item fastgetcwd
  
    my $cwd = fastgetcwd();
  
  The fastgetcwd() function is provided as a synonym for cwd().
  
  =item getdcwd
  
      my $cwd = getdcwd();
      my $cwd = getdcwd('C:');
  
  The getdcwd() function is also provided on Win32 to get the current working
  directory on the specified drive, since Windows maintains a separate current
  working directory for each drive.  If no drive is specified then the current
  drive is assumed.
  
  This function simply calls the Microsoft C library _getdcwd() function.
  
  =back
  
  
  =head2 abs_path and friends
  
  These functions are exported only on request.  They each take a single
  argument and return the absolute pathname for it.  If no argument is
  given they'll use the current working directory.
  
  =over 4
  
  =item abs_path
  
    my $abs_path = abs_path($file);
  
  Uses the same algorithm as getcwd().  Symbolic links and relative-path
  components ("." and "..") are resolved to return the canonical
  pathname, just like realpath(3).
  
  =item realpath
  
    my $abs_path = realpath($file);
  
  A synonym for abs_path().
  
  =item fast_abs_path
  
    my $abs_path = fast_abs_path($file);
  
  A more dangerous, but potentially faster version of abs_path.
  
  =back
  
  =head2 $ENV{PWD}
  
  If you ask to override your chdir() built-in function, 
  
    use Cwd qw(chdir);
  
  then your PWD environment variable will be kept up to date.  Note that
  it will only be kept up to date if all packages which use chdir import
  it from Cwd.
  
  
  =head1 NOTES
  
  =over 4
  
  =item *
  
  Since the path separators are different on some operating systems ('/'
  on Unix, ':' on MacPerl, etc...) we recommend you use the File::Spec
  modules wherever portability is a concern.
  
  =item *
  
  Actually, on Mac OS, the C<getcwd()>, C<fastgetcwd()> and C<fastcwd()>
  functions are all aliases for the C<cwd()> function, which, on Mac OS,
  calls `pwd`.  Likewise, the C<abs_path()> function is an alias for
  C<fast_abs_path()>.
  
  =back
  
  =head1 AUTHOR
  
  Originally by the perl5-porters.
  
  Maintained by Ken Williams <KWILLIAMS@cpan.org>
  
  =head1 COPYRIGHT
  
  Copyright (c) 2004 by the Perl 5 Porters.  All rights reserved.
  
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  Portions of the C code in this library are copyright (c) 1994 by the
  Regents of the University of California.  All rights reserved.  The
  license on this code is compatible with the licensing of the rest of
  the distribution - please see the source code in F<Cwd.xs> for the
  details.
  
  =head1 SEE ALSO
  
  L<File::chdir>
  
  =cut
I686-LINUX-GNU-THREAD-MULTI-64INT_CWD

$fatpacked{"i686-linux-gnu-thread-multi-64int/Digest/MD5.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'I686-LINUX-GNU-THREAD-MULTI-64INT_DIGEST_MD5';
  package Digest::MD5;
  
  use strict;
  use vars qw($VERSION @ISA @EXPORT_OK);
  
  $VERSION = '2.55';
  
  require Exporter;
  *import = \&Exporter::import;
  @EXPORT_OK = qw(md5 md5_hex md5_base64);
  
  eval {
      require Digest::base;
      push(@ISA, 'Digest::base');
  };
  if ($@) {
      my $err = $@;
      *add_bits = sub { die $err };
  }
  
  
  eval {
      require XSLoader;
      XSLoader::load('Digest::MD5', $VERSION);
  };
  if ($@) {
      my $olderr = $@;
      eval {
  	# Try to load the pure perl version
  	require Digest::Perl::MD5;
  
  	Digest::Perl::MD5->import(qw(md5 md5_hex md5_base64));
  	unshift(@ISA, "Digest::Perl::MD5");  # make OO interface work
      };
      if ($@) {
  	# restore the original error
  	die $olderr;
      }
  }
  else {
      *reset = \&new;
  }
  
  1;
  __END__
  
  =head1 NAME
  
  Digest::MD5 - Perl interface to the MD5 Algorithm
  
  =head1 SYNOPSIS
  
   # Functional style
   use Digest::MD5 qw(md5 md5_hex md5_base64);
  
   $digest = md5($data);
   $digest = md5_hex($data);
   $digest = md5_base64($data);
  
   # OO style
   use Digest::MD5;
  
   $ctx = Digest::MD5->new;
  
   $ctx->add($data);
   $ctx->addfile($file_handle);
  
   $digest = $ctx->digest;
   $digest = $ctx->hexdigest;
   $digest = $ctx->b64digest;
  
  =head1 DESCRIPTION
  
  The C<Digest::MD5> module allows you to use the RSA Data Security
  Inc. MD5 Message Digest algorithm from within Perl programs.  The
  algorithm takes as input a message of arbitrary length and produces as
  output a 128-bit "fingerprint" or "message digest" of the input.
  
  Note that the MD5 algorithm is not as strong as it used to be.  It has
  since 2005 been easy to generate different messages that produce the
  same MD5 digest.  It still seems hard to generate messages that
  produce a given digest, but it is probably wise to move to stronger
  algorithms for applications that depend on the digest to uniquely identify
  a message.
  
  The C<Digest::MD5> module provide a procedural interface for simple
  use, as well as an object oriented interface that can handle messages
  of arbitrary length and which can read files directly.
  
  =head1 FUNCTIONS
  
  The following functions are provided by the C<Digest::MD5> module.
  None of these functions are exported by default.
  
  =over 4
  
  =item md5($data,...)
  
  This function will concatenate all arguments, calculate the MD5 digest
  of this "message", and return it in binary form.  The returned string
  will be 16 bytes long.
  
  The result of md5("a", "b", "c") will be exactly the same as the
  result of md5("abc").
  
  =item md5_hex($data,...)
  
  Same as md5(), but will return the digest in hexadecimal form. The
  length of the returned string will be 32 and it will only contain
  characters from this set: '0'..'9' and 'a'..'f'.
  
  =item md5_base64($data,...)
  
  Same as md5(), but will return the digest as a base64 encoded string.
  The length of the returned string will be 22 and it will only contain
  characters from this set: 'A'..'Z', 'a'..'z', '0'..'9', '+' and
  '/'.
  
  Note that the base64 encoded string returned is not padded to be a
  multiple of 4 bytes long.  If you want interoperability with other
  base64 encoded md5 digests you might want to append the redundant
  string "==" to the result.
  
  =back
  
  =head1 METHODS
  
  The object oriented interface to C<Digest::MD5> is described in this
  section.  After a C<Digest::MD5> object has been created, you will add
  data to it and finally ask for the digest in a suitable format.  A
  single object can be used to calculate multiple digests.
  
  The following methods are provided:
  
  =over 4
  
  =item $md5 = Digest::MD5->new
  
  The constructor returns a new C<Digest::MD5> object which encapsulate
  the state of the MD5 message-digest algorithm.
  
  If called as an instance method (i.e. $md5->new) it will just reset the
  state the object to the state of a newly created object.  No new
  object is created in this case.
  
  =item $md5->reset
  
  This is just an alias for $md5->new.
  
  =item $md5->clone
  
  This a copy of the $md5 object. It is useful when you do not want to
  destroy the digests state, but need an intermediate value of the
  digest, e.g. when calculating digests iteratively on a continuous data
  stream.  Example:
  
      my $md5 = Digest::MD5->new;
      while (<>) {
  	$md5->add($_);
  	print "Line $.: ", $md5->clone->hexdigest, "\n";
      }
  
  =item $md5->add($data,...)
  
  The $data provided as argument are appended to the message we
  calculate the digest for.  The return value is the $md5 object itself.
  
  All these lines will have the same effect on the state of the $md5
  object:
  
      $md5->add("a"); $md5->add("b"); $md5->add("c");
      $md5->add("a")->add("b")->add("c");
      $md5->add("a", "b", "c");
      $md5->add("abc");
  
  =item $md5->addfile($io_handle)
  
  The $io_handle will be read until EOF and its content appended to the
  message we calculate the digest for.  The return value is the $md5
  object itself.
  
  The addfile() method will croak() if it fails reading data for some
  reason.  If it croaks it is unpredictable what the state of the $md5
  object will be in. The addfile() method might have been able to read
  the file partially before it failed.  It is probably wise to discard
  or reset the $md5 object if this occurs.
  
  In most cases you want to make sure that the $io_handle is in
  C<binmode> before you pass it as argument to the addfile() method.
  
  =item $md5->add_bits($data, $nbits)
  
  =item $md5->add_bits($bitstring)
  
  Since the MD5 algorithm is byte oriented you might only add bits as
  multiples of 8, so you probably want to just use add() instead.  The
  add_bits() method is provided for compatibility with other digest
  implementations.  See L<Digest> for description of the arguments
  that add_bits() take.
  
  =item $md5->digest
  
  Return the binary digest for the message.  The returned string will be
  16 bytes long.
  
  Note that the C<digest> operation is effectively a destructive,
  read-once operation. Once it has been performed, the C<Digest::MD5>
  object is automatically C<reset> and can be used to calculate another
  digest value.  Call $md5->clone->digest if you want to calculate the
  digest without resetting the digest state.
  
  =item $md5->hexdigest
  
  Same as $md5->digest, but will return the digest in hexadecimal
  form. The length of the returned string will be 32 and it will only
  contain characters from this set: '0'..'9' and 'a'..'f'.
  
  =item $md5->b64digest
  
  Same as $md5->digest, but will return the digest as a base64 encoded
  string.  The length of the returned string will be 22 and it will only
  contain characters from this set: 'A'..'Z', 'a'..'z', '0'..'9', '+'
  and '/'.
  
  
  The base64 encoded string returned is not padded to be a multiple of 4
  bytes long.  If you want interoperability with other base64 encoded
  md5 digests you might want to append the string "==" to the result.
  
  =item @ctx = $md5->context
  
  =item $md5->context(@ctx)
  
  Saves or restores the internal state.  When called with no arguments,
  returns a 3-element list: number of blocks processed, a 16-byte
  internal state buffer, then up to 63 bytes of unprocessed data.  When
  passed those same arguments, restores the state.  This is only useful
  for specialised operations.
  
  =back
  
  
  =head1 EXAMPLES
  
  The simplest way to use this library is to import the md5_hex()
  function (or one of its cousins):
  
      use Digest::MD5 qw(md5_hex);
      print "Digest is ", md5_hex("foobarbaz"), "\n";
  
  The above example would print out the message:
  
      Digest is 6df23dc03f9b54cc38a0fc1483df6e21
  
  The same checksum can also be calculated in OO style:
  
      use Digest::MD5;
      
      $md5 = Digest::MD5->new;
      $md5->add('foo', 'bar');
      $md5->add('baz');
      $digest = $md5->hexdigest;
      
      print "Digest is $digest\n";
  
  With OO style, you can break the message arbitrarily.  This means that we
  are no longer limited to have space for the whole message in memory, i.e.
  we can handle messages of any size.
  
  This is useful when calculating checksum for files:
  
      use Digest::MD5;
  
      my $filename = shift || "/etc/passwd";
      open (my $fh, '<', $filename) or die "Can't open '$filename': $!";
      binmode($fh);
  
      $md5 = Digest::MD5->new;
      while (<$fh>) {
          $md5->add($_);
      }
      close($fh);
      print $md5->b64digest, " $filename\n";
  
  Or we can use the addfile method for more efficient reading of
  the file:
  
      use Digest::MD5;
  
      my $filename = shift || "/etc/passwd";
      open (my $fh, '<', $filename) or die "Can't open '$filename': $!";
      binmode ($fh);
  
      print Digest::MD5->new->addfile($fh)->hexdigest, " $filename\n";
  
  Since the MD5 algorithm is only defined for strings of bytes, it can not be
  used on strings that contains chars with ordinal number above 255 (Unicode
  strings).  The MD5 functions and methods will croak if you try to feed them
  such input data:
  
      use Digest::MD5 qw(md5_hex);
  
      my $str = "abc\x{300}";
      print md5_hex($str), "\n";  # croaks
      # Wide character in subroutine entry
  
  What you can do is calculate the MD5 checksum of the UTF-8
  representation of such strings.  This is achieved by filtering the
  string through encode_utf8() function:
  
      use Digest::MD5 qw(md5_hex);
      use Encode qw(encode_utf8);
  
      my $str = "abc\x{300}";
      print md5_hex(encode_utf8($str)), "\n";
      # 8c2d46911f3f5a326455f0ed7a8ed3b3
  
  =head1 SEE ALSO
  
  L<Digest>,
  L<Digest::MD2>,
  L<Digest::SHA>,
  L<Digest::HMAC>
  
  L<md5sum(1)>
  
  RFC 1321
  
  http://en.wikipedia.org/wiki/MD5
  
  The paper "How to Break MD5 and Other Hash Functions" by Xiaoyun Wang
  and Hongbo Yu.
  
  =head1 COPYRIGHT
  
  This library is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
   Copyright 1998-2003 Gisle Aas.
   Copyright 1995-1996 Neil Winton.
   Copyright 1991-1992 RSA Data Security, Inc.
  
  The MD5 algorithm is defined in RFC 1321. This implementation is
  derived from the reference C code in RFC 1321 which is covered by
  the following copyright statement:
  
  =over 4
  
  =item
  
  Copyright (C) 1991-2, RSA Data Security, Inc. Created 1991. All
  rights reserved.
  
  License to copy and use this software is granted provided that it
  is identified as the "RSA Data Security, Inc. MD5 Message-Digest
  Algorithm" in all material mentioning or referencing this software
  or this function.
  
  License is also granted to make and use derivative works provided
  that such works are identified as "derived from the RSA Data
  Security, Inc. MD5 Message-Digest Algorithm" in all material
  mentioning or referencing the derived work.
  
  RSA Data Security, Inc. makes no representations concerning either
  the merchantability of this software or the suitability of this
  software for any particular purpose. It is provided "as is"
  without express or implied warranty of any kind.
  
  These notices must be retained in any copies of any part of this
  documentation and/or software.
  
  =back
  
  This copyright does not prohibit distribution of any version of Perl
  containing this extension under the terms of the GNU or Artistic
  licenses.
  
  =head1 AUTHORS
  
  The original C<MD5> interface was written by Neil Winton
  (C<N.Winton@axion.bt.co.uk>).
  
  The C<Digest::MD5> module is written by Gisle Aas <gisle@ActiveState.com>.
  
  =cut
I686-LINUX-GNU-THREAD-MULTI-64INT_DIGEST_MD5

$fatpacked{"i686-linux-gnu-thread-multi-64int/Digest/SHA.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'I686-LINUX-GNU-THREAD-MULTI-64INT_DIGEST_SHA';
  package Digest::SHA;
  
  require 5.003000;
  
  use strict;
  use warnings;
  use vars qw($VERSION @ISA @EXPORT_OK);
  use Fcntl qw(O_RDONLY);
  use integer;
  
  $VERSION = '5.96';
  
  require Exporter;
  require DynaLoader;
  @ISA = qw(Exporter DynaLoader);
  @EXPORT_OK = qw(
  	hmac_sha1	hmac_sha1_base64	hmac_sha1_hex
  	hmac_sha224	hmac_sha224_base64	hmac_sha224_hex
  	hmac_sha256	hmac_sha256_base64	hmac_sha256_hex
  	hmac_sha384	hmac_sha384_base64	hmac_sha384_hex
  	hmac_sha512	hmac_sha512_base64	hmac_sha512_hex
  	hmac_sha512224	hmac_sha512224_base64	hmac_sha512224_hex
  	hmac_sha512256	hmac_sha512256_base64	hmac_sha512256_hex
  	sha1		sha1_base64		sha1_hex
  	sha224		sha224_base64		sha224_hex
  	sha256		sha256_base64		sha256_hex
  	sha384		sha384_base64		sha384_hex
  	sha512		sha512_base64		sha512_hex
  	sha512224	sha512224_base64	sha512224_hex
  	sha512256	sha512256_base64	sha512256_hex);
  
  # Inherit from Digest::base if possible
  
  eval {
  	require Digest::base;
  	push(@ISA, 'Digest::base');
  };
  
  # The following routines aren't time-critical, so they can be left in Perl
  
  sub new {
  	my($class, $alg) = @_;
  	$alg =~ s/\D+//g if defined $alg;
  	if (ref($class)) {	# instance method
  		if (!defined($alg) || ($alg == $class->algorithm)) {
  			sharewind($class);
  			return($class);
  		}
  		return shainit($class, $alg) ? $class : undef;
  	}
  	$alg = 1 unless defined $alg;
  	return $class->newSHA($alg);
  }
  
  BEGIN { *reset = \&new }
  
  sub add_bits {
  	my($self, $data, $nbits) = @_;
  	unless (defined $nbits) {
  		$nbits = length($data);
  		$data = pack("B*", $data);
  	}
  	$nbits = length($data) * 8 if $nbits > length($data) * 8;
  	shawrite($data, $nbits, $self);
  	return($self);
  }
  
  sub _bail {
  	my $msg = shift;
  
  	$msg .= ": $!";
  	require Carp;
  	Carp::croak($msg);
  }
  
  {
  	my $_can_T_filehandle;
  
  	sub _istext {
  		local *FH = shift;
  		my $file = shift;
  
  		if (! defined $_can_T_filehandle) {
  			local $^W = 0;
  			my $istext = eval { -T FH };
  			$_can_T_filehandle = $@ ? 0 : 1;
  			return $_can_T_filehandle ? $istext : -T $file;
  		}
  		return $_can_T_filehandle ? -T FH : -T $file;
  	}
  }
  
  sub _addfile {
  	my ($self, $handle) = @_;
  
  	my $n;
  	my $buf = "";
  
  	while (($n = read($handle, $buf, 4096))) {
  		$self->add($buf);
  	}
  	_bail("Read failed") unless defined $n;
  
  	$self;
  }
  
  sub addfile {
  	my ($self, $file, $mode) = @_;
  
  	return(_addfile($self, $file)) unless ref(\$file) eq 'SCALAR';
  
  	$mode = defined($mode) ? $mode : "";
  	my ($binary, $UNIVERSAL, $BITS, $portable) =
  		map { $_ eq $mode } ("b", "U", "0", "p");
  
  		## Always interpret "-" to mean STDIN; otherwise use
  		## sysopen to handle full range of POSIX file names
  
  	local *FH;
  	$file eq '-' and open(FH, '< -')
  		or sysopen(FH, $file, O_RDONLY)
  			or _bail('Open failed');
  
  	if ($BITS) {
  		my ($n, $buf) = (0, "");
  		while (($n = read(FH, $buf, 4096))) {
  			$buf =~ s/[^01]//g;
  			$self->add_bits($buf);
  		}
  		_bail("Read failed") unless defined $n;
  		close(FH);
  		return($self);
  	}
  
  	binmode(FH) if $binary || $portable || $UNIVERSAL;
  	if ($UNIVERSAL && _istext(*FH, $file)) {
  		$self->_addfileuniv(*FH);
  	}
  	elsif ($portable && _istext(*FH, $file)) {
  		while (<FH>) {
  			s/\015?\015\012/\012/g;
  			s/\015/\012/g;
  			$self->add($_);
  		}
  	}
  	else { $self->_addfilebin(*FH) }
  	close(FH);
  
  	$self;
  }
  
  sub getstate {
  	my $self = shift;
  
  	my $alg = $self->algorithm or return;
  	my $state = $self->_getstate or return;
  	my $nD = $alg <= 256 ?  8 :  16;
  	my $nH = $alg <= 256 ? 32 :  64;
  	my $nB = $alg <= 256 ? 64 : 128;
  	my($H, $block, $blockcnt, $lenhh, $lenhl, $lenlh, $lenll) =
  		$state =~ /^(.{$nH})(.{$nB})(.{4})(.{4})(.{4})(.{4})(.{4})$/s;
  	for ($alg, $H, $block, $blockcnt, $lenhh, $lenhl, $lenlh, $lenll) {
  		return unless defined $_;
  	}
  
  	my @s = ();
  	push(@s, "alg:" . $alg);
  	push(@s, "H:" . join(":", unpack("H*", $H) =~ /.{$nD}/g));
  	push(@s, "block:" . join(":", unpack("H*", $block) =~ /.{2}/g));
  	push(@s, "blockcnt:" . unpack("N", $blockcnt));
  	push(@s, "lenhh:" . unpack("N", $lenhh));
  	push(@s, "lenhl:" . unpack("N", $lenhl));
  	push(@s, "lenlh:" . unpack("N", $lenlh));
  	push(@s, "lenll:" . unpack("N", $lenll));
  	join("\n", @s) . "\n";
  }
  
  sub putstate {
  	my($class, $state) = @_;
  
  	my %s = ();
  	for (split(/\n/, $state)) {
  		s/^\s+//;
  		s/\s+$//;
  		next if (/^(#|$)/);
  		my @f = split(/[:\s]+/);
  		my $tag = shift(@f);
  		$s{$tag} = join('', @f);
  	}
  
  	# H and block may contain arbitrary values, but check everything else
  	grep { $_ == $s{'alg'} } (1,224,256,384,512,512224,512256) or return;
  	length($s{'H'}) == ($s{'alg'} <= 256 ? 64 : 128) or return;
  	length($s{'block'}) == ($s{'alg'} <= 256 ? 128 : 256) or return;
  	{
  		no integer;
  		for (qw(blockcnt lenhh lenhl lenlh lenll)) {
  			0 <= $s{$_} or return;
  			$s{$_} <= 4294967295 or return;
  		}
  		$s{'blockcnt'} < ($s{'alg'} <= 256 ? 512 : 1024) or return;
  	}
  
  	my $packed_state = (
  		pack("H*", $s{'H'}) .
  		pack("H*", $s{'block'}) .
  		pack("N",  $s{'blockcnt'}) .
  		pack("N",  $s{'lenhh'}) .
  		pack("N",  $s{'lenhl'}) .
  		pack("N",  $s{'lenlh'}) .
  		pack("N",  $s{'lenll'})
  	);
  
  	return $class->new($s{'alg'})->_putstate($packed_state);
  }
  
  sub dump {
  	my $self = shift;
  	my $file = shift;
  
  	my $state = $self->getstate or return;
  	$file = "-" if (!defined($file) || $file eq "");
  
  	local *FH;
  	open(FH, "> $file") or return;
  	print FH $state;
  	close(FH);
  
  	return($self);
  }
  
  sub load {
  	my $class = shift;
  	my $file = shift;
  
  	$file = "-" if (!defined($file) || $file eq "");
  
  	local *FH;
  	open(FH, "< $file") or return;
  	my $str = join('', <FH>);
  	close(FH);
  
  	$class->putstate($str);
  }
  
  Digest::SHA->bootstrap($VERSION);
  
  1;
  __END__
  
  =head1 NAME
  
  Digest::SHA - Perl extension for SHA-1/224/256/384/512
  
  =head1 SYNOPSIS
  
  In programs:
  
  		# Functional interface
  
  	use Digest::SHA qw(sha1 sha1_hex sha1_base64 ...);
  
  	$digest = sha1($data);
  	$digest = sha1_hex($data);
  	$digest = sha1_base64($data);
  
  	$digest = sha256($data);
  	$digest = sha384_hex($data);
  	$digest = sha512_base64($data);
  
  		# Object-oriented
  
  	use Digest::SHA;
  
  	$sha = Digest::SHA->new($alg);
  
  	$sha->add($data);		# feed data into stream
  
  	$sha->addfile(*F);
  	$sha->addfile($filename);
  
  	$sha->add_bits($bits);
  	$sha->add_bits($data, $nbits);
  
  	$sha_copy = $sha->clone;	# make copy of digest object
  	$state = $sha->getstate;	# save current state to string
  	$sha->putstate($state);		# restore previous $state
  
  	$digest = $sha->digest;		# compute digest
  	$digest = $sha->hexdigest;
  	$digest = $sha->b64digest;
  
  From the command line:
  
  	$ shasum files
  
  	$ shasum --help
  
  =head1 SYNOPSIS (HMAC-SHA)
  
  		# Functional interface only
  
  	use Digest::SHA qw(hmac_sha1 hmac_sha1_hex ...);
  
  	$digest = hmac_sha1($data, $key);
  	$digest = hmac_sha224_hex($data, $key);
  	$digest = hmac_sha256_base64($data, $key);
  
  =head1 ABSTRACT
  
  Digest::SHA is a complete implementation of the NIST Secure Hash Standard.
  It gives Perl programmers a convenient way to calculate SHA-1, SHA-224,
  SHA-256, SHA-384, SHA-512, SHA-512/224, and SHA-512/256 message digests.
  The module can handle all types of input, including partial-byte data.
  
  =head1 DESCRIPTION
  
  Digest::SHA is written in C for speed.  If your platform lacks a
  C compiler, you can install the functionally equivalent (but much
  slower) L<Digest::SHA::PurePerl> module.
  
  The programming interface is easy to use: it's the same one found
  in CPAN's L<Digest> module.  So, if your applications currently
  use L<Digest::MD5> and you'd prefer the stronger security of SHA,
  it's a simple matter to convert them.
  
  The interface provides two ways to calculate digests:  all-at-once,
  or in stages.  To illustrate, the following short program computes
  the SHA-256 digest of "hello world" using each approach:
  
  	use Digest::SHA qw(sha256_hex);
  
  	$data = "hello world";
  	@frags = split(//, $data);
  
  	# all-at-once (Functional style)
  	$digest1 = sha256_hex($data);
  
  	# in-stages (OOP style)
  	$state = Digest::SHA->new(256);
  	for (@frags) { $state->add($_) }
  	$digest2 = $state->hexdigest;
  
  	print $digest1 eq $digest2 ?
  		"whew!\n" : "oops!\n";
  
  To calculate the digest of an n-bit message where I<n> is not a
  multiple of 8, use the I<add_bits()> method.  For example, consider
  the 446-bit message consisting of the bit-string "110" repeated
  148 times, followed by "11".  Here's how to display its SHA-1
  digest:
  
  	use Digest::SHA;
  	$bits = "110" x 148 . "11";
  	$sha = Digest::SHA->new(1)->add_bits($bits);
  	print $sha->hexdigest, "\n";
  
  Note that for larger bit-strings, it's more efficient to use the
  two-argument version I<add_bits($data, $nbits)>, where I<$data> is
  in the customary packed binary format used for Perl strings.
  
  The module also lets you save intermediate SHA states to a string.  The
  I<getstate()> method generates portable, human-readable text describing
  the current state of computation.  You can subsequently restore that
  state with I<putstate()> to resume where the calculation left off.
  
  To see what a state description looks like, just run the following:
  
  	use Digest::SHA;
  	print Digest::SHA->new->add("Shaw" x 1962)->getstate;
  
  As an added convenience, the Digest::SHA module offers routines to
  calculate keyed hashes using the HMAC-SHA-1/224/256/384/512
  algorithms.  These services exist in functional form only, and
  mimic the style and behavior of the I<sha()>, I<sha_hex()>, and
  I<sha_base64()> functions.
  
  	# Test vector from draft-ietf-ipsec-ciph-sha-256-01.txt
  
  	use Digest::SHA qw(hmac_sha256_hex);
  	print hmac_sha256_hex("Hi There", chr(0x0b) x 32), "\n";
  
  =head1 UNICODE AND SIDE EFFECTS
  
  Perl supports Unicode strings as of version 5.6.  Such strings may
  contain wide characters, namely, characters whose ordinal values are
  greater than 255.  This can cause problems for digest algorithms such
  as SHA that are specified to operate on sequences of bytes.
  
  The rule by which Digest::SHA handles a Unicode string is easy
  to state, but potentially confusing to grasp: the string is interpreted
  as a sequence of byte values, where each byte value is equal to the
  ordinal value (viz. code point) of its corresponding Unicode character.
  That way, the Unicode string 'abc' has exactly the same digest value as
  the ordinary string 'abc'.
  
  Since a wide character does not fit into a byte, the Digest::SHA
  routines croak if they encounter one.  Whereas if a Unicode string
  contains no wide characters, the module accepts it quite happily.
  The following code illustrates the two cases:
  
  	$str1 = pack('U*', (0..255));
  	print sha1_hex($str1);		# ok
  
  	$str2 = pack('U*', (0..256));
  	print sha1_hex($str2);		# croaks
  
  Be aware that the digest routines silently convert UTF-8 input into its
  equivalent byte sequence in the native encoding (cf. utf8::downgrade).
  This side effect influences only the way Perl stores the data internally,
  but otherwise leaves the actual value of the data intact.
  
  =head1 NIST STATEMENT ON SHA-1
  
  NIST acknowledges that the work of Prof. Xiaoyun Wang constitutes a
  practical collision attack on SHA-1.  Therefore, NIST encourages the
  rapid adoption of the SHA-2 hash functions (e.g. SHA-256) for applications
  requiring strong collision resistance, such as digital signatures.
  
  ref. L<http://csrc.nist.gov/groups/ST/hash/statement.html>
  
  =head1 PADDING OF BASE64 DIGESTS
  
  By convention, CPAN Digest modules do B<not> pad their Base64 output.
  Problems can occur when feeding such digests to other software that
  expects properly padded Base64 encodings.
  
  For the time being, any necessary padding must be done by the user.
  Fortunately, this is a simple operation: if the length of a Base64-encoded
  digest isn't a multiple of 4, simply append "=" characters to the end
  of the digest until it is:
  
  	while (length($b64_digest) % 4) {
  		$b64_digest .= '=';
  	}
  
  To illustrate, I<sha256_base64("abc")> is computed to be
  
  	ungWv48Bz+pBQUDeXa4iI7ADYaOWF3qctBD/YfIAFa0
  
  which has a length of 43.  So, the properly padded version is
  
  	ungWv48Bz+pBQUDeXa4iI7ADYaOWF3qctBD/YfIAFa0=
  
  =head1 EXPORT
  
  None by default.
  
  =head1 EXPORTABLE FUNCTIONS
  
  Provided your C compiler supports a 64-bit type (e.g. the I<long
  long> of C99, or I<__int64> used by Microsoft C/C++), all of these
  functions will be available for use.  Otherwise, you won't be able
  to perform the SHA-384 and SHA-512 transforms, both of which require
  64-bit operations.
  
  I<Functional style>
  
  =over 4
  
  =item B<sha1($data, ...)>
  
  =item B<sha224($data, ...)>
  
  =item B<sha256($data, ...)>
  
  =item B<sha384($data, ...)>
  
  =item B<sha512($data, ...)>
  
  =item B<sha512224($data, ...)>
  
  =item B<sha512256($data, ...)>
  
  Logically joins the arguments into a single string, and returns
  its SHA-1/224/256/384/512 digest encoded as a binary string.
  
  =item B<sha1_hex($data, ...)>
  
  =item B<sha224_hex($data, ...)>
  
  =item B<sha256_hex($data, ...)>
  
  =item B<sha384_hex($data, ...)>
  
  =item B<sha512_hex($data, ...)>
  
  =item B<sha512224_hex($data, ...)>
  
  =item B<sha512256_hex($data, ...)>
  
  Logically joins the arguments into a single string, and returns
  its SHA-1/224/256/384/512 digest encoded as a hexadecimal string.
  
  =item B<sha1_base64($data, ...)>
  
  =item B<sha224_base64($data, ...)>
  
  =item B<sha256_base64($data, ...)>
  
  =item B<sha384_base64($data, ...)>
  
  =item B<sha512_base64($data, ...)>
  
  =item B<sha512224_base64($data, ...)>
  
  =item B<sha512256_base64($data, ...)>
  
  Logically joins the arguments into a single string, and returns
  its SHA-1/224/256/384/512 digest encoded as a Base64 string.
  
  It's important to note that the resulting string does B<not> contain
  the padding characters typical of Base64 encodings.  This omission is
  deliberate, and is done to maintain compatibility with the family of
  CPAN Digest modules.  See L</"PADDING OF BASE64 DIGESTS"> for details.
  
  =back
  
  I<OOP style>
  
  =over 4
  
  =item B<new($alg)>
  
  Returns a new Digest::SHA object.  Allowed values for I<$alg> are 1,
  224, 256, 384, 512, 512224, or 512256.  It's also possible to use
  common string representations of the algorithm (e.g. "sha256",
  "SHA-384").  If the argument is missing, SHA-1 will be used by
  default.
  
  Invoking I<new> as an instance method will reset the object to the
  initial state associated with I<$alg>.  If the argument is missing,
  the object will continue using the same algorithm that was selected
  at creation.
  
  =item B<reset($alg)>
  
  This method has exactly the same effect as I<new($alg)>.  In fact,
  I<reset> is just an alias for I<new>.
  
  =item B<hashsize>
  
  Returns the number of digest bits for this object.  The values are
  160, 224, 256, 384, 512, 224, and 256 for SHA-1, SHA-224, SHA-256,
  SHA-384, SHA-512, SHA-512/224 and SHA-512/256, respectively.
  
  =item B<algorithm>
  
  Returns the digest algorithm for this object.  The values are 1,
  224, 256, 384, 512, 512224, and 512256 for SHA-1, SHA-224, SHA-256,
  SHA-384, SHA-512, SHA-512/224, and SHA-512/256, respectively.
  
  =item B<clone>
  
  Returns a duplicate copy of the object.
  
  =item B<add($data, ...)>
  
  Logically joins the arguments into a single string, and uses it to
  update the current digest state.  In other words, the following
  statements have the same effect:
  
  	$sha->add("a"); $sha->add("b"); $sha->add("c");
  	$sha->add("a")->add("b")->add("c");
  	$sha->add("a", "b", "c");
  	$sha->add("abc");
  
  The return value is the updated object itself.
  
  =item B<add_bits($data, $nbits)>
  
  =item B<add_bits($bits)>
  
  Updates the current digest state by appending bits to it.  The
  return value is the updated object itself.
  
  The first form causes the most-significant I<$nbits> of I<$data>
  to be appended to the stream.  The I<$data> argument is in the
  customary binary format used for Perl strings.
  
  The second form takes an ASCII string of "0" and "1" characters as
  its argument.  It's equivalent to
  
  	$sha->add_bits(pack("B*", $bits), length($bits));
  
  So, the following two statements do the same thing:
  
  	$sha->add_bits("111100001010");
  	$sha->add_bits("\xF0\xA0", 12);
  
  Note that SHA-1 and SHA-2 use I<most-significant-bit ordering>
  for their internal state.  This means that
  
  	$sha3->add_bits("110");
  
  is equivalent to
  
  	$sha3->add_bits("1")->add_bits("1")->add_bits("0");
  
  =item B<addfile(*FILE)>
  
  Reads from I<FILE> until EOF, and appends that data to the current
  state.  The return value is the updated object itself.
  
  =item B<addfile($filename [, $mode])>
  
  Reads the contents of I<$filename>, and appends that data to the current
  state.  The return value is the updated object itself.
  
  By default, I<$filename> is simply opened and read; no special modes
  or I/O disciplines are used.  To change this, set the optional I<$mode>
  argument to one of the following values:
  
  	"b"	read file in binary mode
  
  	"U"	use universal newlines
  
  	"0"	use BITS mode
  
  	"p"	use portable mode (to be deprecated)
  
  The "U" mode is modeled on Python's "Universal Newlines" concept, whereby
  DOS and Mac OS line terminators are converted internally to UNIX newlines
  before processing.  This ensures consistent digest values when working
  simultaneously across multiple file systems.  B<The "U" mode influences
  only text files>, namely those passing Perl's I<-T> test; binary files
  are processed with no translation whatsoever.
  
  The "p" mode differs from "U" only in that it treats "\r\r\n" as a single
  newline, a quirky feature designed to accommodate legacy applications that
  occasionally added an extra carriage return before DOS line terminators.
  The "p" mode will be phased out eventually in favor of the cleaner and
  more well-established Universal Newlines concept.
  
  The BITS mode ("0") interprets the contents of I<$filename> as a logical
  stream of bits, where each ASCII '0' or '1' character represents a 0 or
  1 bit, respectively.  All other characters are ignored.  This provides
  a convenient way to calculate the digest values of partial-byte data
  by using files, rather than having to write separate programs employing
  the I<add_bits> method.
  
  =item B<getstate>
  
  Returns a string containing a portable, human-readable representation
  of the current SHA state.
  
  =item B<putstate($str)>
  
  Returns a Digest::SHA object representing the SHA state contained
  in I<$str>.  The format of I<$str> matches the format of the output
  produced by method I<getstate>.  If called as a class method, a new
  object is created; if called as an instance method, the object is reset
  to the state contained in I<$str>.
  
  =item B<dump($filename)>
  
  Writes the output of I<getstate> to I<$filename>.  If the argument is
  missing, or equal to the empty string, the state information will be
  written to STDOUT.
  
  =item B<load($filename)>
  
  Returns a Digest::SHA object that results from calling I<putstate> on
  the contents of I<$filename>.  If the argument is missing, or equal to
  the empty string, the state information will be read from STDIN.
  
  =item B<digest>
  
  Returns the digest encoded as a binary string.
  
  Note that the I<digest> method is a read-once operation. Once it
  has been performed, the Digest::SHA object is automatically reset
  in preparation for calculating another digest value.  Call
  I<$sha-E<gt>clone-E<gt>digest> if it's necessary to preserve the
  original digest state.
  
  =item B<hexdigest>
  
  Returns the digest encoded as a hexadecimal string.
  
  Like I<digest>, this method is a read-once operation.  Call
  I<$sha-E<gt>clone-E<gt>hexdigest> if it's necessary to preserve
  the original digest state.
  
  =item B<b64digest>
  
  Returns the digest encoded as a Base64 string.
  
  Like I<digest>, this method is a read-once operation.  Call
  I<$sha-E<gt>clone-E<gt>b64digest> if it's necessary to preserve
  the original digest state.
  
  It's important to note that the resulting string does B<not> contain
  the padding characters typical of Base64 encodings.  This omission is
  deliberate, and is done to maintain compatibility with the family of
  CPAN Digest modules.  See L</"PADDING OF BASE64 DIGESTS"> for details.
  
  =back
  
  I<HMAC-SHA-1/224/256/384/512>
  
  =over 4
  
  =item B<hmac_sha1($data, $key)>
  
  =item B<hmac_sha224($data, $key)>
  
  =item B<hmac_sha256($data, $key)>
  
  =item B<hmac_sha384($data, $key)>
  
  =item B<hmac_sha512($data, $key)>
  
  =item B<hmac_sha512224($data, $key)>
  
  =item B<hmac_sha512256($data, $key)>
  
  Returns the HMAC-SHA-1/224/256/384/512 digest of I<$data>/I<$key>,
  with the result encoded as a binary string.  Multiple I<$data>
  arguments are allowed, provided that I<$key> is the last argument
  in the list.
  
  =item B<hmac_sha1_hex($data, $key)>
  
  =item B<hmac_sha224_hex($data, $key)>
  
  =item B<hmac_sha256_hex($data, $key)>
  
  =item B<hmac_sha384_hex($data, $key)>
  
  =item B<hmac_sha512_hex($data, $key)>
  
  =item B<hmac_sha512224_hex($data, $key)>
  
  =item B<hmac_sha512256_hex($data, $key)>
  
  Returns the HMAC-SHA-1/224/256/384/512 digest of I<$data>/I<$key>,
  with the result encoded as a hexadecimal string.  Multiple I<$data>
  arguments are allowed, provided that I<$key> is the last argument
  in the list.
  
  =item B<hmac_sha1_base64($data, $key)>
  
  =item B<hmac_sha224_base64($data, $key)>
  
  =item B<hmac_sha256_base64($data, $key)>
  
  =item B<hmac_sha384_base64($data, $key)>
  
  =item B<hmac_sha512_base64($data, $key)>
  
  =item B<hmac_sha512224_base64($data, $key)>
  
  =item B<hmac_sha512256_base64($data, $key)>
  
  Returns the HMAC-SHA-1/224/256/384/512 digest of I<$data>/I<$key>,
  with the result encoded as a Base64 string.  Multiple I<$data>
  arguments are allowed, provided that I<$key> is the last argument
  in the list.
  
  It's important to note that the resulting string does B<not> contain
  the padding characters typical of Base64 encodings.  This omission is
  deliberate, and is done to maintain compatibility with the family of
  CPAN Digest modules.  See L</"PADDING OF BASE64 DIGESTS"> for details.
  
  =back
  
  =head1 SEE ALSO
  
  L<Digest>, L<Digest::SHA::PurePerl>
  
  The Secure Hash Standard (Draft FIPS PUB 180-4) can be found at:
  
  L<http://csrc.nist.gov/publications/drafts/fips180-4/Draft-FIPS180-4_Feb2011.pdf>
  
  The Keyed-Hash Message Authentication Code (HMAC):
  
  L<http://csrc.nist.gov/publications/fips/fips198/fips-198a.pdf>
  
  =head1 AUTHOR
  
  	Mark Shelor	<mshelor@cpan.org>
  
  =head1 ACKNOWLEDGMENTS
  
  The author is particularly grateful to
  
  	Gisle Aas
  	H. Merijn Brand
  	Sean Burke
  	Chris Carey
  	Alexandr Ciornii
  	Jim Doble
  	Thomas Drugeon
  	Julius Duque
  	Jeffrey Friedl
  	Robert Gilmour
  	Brian Gladman
  	Jarkko Hietaniemi
  	Adam Kennedy
  	Mark Lawrence
  	Andy Lester
  	Alex Muntada
  	Steve Peters
  	Chris Skiscim
  	Martin Thurn
  	Gunnar Wolf
  	Adam Woodbury
  
  "who by trained skill rescued life from such great billows and such thick
  darkness and moored it in so perfect a calm and in so brilliant a light"
  - Lucretius
  
  =head1 COPYRIGHT AND LICENSE
  
  Copyright (C) 2003-2016 Mark Shelor
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  L<perlartistic>
  
  =cut
I686-LINUX-GNU-THREAD-MULTI-64INT_DIGEST_SHA

$fatpacked{"i686-linux-gnu-thread-multi-64int/Encode.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'I686-LINUX-GNU-THREAD-MULTI-64INT_ENCODE';
  #
  # $Id: Encode.pm,v 2.88 2016/11/29 23:30:30 dankogai Exp dankogai $
  #
  package Encode;
  use strict;
  use warnings;
  our $VERSION = sprintf "%d.%02d", q$Revision: 2.88 $ =~ /(\d+)/g;
  use constant DEBUG => !!$ENV{PERL_ENCODE_DEBUG};
  use XSLoader ();
  XSLoader::load( __PACKAGE__, $VERSION );
  
  use Exporter 5.57 'import';
  
  # Public, encouraged API is exported by default
  
  our @EXPORT = qw(
    decode  decode_utf8  encode  encode_utf8 str2bytes bytes2str
    encodings  find_encoding find_mime_encoding clone_encoding
  );
  our @FB_FLAGS = qw(
    DIE_ON_ERR WARN_ON_ERR RETURN_ON_ERR LEAVE_SRC
    PERLQQ HTMLCREF XMLCREF STOP_AT_PARTIAL
  );
  our @FB_CONSTS = qw(
    FB_DEFAULT FB_CROAK FB_QUIET FB_WARN
    FB_PERLQQ FB_HTMLCREF FB_XMLCREF
  );
  our @EXPORT_OK = (
      qw(
        _utf8_off _utf8_on define_encoding from_to is_16bit is_8bit
        is_utf8 perlio_ok resolve_alias utf8_downgrade utf8_upgrade
        ),
      @FB_FLAGS, @FB_CONSTS,
  );
  
  our %EXPORT_TAGS = (
      all          => [ @EXPORT,    @EXPORT_OK ],
      default      => [ @EXPORT ],
      fallbacks    => [ @FB_CONSTS ],
      fallback_all => [ @FB_CONSTS, @FB_FLAGS ],
  );
  
  # Documentation moved after __END__ for speed - NI-S
  
  our $ON_EBCDIC = ( ord("A") == 193 );
  
  use Encode::Alias;
  
  # Make a %Encoding package variable to allow a certain amount of cheating
  our %Encoding;
  our %ExtModule;
  require Encode::Config;
  #  See
  #  https://bugzilla.redhat.com/show_bug.cgi?id=435505#c2
  #  to find why sig handlers inside eval{} are disabled.
  eval {
      local $SIG{__DIE__};
      local $SIG{__WARN__};
      local @INC = @INC;
      pop @INC if $INC[-1] eq '.';
      require Encode::ConfigLocal;
  };
  
  sub encodings {
      my %enc;
      my $arg  = $_[1] || '';
      if ( $arg eq ":all" ) {
          %enc = ( %Encoding, %ExtModule );
      }
      else {
          %enc = %Encoding;
          for my $mod ( map { m/::/ ? $_ : "Encode::$_" } @_ ) {
              DEBUG and warn $mod;
              for my $enc ( keys %ExtModule ) {
                  $ExtModule{$enc} eq $mod and $enc{$enc} = $mod;
              }
          }
      }
      return sort { lc $a cmp lc $b }
        grep      { !/^(?:Internal|Unicode|Guess)$/o } keys %enc;
  }
  
  sub perlio_ok {
      my $obj = ref( $_[0] ) ? $_[0] : find_encoding( $_[0] );
      $obj->can("perlio_ok") and return $obj->perlio_ok();
      return 0;    # safety net
  }
  
  sub define_encoding {
      my $obj  = shift;
      my $name = shift;
      $Encoding{$name} = $obj;
      my $lc = lc($name);
      define_alias( $lc => $obj ) unless $lc eq $name;
      while (@_) {
          my $alias = shift;
          define_alias( $alias, $obj );
      }
      return $obj;
  }
  
  sub getEncoding {
      my ( $class, $name, $skip_external ) = @_;
  
      defined($name) or return;
  
      $name =~ s/\s+//g; # https://rt.cpan.org/Ticket/Display.html?id=65796
  
      ref($name) && $name->can('renew') and return $name;
      exists $Encoding{$name} and return $Encoding{$name};
      my $lc = lc $name;
      exists $Encoding{$lc} and return $Encoding{$lc};
  
      my $oc = $class->find_alias($name);
      defined($oc) and return $oc;
      $lc ne $name and $oc = $class->find_alias($lc);
      defined($oc) and return $oc;
  
      unless ($skip_external) {
          if ( my $mod = $ExtModule{$name} || $ExtModule{$lc} ) {
              $mod =~ s,::,/,g;
              $mod .= '.pm';
              eval { require $mod; };
              exists $Encoding{$name} and return $Encoding{$name};
          }
      }
      return;
  }
  
  sub find_encoding($;$) {
      my ( $name, $skip_external ) = @_;
      return __PACKAGE__->getEncoding( $name, $skip_external );
  }
  
  sub find_mime_encoding($;$) {
      my ( $mime_name, $skip_external ) = @_;
      eval { require Encode::MIME::Name; };
      $@ and return;
      my $name = Encode::MIME::Name::get_encode_name( $mime_name );
      return find_encoding( $name, $skip_external );
  }
  
  sub resolve_alias($) {
      my $obj = find_encoding(shift);
      defined $obj and return $obj->name;
      return;
  }
  
  sub clone_encoding($) {
      my $obj = find_encoding(shift);
      ref $obj or return;
      eval { require Storable };
      $@ and return;
      return Storable::dclone($obj);
  }
  
  sub encode($$;$) {
      my ( $name, $string, $check ) = @_;
      return undef unless defined $string;
      $string .= '';    # stringify;
      $check ||= 0;
      unless ( defined $name ) {
          require Carp;
          Carp::croak("Encoding name should not be undef");
      }
      my $enc = find_encoding($name);
      unless ( defined $enc ) {
          require Carp;
          Carp::croak("Unknown encoding '$name'");
      }
      # For Unicode, warnings need to be caught and re-issued at this level
      # so that callers can disable utf8 warnings lexically.
      my $octets;
      if ( ref($enc) eq 'Encode::Unicode' ) {
          my $warn = '';
          {
              local $SIG{__WARN__} = sub { $warn = shift };
              $octets = $enc->encode( $string, $check );
          }
          warnings::warnif('utf8', $warn) if length $warn;
      }
      else {
          $octets = $enc->encode( $string, $check );
      }
      $_[1] = $string if $check and !ref $check and !( $check & LEAVE_SRC() );
      return $octets;
  }
  *str2bytes = \&encode;
  
  sub decode($$;$) {
      my ( $name, $octets, $check ) = @_;
      return undef unless defined $octets;
      $octets .= '';
      $check ||= 0;
      my $enc = find_encoding($name);
      unless ( defined $enc ) {
          require Carp;
          Carp::croak("Unknown encoding '$name'");
      }
      # For Unicode, warnings need to be caught and re-issued at this level
      # so that callers can disable utf8 warnings lexically.
      my $string;
      if ( ref($enc) eq 'Encode::Unicode' ) {
          my $warn = '';
          {
              local $SIG{__WARN__} = sub { $warn = shift };
              $string = $enc->decode( $octets, $check );
          }
          warnings::warnif('utf8', $warn) if length $warn;
      }
      else {
          $string = $enc->decode( $octets, $check );
      }
      $_[1] = $octets if $check and !ref $check and !( $check & LEAVE_SRC() );
      return $string;
  }
  *bytes2str = \&decode;
  
  sub from_to($$$;$) {
      my ( $string, $from, $to, $check ) = @_;
      return undef unless defined $string;
      $check ||= 0;
      my $f = find_encoding($from);
      unless ( defined $f ) {
          require Carp;
          Carp::croak("Unknown encoding '$from'");
      }
      my $t = find_encoding($to);
      unless ( defined $t ) {
          require Carp;
          Carp::croak("Unknown encoding '$to'");
      }
  
      # For Unicode, warnings need to be caught and re-issued at this level
      # so that callers can disable utf8 warnings lexically.
      my $uni;
      if ( ref($f) eq 'Encode::Unicode' ) {
          my $warn = '';
          {
              local $SIG{__WARN__} = sub { $warn = shift };
              $uni = $f->decode($string);
          }
          warnings::warnif('utf8', $warn) if length $warn;
      }
      else {
          $uni = $f->decode($string);
      }
  
      if ( ref($t) eq 'Encode::Unicode' ) {
          my $warn = '';
          {
              local $SIG{__WARN__} = sub { $warn = shift };
              $_[0] = $string = $t->encode( $uni, $check );
          }
          warnings::warnif('utf8', $warn) if length $warn;
      }
      else {
          $_[0] = $string = $t->encode( $uni, $check );
      }
  
      return undef if ( $check && length($uni) );
      return defined( $_[0] ) ? length($string) : undef;
  }
  
  sub encode_utf8($) {
      my ($str) = @_;
      return undef unless defined $str;
      utf8::encode($str);
      return $str;
  }
  
  my $utf8enc;
  
  sub decode_utf8($;$) {
      my ( $octets, $check ) = @_;
      return undef unless defined $octets;
      $octets .= '';
      $check   ||= 0;
      $utf8enc ||= find_encoding('utf8');
      my $string = $utf8enc->decode( $octets, $check );
      $_[0] = $octets if $check and !ref $check and !( $check & LEAVE_SRC() );
      return $string;
  }
  
  # sub decode_utf8($;$) {
  #     my ( $str, $check ) = @_;
  #     return $str if is_utf8($str);
  #     if ($check) {
  #         return decode( "utf8", $str, $check );
  #     }
  #     else {
  #         return decode( "utf8", $str );
  #         return $str;
  #     }
  # }
  
  predefine_encodings(1);
  
  #
  # This is to restore %Encoding if really needed;
  #
  
  sub predefine_encodings {
      require Encode::Encoding;
      no warnings 'redefine';
      my $use_xs = shift;
      if ($ON_EBCDIC) {
  
          # was in Encode::UTF_EBCDIC
          package Encode::UTF_EBCDIC;
          push @Encode::UTF_EBCDIC::ISA, 'Encode::Encoding';
          *decode = sub {
              my ( undef, $str, $chk ) = @_;
              my $res = '';
              for ( my $i = 0 ; $i < length($str) ; $i++ ) {
                  $res .=
                    chr(
                      utf8::unicode_to_native( ord( substr( $str, $i, 1 ) ) )
                    );
              }
              $_[1] = '' if $chk;
              return $res;
          };
          *encode = sub {
              my ( undef, $str, $chk ) = @_;
              my $res = '';
              for ( my $i = 0 ; $i < length($str) ; $i++ ) {
                  $res .=
                    chr(
                      utf8::native_to_unicode( ord( substr( $str, $i, 1 ) ) )
                    );
              }
              $_[1] = '' if $chk;
              return $res;
          };
          $Encode::Encoding{Unicode} =
            bless { Name => "UTF_EBCDIC" } => "Encode::UTF_EBCDIC";
      }
      else {
  
          package Encode::Internal;
          push @Encode::Internal::ISA, 'Encode::Encoding';
          *decode = sub {
              my ( undef, $str, $chk ) = @_;
              utf8::upgrade($str);
              $_[1] = '' if $chk;
              return $str;
          };
          *encode = \&decode;
          $Encode::Encoding{Unicode} =
            bless { Name => "Internal" } => "Encode::Internal";
      }
      {
          # https://rt.cpan.org/Public/Bug/Display.html?id=103253
          package Encode::XS;
          push @Encode::XS::ISA, 'Encode::Encoding';
      }
      {
  
          # was in Encode::utf8
          package Encode::utf8;
          push @Encode::utf8::ISA, 'Encode::Encoding';
  
          #
          if ($use_xs) {
              Encode::DEBUG and warn __PACKAGE__, " XS on";
              *decode = \&decode_xs;
              *encode = \&encode_xs;
          }
          else {
              Encode::DEBUG and warn __PACKAGE__, " XS off";
              *decode = sub {
                  my ( undef, $octets, $chk ) = @_;
                  my $str = Encode::decode_utf8($octets);
                  if ( defined $str ) {
                      $_[1] = '' if $chk;
                      return $str;
                  }
                  return undef;
              };
              *encode = sub {
                  my ( undef, $string, $chk ) = @_;
                  my $octets = Encode::encode_utf8($string);
                  $_[1] = '' if $chk;
                  return $octets;
              };
          }
          *cat_decode = sub {    # ($obj, $dst, $src, $pos, $trm, $chk)
                                 # currently ignores $chk
              my ( undef, undef, undef, $pos, $trm ) = @_;
              my ( $rdst, $rsrc, $rpos ) = \@_[ 1, 2, 3 ];
              use bytes;
              if ( ( my $npos = index( $$rsrc, $trm, $pos ) ) >= 0 ) {
                  $$rdst .=
                    substr( $$rsrc, $pos, $npos - $pos + length($trm) );
                  $$rpos = $npos + length($trm);
                  return 1;
              }
              $$rdst .= substr( $$rsrc, $pos );
              $$rpos = length($$rsrc);
              return '';
          };
          $Encode::Encoding{utf8} =
            bless { Name => "utf8" } => "Encode::utf8";
          $Encode::Encoding{"utf-8-strict"} =
            bless { Name => "utf-8-strict", strict_utf8 => 1 } 
              => "Encode::utf8";
      }
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Encode - character encodings in Perl
  
  =head1 SYNOPSIS
  
      use Encode qw(decode encode);
      $characters = decode('UTF-8', $octets,     Encode::FB_CROAK);
      $octets     = encode('UTF-8', $characters, Encode::FB_CROAK);
  
  =head2 Table of Contents
  
  Encode consists of a collection of modules whose details are too extensive
  to fit in one document.  This one itself explains the top-level APIs
  and general topics at a glance.  For other topics and more details,
  see the documentation for these modules:
  
  =over 2
  
  =item L<Encode::Alias> - Alias definitions to encodings
  
  =item L<Encode::Encoding> - Encode Implementation Base Class
  
  =item L<Encode::Supported> - List of Supported Encodings
  
  =item L<Encode::CN> - Simplified Chinese Encodings
  
  =item L<Encode::JP> - Japanese Encodings
  
  =item L<Encode::KR> - Korean Encodings
  
  =item L<Encode::TW> - Traditional Chinese Encodings
  
  =back
  
  =head1 DESCRIPTION
  
  The C<Encode> module provides the interface between Perl strings
  and the rest of the system.  Perl strings are sequences of
  I<characters>.
  
  The repertoire of characters that Perl can represent is a superset of those
  defined by the Unicode Consortium. On most platforms the ordinal
  values of a character as returned by C<ord(I<S>)> is the I<Unicode
  codepoint> for that character. The exceptions are platforms where
  the legacy encoding is some variant of EBCDIC rather than a superset
  of ASCII; see L<perlebcdic>.
  
  During recent history, data is moved around a computer in 8-bit chunks,
  often called "bytes" but also known as "octets" in standards documents.
  Perl is widely used to manipulate data of many types: not only strings of
  characters representing human or computer languages, but also "binary"
  data, being the machine's representation of numbers, pixels in an image, or
  just about anything.
  
  When Perl is processing "binary data", the programmer wants Perl to
  process "sequences of bytes". This is not a problem for Perl: because a
  byte has 256 possible values, it easily fits in Perl's much larger
  "logical character".
  
  This document mostly explains the I<how>. L<perlunitut> and L<perlunifaq>
  explain the I<why>.
  
  =head2 TERMINOLOGY
  
  =head3 character
  
  A character in the range 0 .. 2**32-1 (or more);
  what Perl's strings are made of.
  
  =head3 byte
  
  A character in the range 0..255;
  a special case of a Perl character.
  
  =head3 octet
  
  8 bits of data, with ordinal values 0..255;
  term for bytes passed to or from a non-Perl context, such as a disk file,
  standard I/O stream, database, command-line argument, environment variable,
  socket etc.
  
  =head1 THE PERL ENCODING API
  
  =head2 Basic methods
  
  =head3 encode
  
    $octets  = encode(ENCODING, STRING[, CHECK])
  
  Encodes the scalar value I<STRING> from Perl's internal form into
  I<ENCODING> and returns a sequence of octets.  I<ENCODING> can be either a
  canonical name or an alias.  For encoding names and aliases, see
  L</"Defining Aliases">.  For CHECK, see L</"Handling Malformed Data">.
  
  B<CAVEAT>: the input scalar I<STRING> might be modified in-place depending
  on what is set in CHECK. See L</LEAVE_SRC> if you want your inputs to be
  left unchanged.
  
  For example, to convert a string from Perl's internal format into
  ISO-8859-1, also known as Latin1:
  
    $octets = encode("iso-8859-1", $string);
  
  B<CAVEAT>: When you run C<$octets = encode("utf8", $string)>, then
  $octets I<might not be equal to> $string.  Though both contain the
  same data, the UTF8 flag for $octets is I<always> off.  When you
  encode anything, the UTF8 flag on the result is always off, even when it
  contains a completely valid utf8 string. See L</"The UTF8 flag"> below.
  
  If the $string is C<undef>, then C<undef> is returned.
  
  =head3 decode
  
    $string = decode(ENCODING, OCTETS[, CHECK])
  
  This function returns the string that results from decoding the scalar
  value I<OCTETS>, assumed to be a sequence of octets in I<ENCODING>, into
  Perl's internal form.  As with encode(),
  I<ENCODING> can be either a canonical name or an alias. For encoding names
  and aliases, see L</"Defining Aliases">; for I<CHECK>, see L</"Handling
  Malformed Data">.
  
  B<CAVEAT>: the input scalar I<OCTETS> might be modified in-place depending
  on what is set in CHECK. See L</LEAVE_SRC> if you want your inputs to be
  left unchanged.
  
  For example, to convert ISO-8859-1 data into a string in Perl's
  internal format:
  
    $string = decode("iso-8859-1", $octets);
  
  B<CAVEAT>: When you run C<$string = decode("utf8", $octets)>, then $string
  I<might not be equal to> $octets.  Though both contain the same data, the
  UTF8 flag for $string is on.  See L</"The UTF8 flag">
  below.
  
  If the $string is C<undef>, then C<undef> is returned.
  
  =head3 find_encoding
  
    [$obj =] find_encoding(ENCODING)
  
  Returns the I<encoding object> corresponding to I<ENCODING>.  Returns
  C<undef> if no matching I<ENCODING> is find.  The returned object is
  what does the actual encoding or decoding.
  
    $utf8 = decode($name, $bytes);
  
  is in fact
  
      $utf8 = do {
          $obj = find_encoding($name);
          croak qq(encoding "$name" not found) unless ref $obj;
          $obj->decode($bytes);
      };
  
  with more error checking.
  
  You can therefore save time by reusing this object as follows;
  
      my $enc = find_encoding("iso-8859-1");
      while(<>) {
          my $utf8 = $enc->decode($_);
          ... # now do something with $utf8;
      }
  
  Besides L</decode> and L</encode>, other methods are
  available as well.  For instance, C<name()> returns the canonical
  name of the encoding object.
  
    find_encoding("latin1")->name; # iso-8859-1
  
  See L<Encode::Encoding> for details.
  
  =head3 find_mime_encoding
  
    [$obj =] find_mime_encoding(MIME_ENCODING)
  
  Returns the I<encoding object> corresponding to I<MIME_ENCODING>.  Acts
  same as C<find_encoding()> but C<mime_name()> of returned object must
  match to I<MIME_ENCODING>.  So as opposite of C<find_encoding()>
  canonical names and aliases are not used when searching for object.
  
      find_mime_encoding("utf8"); # returns undef because "utf8" is not valid I<MIME_ENCODING>
      find_mime_encoding("utf-8"); # returns encode object "utf-8-strict"
      find_mime_encoding("UTF-8"); # same as "utf-8" because I<MIME_ENCODING> is case insensitive
      find_mime_encoding("utf-8-strict"); returns undef because "utf-8-strict" is not valid I<MIME_ENCODING>
  
  =head3 from_to
  
    [$length =] from_to($octets, FROM_ENC, TO_ENC [, CHECK])
  
  Converts I<in-place> data between two encodings. The data in $octets
  must be encoded as octets and I<not> as characters in Perl's internal
  format. For example, to convert ISO-8859-1 data into Microsoft's CP1250
  encoding:
  
    from_to($octets, "iso-8859-1", "cp1250");
  
  and to convert it back:
  
    from_to($octets, "cp1250", "iso-8859-1");
  
  Because the conversion happens in place, the data to be
  converted cannot be a string constant: it must be a scalar variable.
  
  C<from_to()> returns the length of the converted string in octets on success,
  and C<undef> on error.
  
  B<CAVEAT>: The following operations may look the same, but are not:
  
    from_to($data, "iso-8859-1", "utf8"); #1
    $data = decode("iso-8859-1", $data);  #2
  
  Both #1 and #2 make $data consist of a completely valid UTF-8 string,
  but only #2 turns the UTF8 flag on.  #1 is equivalent to:
  
    $data = encode("utf8", decode("iso-8859-1", $data));
  
  See L</"The UTF8 flag"> below.
  
  Also note that:
  
    from_to($octets, $from, $to, $check);
  
  is equivalent to:
  
    $octets = encode($to, decode($from, $octets), $check);
  
  Yes, it does I<not> respect the $check during decoding.  It is
  deliberately done that way.  If you need minute control, use C<decode>
  followed by C<encode> as follows:
  
    $octets = encode($to, decode($from, $octets, $check_from), $check_to);
  
  =head3 encode_utf8
  
    $octets = encode_utf8($string);
  
  Equivalent to C<$octets = encode("utf8", $string)>.  The characters in
  $string are encoded in Perl's internal format, and the result is returned
  as a sequence of octets.  Because all possible characters in Perl have a
  (loose, not strict) UTF-8 representation, this function cannot fail.
  
  =head3 decode_utf8
  
    $string = decode_utf8($octets [, CHECK]);
  
  Equivalent to C<$string = decode("utf8", $octets [, CHECK])>.
  The sequence of octets represented by $octets is decoded
  from UTF-8 into a sequence of logical characters.
  Because not all sequences of octets are valid UTF-8,
  it is quite possible for this function to fail.
  For CHECK, see L</"Handling Malformed Data">.
  
  B<CAVEAT>: the input I<$octets> might be modified in-place depending on
  what is set in CHECK. See L</LEAVE_SRC> if you want your inputs to be
  left unchanged.
  
  =head2 Listing available encodings
  
    use Encode;
    @list = Encode->encodings();
  
  Returns a list of canonical names of available encodings that have already
  been loaded.  To get a list of all available encodings including those that
  have not yet been loaded, say:
  
    @all_encodings = Encode->encodings(":all");
  
  Or you can give the name of a specific module:
  
    @with_jp = Encode->encodings("Encode::JP");
  
  When "C<::>" is not in the name, "C<Encode::>" is assumed.
  
    @ebcdic = Encode->encodings("EBCDIC");
  
  To find out in detail which encodings are supported by this package,
  see L<Encode::Supported>.
  
  =head2 Defining Aliases
  
  To add a new alias to a given encoding, use:
  
    use Encode;
    use Encode::Alias;
    define_alias(NEWNAME => ENCODING);
  
  After that, I<NEWNAME> can be used as an alias for I<ENCODING>.
  I<ENCODING> may be either the name of an encoding or an
  I<encoding object>.
  
  Before you do that, first make sure the alias is nonexistent using
  C<resolve_alias()>, which returns the canonical name thereof.
  For example:
  
    Encode::resolve_alias("latin1") eq "iso-8859-1" # true
    Encode::resolve_alias("iso-8859-12")   # false; nonexistent
    Encode::resolve_alias($name) eq $name  # true if $name is canonical
  
  C<resolve_alias()> does not need C<use Encode::Alias>; it can be
  imported via C<use Encode qw(resolve_alias)>.
  
  See L<Encode::Alias> for details.
  
  =head2 Finding IANA Character Set Registry names
  
  The canonical name of a given encoding does not necessarily agree with
  IANA Character Set Registry, commonly seen as C<< Content-Type:
  text/plain; charset=I<WHATEVER> >>.  For most cases, the canonical name
  works, but sometimes it does not, most notably with "utf-8-strict".
  
  As of C<Encode> version 2.21, a new method C<mime_name()> is therefore added.
  
    use Encode;
    my $enc = find_encoding("UTF-8");
    warn $enc->name;      # utf-8-strict
    warn $enc->mime_name; # UTF-8
  
  See also:  L<Encode::Encoding>
  
  =head1 Encoding via PerlIO
  
  If your perl supports C<PerlIO> (which is the default), you can use a
  C<PerlIO> layer to decode and encode directly via a filehandle.  The
  following two examples are fully identical in functionality:
  
    ### Version 1 via PerlIO
      open(INPUT,  "< :encoding(shiftjis)", $infile)
          || die "Can't open < $infile for reading: $!";
      open(OUTPUT, "> :encoding(euc-jp)",  $outfile)
          || die "Can't open > $output for writing: $!";
      while (<INPUT>) {   # auto decodes $_
          print OUTPUT;   # auto encodes $_
      }
      close(INPUT)   || die "can't close $infile: $!";
      close(OUTPUT)  || die "can't close $outfile: $!";
  
    ### Version 2 via from_to()
      open(INPUT,  "< :raw", $infile)
          || die "Can't open < $infile for reading: $!";
      open(OUTPUT, "> :raw",  $outfile)
          || die "Can't open > $output for writing: $!";
  
      while (<INPUT>) {
          from_to($_, "shiftjis", "euc-jp", 1);  # switch encoding
          print OUTPUT;   # emit raw (but properly encoded) data
      }
      close(INPUT)   || die "can't close $infile: $!";
      close(OUTPUT)  || die "can't close $outfile: $!";
  
  In the first version above, you let the appropriate encoding layer
  handle the conversion.  In the second, you explicitly translate
  from one encoding to the other.
  
  Unfortunately, it may be that encodings are not C<PerlIO>-savvy.  You can check
  to see whether your encoding is supported by C<PerlIO> by invoking the
  C<perlio_ok> method on it:
  
    Encode::perlio_ok("hz");             # false
    find_encoding("euc-cn")->perlio_ok;  # true wherever PerlIO is available
  
    use Encode qw(perlio_ok);            # imported upon request
    perlio_ok("euc-jp")
  
  Fortunately, all encodings that come with C<Encode> core are C<PerlIO>-savvy
  except for C<hz> and C<ISO-2022-kr>.  For the gory details, see
  L<Encode::Encoding> and L<Encode::PerlIO>.
  
  =head1 Handling Malformed Data
  
  The optional I<CHECK> argument tells C<Encode> what to do when
  encountering malformed data.  Without I<CHECK>, C<Encode::FB_DEFAULT>
  (== 0) is assumed.
  
  As of version 2.12, C<Encode> supports coderef values for C<CHECK>;
  see below.
  
  B<NOTE:> Not all encodings support this feature.
  Some encodings ignore the I<CHECK> argument.  For example,
  L<Encode::Unicode> ignores I<CHECK> and it always croaks on error.
  
  =head2 List of I<CHECK> values
  
  =head3 FB_DEFAULT
  
    I<CHECK> = Encode::FB_DEFAULT ( == 0)
  
  If I<CHECK> is 0, encoding and decoding replace any malformed character
  with a I<substitution character>.  When you encode, I<SUBCHAR> is used.
  When you decode, the Unicode REPLACEMENT CHARACTER, code point U+FFFD, is
  used.  If the data is supposed to be UTF-8, an optional lexical warning of
  warning category C<"utf8"> is given.
  
  =head3 FB_CROAK
  
    I<CHECK> = Encode::FB_CROAK ( == 1)
  
  If I<CHECK> is 1, methods immediately die with an error
  message.  Therefore, when I<CHECK> is 1, you should trap
  exceptions with C<eval{}>, unless you really want to let it C<die>.
  
  =head3 FB_QUIET
  
    I<CHECK> = Encode::FB_QUIET
  
  If I<CHECK> is set to C<Encode::FB_QUIET>, encoding and decoding immediately
  return the portion of the data that has been processed so far when an
  error occurs. The data argument is overwritten with everything
  after that point; that is, the unprocessed portion of the data.  This is
  handy when you have to call C<decode> repeatedly in the case where your
  source data may contain partial multi-byte character sequences,
  (that is, you are reading with a fixed-width buffer). Here's some sample
  code to do exactly that:
  
      my($buffer, $string) = ("", "");
      while (read($fh, $buffer, 256, length($buffer))) {
          $string .= decode($encoding, $buffer, Encode::FB_QUIET);
          # $buffer now contains the unprocessed partial character
      }
  
  =head3 FB_WARN
  
    I<CHECK> = Encode::FB_WARN
  
  This is the same as C<FB_QUIET> above, except that instead of being silent
  on errors, it issues a warning.  This is handy for when you are debugging.
  
  =head3 FB_PERLQQ FB_HTMLCREF FB_XMLCREF
  
  =over 2
  
  =item perlqq mode (I<CHECK> = Encode::FB_PERLQQ)
  
  =item HTML charref mode (I<CHECK> = Encode::FB_HTMLCREF)
  
  =item XML charref mode (I<CHECK> = Encode::FB_XMLCREF)
  
  =back
  
  For encodings that are implemented by the C<Encode::XS> module, C<CHECK> C<==>
  C<Encode::FB_PERLQQ> puts C<encode> and C<decode> into C<perlqq> fallback mode.
  
  When you decode, C<\xI<HH>> is inserted for a malformed character, where
  I<HH> is the hex representation of the octet that could not be decoded to
  utf8.  When you encode, C<\x{I<HHHH>}> will be inserted, where I<HHHH> is
  the Unicode code point (in any number of hex digits) of the character that
  cannot be found in the character repertoire of the encoding.
  
  The HTML/XML character reference modes are about the same. In place of
  C<\x{I<HHHH>}>, HTML uses C<&#I<NNN>;> where I<NNN> is a decimal number, and
  XML uses C<&#xI<HHHH>;> where I<HHHH> is the hexadecimal number.
  
  In C<Encode> 2.10 or later, C<LEAVE_SRC> is also implied.
  
  =head3 The bitmask
  
  These modes are all actually set via a bitmask.  Here is how the C<FB_I<XXX>>
  constants are laid out.  You can import the C<FB_I<XXX>> constants via
  C<use Encode qw(:fallbacks)>, and you can import the generic bitmask
  constants via C<use Encode qw(:fallback_all)>.
  
                       FB_DEFAULT FB_CROAK FB_QUIET FB_WARN  FB_PERLQQ
   DIE_ON_ERR    0x0001             X
   WARN_ON_ERR   0x0002                               X
   RETURN_ON_ERR 0x0004                      X        X
   LEAVE_SRC     0x0008                                        X
   PERLQQ        0x0100                                        X
   HTMLCREF      0x0200
   XMLCREF       0x0400
  
  =head3 LEAVE_SRC
  
    Encode::LEAVE_SRC
  
  If the C<Encode::LEAVE_SRC> bit is I<not> set but I<CHECK> is set, then the
  source string to encode() or decode() will be overwritten in place.
  If you're not interested in this, then bitwise-OR it with the bitmask.
  
  =head2 coderef for CHECK
  
  As of C<Encode> 2.12, C<CHECK> can also be a code reference which takes the
  ordinal value of the unmapped character as an argument and returns
  octets that represent the fallback character.  For instance:
  
    $ascii = encode("ascii", $utf8, sub{ sprintf "<U+%04X>", shift });
  
  Acts like C<FB_PERLQQ> but U+I<XXXX> is used instead of C<\x{I<XXXX>}>.
  
  Even the fallback for C<decode> must return octets, which are
  then decoded with the character encoding that C<decode> accepts. So for
  example if you wish to decode octets as UTF-8, and use ISO-8859-15 as
  a fallback for bytes that are not valid UTF-8, you could write
  
      $str = decode 'UTF-8', $octets, sub {
          my $tmp = chr shift;
          from_to $tmp, 'ISO-8859-15', 'UTF-8';
          return $tmp;
      };
  
  =head1 Defining Encodings
  
  To define a new encoding, use:
  
      use Encode qw(define_encoding);
      define_encoding($object, CANONICAL_NAME [, alias...]);
  
  I<CANONICAL_NAME> will be associated with I<$object>.  The object
  should provide the interface described in L<Encode::Encoding>.
  If more than two arguments are provided, additional
  arguments are considered aliases for I<$object>.
  
  See L<Encode::Encoding> for details.
  
  =head1 The UTF8 flag
  
  Before the introduction of Unicode support in Perl, The C<eq> operator
  just compared the strings represented by two scalars. Beginning with
  Perl 5.8, C<eq> compares two strings with simultaneous consideration of
  I<the UTF8 flag>. To explain why we made it so, I quote from page 402 of
  I<Programming Perl, 3rd ed.>
  
  =over 2
  
  =item Goal #1:
  
  Old byte-oriented programs should not spontaneously break on the old
  byte-oriented data they used to work on.
  
  =item Goal #2:
  
  Old byte-oriented programs should magically start working on the new
  character-oriented data when appropriate.
  
  =item Goal #3:
  
  Programs should run just as fast in the new character-oriented mode
  as in the old byte-oriented mode.
  
  =item Goal #4:
  
  Perl should remain one language, rather than forking into a
  byte-oriented Perl and a character-oriented Perl.
  
  =back
  
  When I<Programming Perl, 3rd ed.> was written, not even Perl 5.6.0 had been
  born yet, many features documented in the book remained unimplemented for a
  long time.  Perl 5.8 corrected much of this, and the introduction of the
  UTF8 flag is one of them.  You can think of there being two fundamentally
  different kinds of strings and string-operations in Perl: one a
  byte-oriented mode  for when the internal UTF8 flag is off, and the other a
  character-oriented mode for when the internal UTF8 flag is on.
  
  Here is how C<Encode> handles the UTF8 flag.
  
  =over 2
  
  =item *
  
  When you I<encode>, the resulting UTF8 flag is always B<off>.
  
  =item *
  
  When you I<decode>, the resulting UTF8 flag is B<on>--I<unless> you can
  unambiguously represent data.  Here is what we mean by "unambiguously".
  After C<$utf8 = decode("foo", $octet)>,
  
    When $octet is...   The UTF8 flag in $utf8 is
    ---------------------------------------------
    In ASCII only (or EBCDIC only)            OFF
    In ISO-8859-1                              ON
    In any other Encoding                      ON
    ---------------------------------------------
  
  As you see, there is one exception: in ASCII.  That way you can assume
  Goal #1.  And with C<Encode>, Goal #2 is assumed but you still have to be
  careful in the cases mentioned in the B<CAVEAT> paragraphs above.
  
  This UTF8 flag is not visible in Perl scripts, exactly for the same reason
  you cannot (or rather, you I<don't have to>) see whether a scalar contains
  a string, an integer, or a floating-point number.   But you can still peek
  and poke these if you will.  See the next section.
  
  =back
  
  =head2 Messing with Perl's Internals
  
  The following API uses parts of Perl's internals in the current
  implementation.  As such, they are efficient but may change in a future
  release.
  
  =head3 is_utf8
  
    is_utf8(STRING [, CHECK])
  
  [INTERNAL] Tests whether the UTF8 flag is turned on in the I<STRING>.
  If I<CHECK> is true, also checks whether I<STRING> contains well-formed
  UTF-8.  Returns true if successful, false otherwise.
  
  As of Perl 5.8.1, L<utf8> also has the C<utf8::is_utf8> function.
  
  =head3 _utf8_on
  
    _utf8_on(STRING)
  
  [INTERNAL] Turns the I<STRING>'s internal UTF8 flag B<on>.  The I<STRING>
  is I<not> checked for containing only well-formed UTF-8.  Do not use this
  unless you I<know with absolute certainty> that the STRING holds only
  well-formed UTF-8.  Returns the previous state of the UTF8 flag (so please
  don't treat the return value as indicating success or failure), or C<undef>
  if I<STRING> is not a string.
  
  B<NOTE>: For security reasons, this function does not work on tainted values.
  
  =head3 _utf8_off
  
    _utf8_off(STRING)
  
  [INTERNAL] Turns the I<STRING>'s internal UTF8 flag B<off>.  Do not use
  frivolously.  Returns the previous state of the UTF8 flag, or C<undef> if
  I<STRING> is not a string.  Do not treat the return value as indicative of
  success or failure, because that isn't what it means: it is only the
  previous setting.
  
  B<NOTE>: For security reasons, this function does not work on tainted values.
  
  =head1 UTF-8 vs. utf8 vs. UTF8
  
    ....We now view strings not as sequences of bytes, but as sequences
    of numbers in the range 0 .. 2**32-1 (or in the case of 64-bit
    computers, 0 .. 2**64-1) -- Programming Perl, 3rd ed.
  
  That has historically been Perl's notion of UTF-8, as that is how UTF-8 was
  first conceived by Ken Thompson when he invented it. However, thanks to
  later revisions to the applicable standards, official UTF-8 is now rather
  stricter than that. For example, its range is much narrower (0 .. 0x10_FFFF
  to cover only 21 bits instead of 32 or 64 bits) and some sequences
  are not allowed, like those used in surrogate pairs, the 31 non-character
  code points 0xFDD0 .. 0xFDEF, the last two code points in I<any> plane
  (0xI<XX>_FFFE and 0xI<XX>_FFFF), all non-shortest encodings, etc.
  
  The former default in which Perl would always use a loose interpretation of
  UTF-8 has now been overruled:
  
    From: Larry Wall <larry@wall.org>
    Date: December 04, 2004 11:51:58 JST
    To: perl-unicode@perl.org
    Subject: Re: Make Encode.pm support the real UTF-8
    Message-Id: <20041204025158.GA28754@wall.org>
  
    On Fri, Dec 03, 2004 at 10:12:12PM +0000, Tim Bunce wrote:
    : I've no problem with 'utf8' being perl's unrestricted uft8 encoding,
    : but "UTF-8" is the name of the standard and should give the
    : corresponding behaviour.
  
    For what it's worth, that's how I've always kept them straight in my
    head.
  
    Also for what it's worth, Perl 6 will mostly default to strict but
    make it easy to switch back to lax.
  
    Larry
  
  Got that?  As of Perl 5.8.7, B<"UTF-8"> means UTF-8 in its current
  sense, which is conservative and strict and security-conscious, whereas
  B<"utf8"> means UTF-8 in its former sense, which was liberal and loose and
  lax.  C<Encode> version 2.10 or later thus groks this subtle but critically
  important distinction between C<"UTF-8"> and C<"utf8">.
  
    encode("utf8",  "\x{FFFF_FFFF}", 1); # okay
    encode("UTF-8", "\x{FFFF_FFFF}", 1); # croaks
  
  In the C<Encode> module, C<"UTF-8"> is actually a canonical name for
  C<"utf-8-strict">.  That hyphen between the C<"UTF"> and the C<"8"> is
  critical; without it, C<Encode> goes "liberal" and (perhaps overly-)permissive:
  
    find_encoding("UTF-8")->name # is 'utf-8-strict'
    find_encoding("utf-8")->name # ditto. names are case insensitive
    find_encoding("utf_8")->name # ditto. "_" are treated as "-"
    find_encoding("UTF8")->name  # is 'utf8'.
  
  Perl's internal UTF8 flag is called "UTF8", without a hyphen. It indicates
  whether a string is internally encoded as "utf8", also without a hyphen.
  
  =head1 SEE ALSO
  
  L<Encode::Encoding>,
  L<Encode::Supported>,
  L<Encode::PerlIO>,
  L<encoding>,
  L<perlebcdic>,
  L<perlfunc/open>,
  L<perlunicode>, L<perluniintro>, L<perlunifaq>, L<perlunitut>
  L<utf8>,
  the Perl Unicode Mailing List L<http://lists.perl.org/list/perl-unicode.html>
  
  =head1 MAINTAINER
  
  This project was originated by the late Nick Ing-Simmons and later
  maintained by Dan Kogai I<< <dankogai@cpan.org> >>.  See AUTHORS
  for a full list of people involved.  For any questions, send mail to
  I<< <perl-unicode@perl.org> >> so that we can all share.
  
  While Dan Kogai retains the copyright as a maintainer, credit
  should go to all those involved.  See AUTHORS for a list of those
  who submitted code to the project.
  
  =head1 COPYRIGHT
  
  Copyright 2002-2014 Dan Kogai I<< <dankogai@cpan.org> >>.
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =cut
I686-LINUX-GNU-THREAD-MULTI-64INT_ENCODE

$fatpacked{"i686-linux-gnu-thread-multi-64int/Encode/Alias.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'I686-LINUX-GNU-THREAD-MULTI-64INT_ENCODE_ALIAS';
  package Encode::Alias;
  use strict;
  use warnings;
  no warnings 'redefine';
  our $VERSION = do { my @r = ( q$Revision: 2.21 $ =~ /\d+/g ); sprintf "%d." . "%02d" x $#r, @r };
  use constant DEBUG => !!$ENV{PERL_ENCODE_DEBUG};
  
  use Exporter 'import';
  
  # Public, encouraged API is exported by default
  
  our @EXPORT =
    qw (
    define_alias
    find_alias
  );
  
  our @Alias;    # ordered matching list
  our %Alias;    # cached known aliases
  
  sub find_alias {
      require Encode;
      my $class = shift;
      my $find  = shift;
      unless ( exists $Alias{$find} ) {
          $Alias{$find} = undef;    # Recursion guard
          for ( my $i = 0 ; $i < @Alias ; $i += 2 ) {
              my $alias = $Alias[$i];
              my $val   = $Alias[ $i + 1 ];
              my $new;
              if ( ref($alias) eq 'Regexp' && $find =~ $alias ) {
                  DEBUG and warn "eval $val";
                  $new = eval $val;
                  DEBUG and $@ and warn "$val, $@";
              }
              elsif ( ref($alias) eq 'CODE' ) {
                  DEBUG and warn "$alias", "->", "($find)";
                  $new = $alias->($find);
              }
              elsif ( lc($find) eq lc($alias) ) {
                  $new = $val;
              }
              if ( defined($new) ) {
                  next if $new eq $find;    # avoid (direct) recursion on bugs
                  DEBUG and warn "$alias, $new";
                  my $enc =
                    ( ref($new) ) ? $new : Encode::find_encoding($new);
                  if ($enc) {
                      $Alias{$find} = $enc;
                      last;
                  }
              }
          }
  
          # case insensitive search when canonical is not in all lowercase
          # RT ticket #7835
          unless ( $Alias{$find} ) {
              my $lcfind = lc($find);
              for my $name ( keys %Encode::Encoding, keys %Encode::ExtModule )
              {
                  $lcfind eq lc($name) or next;
                  $Alias{$find} = Encode::find_encoding($name);
                  DEBUG and warn "$find => $name";
              }
          }
      }
      if (DEBUG) {
          my $name;
          if ( my $e = $Alias{$find} ) {
              $name = $e->name;
          }
          else {
              $name = "";
          }
          warn "find_alias($class, $find)->name = $name";
      }
      return $Alias{$find};
  }
  
  sub define_alias {
      while (@_) {
          my $alias = shift;
          my $name = shift;
          unshift( @Alias, $alias => $name )    # newer one has precedence
              if defined $alias;
          if ( ref($alias) ) {
  
              # clear %Alias cache to allow overrides
              my @a = keys %Alias;
              for my $k (@a) {
                  if ( ref($alias) eq 'Regexp' && $k =~ $alias ) {
                      DEBUG and warn "delete \$Alias\{$k\}";
                      delete $Alias{$k};
                  }
                  elsif ( ref($alias) eq 'CODE' && $alias->($k) ) {
                      DEBUG and warn "delete \$Alias\{$k\}";
                      delete $Alias{$k};
                  }
              }
          }
          elsif (defined $alias) {
              DEBUG and warn "delete \$Alias\{$alias\}";
              delete $Alias{$alias};
          }
          elsif (DEBUG) {
              require Carp;
              Carp::croak("undef \$alias");
          }
      }
  }
  
  # Allow latin-1 style names as well
  # 0  1  2  3  4  5   6   7   8   9  10
  our @Latin2iso = ( 0, 1, 2, 3, 4, 9, 10, 13, 14, 15, 16 );
  
  # Allow winlatin1 style names as well
  our %Winlatin2cp = (
      'latin1'     => 1252,
      'latin2'     => 1250,
      'cyrillic'   => 1251,
      'greek'      => 1253,
      'turkish'    => 1254,
      'hebrew'     => 1255,
      'arabic'     => 1256,
      'baltic'     => 1257,
      'vietnamese' => 1258,
  );
  
  init_aliases();
  
  sub undef_aliases {
      @Alias = ();
      %Alias = ();
  }
  
  sub init_aliases {
      require Encode;
      undef_aliases();
  
      # Try all-lower-case version should all else fails
      define_alias( qr/^(.*)$/ => '"\L$1"' );
  
      # UTF/UCS stuff
      define_alias( qr/^(unicode-1-1-)?UTF-?7$/i     => '"UTF-7"' );
      define_alias( qr/^UCS-?2-?LE$/i => '"UCS-2LE"' );
      define_alias(
          qr/^UCS-?2-?(BE)?$/i    => '"UCS-2BE"',
          qr/^UCS-?4-?(BE|LE|)?$/i => 'uc("UTF-32$1")',
          qr/^iso-10646-1$/i      => '"UCS-2BE"'
      );
      define_alias(
          qr/^UTF-?(16|32)-?BE$/i => '"UTF-$1BE"',
          qr/^UTF-?(16|32)-?LE$/i => '"UTF-$1LE"',
          qr/^UTF-?(16|32)$/i     => '"UTF-$1"',
      );
  
      # ASCII
      define_alias( qr/^(?:US-?)ascii$/i       => '"ascii"' );
      define_alias( 'C'                        => 'ascii' );
      define_alias( qr/\b(?:ISO[-_]?)?646(?:[-_]?US)?$/i => '"ascii"' );
  
      # Allow variants of iso-8859-1 etc.
      define_alias( qr/\biso[-_]?(\d+)[-_](\d+)$/i => '"iso-$1-$2"' );
  
      # At least HP-UX has these.
      define_alias( qr/\biso8859(\d+)$/i => '"iso-8859-$1"' );
  
      # More HP stuff.
      define_alias(
          qr/\b(?:hp-)?(arabic|greek|hebrew|kana|roman|thai|turkish)8$/i =>
            '"${1}8"' );
  
      # The Official name of ASCII.
      define_alias( qr/\bANSI[-_]?X3\.4[-_]?1968$/i => '"ascii"' );
  
      # This is a font issue, not an encoding issue.
      # (The currency symbol of the Latin 1 upper half
      #  has been redefined as the euro symbol.)
      define_alias( qr/^(.+)\@euro$/i => '"$1"' );
  
      define_alias( qr/\b(?:iso[-_]?)?latin[-_]?(\d+)$/i =>
  'defined $Encode::Alias::Latin2iso[$1] ? "iso-8859-$Encode::Alias::Latin2iso[$1]" : undef'
      );
  
      define_alias(
          qr/\bwin(latin[12]|cyrillic|baltic|greek|turkish|
               hebrew|arabic|baltic|vietnamese)$/ix =>
            '"cp" . $Encode::Alias::Winlatin2cp{lc($1)}'
      );
  
      # Common names for non-latin preferred MIME names
      define_alias(
          'ascii'    => 'US-ascii',
          'cyrillic' => 'iso-8859-5',
          'arabic'   => 'iso-8859-6',
          'greek'    => 'iso-8859-7',
          'hebrew'   => 'iso-8859-8',
          'thai'     => 'iso-8859-11',
      );
      # RT #20781
      define_alias(qr/\btis-?620\b/i  => '"iso-8859-11"');
  
      # At least AIX has IBM-NNN (surprisingly...) instead of cpNNN.
      # And Microsoft has their own naming (again, surprisingly).
      # And windows-* is registered in IANA!
      define_alias(
          qr/\b(?:cp|ibm|ms|windows)[-_ ]?(\d{2,4})$/i => '"cp$1"' );
  
      # Sometimes seen with a leading zero.
      # define_alias( qr/\bcp037\b/i => '"cp37"');
  
      # Mac Mappings
      # predefined in *.ucm; unneeded
      # define_alias( qr/\bmacIcelandic$/i => '"macIceland"');
      define_alias( qr/^(?:x[_-])?mac[_-](.*)$/i => '"mac$1"' );
      # http://rt.cpan.org/Ticket/Display.html?id=36326
      define_alias( qr/^macintosh$/i => '"MacRoman"' );
      # https://rt.cpan.org/Ticket/Display.html?id=78125
      define_alias( qr/^macce$/i => '"MacCentralEurRoman"' );
      # Ououououou. gone.  They are different!
      # define_alias( qr/\bmacRomanian$/i => '"macRumanian"');
  
      # Standardize on the dashed versions.
      define_alias( qr/\bkoi8[\s\-_]*([ru])$/i => '"koi8-$1"' );
  
      unless ($Encode::ON_EBCDIC) {
  
          # for Encode::CN
          define_alias( qr/\beuc.*cn$/i => '"euc-cn"' );
          define_alias( qr/\bcn.*euc$/i => '"euc-cn"' );
  
          # define_alias( qr/\bGB[- ]?(\d+)$/i => '"euc-cn"' )
          # CP936 doesn't have vendor-addon for GBK, so they're identical.
          define_alias( qr/^gbk$/i => '"cp936"' );
  
          # This fixes gb2312 vs. euc-cn confusion, practically
          define_alias( qr/\bGB[-_ ]?2312(?!-?raw)/i => '"euc-cn"' );
  
          # for Encode::JP
          define_alias( qr/\bjis$/i         => '"7bit-jis"' );
          define_alias( qr/\beuc.*jp$/i     => '"euc-jp"' );
          define_alias( qr/\bjp.*euc$/i     => '"euc-jp"' );
          define_alias( qr/\bujis$/i        => '"euc-jp"' );
          define_alias( qr/\bshift.*jis$/i  => '"shiftjis"' );
          define_alias( qr/\bsjis$/i        => '"shiftjis"' );
          define_alias( qr/\bwindows-31j$/i => '"cp932"' );
  
          # for Encode::KR
          define_alias( qr/\beuc.*kr$/i => '"euc-kr"' );
          define_alias( qr/\bkr.*euc$/i => '"euc-kr"' );
  
          # This fixes ksc5601 vs. euc-kr confusion, practically
          define_alias( qr/(?:x-)?uhc$/i         => '"cp949"' );
          define_alias( qr/(?:x-)?windows-949$/i => '"cp949"' );
          define_alias( qr/\bks_c_5601-1987$/i   => '"cp949"' );
  
          # for Encode::TW
          define_alias( qr/\bbig-?5$/i              => '"big5-eten"' );
          define_alias( qr/\bbig5-?et(?:en)?$/i     => '"big5-eten"' );
          define_alias( qr/\btca[-_]?big5$/i        => '"big5-eten"' );
          define_alias( qr/\bbig5-?hk(?:scs)?$/i    => '"big5-hkscs"' );
          define_alias( qr/\bhk(?:scs)?[-_]?big5$/i => '"big5-hkscs"' );
      }
  
      # https://github.com/dankogai/p5-encode/issues/37
      define_alias(qr/cp65000/i => '"UTF-7"');
      define_alias(qr/cp65001/i => '"utf-8-strict"');
  
      # utf8 is blessed :)
      define_alias( qr/\bUTF-8$/i => '"utf-8-strict"' );
  
      # At last, Map white space and _ to '-'
      define_alias( qr/^(\S+)[\s_]+(.*)$/i => '"$1-$2"' );
  }
  
  1;
  __END__
  
  # TODO: HP-UX '8' encodings arabic8 greek8 hebrew8 kana8 thai8 turkish8
  # TODO: HP-UX '15' encodings japanese15 korean15 roi15
  # TODO: Cyrillic encoding ISO-IR-111 (useful?)
  # TODO: Armenian encoding ARMSCII-8
  # TODO: Hebrew encoding ISO-8859-8-1
  # TODO: Thai encoding TCVN
  # TODO: Vietnamese encodings VPS
  # TODO: Mac Asian+African encodings: Arabic Armenian Bengali Burmese
  #       ChineseSimp ChineseTrad Devanagari Ethiopic ExtArabic
  #       Farsi Georgian Gujarati Gurmukhi Hebrew Japanese
  #       Kannada Khmer Korean Laotian Malayalam Mongolian
  #       Oriya Sinhalese Symbol Tamil Telugu Tibetan Vietnamese
  
  =head1 NAME
  
  Encode::Alias - alias definitions to encodings
  
  =head1 SYNOPSIS
  
    use Encode;
    use Encode::Alias;
    define_alias( "newName" => ENCODING);
    define_alias( qr/.../ => ENCODING);
    define_alias( sub { return ENCODING if ...; } );
  
  =head1 DESCRIPTION
  
  Allows newName to be used as an alias for ENCODING. ENCODING may be
  either the name of an encoding or an encoding object (as described 
  in L<Encode>).
  
  Currently the first argument to define_alias() can be specified in the
  following ways:
  
  =over 4
  
  =item As a simple string.
  
  =item As a qr// compiled regular expression, e.g.:
  
    define_alias( qr/^iso8859-(\d+)$/i => '"iso-8859-$1"' );
  
  In this case, if I<ENCODING> is not a reference, it is C<eval>-ed
  in order to allow C<$1> etc. to be substituted.  The example is one
  way to alias names as used in X11 fonts to the MIME names for the
  iso-8859-* family.  Note the double quotes inside the single quotes.
  
  (or, you don't have to do this yourself because this example is predefined)
  
  If you are using a regex here, you have to use the quotes as shown or
  it won't work.  Also note that regex handling is tricky even for the
  experienced.  Use this feature with caution.
  
  =item As a code reference, e.g.:
  
    define_alias( sub {shift =~ /^iso8859-(\d+)$/i ? "iso-8859-$1" : undef } );
  
  The same effect as the example above in a different way.  The coderef
  takes the alias name as an argument and returns a canonical name on
  success or undef if not.  Note the second argument is ignored if provided.
  Use this with even more caution than the regex version.
  
  =back
  
  =head3 Changes in code reference aliasing
  
  As of Encode 1.87, the older form
  
    define_alias( sub { return  /^iso8859-(\d+)$/i ? "iso-8859-$1" : undef } );
  
  no longer works. 
  
  Encode up to 1.86 internally used "local $_" to implement this older
  form.  But consider the code below;
  
    use Encode;
    $_ = "eeeee" ;
    while (/(e)/g) {
      my $utf = decode('aliased-encoding-name', $1);
      print "position:",pos,"\n";
    }
  
  Prior to Encode 1.86 this fails because of "local $_".
  
  =head2 Alias overloading
  
  You can override predefined aliases by simply applying define_alias().
  The new alias is always evaluated first, and when necessary,
  define_alias() flushes the internal cache to make the new definition
  available.
  
    # redirect SHIFT_JIS to MS/IBM Code Page 932, which is a
    # superset of SHIFT_JIS
  
    define_alias( qr/shift.*jis$/i  => '"cp932"' );
    define_alias( qr/sjis$/i        => '"cp932"' );
  
  If you want to zap all predefined aliases, you can use
  
    Encode::Alias->undef_aliases;
  
  to do so.  And
  
    Encode::Alias->init_aliases;
  
  gets the factory settings back.
  
  Note that define_alias() will not be able to override the canonical name
  of encodings. Encodings are first looked up by canonical name before
  potential aliases are tried.
  
  =head1 SEE ALSO
  
  L<Encode>, L<Encode::Supported>
  
  =cut
  
I686-LINUX-GNU-THREAD-MULTI-64INT_ENCODE_ALIAS

$fatpacked{"i686-linux-gnu-thread-multi-64int/Encode/Byte.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'I686-LINUX-GNU-THREAD-MULTI-64INT_ENCODE_BYTE';
  package Encode::Byte;
  use strict;
  use warnings;
  use Encode;
  our $VERSION = do { my @r = ( q$Revision: 2.4 $ =~ /\d+/g ); sprintf "%d." . "%02d" x $#r, @r };
  
  use XSLoader;
  XSLoader::load( __PACKAGE__, $VERSION );
  
  1;
  __END__
  
  =head1 NAME
  
  Encode::Byte - Single Byte Encodings
  
  =head1 SYNOPSIS
  
      use Encode qw/encode decode/; 
      $greek = encode("iso-8859-7", $utf8);  # loads Encode::Byte implicitly
      $utf8  = decode("iso-8859-7", $greek); # ditto
  
  =head1 ABSTRACT
  
  This module implements various single byte encodings.  For most cases it uses
  \x80-\xff (upper half) to map non-ASCII characters.  Encodings
  supported are as follows.   
  
    Canonical      Alias		                      Description
    --------------------------------------------------------------------
    # ISO 8859 series
    (iso-8859-1	is in built-in)
    iso-8859-2	latin2					     [ISO]
    iso-8859-3	latin3					     [ISO]
    iso-8859-4	latin4					     [ISO]
    iso-8859-5						     [ISO]
    iso-8859-6						     [ISO]
    iso-8859-7						     [ISO]
    iso-8859-8						     [ISO]
    iso-8859-9	latin5					     [ISO]
    iso-8859-10	latin6					     [ISO]
    iso-8859-11
    (iso-8859-12 is nonexistent)
    iso-8859-13   latin7					     [ISO]
    iso-8859-14	latin8					     [ISO]
    iso-8859-15	latin9					     [ISO]
    iso-8859-16	latin10					     [ISO]
  
    # Cyrillic
    koi8-f					
    koi8-r        cp878					 [RFC1489]
    koi8-u						 [RFC2319]
  
    # Vietnamese
    viscii
  
    # all cp* are also available as ibm-*, ms-*, and windows-*
    # also see L<http://msdn.microsoft.com/en-us/library/aa752010%28VS.85%29.aspx>
  
    cp424  
    cp437  
    cp737  
    cp775  
    cp850  
    cp852  
    cp855  
    cp856  
    cp857  
    cp860  
    cp861  
    cp862  
    cp863  
    cp864  
    cp865  
    cp866  
    cp869  
    cp874  
    cp1006  
    cp1250	WinLatin2
    cp1251	WinCyrillic
    cp1252	WinLatin1
    cp1253	WinGreek
    cp1254	WinTurkish
    cp1255	WinHebrew
    cp1256	WinArabic
    cp1257	WinBaltic
    cp1258	WinVietnamese
  
    # Macintosh
    # Also see L<http://developer.apple.com/technotes/tn/tn1150.html>
    MacArabic  
    MacCentralEurRoman  
    MacCroatian  
    MacCyrillic  
    MacFarsi  
    MacGreek  
    MacHebrew  
    MacIcelandic  
    MacRoman  
    MacRomanian  
    MacRumanian  
    MacSami  
    MacThai  
    MacTurkish  
    MacUkrainian  
  
    # More vendor encodings
    AdobeStandardEncoding
    nextstep
    hp-roman8
  
  =head1 DESCRIPTION
  
  To find how to use this module in detail, see L<Encode>.
  
  =head1 SEE ALSO
  
  L<Encode>
  
  =cut
I686-LINUX-GNU-THREAD-MULTI-64INT_ENCODE_BYTE

$fatpacked{"i686-linux-gnu-thread-multi-64int/Encode/CJKConstants.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'I686-LINUX-GNU-THREAD-MULTI-64INT_ENCODE_CJKCONSTANTS';
  #
  # $Id: CJKConstants.pm,v 2.2 2006/06/03 20:28:48 dankogai Exp $
  #
  
  package Encode::CJKConstants;
  
  use strict;
  use warnings;
  our $RCSID = q$Id: CJKConstants.pm,v 2.2 2006/06/03 20:28:48 dankogai Exp $;
  our $VERSION = do { my @r = ( q$Revision: 2.2 $ =~ /\d+/g ); sprintf "%d." . "%02d" x $#r, @r };
  
  use Carp;
  
  require Exporter;
  our @ISA         = qw(Exporter);
  our @EXPORT      = qw();
  our @EXPORT_OK   = qw(%CHARCODE %ESC %RE);
  our %EXPORT_TAGS = ( 'all' => [ @EXPORT_OK, @EXPORT ] );
  
  my %_0208 = (
      1978 => '\e\$\@',
      1983 => '\e\$B',
      1990 => '\e&\@\e\$B',
  );
  
  our %CHARCODE = (
      UNDEF_EUC     => "\xa2\xae",    #  in EUC
      UNDEF_SJIS    => "\x81\xac",    #  in SJIS
      UNDEF_JIS     => "\xa2\xf7",    #  -- used in unicode
      UNDEF_UNICODE => "\x20\x20",    #  -- used in unicode
  );
  
  our %ESC = (
      GB_2312   => "\e\$A",
      JIS_0208  => "\e\$B",
      JIS_0212  => "\e\$(D",
      KSC_5601  => "\e\$(C",
      ASC       => "\e\(B",
      KANA      => "\e\(I",
      '2022_KR' => "\e\$)C",
  );
  
  our %RE = (
      ASCII     => '[\x00-\x7f]',
      BIN       => '[\x00-\x06\x7f\xff]',
      EUC_0212  => '\x8f[\xa1-\xfe][\xa1-\xfe]',
      EUC_C     => '[\xa1-\xfe][\xa1-\xfe]',
      EUC_KANA  => '\x8e[\xa1-\xdf]',
      JIS_0208  => "$_0208{1978}|$_0208{1983}|$_0208{1990}",
      JIS_0212  => "\e" . '\$\(D',
      ISO_ASC   => "\e" . '\([BJ]',
      JIS_KANA  => "\e" . '\(I',
      '2022_KR' => "\e" . '\$\)C',
      SJIS_C    => '[\x81-\x9f\xe0-\xfc][\x40-\x7e\x80-\xfc]',
      SJIS_KANA => '[\xa1-\xdf]',
      UTF8      => '[\xc0-\xdf][\x80-\xbf]|[\xe0-\xef][\x80-\xbf][\x80-\xbf]'
  );
  
  1;
  
  =head1 NAME
  
  Encode::CJKConstants.pm -- Internally used by Encode::??::ISO_2022_*
  
  =cut
  
I686-LINUX-GNU-THREAD-MULTI-64INT_ENCODE_CJKCONSTANTS

$fatpacked{"i686-linux-gnu-thread-multi-64int/Encode/CN.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'I686-LINUX-GNU-THREAD-MULTI-64INT_ENCODE_CN';
  package Encode::CN;
  BEGIN {
      if ( ord("A") == 193 ) {
          die "Encode::CN not supported on EBCDIC\n";
      }
  }
  use strict;
  use warnings;
  use Encode;
  our $VERSION = do { my @r = ( q$Revision: 2.3 $ =~ /\d+/g ); sprintf "%d." . "%02d" x $#r, @r };
  use XSLoader;
  XSLoader::load( __PACKAGE__, $VERSION );
  
  # Relocated from Encode.pm
  
  use Encode::CN::HZ;
  
  # use Encode::CN::2022_CN;
  
  1;
  __END__
  
  =head1 NAME
  
  Encode::CN - China-based Chinese Encodings
  
  =head1 SYNOPSIS
  
      use Encode qw/encode decode/; 
      $euc_cn = encode("euc-cn", $utf8);   # loads Encode::CN implicitly
      $utf8   = decode("euc-cn", $euc_cn); # ditto
  
  =head1 DESCRIPTION
  
  This module implements China-based Chinese charset encodings.
  Encodings supported are as follows.
  
    Canonical   Alias		Description
    --------------------------------------------------------------------
    euc-cn      /\beuc.*cn$/i	EUC (Extended Unix Character)
            /\bcn.*euc$/i
                /\bGB[-_ ]?2312(?:\D.*$|$)/i (see below)
    gb2312-raw			The raw (low-bit) GB2312 character map
    gb12345-raw			Traditional chinese counterpart to 
                  GB2312 (raw)
    iso-ir-165			GB2312 + GB6345 + GB8565 + additions
    MacChineseSimp                GB2312 + Apple Additions
    cp936				Code Page 936, also known as GBK 
                  (Extended GuoBiao)
    hz				7-bit escaped GB2312 encoding
    --------------------------------------------------------------------
  
  To find how to use this module in detail, see L<Encode>.
  
  =head1 NOTES
  
  Due to size concerns, C<GB 18030> (an extension to C<GBK>) is distributed
  separately on CPAN, under the name L<Encode::HanExtra>. That module
  also contains extra Taiwan-based encodings.
  
  =head1 BUGS
  
  When you see C<charset=gb2312> on mails and web pages, they really
  mean C<euc-cn> encodings.  To fix that, C<gb2312> is aliased to C<euc-cn>.
  Use C<gb2312-raw> when you really mean it.
  
  The ASCII region (0x00-0x7f) is preserved for all encodings, even though
  this conflicts with mappings by the Unicode Consortium.
  
  =head1 SEE ALSO
  
  L<Encode>
  
  =cut
I686-LINUX-GNU-THREAD-MULTI-64INT_ENCODE_CN

$fatpacked{"i686-linux-gnu-thread-multi-64int/Encode/CN/HZ.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'I686-LINUX-GNU-THREAD-MULTI-64INT_ENCODE_CN_HZ';
  package Encode::CN::HZ;
  
  use strict;
  use warnings;
  use utf8 ();
  
  use vars qw($VERSION);
  $VERSION = do { my @r = ( q$Revision: 2.8 $ =~ /\d+/g ); sprintf "%d." . "%02d" x $#r, @r };
  
  use Encode qw(:fallbacks);
  
  use parent qw(Encode::Encoding);
  __PACKAGE__->Define('hz');
  
  # HZ is a combination of ASCII and escaped GB, so we implement it
  # with the GB2312(raw) encoding here. Cf. RFCs 1842 & 1843.
  
  # not ported for EBCDIC.  Which should be used, "~" or "\x7E"?
  
  sub needs_lines { 1 }
  
  sub decode ($$;$) {
      my ( $obj, $str, $chk ) = @_;
  
      my $GB  = Encode::find_encoding('gb2312-raw');
      my $ret = substr($str, 0, 0); # to propagate taintedness
      my $in_ascii = 1;    # default mode is ASCII.
  
      while ( length $str ) {
          if ($in_ascii) {    # ASCII mode
              if ( $str =~ s/^([\x00-\x7D\x7F]+)// ) {    # no '~' => ASCII
                  $ret .= $1;
  
                  # EBCDIC should need ascii2native, but not ported.
              }
              elsif ( $str =~ s/^\x7E\x7E// ) {           # escaped tilde
                  $ret .= '~';
              }
              elsif ( $str =~ s/^\x7E\cJ// ) {    # '\cJ' == LF in ASCII
                  1;                              # no-op
              }
              elsif ( $str =~ s/^\x7E\x7B// ) {    # '~{'
                  $in_ascii = 0;                   # to GB
              }
              else {    # encounters an invalid escape, \x80 or greater
                  last;
              }
          }
          else {        # GB mode; the byte ranges are as in RFC 1843.
              no warnings 'uninitialized';
              if ( $str =~ s/^((?:[\x21-\x77][\x21-\x7E])+)// ) {
                  my $prefix = $1;
                  $ret .= $GB->decode( $prefix, $chk );
              }
              elsif ( $str =~ s/^\x7E\x7D// ) {    # '~}'
                  $in_ascii = 1;
              }
              else {                               # invalid
                  last;
              }
          }
      }
      $_[1] = '' if $chk;    # needs_lines guarantees no partial character
      return $ret;
  }
  
  sub cat_decode {
      my ( $obj, undef, $src, $pos, $trm, $chk ) = @_;
      my ( $rdst, $rsrc, $rpos ) = \@_[ 1 .. 3 ];
  
      my $GB  = Encode::find_encoding('gb2312-raw');
      my $ret = '';
      my $in_ascii = 1;      # default mode is ASCII.
  
      my $ini_pos = pos($$rsrc);
  
      substr( $src, 0, $pos ) = '';
  
      my $ini_len = bytes::length($src);
  
      # $trm is the first of the pair '~~', then 2nd tilde is to be removed.
      # XXX: Is better C<$src =~ s/^\x7E// or die if ...>?
      $src =~ s/^\x7E// if $trm eq "\x7E";
  
      while ( length $src ) {
          my $now;
          if ($in_ascii) {    # ASCII mode
              if ( $src =~ s/^([\x00-\x7D\x7F])// ) {    # no '~' => ASCII
                  $now = $1;
              }
              elsif ( $src =~ s/^\x7E\x7E// ) {          # escaped tilde
                  $now = '~';
              }
              elsif ( $src =~ s/^\x7E\cJ// ) {    # '\cJ' == LF in ASCII
                  next;
              }
              elsif ( $src =~ s/^\x7E\x7B// ) {    # '~{'
                  $in_ascii = 0;                   # to GB
                  next;
              }
              else {    # encounters an invalid escape, \x80 or greater
                  last;
              }
          }
          else {        # GB mode; the byte ranges are as in RFC 1843.
              if ( $src =~ s/^((?:[\x21-\x77][\x21-\x7F])+)// ) {
                  $now = $GB->decode( $1, $chk );
              }
              elsif ( $src =~ s/^\x7E\x7D// ) {    # '~}'
                  $in_ascii = 1;
                  next;
              }
              else {                               # invalid
                  last;
              }
          }
  
          next if !defined $now;
  
          $ret .= $now;
  
          if ( $now eq $trm ) {
              $$rdst .= $ret;
              $$rpos = $ini_pos + $pos + $ini_len - bytes::length($src);
              pos($$rsrc) = $ini_pos;
              return 1;
          }
      }
  
      $$rdst .= $ret;
      $$rpos = $ini_pos + $pos + $ini_len - bytes::length($src);
      pos($$rsrc) = $ini_pos;
      return '';    # terminator not found
  }
  
  sub encode($$;$) {
       my ( $obj, $str, $chk ) = @_;
  
      my $GB  = Encode::find_encoding('gb2312-raw');
      my $ret = substr($str, 0, 0); # to propagate taintedness;
      my $in_ascii = 1;    # default mode is ASCII.
  
      no warnings 'utf8';  # $str may be malformed UTF8 at the end of a chunk.
  
      while ( length $str ) {
          if ( $str =~ s/^([[:ascii:]]+)// ) {
              my $tmp = $1;
              $tmp =~ s/~/~~/g;    # escapes tildes
              if ( !$in_ascii ) {
                  $ret .= "\x7E\x7D";    # '~}'
                  $in_ascii = 1;
              }
              $ret .= pack 'a*', $tmp;    # remove UTF8 flag.
          }
          elsif ( $str =~ s/(.)// ) {
              my $s = $1;
              my $tmp = $GB->encode( $s, $chk );
              last if !defined $tmp;
              if ( length $tmp == 2 ) {    # maybe a valid GB char (XXX)
                  if ($in_ascii) {
                      $ret .= "\x7E\x7B";    # '~{'
                      $in_ascii = 0;
                  }
                  $ret .= $tmp;
              }
              elsif ( length $tmp ) {        # maybe FALLBACK in ASCII (XXX)
                  if ( !$in_ascii ) {
                      $ret .= "\x7E\x7D";    # '~}'
                      $in_ascii = 1;
                  }
                  $ret .= $tmp;
              }
          }
          else {    # if $str is malformed UTF8 *and* if length $str != 0.
              last;
          }
      }
      $_[1] = $str if $chk;
  
      # The state at the end of the chunk is discarded, even if in GB mode.
      # That results in the combination of GB-OUT and GB-IN, i.e. "~}~{".
      # Parhaps it is harmless, but further investigations may be required...
  
      if ( !$in_ascii ) {
          $ret .= "\x7E\x7D";    # '~}'
          $in_ascii = 1;
      }
      utf8::encode($ret); # https://rt.cpan.org/Ticket/Display.html?id=35120
      return $ret;
  }
  
  1;
  __END__
  
  =head1 NAME
  
  Encode::CN::HZ -- internally used by Encode::CN
  
  =cut
I686-LINUX-GNU-THREAD-MULTI-64INT_ENCODE_CN_HZ

$fatpacked{"i686-linux-gnu-thread-multi-64int/Encode/Config.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'I686-LINUX-GNU-THREAD-MULTI-64INT_ENCODE_CONFIG';
  #
  # Demand-load module list
  #
  package Encode::Config;
  our $VERSION = do { my @r = ( q$Revision: 2.5 $ =~ /\d+/g ); sprintf "%d." . "%02d" x $#r, @r };
  
  use strict;
  use warnings;
  
  our %ExtModule = (
  
      # Encode::Byte
      #iso-8859-1 is in Encode.pm itself
      'iso-8859-2'            => 'Encode::Byte',
      'iso-8859-3'            => 'Encode::Byte',
      'iso-8859-4'            => 'Encode::Byte',
      'iso-8859-5'            => 'Encode::Byte',
      'iso-8859-6'            => 'Encode::Byte',
      'iso-8859-7'            => 'Encode::Byte',
      'iso-8859-8'            => 'Encode::Byte',
      'iso-8859-9'            => 'Encode::Byte',
      'iso-8859-10'           => 'Encode::Byte',
      'iso-8859-11'           => 'Encode::Byte',
      'iso-8859-13'           => 'Encode::Byte',
      'iso-8859-14'           => 'Encode::Byte',
      'iso-8859-15'           => 'Encode::Byte',
      'iso-8859-16'           => 'Encode::Byte',
      'koi8-f'                => 'Encode::Byte',
      'koi8-r'                => 'Encode::Byte',
      'koi8-u'                => 'Encode::Byte',
      'viscii'                => 'Encode::Byte',
      'cp424'                 => 'Encode::Byte',
      'cp437'                 => 'Encode::Byte',
      'cp737'                 => 'Encode::Byte',
      'cp775'                 => 'Encode::Byte',
      'cp850'                 => 'Encode::Byte',
      'cp852'                 => 'Encode::Byte',
      'cp855'                 => 'Encode::Byte',
      'cp856'                 => 'Encode::Byte',
      'cp857'                 => 'Encode::Byte',
      'cp858'                 => 'Encode::Byte',
      'cp860'                 => 'Encode::Byte',
      'cp861'                 => 'Encode::Byte',
      'cp862'                 => 'Encode::Byte',
      'cp863'                 => 'Encode::Byte',
      'cp864'                 => 'Encode::Byte',
      'cp865'                 => 'Encode::Byte',
      'cp866'                 => 'Encode::Byte',
      'cp869'                 => 'Encode::Byte',
      'cp874'                 => 'Encode::Byte',
      'cp1006'                => 'Encode::Byte',
      'cp1250'                => 'Encode::Byte',
      'cp1251'                => 'Encode::Byte',
      'cp1252'                => 'Encode::Byte',
      'cp1253'                => 'Encode::Byte',
      'cp1254'                => 'Encode::Byte',
      'cp1255'                => 'Encode::Byte',
      'cp1256'                => 'Encode::Byte',
      'cp1257'                => 'Encode::Byte',
      'cp1258'                => 'Encode::Byte',
      'AdobeStandardEncoding' => 'Encode::Byte',
      'MacArabic'             => 'Encode::Byte',
      'MacCentralEurRoman'    => 'Encode::Byte',
      'MacCroatian'           => 'Encode::Byte',
      'MacCyrillic'           => 'Encode::Byte',
      'MacFarsi'              => 'Encode::Byte',
      'MacGreek'              => 'Encode::Byte',
      'MacHebrew'             => 'Encode::Byte',
      'MacIcelandic'          => 'Encode::Byte',
      'MacRoman'              => 'Encode::Byte',
      'MacRomanian'           => 'Encode::Byte',
      'MacRumanian'           => 'Encode::Byte',
      'MacSami'               => 'Encode::Byte',
      'MacThai'               => 'Encode::Byte',
      'MacTurkish'            => 'Encode::Byte',
      'MacUkrainian'          => 'Encode::Byte',
      'nextstep'              => 'Encode::Byte',
      'hp-roman8'             => 'Encode::Byte',
      #'gsm0338'               => 'Encode::Byte',
      'gsm0338'               => 'Encode::GSM0338',
  
      # Encode::EBCDIC
      'cp37'     => 'Encode::EBCDIC',
      'cp500'    => 'Encode::EBCDIC',
      'cp875'    => 'Encode::EBCDIC',
      'cp1026'   => 'Encode::EBCDIC',
      'cp1047'   => 'Encode::EBCDIC',
      'posix-bc' => 'Encode::EBCDIC',
  
      # Encode::Symbol
      'dingbats'      => 'Encode::Symbol',
      'symbol'        => 'Encode::Symbol',
      'AdobeSymbol'   => 'Encode::Symbol',
      'AdobeZdingbat' => 'Encode::Symbol',
      'MacDingbats'   => 'Encode::Symbol',
      'MacSymbol'     => 'Encode::Symbol',
  
      # Encode::Unicode
      'UCS-2BE'  => 'Encode::Unicode',
      'UCS-2LE'  => 'Encode::Unicode',
      'UTF-16'   => 'Encode::Unicode',
      'UTF-16BE' => 'Encode::Unicode',
      'UTF-16LE' => 'Encode::Unicode',
      'UTF-32'   => 'Encode::Unicode',
      'UTF-32BE' => 'Encode::Unicode',
      'UTF-32LE' => 'Encode::Unicode',
      'UTF-7'    => 'Encode::Unicode::UTF7',
  );
  
  unless ( ord("A") == 193 ) {
      %ExtModule = (
          %ExtModule,
          'euc-cn'         => 'Encode::CN',
          'gb12345-raw'    => 'Encode::CN',
          'gb2312-raw'     => 'Encode::CN',
          'hz'             => 'Encode::CN',
          'iso-ir-165'     => 'Encode::CN',
          'cp936'          => 'Encode::CN',
          'MacChineseSimp' => 'Encode::CN',
  
          '7bit-jis'      => 'Encode::JP',
          'euc-jp'        => 'Encode::JP',
          'iso-2022-jp'   => 'Encode::JP',
          'iso-2022-jp-1' => 'Encode::JP',
          'jis0201-raw'   => 'Encode::JP',
          'jis0208-raw'   => 'Encode::JP',
          'jis0212-raw'   => 'Encode::JP',
          'cp932'         => 'Encode::JP',
          'MacJapanese'   => 'Encode::JP',
          'shiftjis'      => 'Encode::JP',
  
          'euc-kr'      => 'Encode::KR',
          'iso-2022-kr' => 'Encode::KR',
          'johab'       => 'Encode::KR',
          'ksc5601-raw' => 'Encode::KR',
          'cp949'       => 'Encode::KR',
          'MacKorean'   => 'Encode::KR',
  
          'big5-eten'      => 'Encode::TW',
          'big5-hkscs'     => 'Encode::TW',
          'cp950'          => 'Encode::TW',
          'MacChineseTrad' => 'Encode::TW',
  
          #'big5plus'           => 'Encode::HanExtra',
          #'euc-tw'             => 'Encode::HanExtra',
          #'gb18030'            => 'Encode::HanExtra',
  
          'MIME-Header' => 'Encode::MIME::Header',
          'MIME-B'      => 'Encode::MIME::Header',
          'MIME-Q'      => 'Encode::MIME::Header',
  
          'MIME-Header-ISO_2022_JP' => 'Encode::MIME::Header::ISO_2022_JP',
      );
  }
  
  #
  # Why not export ? to keep ConfigLocal Happy!
  #
  while ( my ( $enc, $mod ) = each %ExtModule ) {
      $Encode::ExtModule{$enc} = $mod;
  }
  
  1;
  __END__
  
  =head1 NAME
  
  Encode::Config -- internally used by Encode
  
  =cut
I686-LINUX-GNU-THREAD-MULTI-64INT_ENCODE_CONFIG

$fatpacked{"i686-linux-gnu-thread-multi-64int/Encode/EBCDIC.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'I686-LINUX-GNU-THREAD-MULTI-64INT_ENCODE_EBCDIC';
  package Encode::EBCDIC;
  use strict;
  use warnings;
  use Encode;
  our $VERSION = do { my @r = ( q$Revision: 2.2 $ =~ /\d+/g ); sprintf "%d." . "%02d" x $#r, @r };
  
  use XSLoader;
  XSLoader::load( __PACKAGE__, $VERSION );
  
  1;
  __END__
  
  =head1 NAME
  
  Encode::EBCDIC - EBCDIC Encodings
  
  =head1 SYNOPSIS
  
      use Encode qw/encode decode/; 
      $posix_bc  = encode("posix-bc", $utf8); # loads Encode::EBCDIC implicitly
      $utf8 = decode("", $posix_bc);          # ditto
  
  =head1 ABSTRACT
  
  This module implements various EBCDIC-Based encodings.  Encodings
  supported are as follows.   
  
    Canonical   Alias		Description
    --------------------------------------------------------------------
    cp37  
    cp500  
    cp875  
    cp1026  
    cp1047  
    posix-bc
  
  =head1 DESCRIPTION
  
  To find how to use this module in detail, see L<Encode>.
  
  =head1 SEE ALSO
  
  L<Encode>, L<perlebcdic>
  
  =cut
I686-LINUX-GNU-THREAD-MULTI-64INT_ENCODE_EBCDIC

$fatpacked{"i686-linux-gnu-thread-multi-64int/Encode/Encoder.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'I686-LINUX-GNU-THREAD-MULTI-64INT_ENCODE_ENCODER';
  #
  # $Id: Encoder.pm,v 2.3 2013/09/14 07:51:59 dankogai Exp $
  #
  package Encode::Encoder;
  use strict;
  use warnings;
  our $VERSION = do { my @r = ( q$Revision: 2.3 $ =~ /\d+/g ); sprintf "%d." . "%02d" x $#r, @r };
  
  require Exporter;
  our @ISA       = qw(Exporter);
  our @EXPORT_OK = qw ( encoder );
  
  our $AUTOLOAD;
  use constant DEBUG => !!$ENV{PERL_ENCODE_DEBUG};
  use Encode qw(encode decode find_encoding from_to);
  use Carp;
  
  sub new {
      my ( $class, $data, $encname ) = @_;
      unless ($encname) {
          $encname = Encode::is_utf8($data) ? 'utf8' : '';
      }
      else {
          my $obj = find_encoding($encname)
            or croak __PACKAGE__, ": unknown encoding: $encname";
          $encname = $obj->name;
      }
      my $self = {
          data     => $data,
          encoding => $encname,
      };
      bless $self => $class;
  }
  
  sub encoder { __PACKAGE__->new(@_) }
  
  sub data {
      my ( $self, $data ) = @_;
      if ( defined $data ) {
          $self->{data} = $data;
          return $data;
      }
      else {
          return $self->{data};
      }
  }
  
  sub encoding {
      my ( $self, $encname ) = @_;
      if ($encname) {
          my $obj = find_encoding($encname)
            or confess __PACKAGE__, ": unknown encoding: $encname";
          $self->{encoding} = $obj->name;
          return $self;
      }
      else {
          return $self->{encoding};
      }
  }
  
  sub bytes {
      my ( $self, $encname ) = @_;
      $encname ||= $self->{encoding};
      my $obj = find_encoding($encname)
        or confess __PACKAGE__, ": unknown encoding: $encname";
      $self->{data} = $obj->decode( $self->{data}, 1 );
      $self->{encoding} = '';
      return $self;
  }
  
  sub DESTROY {    # defined so it won't autoload.
      DEBUG and warn shift;
  }
  
  sub AUTOLOAD {
      my $self = shift;
      my $type = ref($self)
        or confess "$self is not an object";
      my $myname = $AUTOLOAD;
      $myname =~ s/.*://;    # strip fully-qualified portion
      my $obj = find_encoding($myname)
        or confess __PACKAGE__, ": unknown encoding: $myname";
      DEBUG and warn $self->{encoding}, " => ", $obj->name;
      if ( $self->{encoding} ) {
          from_to( $self->{data}, $self->{encoding}, $obj->name, 1 );
      }
      else {
          $self->{data} = $obj->encode( $self->{data}, 1 );
      }
      $self->{encoding} = $obj->name;
      return $self;
  }
  
  use overload
    q("") => sub { $_[0]->{data} },
    q(0+) => sub { use bytes(); bytes::length( $_[0]->{data} ) },
    fallback => 1,
    ;
  
  1;
  __END__
  
  =head1 NAME
  
  Encode::Encoder -- Object Oriented Encoder
  
  =head1 SYNOPSIS
  
    use Encode::Encoder;
    # Encode::encode("ISO-8859-1", $data); 
    Encode::Encoder->new($data)->iso_8859_1; # OOP way
    # shortcut
    use Encode::Encoder qw(encoder);
    encoder($data)->iso_8859_1;
    # you can stack them!
    encoder($data)->iso_8859_1->base64;  # provided base64() is defined
    # you can use it as a decoder as well
    encoder($base64)->bytes('base64')->latin1;
    # stringified
    print encoder($data)->utf8->latin1;  # prints the string in latin1
    # numified
    encoder("\x{abcd}\x{ef}g")->utf8 == 6; # true. bytes::length($data)
  
  =head1 ABSTRACT
  
  B<Encode::Encoder> allows you to use Encode in an object-oriented
  style.  This is not only more intuitive than a functional approach,
  but also handier when you want to stack encodings.  Suppose you want
  your UTF-8 string converted to Latin1 then Base64: you can simply say
  
    my $base64 = encoder($utf8)->latin1->base64;
  
  instead of
  
    my $latin1 = encode("latin1", $utf8);
    my $base64 = encode_base64($utf8);
  
  or the lazier and more convoluted
  
    my $base64 = encode_base64(encode("latin1", $utf8));
  
  =head1 Description
  
  Here is how to use this module.
  
  =over 4
  
  =item *
  
  There are at least two instance variables stored in a hash reference,
  {data} and {encoding}.
  
  =item *
  
  When there is no method, it takes the method name as the name of the
  encoding and encodes the instance I<data> with I<encoding>.  If successful,
  the instance I<encoding> is set accordingly.
  
  =item *
  
  You can retrieve the result via -E<gt>data but usually you don't have to 
  because the stringify operator ("") is overridden to do exactly that.
  
  =back
  
  =head2 Predefined Methods
  
  This module predefines the methods below:
  
  =over 4
  
  =item $e = Encode::Encoder-E<gt>new([$data, $encoding]);
  
  returns an encoder object.  Its data is initialized with $data if
  present, and its encoding is set to $encoding if present.
  
  When $encoding is omitted, it defaults to utf8 if $data is already in
  utf8 or "" (empty string) otherwise.
  
  =item encoder()
  
  is an alias of Encode::Encoder-E<gt>new().  This one is exported on demand.
  
  =item $e-E<gt>data([$data])
  
  When $data is present, sets the instance data to $data and returns the
  object itself.  Otherwise, the current instance data is returned.
  
  =item $e-E<gt>encoding([$encoding])
  
  When $encoding is present, sets the instance encoding to $encoding and
  returns the object itself.  Otherwise, the current instance encoding is
  returned.
  
  =item $e-E<gt>bytes([$encoding])
  
  decodes instance data from $encoding, or the instance encoding if
  omitted.  If the conversion is successful, the instance encoding
  will be set to "".
  
  The name I<bytes> was deliberately picked to avoid namespace tainting
  -- this module may be used as a base class so method names that appear
  in Encode::Encoding are avoided.
  
  =back
  
  =head2 Example: base64 transcoder
  
  This module is designed to work with L<Encode::Encoding>.
  To make the Base64 transcoder example above really work, you could
  write a module like this:
  
    package Encode::Base64;
    use parent 'Encode::Encoding';
    __PACKAGE__->Define('base64');
    use MIME::Base64;
    sub encode{ 
        my ($obj, $data) = @_; 
        return encode_base64($data);
    }
    sub decode{
        my ($obj, $data) = @_; 
        return decode_base64($data);
    }
    1;
    __END__
  
  And your caller module would be something like this:
  
    use Encode::Encoder;
    use Encode::Base64;
  
    # now you can really do the following
  
    encoder($data)->iso_8859_1->base64;
    encoder($base64)->bytes('base64')->latin1;
  
  =head2 Operator Overloading
  
  This module overloads two operators, stringify ("") and numify (0+).
  
  Stringify dumps the data inside the object.
  
  Numify returns the number of bytes in the instance data.
  
  They come in handy when you want to print or find the size of data.
  
  =head1 SEE ALSO
  
  L<Encode>,
  L<Encode::Encoding>
  
  =cut
I686-LINUX-GNU-THREAD-MULTI-64INT_ENCODE_ENCODER

$fatpacked{"i686-linux-gnu-thread-multi-64int/Encode/Encoding.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'I686-LINUX-GNU-THREAD-MULTI-64INT_ENCODE_ENCODING';
  package Encode::Encoding;
  
  # Base class for classes which implement encodings
  use strict;
  use warnings;
  our $VERSION = do { my @r = ( q$Revision: 2.7 $ =~ /\d+/g ); sprintf "%d." . "%02d" x $#r, @r };
  
  require Encode;
  
  sub DEBUG { 0 }
  
  sub Define {
      my $obj       = shift;
      my $canonical = shift;
      $obj = bless { Name => $canonical }, $obj unless ref $obj;
  
      # warn "$canonical => $obj\n";
      Encode::define_encoding( $obj, $canonical, @_ );
  }
  
  sub name { return shift->{'Name'} }
  
  sub mime_name{
      require Encode::MIME::Name;
      return Encode::MIME::Name::get_mime_name(shift->name);
  }
  
  # sub renew { return $_[0] }
  
  sub renew {
      my $self = shift;
      my $clone = bless {%$self} => ref($self);
      $clone->{renewed}++;    # so the caller can see it
      DEBUG and warn $clone->{renewed};
      return $clone;
  }
  
  sub renewed { return $_[0]->{renewed} || 0 }
  
  *new_sequence = \&renew;
  
  sub needs_lines { 0 }
  
  sub perlio_ok {
      eval { require PerlIO::encoding };
      return $@ ? 0 : 1;
  }
  
  # (Temporary|legacy) methods
  
  sub toUnicode   { shift->decode(@_) }
  sub fromUnicode { shift->encode(@_) }
  
  #
  # Needs to be overloaded or just croak
  #
  
  sub encode {
      require Carp;
      my $obj = shift;
      my $class = ref($obj) ? ref($obj) : $obj;
      Carp::croak( $class . "->encode() not defined!" );
  }
  
  sub decode {
      require Carp;
      my $obj = shift;
      my $class = ref($obj) ? ref($obj) : $obj;
      Carp::croak( $class . "->encode() not defined!" );
  }
  
  sub DESTROY { }
  
  1;
  __END__
  
  =head1 NAME
  
  Encode::Encoding - Encode Implementation Base Class
  
  =head1 SYNOPSIS
  
    package Encode::MyEncoding;
    use parent qw(Encode::Encoding);
  
    __PACKAGE__->Define(qw(myCanonical myAlias));
  
  =head1 DESCRIPTION
  
  As mentioned in L<Encode>, encodings are (in the current
  implementation at least) defined as objects. The mapping of encoding
  name to object is via the C<%Encode::Encoding> hash.  Though you can
  directly manipulate this hash, it is strongly encouraged to use this
  base class module and add encode() and decode() methods.
  
  =head2 Methods you should implement
  
  You are strongly encouraged to implement methods below, at least
  either encode() or decode().
  
  =over 4
  
  =item -E<gt>encode($string [,$check])
  
  MUST return the octet sequence representing I<$string>. 
  
  =over 2
  
  =item *
  
  If I<$check> is true, it SHOULD modify I<$string> in place to remove
  the converted part (i.e.  the whole string unless there is an error).
  If perlio_ok() is true, SHOULD becomes MUST.
  
  =item *
  
  If an error occurs, it SHOULD return the octet sequence for the
  fragment of string that has been converted and modify $string in-place
  to remove the converted part leaving it starting with the problem
  fragment.  If perlio_ok() is true, SHOULD becomes MUST.
  
  =item *
  
  If I<$check> is false then C<encode> MUST  make a "best effort" to
  convert the string - for example, by using a replacement character.
  
  =back
  
  =item -E<gt>decode($octets [,$check])
  
  MUST return the string that I<$octets> represents.
  
  =over 2
  
  =item *
  
  If I<$check> is true, it SHOULD modify I<$octets> in place to remove
  the converted part (i.e.  the whole sequence unless there is an
  error).  If perlio_ok() is true, SHOULD becomes MUST.
  
  =item *
  
  If an error occurs, it SHOULD return the fragment of string that has
  been converted and modify $octets in-place to remove the converted
  part leaving it starting with the problem fragment.  If perlio_ok() is
  true, SHOULD becomes MUST.
  
  =item *
  
  If I<$check> is false then C<decode> should make a "best effort" to
  convert the string - for example by using Unicode's "\x{FFFD}" as a
  replacement character.
  
  =back
  
  =back
  
  If you want your encoding to work with L<encoding> pragma, you should
  also implement the method below.
  
  =over 4
  
  =item -E<gt>cat_decode($destination, $octets, $offset, $terminator [,$check])
  
  MUST decode I<$octets> with I<$offset> and concatenate it to I<$destination>.
  Decoding will terminate when $terminator (a string) appears in output.
  I<$offset> will be modified to the last $octets position at end of decode.
  Returns true if $terminator appears output, else returns false.
  
  =back
  
  =head2 Other methods defined in Encode::Encodings
  
  You do not have to override methods shown below unless you have to.
  
  =over 4
  
  =item -E<gt>name
  
  Predefined As:
  
    sub name  { return shift->{'Name'} }
  
  MUST return the string representing the canonical name of the encoding.
  
  =item -E<gt>mime_name
  
  Predefined As:
  
    sub mime_name{
      require Encode::MIME::Name;
      return Encode::MIME::Name::get_mime_name(shift->name);
    }
  
  MUST return the string representing the IANA charset name of the encoding.
  
  =item -E<gt>renew
  
  Predefined As:
  
    sub renew {
      my $self = shift;
      my $clone = bless { %$self } => ref($self);
      $clone->{renewed}++;
      return $clone;
    }
  
  This method reconstructs the encoding object if necessary.  If you need
  to store the state during encoding, this is where you clone your object.
  
  PerlIO ALWAYS calls this method to make sure it has its own private
  encoding object.
  
  =item -E<gt>renewed
  
  Predefined As:
  
    sub renewed { $_[0]->{renewed} || 0 }
  
  Tells whether the object is renewed (and how many times).  Some
  modules emit C<Use of uninitialized value in null operation> warning
  unless the value is numeric so return 0 for false.
  
  =item -E<gt>perlio_ok()
  
  Predefined As:
  
    sub perlio_ok { 
        eval{ require PerlIO::encoding };
        return $@ ? 0 : 1;
    }
  
  If your encoding does not support PerlIO for some reasons, just;
  
   sub perlio_ok { 0 }
  
  =item -E<gt>needs_lines()
  
  Predefined As:
  
    sub needs_lines { 0 };
  
  If your encoding can work with PerlIO but needs line buffering, you
  MUST define this method so it returns true.  7bit ISO-2022 encodings
  are one example that needs this.  When this method is missing, false
  is assumed.
  
  =back
  
  =head2 Example: Encode::ROT13
  
    package Encode::ROT13;
    use strict;
    use parent qw(Encode::Encoding);
  
    __PACKAGE__->Define('rot13');
  
    sub encode($$;$){
        my ($obj, $str, $chk) = @_;
        $str =~ tr/A-Za-z/N-ZA-Mn-za-m/;
        $_[1] = '' if $chk; # this is what in-place edit means
        return $str;
    }
  
    # Jr pna or ynml yvxr guvf;
    *decode = \&encode;
  
    1;
  
  =head1 Why the heck Encode API is different?
  
  It should be noted that the I<$check> behaviour is different from the
  outer public API. The logic is that the "unchecked" case is useful
  when the encoding is part of a stream which may be reporting errors
  (e.g. STDERR).  In such cases, it is desirable to get everything
  through somehow without causing additional errors which obscure the
  original one. Also, the encoding is best placed to know what the
  correct replacement character is, so if that is the desired behaviour
  then letting low level code do it is the most efficient.
  
  By contrast, if I<$check> is true, the scheme above allows the
  encoding to do as much as it can and tell the layer above how much
  that was. What is lacking at present is a mechanism to report what
  went wrong. The most likely interface will be an additional method
  call to the object, or perhaps (to avoid forcing per-stream objects
  on otherwise stateless encodings) an additional parameter.
  
  It is also highly desirable that encoding classes inherit from
  C<Encode::Encoding> as a base class. This allows that class to define
  additional behaviour for all encoding objects.
  
    package Encode::MyEncoding;
    use parent qw(Encode::Encoding);
  
    __PACKAGE__->Define(qw(myCanonical myAlias));
  
  to create an object with C<< bless {Name => ...}, $class >>, and call
  define_encoding.  They inherit their C<name> method from
  C<Encode::Encoding>.
  
  =head2 Compiled Encodings
  
  For the sake of speed and efficiency, most of the encodings are now
  supported via a I<compiled form>: XS modules generated from UCM
  files.   Encode provides the enc2xs tool to achieve that.  Please see
  L<enc2xs> for more details.
  
  =head1 SEE ALSO
  
  L<perlmod>, L<enc2xs>
  
  =begin future
  
  =over 4
  
  =item Scheme 1
  
  The fixup routine gets passed the remaining fragment of string being
  processed.  It modifies it in place to remove bytes/characters it can
  understand and returns a string used to represent them.  For example:
  
   sub fixup {
     my $ch = substr($_[0],0,1,'');
     return sprintf("\x{%02X}",ord($ch);
   }
  
  This scheme is close to how the underlying C code for Encode works,
  but gives the fixup routine very little context.
  
  =item Scheme 2
  
  The fixup routine gets passed the original string, an index into
  it of the problem area, and the output string so far.  It appends
  what it wants to the output string and returns a new index into the
  original string.  For example:
  
   sub fixup {
     # my ($s,$i,$d) = @_;
     my $ch = substr($_[0],$_[1],1);
     $_[2] .= sprintf("\x{%02X}",ord($ch);
     return $_[1]+1;
   }
  
  This scheme gives maximal control to the fixup routine but is more
  complicated to code, and may require that the internals of Encode be tweaked to
  keep the original string intact.
  
  =item Other Schemes
  
  Hybrids of the above.
  
  Multiple return values rather than in-place modifications.
  
  Index into the string could be C<pos($str)> allowing C<s/\G...//>.
  
  =back
  
  =end future
  
  =cut
I686-LINUX-GNU-THREAD-MULTI-64INT_ENCODE_ENCODING

$fatpacked{"i686-linux-gnu-thread-multi-64int/Encode/GSM0338.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'I686-LINUX-GNU-THREAD-MULTI-64INT_ENCODE_GSM0338';
  #
  # $Id: GSM0338.pm,v 2.5 2013/09/14 07:51:59 dankogai Exp $
  #
  package Encode::GSM0338;
  
  use strict;
  use warnings;
  use Carp;
  
  use vars qw($VERSION);
  $VERSION = do { my @r = ( q$Revision: 2.5 $ =~ /\d+/g ); sprintf "%d." . "%02d" x $#r, @r };
  
  use Encode qw(:fallbacks);
  
  use parent qw(Encode::Encoding);
  __PACKAGE__->Define('gsm0338');
  
  sub needs_lines { 1 }
  sub perlio_ok   { 0 }
  
  use utf8;
  our %UNI2GSM = (
      "\x{0040}" => "\x00",        # COMMERCIAL AT
      "\x{000A}" => "\x0A",        # LINE FEED
      "\x{000C}" => "\x1B\x0A",    # FORM FEED
      "\x{000D}" => "\x0D",        # CARRIAGE RETURN
      "\x{0020}" => "\x20",        # SPACE
      "\x{0021}" => "\x21",        # EXCLAMATION MARK
      "\x{0022}" => "\x22",        # QUOTATION MARK
      "\x{0023}" => "\x23",        # NUMBER SIGN
      "\x{0024}" => "\x02",        # DOLLAR SIGN
      "\x{0025}" => "\x25",        # PERCENT SIGN
      "\x{0026}" => "\x26",        # AMPERSAND
      "\x{0027}" => "\x27",        # APOSTROPHE
      "\x{0028}" => "\x28",        # LEFT PARENTHESIS
      "\x{0029}" => "\x29",        # RIGHT PARENTHESIS
      "\x{002A}" => "\x2A",        # ASTERISK
      "\x{002B}" => "\x2B",        # PLUS SIGN
      "\x{002C}" => "\x2C",        # COMMA
      "\x{002D}" => "\x2D",        # HYPHEN-MINUS
      "\x{002E}" => "\x2E",        # FULL STOP
      "\x{002F}" => "\x2F",        # SOLIDUS
      "\x{0030}" => "\x30",        # DIGIT ZERO
      "\x{0031}" => "\x31",        # DIGIT ONE
      "\x{0032}" => "\x32",        # DIGIT TWO
      "\x{0033}" => "\x33",        # DIGIT THREE
      "\x{0034}" => "\x34",        # DIGIT FOUR
      "\x{0035}" => "\x35",        # DIGIT FIVE
      "\x{0036}" => "\x36",        # DIGIT SIX
      "\x{0037}" => "\x37",        # DIGIT SEVEN
      "\x{0038}" => "\x38",        # DIGIT EIGHT
      "\x{0039}" => "\x39",        # DIGIT NINE
      "\x{003A}" => "\x3A",        # COLON
      "\x{003B}" => "\x3B",        # SEMICOLON
      "\x{003C}" => "\x3C",        # LESS-THAN SIGN
      "\x{003D}" => "\x3D",        # EQUALS SIGN
      "\x{003E}" => "\x3E",        # GREATER-THAN SIGN
      "\x{003F}" => "\x3F",        # QUESTION MARK
      "\x{0041}" => "\x41",        # LATIN CAPITAL LETTER A
      "\x{0042}" => "\x42",        # LATIN CAPITAL LETTER B
      "\x{0043}" => "\x43",        # LATIN CAPITAL LETTER C
      "\x{0044}" => "\x44",        # LATIN CAPITAL LETTER D
      "\x{0045}" => "\x45",        # LATIN CAPITAL LETTER E
      "\x{0046}" => "\x46",        # LATIN CAPITAL LETTER F
      "\x{0047}" => "\x47",        # LATIN CAPITAL LETTER G
      "\x{0048}" => "\x48",        # LATIN CAPITAL LETTER H
      "\x{0049}" => "\x49",        # LATIN CAPITAL LETTER I
      "\x{004A}" => "\x4A",        # LATIN CAPITAL LETTER J
      "\x{004B}" => "\x4B",        # LATIN CAPITAL LETTER K
      "\x{004C}" => "\x4C",        # LATIN CAPITAL LETTER L
      "\x{004D}" => "\x4D",        # LATIN CAPITAL LETTER M
      "\x{004E}" => "\x4E",        # LATIN CAPITAL LETTER N
      "\x{004F}" => "\x4F",        # LATIN CAPITAL LETTER O
      "\x{0050}" => "\x50",        # LATIN CAPITAL LETTER P
      "\x{0051}" => "\x51",        # LATIN CAPITAL LETTER Q
      "\x{0052}" => "\x52",        # LATIN CAPITAL LETTER R
      "\x{0053}" => "\x53",        # LATIN CAPITAL LETTER S
      "\x{0054}" => "\x54",        # LATIN CAPITAL LETTER T
      "\x{0055}" => "\x55",        # LATIN CAPITAL LETTER U
      "\x{0056}" => "\x56",        # LATIN CAPITAL LETTER V
      "\x{0057}" => "\x57",        # LATIN CAPITAL LETTER W
      "\x{0058}" => "\x58",        # LATIN CAPITAL LETTER X
      "\x{0059}" => "\x59",        # LATIN CAPITAL LETTER Y
      "\x{005A}" => "\x5A",        # LATIN CAPITAL LETTER Z
      "\x{005F}" => "\x11",        # LOW LINE
      "\x{0061}" => "\x61",        # LATIN SMALL LETTER A
      "\x{0062}" => "\x62",        # LATIN SMALL LETTER B
      "\x{0063}" => "\x63",        # LATIN SMALL LETTER C
      "\x{0064}" => "\x64",        # LATIN SMALL LETTER D
      "\x{0065}" => "\x65",        # LATIN SMALL LETTER E
      "\x{0066}" => "\x66",        # LATIN SMALL LETTER F
      "\x{0067}" => "\x67",        # LATIN SMALL LETTER G
      "\x{0068}" => "\x68",        # LATIN SMALL LETTER H
      "\x{0069}" => "\x69",        # LATIN SMALL LETTER I
      "\x{006A}" => "\x6A",        # LATIN SMALL LETTER J
      "\x{006B}" => "\x6B",        # LATIN SMALL LETTER K
      "\x{006C}" => "\x6C",        # LATIN SMALL LETTER L
      "\x{006D}" => "\x6D",        # LATIN SMALL LETTER M
      "\x{006E}" => "\x6E",        # LATIN SMALL LETTER N
      "\x{006F}" => "\x6F",        # LATIN SMALL LETTER O
      "\x{0070}" => "\x70",        # LATIN SMALL LETTER P
      "\x{0071}" => "\x71",        # LATIN SMALL LETTER Q
      "\x{0072}" => "\x72",        # LATIN SMALL LETTER R
      "\x{0073}" => "\x73",        # LATIN SMALL LETTER S
      "\x{0074}" => "\x74",        # LATIN SMALL LETTER T
      "\x{0075}" => "\x75",        # LATIN SMALL LETTER U
      "\x{0076}" => "\x76",        # LATIN SMALL LETTER V
      "\x{0077}" => "\x77",        # LATIN SMALL LETTER W
      "\x{0078}" => "\x78",        # LATIN SMALL LETTER X
      "\x{0079}" => "\x79",        # LATIN SMALL LETTER Y
      "\x{007A}" => "\x7A",        # LATIN SMALL LETTER Z
      "\x{000C}" => "\x1B\x0A",    # FORM FEED
      "\x{005B}" => "\x1B\x3C",    # LEFT SQUARE BRACKET
      "\x{005C}" => "\x1B\x2F",    # REVERSE SOLIDUS
      "\x{005D}" => "\x1B\x3E",    # RIGHT SQUARE BRACKET
      "\x{005E}" => "\x1B\x14",    # CIRCUMFLEX ACCENT
      "\x{007B}" => "\x1B\x28",    # LEFT CURLY BRACKET
      "\x{007C}" => "\x1B\x40",    # VERTICAL LINE
      "\x{007D}" => "\x1B\x29",    # RIGHT CURLY BRACKET
      "\x{007E}" => "\x1B\x3D",    # TILDE
      "\x{00A0}" => "\x1B",        # NO-BREAK SPACE
      "\x{00A1}" => "\x40",        # INVERTED EXCLAMATION MARK
      "\x{00A3}" => "\x01",        # POUND SIGN
      "\x{00A4}" => "\x24",        # CURRENCY SIGN
      "\x{00A5}" => "\x03",        # YEN SIGN
      "\x{00A7}" => "\x5F",        # SECTION SIGN
      "\x{00BF}" => "\x60",        # INVERTED QUESTION MARK
      "\x{00C4}" => "\x5B",        # LATIN CAPITAL LETTER A WITH DIAERESIS
      "\x{00C5}" => "\x0E",        # LATIN CAPITAL LETTER A WITH RING ABOVE
      "\x{00C6}" => "\x1C",        # LATIN CAPITAL LETTER AE
      "\x{00C9}" => "\x1F",        # LATIN CAPITAL LETTER E WITH ACUTE
      "\x{00D1}" => "\x5D",        # LATIN CAPITAL LETTER N WITH TILDE
      "\x{00D6}" => "\x5C",        # LATIN CAPITAL LETTER O WITH DIAERESIS
      "\x{00D8}" => "\x0B",        # LATIN CAPITAL LETTER O WITH STROKE
      "\x{00DC}" => "\x5E",        # LATIN CAPITAL LETTER U WITH DIAERESIS
      "\x{00DF}" => "\x1E",        # LATIN SMALL LETTER SHARP S
      "\x{00E0}" => "\x7F",        # LATIN SMALL LETTER A WITH GRAVE
      "\x{00E4}" => "\x7B",        # LATIN SMALL LETTER A WITH DIAERESIS
      "\x{00E5}" => "\x0F",        # LATIN SMALL LETTER A WITH RING ABOVE
      "\x{00E6}" => "\x1D",        # LATIN SMALL LETTER AE
      #"\x{00E7}" => "\x09",        # LATIN SMALL LETTER C WITH CEDILLA
      "\x{00C7}" => "\x09",        # LATIN CAPITAL LETTER C WITH CEDILLA
      "\x{00E8}" => "\x04",        # LATIN SMALL LETTER E WITH GRAVE
      "\x{00E9}" => "\x05",        # LATIN SMALL LETTER E WITH ACUTE
      "\x{00EC}" => "\x07",        # LATIN SMALL LETTER I WITH GRAVE
      "\x{00F1}" => "\x7D",        # LATIN SMALL LETTER N WITH TILDE
      "\x{00F2}" => "\x08",        # LATIN SMALL LETTER O WITH GRAVE
      "\x{00F6}" => "\x7C",        # LATIN SMALL LETTER O WITH DIAERESIS
      "\x{00F8}" => "\x0C",        # LATIN SMALL LETTER O WITH STROKE
      "\x{00F9}" => "\x06",        # LATIN SMALL LETTER U WITH GRAVE
      "\x{00FC}" => "\x7E",        # LATIN SMALL LETTER U WITH DIAERESIS
      "\x{0393}" => "\x13",        # GREEK CAPITAL LETTER GAMMA
      "\x{0394}" => "\x10",        # GREEK CAPITAL LETTER DELTA
      "\x{0398}" => "\x19",        # GREEK CAPITAL LETTER THETA
      "\x{039B}" => "\x14",        # GREEK CAPITAL LETTER LAMDA
      "\x{039E}" => "\x1A",        # GREEK CAPITAL LETTER XI
      "\x{03A0}" => "\x16",        # GREEK CAPITAL LETTER PI
      "\x{03A3}" => "\x18",        # GREEK CAPITAL LETTER SIGMA
      "\x{03A6}" => "\x12",        # GREEK CAPITAL LETTER PHI
      "\x{03A8}" => "\x17",        # GREEK CAPITAL LETTER PSI
      "\x{03A9}" => "\x15",        # GREEK CAPITAL LETTER OMEGA
      "\x{20AC}" => "\x1B\x65",    # EURO SIGN
  );
  our %GSM2UNI = reverse %UNI2GSM;
  our $ESC    = "\x1b";
  our $ATMARK = "\x40";
  our $FBCHAR = "\x3F";
  our $NBSP   = "\x{00A0}";
  
  #define ERR_DECODE_NOMAP "%s \"\\x%02" UVXf "\" does not map to Unicode"
  
  sub decode ($$;$) {
      my ( $obj, $bytes, $chk ) = @_;
      my $str = substr($bytes, 0, 0); # to propagate taintedness;
      while ( length $bytes ) {
          my $c = substr( $bytes, 0, 1, '' );
          my $u;
          if ( $c eq "\x00" ) {
              my $c2 = substr( $bytes, 0, 1, '' );
              $u =
                  !length $c2 ? $ATMARK
                : $c2 eq "\x00" ? "\x{0000}"
                : exists $GSM2UNI{$c2} ? $ATMARK . $GSM2UNI{$c2}
                : $chk
                ? croak sprintf( "\\x%02X\\x%02X does not map to Unicode",
  			       ord($c), ord($c2) )
                : $ATMARK . $FBCHAR;
  
          }
          elsif ( $c eq $ESC ) {
              my $c2 = substr( $bytes, 0, 1, '' );
              $u =
                  exists $GSM2UNI{ $c . $c2 } ? $GSM2UNI{ $c . $c2 }
                : exists $GSM2UNI{$c2}        ? $NBSP . $GSM2UNI{$c2}
                : $chk
                ? croak sprintf( "\\x%02X\\x%02X does not map to Unicode",
  			       ord($c), ord($c2) )
                : $NBSP . $FBCHAR;
          }
          else {
              $u =
                exists $GSM2UNI{$c}
                ? $GSM2UNI{$c}
                : $chk ? ref $chk eq 'CODE'
                    ? $chk->( ord $c )
                    : croak sprintf( "\\x%02X does not map to Unicode", ord($c) )
                : $FBCHAR;
          }
          $str .= $u;
      }
      $_[1] = $bytes if $chk;
      return $str;
  }
  
  #define ERR_ENCODE_NOMAP "\"\\x{%04" UVxf "}\" does not map to %s"
  
  sub encode($$;$) {
      my ( $obj, $str, $chk ) = @_;
      my $bytes = substr($str, 0, 0); # to propagate taintedness
      while ( length $str ) {
          my $u = substr( $str, 0, 1, '' );
          my $c;
          $bytes .=
            exists $UNI2GSM{$u}
            ? $UNI2GSM{$u}
            : $chk ? ref $chk eq 'CODE'
                ? $chk->( ord($u) )
                : croak sprintf( "\\x{%04x} does not map to %s", 
  			       ord($u), $obj->name )
            : $FBCHAR;
      }
      $_[1] = $str if $chk;
      return $bytes;
  }
  
  1;
  __END__
  
  =head1 NAME
  
  Encode::GSM0338 -- ESTI GSM 03.38 Encoding
  
  =head1 SYNOPSIS
  
    use Encode qw/encode decode/; 
    $gsm0338 = encode("gsm0338", $utf8);    # loads Encode::GSM0338 implicitly
    $utf8    = decode("gsm0338", $gsm0338); # ditto
  
  =head1 DESCRIPTION
  
  GSM0338 is for GSM handsets. Though it shares alphanumerals with ASCII,
  control character ranges and other parts are mapped very differently,
  mainly to store Greek characters.  There are also escape sequences
  (starting with 0x1B) to cover e.g. the Euro sign.
  
  This was once handled by L<Encode::Bytes> but because of all those
  unusual specifications, Encode 2.20 has relocated the support to
  this module.
  
  =head1 NOTES
  
  Unlike most other encodings,  the following always croaks on error
  for any $chk that evaluates to true.
  
    $gsm0338 = encode("gsm0338", $utf8      $chk);
    $utf8    = decode("gsm0338", $gsm0338,  $chk);
  
  So if you want to check the validity of the encoding, surround the
  expression with C<eval {}> block as follows;
  
    eval {
      $utf8    = decode("gsm0338", $gsm0338,  $chk);
    };
    if ($@){
      # handle exception here
    }
  
  =head1 BUGS
  
  ESTI GSM 03.38 Encoding itself.
  
  Mapping \x00 to '@' causes too much pain everywhere.
  
  Its use of \x1b (escape) is also very questionable.  
  
  Because of those two, the code paging approach used use in ucm-based
  Encoding SOMETIMES fails so this module was written.
  
  =head1 SEE ALSO
  
  L<Encode>
  
  =cut
I686-LINUX-GNU-THREAD-MULTI-64INT_ENCODE_GSM0338

$fatpacked{"i686-linux-gnu-thread-multi-64int/Encode/Guess.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'I686-LINUX-GNU-THREAD-MULTI-64INT_ENCODE_GUESS';
  package Encode::Guess;
  use strict;
  use warnings;
  use Encode qw(:fallbacks find_encoding);
  our $VERSION = do { my @r = ( q$Revision: 2.6 $ =~ /\d+/g ); sprintf "%d." . "%02d" x $#r, @r };
  
  my $Canon = 'Guess';
  use constant DEBUG => !!$ENV{PERL_ENCODE_DEBUG};
  our %DEF_SUSPECTS = map { $_ => find_encoding($_) } qw(ascii utf8);
  $Encode::Encoding{$Canon} = bless {
      Name     => $Canon,
      Suspects => {%DEF_SUSPECTS},
  } => __PACKAGE__;
  
  use parent qw(Encode::Encoding);
  sub needs_lines { 1 }
  sub perlio_ok   { 0 }
  
  our @EXPORT         = qw(guess_encoding);
  our $NoUTFAutoGuess = 0;
  our $UTF8_BOM       = pack( "C3", 0xef, 0xbb, 0xbf );
  
  sub import {    # Exporter not used so we do it on our own
      my $callpkg = caller;
      for my $item (@EXPORT) {
          no strict 'refs';
          *{"$callpkg\::$item"} = \&{"$item"};
      }
      set_suspects(@_);
  }
  
  sub set_suspects {
      my $class = shift;
      my $self = ref($class) ? $class : $Encode::Encoding{$Canon};
      $self->{Suspects} = {%DEF_SUSPECTS};
      $self->add_suspects(@_);
  }
  
  sub add_suspects {
      my $class = shift;
      my $self = ref($class) ? $class : $Encode::Encoding{$Canon};
      for my $c (@_) {
          my $e = find_encoding($c) or die "Unknown encoding: $c";
          $self->{Suspects}{ $e->name } = $e;
          DEBUG and warn "Added: ", $e->name;
      }
  }
  
  sub decode($$;$) {
      my ( $obj, $octet, $chk ) = @_;
      my $guessed = guess( $obj, $octet );
      unless ( ref($guessed) ) {
          require Carp;
          Carp::croak($guessed);
      }
      my $utf8 = $guessed->decode( $octet, $chk || 0 );
      $_[1] = $octet if $chk;
      return $utf8;
  }
  
  sub guess_encoding {
      guess( $Encode::Encoding{$Canon}, @_ );
  }
  
  sub guess {
      my $class = shift;
      my $obj   = ref($class) ? $class : $Encode::Encoding{$Canon};
      my $octet = shift;
  
      # sanity check
      return "Empty string, empty guess" unless defined $octet and length $octet;
  
      # cheat 0: utf8 flag;
      if ( Encode::is_utf8($octet) ) {
          return find_encoding('utf8') unless $NoUTFAutoGuess;
          Encode::_utf8_off($octet);
      }
  
      # cheat 1: BOM
      use Encode::Unicode;
      unless ($NoUTFAutoGuess) {
          my $BOM = pack( 'C3', unpack( "C3", $octet ) );
          return find_encoding('utf8')
            if ( defined $BOM and $BOM eq $UTF8_BOM );
          $BOM = unpack( 'N', $octet );
          return find_encoding('UTF-32')
            if ( defined $BOM and ( $BOM == 0xFeFF or $BOM == 0xFFFe0000 ) );
          $BOM = unpack( 'n', $octet );
          return find_encoding('UTF-16')
            if ( defined $BOM and ( $BOM == 0xFeFF or $BOM == 0xFFFe ) );
          if ( $octet =~ /\x00/o )
          {    # if \x00 found, we assume UTF-(16|32)(BE|LE)
              my $utf;
              my ( $be, $le ) = ( 0, 0 );
              if ( $octet =~ /\x00\x00/o ) {    # UTF-32(BE|LE) assumed
                  $utf = "UTF-32";
                  for my $char ( unpack( 'N*', $octet ) ) {
                      $char & 0x0000ffff and $be++;
                      $char & 0xffff0000 and $le++;
                  }
              }
              else {                            # UTF-16(BE|LE) assumed
                  $utf = "UTF-16";
                  for my $char ( unpack( 'n*', $octet ) ) {
                      $char & 0x00ff and $be++;
                      $char & 0xff00 and $le++;
                  }
              }
              DEBUG and warn "$utf, be == $be, le == $le";
              $be == $le
                and return
                "Encodings ambiguous between $utf BE and LE ($be, $le)";
              $utf .= ( $be > $le ) ? 'BE' : 'LE';
              return find_encoding($utf);
          }
      }
      my %try = %{ $obj->{Suspects} };
      for my $c (@_) {
          my $e = find_encoding($c) or die "Unknown encoding: $c";
          $try{ $e->name } = $e;
          DEBUG and warn "Added: ", $e->name;
      }
      my $nline = 1;
      for my $line ( split /\r\n?|\n/, $octet ) {
  
          # cheat 2 -- \e in the string
          if ( $line =~ /\e/o ) {
              my @keys = keys %try;
              delete @try{qw/utf8 ascii/};
              for my $k (@keys) {
                  ref( $try{$k} ) eq 'Encode::XS' and delete $try{$k};
              }
          }
          my %ok = %try;
  
          # warn join(",", keys %try);
          for my $k ( keys %try ) {
              my $scratch = $line;
              $try{$k}->decode( $scratch, FB_QUIET );
              if ( $scratch eq '' ) {
                  DEBUG and warn sprintf( "%4d:%-24s ok\n", $nline, $k );
              }
              else {
                  use bytes ();
                  DEBUG
                    and warn sprintf( "%4d:%-24s not ok; %d bytes left\n",
                      $nline, $k, bytes::length($scratch) );
                  delete $ok{$k};
              }
          }
          %ok or return "No appropriate encodings found!";
          if ( scalar( keys(%ok) ) == 1 ) {
              my ($retval) = values(%ok);
              return $retval;
          }
          %try = %ok;
          $nline++;
      }
      $try{ascii}
        or return "Encodings too ambiguous: ", join( " or ", keys %try );
      return $try{ascii};
  }
  
  1;
  __END__
  
  =head1 NAME
  
  Encode::Guess -- Guesses encoding from data
  
  =head1 SYNOPSIS
  
    # if you are sure $data won't contain anything bogus
  
    use Encode;
    use Encode::Guess qw/euc-jp shiftjis 7bit-jis/;
    my $utf8 = decode("Guess", $data);
    my $data = encode("Guess", $utf8);   # this doesn't work!
  
    # more elaborate way
    use Encode::Guess;
    my $enc = guess_encoding($data, qw/euc-jp shiftjis 7bit-jis/);
    ref($enc) or die "Can't guess: $enc"; # trap error this way
    $utf8 = $enc->decode($data);
    # or
    $utf8 = decode($enc->name, $data)
  
  =head1 ABSTRACT
  
  Encode::Guess enables you to guess in what encoding a given data is
  encoded, or at least tries to.  
  
  =head1 DESCRIPTION
  
  By default, it checks only ascii, utf8 and UTF-16/32 with BOM.
  
    use Encode::Guess; # ascii/utf8/BOMed UTF
  
  To use it more practically, you have to give the names of encodings to
  check (I<suspects> as follows).  The name of suspects can either be
  canonical names or aliases.
  
  CAVEAT: Unlike UTF-(16|32), BOM in utf8 is NOT AUTOMATICALLY STRIPPED.
  
   # tries all major Japanese Encodings as well
    use Encode::Guess qw/euc-jp shiftjis 7bit-jis/;
  
  If the C<$Encode::Guess::NoUTFAutoGuess> variable is set to a true
  value, no heuristics will be applied to UTF8/16/32, and the result
  will be limited to the suspects and C<ascii>.
  
  =over 4
  
  =item Encode::Guess->set_suspects
  
  You can also change the internal suspects list via C<set_suspects>
  method. 
  
    use Encode::Guess;
    Encode::Guess->set_suspects(qw/euc-jp shiftjis 7bit-jis/);
  
  =item Encode::Guess->add_suspects
  
  Or you can use C<add_suspects> method.  The difference is that
  C<set_suspects> flushes the current suspects list while
  C<add_suspects> adds.
  
    use Encode::Guess;
    Encode::Guess->add_suspects(qw/euc-jp shiftjis 7bit-jis/);
    # now the suspects are euc-jp,shiftjis,7bit-jis, AND
    # euc-kr,euc-cn, and big5-eten
    Encode::Guess->add_suspects(qw/euc-kr euc-cn big5-eten/);
  
  =item Encode::decode("Guess" ...)
  
  When you are content with suspects list, you can now
  
    my $utf8 = Encode::decode("Guess", $data);
  
  =item Encode::Guess->guess($data)
  
  But it will croak if:
  
  =over
  
  =item *
  
  Two or more suspects remain
  
  =item *
  
  No suspects left
  
  =back
  
  So you should instead try this;
  
    my $decoder = Encode::Guess->guess($data);
  
  On success, $decoder is an object that is documented in
  L<Encode::Encoding>.  So you can now do this;
  
    my $utf8 = $decoder->decode($data);
  
  On failure, $decoder now contains an error message so the whole thing
  would be as follows;
  
    my $decoder = Encode::Guess->guess($data);
    die $decoder unless ref($decoder);
    my $utf8 = $decoder->decode($data);
  
  =item guess_encoding($data, [, I<list of suspects>])
  
  You can also try C<guess_encoding> function which is exported by
  default.  It takes $data to check and it also takes the list of
  suspects by option.  The optional suspect list is I<not reflected> to
  the internal suspects list.
  
    my $decoder = guess_encoding($data, qw/euc-jp euc-kr euc-cn/);
    die $decoder unless ref($decoder);
    my $utf8 = $decoder->decode($data);
    # check only ascii, utf8 and UTF-(16|32) with BOM
    my $decoder = guess_encoding($data);
  
  =back
  
  =head1 CAVEATS
  
  =over 4
  
  =item *
  
  Because of the algorithm used, ISO-8859 series and other single-byte
  encodings do not work well unless either one of ISO-8859 is the only
  one suspect (besides ascii and utf8).
  
    use Encode::Guess;
    # perhaps ok
    my $decoder = guess_encoding($data, 'latin1');
    # definitely NOT ok
    my $decoder = guess_encoding($data, qw/latin1 greek/);
  
  The reason is that Encode::Guess guesses encoding by trial and error.
  It first splits $data into lines and tries to decode the line for each
  suspect.  It keeps it going until all but one encoding is eliminated
  out of suspects list.  ISO-8859 series is just too successful for most
  cases (because it fills almost all code points in \x00-\xff).
  
  =item *
  
  Do not mix national standard encodings and the corresponding vendor
  encodings.
  
    # a very bad idea
    my $decoder
       = guess_encoding($data, qw/shiftjis MacJapanese cp932/);
  
  The reason is that vendor encoding is usually a superset of national
  standard so it becomes too ambiguous for most cases.
  
  =item *
  
  On the other hand, mixing various national standard encodings
  automagically works unless $data is too short to allow for guessing.
  
   # This is ok if $data is long enough
   my $decoder =  
    guess_encoding($data, qw/euc-cn
                             euc-jp shiftjis 7bit-jis
                             euc-kr
                             big5-eten/);
  
  =item *
  
  DO NOT PUT TOO MANY SUSPECTS!  Don't you try something like this!
  
    my $decoder = guess_encoding($data, 
                                 Encode->encodings(":all"));
  
  =back
  
  It is, after all, just a guess.  You should alway be explicit when it
  comes to encodings.  But there are some, especially Japanese,
  environment that guess-coding is a must.  Use this module with care. 
  
  =head1 TO DO
  
  Encode::Guess does not work on EBCDIC platforms.
  
  =head1 SEE ALSO
  
  L<Encode>, L<Encode::Encoding>
  
  =cut
  
I686-LINUX-GNU-THREAD-MULTI-64INT_ENCODE_GUESS

$fatpacked{"i686-linux-gnu-thread-multi-64int/Encode/JP.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'I686-LINUX-GNU-THREAD-MULTI-64INT_ENCODE_JP';
  package Encode::JP;
  BEGIN {
      if ( ord("A") == 193 ) {
          die "Encode::JP not supported on EBCDIC\n";
      }
  }
  use strict;
  use warnings;
  use Encode;
  our $VERSION = do { my @r = ( q$Revision: 2.4 $ =~ /\d+/g ); sprintf "%d." . "%02d" x $#r, @r };
  
  use XSLoader;
  XSLoader::load( __PACKAGE__, $VERSION );
  
  use Encode::JP::JIS7;
  
  1;
  __END__
  
  =head1 NAME
  
  Encode::JP - Japanese Encodings
  
  =head1 SYNOPSIS
  
      use Encode qw/encode decode/; 
      $euc_jp = encode("euc-jp", $utf8);   # loads Encode::JP implicitly
      $utf8   = decode("euc-jp", $euc_jp); # ditto
  
  =head1 ABSTRACT
  
  This module implements Japanese charset encodings.  Encodings
  supported are as follows.
  
    Canonical   Alias		Description
    --------------------------------------------------------------------
    euc-jp      /\beuc.*jp$/i	EUC (Extended Unix Character)
                /\bjp.*euc/i   
            /\bujis$/i
    shiftjis    /\bshift.*jis$/i	Shift JIS (aka MS Kanji)
            /\bsjis$/i
    7bit-jis    /\bjis$/i		7bit JIS
    iso-2022-jp			ISO-2022-JP                  [RFC1468]
                  = 7bit JIS with all Halfwidth Kana 
                    converted to Fullwidth
    iso-2022-jp-1			ISO-2022-JP-1                [RFC2237]
                                  = ISO-2022-JP with JIS X 0212-1990
                    support.  See below
    MacJapanese	                Shift JIS + Apple vendor mappings
    cp932       /\bwindows-31j$/i Code Page 932
                                  = Shift JIS + MS/IBM vendor mappings
    jis0201-raw                   JIS0201, raw format
    jis0208-raw                   JIS0201, raw format
    jis0212-raw                   JIS0201, raw format
    --------------------------------------------------------------------
  
  =head1 DESCRIPTION
  
  To find out how to use this module in detail, see L<Encode>.
  
  =head1 Note on ISO-2022-JP(-1)?
  
  ISO-2022-JP-1 (RFC2237) is a superset of ISO-2022-JP (RFC1468) which
  adds support for JIS X 0212-1990.  That means you can use the same
  code to decode to utf8 but not vice versa.
  
    $utf8 = decode('iso-2022-jp-1', $stream);
  
  and
  
    $utf8 = decode('iso-2022-jp',   $stream);
  
  yield the same result but
  
    $with_0212 = encode('iso-2022-jp-1', $utf8);
  
  is now different from
  
    $without_0212 = encode('iso-2022-jp', $utf8 );
  
  In the latter case, characters that map to 0212 are first converted
  to U+3013 (0xA2AE in EUC-JP; a white square also known as 'Tofu' or
  'geta mark') then fed to the decoding engine.  U+FFFD is not used,
  in order to preserve text layout as much as possible.
  
  =head1 BUGS
  
  The ASCII region (0x00-0x7f) is preserved for all encodings, even
  though this conflicts with mappings by the Unicode Consortium.
  
  =head1 SEE ALSO
  
  L<Encode>
  
  =cut
I686-LINUX-GNU-THREAD-MULTI-64INT_ENCODE_JP

$fatpacked{"i686-linux-gnu-thread-multi-64int/Encode/JP/H2Z.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'I686-LINUX-GNU-THREAD-MULTI-64INT_ENCODE_JP_H2Z';
  #
  # $Id: H2Z.pm,v 2.2 2006/06/03 20:28:48 dankogai Exp $
  #
  
  package Encode::JP::H2Z;
  
  use strict;
  use warnings;
  
  our $RCSID = q$Id: H2Z.pm,v 2.2 2006/06/03 20:28:48 dankogai Exp $;
  our $VERSION = do { my @r = ( q$Revision: 2.2 $ =~ /\d+/g ); sprintf "%d." . "%02d" x $#r, @r };
  
  use Encode::CJKConstants qw(:all);
  
  use vars qw(%_D2Z  $_PAT_D2Z
    %_Z2D  $_PAT_Z2D
    %_H2Z  $_PAT_H2Z
    %_Z2H  $_PAT_Z2H);
  
  %_H2Z = (
      "\x8e\xa1" => "\xa1\xa3",    #
      "\x8e\xa2" => "\xa1\xd6",    #
      "\x8e\xa3" => "\xa1\xd7",    #
      "\x8e\xa4" => "\xa1\xa2",    #
      "\x8e\xa5" => "\xa1\xa6",    #
      "\x8e\xa6" => "\xa5\xf2",    #
      "\x8e\xa7" => "\xa5\xa1",    #
      "\x8e\xa8" => "\xa5\xa3",    #
      "\x8e\xa9" => "\xa5\xa5",    #
      "\x8e\xaa" => "\xa5\xa7",    #
      "\x8e\xab" => "\xa5\xa9",    #
      "\x8e\xac" => "\xa5\xe3",    #
      "\x8e\xad" => "\xa5\xe5",    #
      "\x8e\xae" => "\xa5\xe7",    #
      "\x8e\xaf" => "\xa5\xc3",    #
      "\x8e\xb0" => "\xa1\xbc",    #
      "\x8e\xb1" => "\xa5\xa2",    #
      "\x8e\xb2" => "\xa5\xa4",    #
      "\x8e\xb3" => "\xa5\xa6",    #
      "\x8e\xb4" => "\xa5\xa8",    #
      "\x8e\xb5" => "\xa5\xaa",    #
      "\x8e\xb6" => "\xa5\xab",    #
      "\x8e\xb7" => "\xa5\xad",    #
      "\x8e\xb8" => "\xa5\xaf",    #
      "\x8e\xb9" => "\xa5\xb1",    #
      "\x8e\xba" => "\xa5\xb3",    #
      "\x8e\xbb" => "\xa5\xb5",    #
      "\x8e\xbc" => "\xa5\xb7",    #
      "\x8e\xbd" => "\xa5\xb9",    #
      "\x8e\xbe" => "\xa5\xbb",    #
      "\x8e\xbf" => "\xa5\xbd",    #
      "\x8e\xc0" => "\xa5\xbf",    #
      "\x8e\xc1" => "\xa5\xc1",    #
      "\x8e\xc2" => "\xa5\xc4",    #
      "\x8e\xc3" => "\xa5\xc6",    #
      "\x8e\xc4" => "\xa5\xc8",    #
      "\x8e\xc5" => "\xa5\xca",    #
      "\x8e\xc6" => "\xa5\xcb",    #
      "\x8e\xc7" => "\xa5\xcc",    #
      "\x8e\xc8" => "\xa5\xcd",    #
      "\x8e\xc9" => "\xa5\xce",    #
      "\x8e\xca" => "\xa5\xcf",    #
      "\x8e\xcb" => "\xa5\xd2",    #
      "\x8e\xcc" => "\xa5\xd5",    #
      "\x8e\xcd" => "\xa5\xd8",    #
      "\x8e\xce" => "\xa5\xdb",    #
      "\x8e\xcf" => "\xa5\xde",    #
      "\x8e\xd0" => "\xa5\xdf",    #
      "\x8e\xd1" => "\xa5\xe0",    #
      "\x8e\xd2" => "\xa5\xe1",    #
      "\x8e\xd3" => "\xa5\xe2",    #
      "\x8e\xd4" => "\xa5\xe4",    #
      "\x8e\xd5" => "\xa5\xe6",    #
      "\x8e\xd6" => "\xa5\xe8",    #
      "\x8e\xd7" => "\xa5\xe9",    #
      "\x8e\xd8" => "\xa5\xea",    #
      "\x8e\xd9" => "\xa5\xeb",    #
      "\x8e\xda" => "\xa5\xec",    #
      "\x8e\xdb" => "\xa5\xed",    #
      "\x8e\xdc" => "\xa5\xef",    #
      "\x8e\xdd" => "\xa5\xf3",    #
      "\x8e\xde" => "\xa1\xab",    #
      "\x8e\xdf" => "\xa1\xac",    #
  );
  
  %_D2Z = (
      "\x8e\xb6\x8e\xde" => "\xa5\xac",    #
      "\x8e\xb7\x8e\xde" => "\xa5\xae",    #
      "\x8e\xb8\x8e\xde" => "\xa5\xb0",    #
      "\x8e\xb9\x8e\xde" => "\xa5\xb2",    #
      "\x8e\xba\x8e\xde" => "\xa5\xb4",    #
      "\x8e\xbb\x8e\xde" => "\xa5\xb6",    #
      "\x8e\xbc\x8e\xde" => "\xa5\xb8",    #
      "\x8e\xbd\x8e\xde" => "\xa5\xba",    #
      "\x8e\xbe\x8e\xde" => "\xa5\xbc",    #
      "\x8e\xbf\x8e\xde" => "\xa5\xbe",    #
      "\x8e\xc0\x8e\xde" => "\xa5\xc0",    #
      "\x8e\xc1\x8e\xde" => "\xa5\xc2",    #
      "\x8e\xc2\x8e\xde" => "\xa5\xc5",    #
      "\x8e\xc3\x8e\xde" => "\xa5\xc7",    #
      "\x8e\xc4\x8e\xde" => "\xa5\xc9",    #
      "\x8e\xca\x8e\xde" => "\xa5\xd0",    #
      "\x8e\xcb\x8e\xde" => "\xa5\xd3",    #
      "\x8e\xcc\x8e\xde" => "\xa5\xd6",    #
      "\x8e\xcd\x8e\xde" => "\xa5\xd9",    #
      "\x8e\xce\x8e\xde" => "\xa5\xdc",    #
      "\x8e\xca\x8e\xdf" => "\xa5\xd1",    #
      "\x8e\xcb\x8e\xdf" => "\xa5\xd4",    #
      "\x8e\xcc\x8e\xdf" => "\xa5\xd7",    #
      "\x8e\xcd\x8e\xdf" => "\xa5\xda",    #
      "\x8e\xce\x8e\xdf" => "\xa5\xdd",    #
      "\x8e\xb3\x8e\xde" => "\xa5\xf4",    #
  );
  
  # init only once;
  
  #$_PAT_D2Z = join("|", keys %_D2Z);
  #$_PAT_H2Z = join("|", keys %_H2Z);
  
  %_Z2H = reverse %_H2Z;
  %_Z2D = reverse %_D2Z;
  
  #$_PAT_Z2H    = join("|", keys %_Z2H);
  #$_PAT_Z2D    = join("|", keys %_Z2D);
  
  sub h2z {
      no warnings qw(uninitialized);
      my $r_str          = shift;
      my ($keep_dakuten) = @_;
      my $n              = 0;
      unless ($keep_dakuten) {
          $n = (
              $$r_str =~ s(
                 ($RE{EUC_KANA}
                  (?:\x8e[\xde\xdf])?)
                 ){
            my $str = $1;
            $_D2Z{$str} || $_H2Z{$str} || 
                # in case dakuten and handakuten are side-by-side!
                $_H2Z{substr($str,0,2)} . $_H2Z{substr($str,2,2)};
            }eogx
          );
      }
      else {
          $n = (
              $$r_str =~ s(
                 ($RE{EUC_KANA})
                 ){
            $_H2Z{$1};
            }eogx
          );
      }
      $n;
  }
  
  sub z2h {
      my $r_str = shift;
      my $n     = (
          $$r_str =~ s(
                ($RE{EUC_C}|$RE{EUC_0212}|$RE{EUC_KANA})
                ){
           $_Z2D{$1} || $_Z2H{$1} || $1;
           }eogx
      );
      $n;
  }
  
  1;
  __END__
  
  
  =head1 NAME
  
  Encode::JP::H2Z -- internally used by Encode::JP::2022_JP*
  
  =cut
I686-LINUX-GNU-THREAD-MULTI-64INT_ENCODE_JP_H2Z

$fatpacked{"i686-linux-gnu-thread-multi-64int/Encode/JP/JIS7.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'I686-LINUX-GNU-THREAD-MULTI-64INT_ENCODE_JP_JIS7';
  package Encode::JP::JIS7;
  use strict;
  use warnings;
  our $VERSION = do { my @r = ( q$Revision: 2.5 $ =~ /\d+/g ); sprintf "%d." . "%02d" x $#r, @r };
  
  use Encode qw(:fallbacks);
  
  for my $name ( '7bit-jis', 'iso-2022-jp', 'iso-2022-jp-1' ) {
      my $h2z     = ( $name eq '7bit-jis' )    ? 0 : 1;
      my $jis0212 = ( $name eq 'iso-2022-jp' ) ? 0 : 1;
  
      $Encode::Encoding{$name} = bless {
          Name    => $name,
          h2z     => $h2z,
          jis0212 => $jis0212,
      } => __PACKAGE__;
  }
  
  use parent qw(Encode::Encoding);
  
  # we override this to 1 so PerlIO works
  sub needs_lines { 1 }
  
  use Encode::CJKConstants qw(:all);
  
  #
  # decode is identical for all 2022 variants
  #
  
  sub decode($$;$) {
      my ( $obj, $str, $chk ) = @_;
      my $residue = '';
      if ($chk) {
          $str =~ s/([^\x00-\x7f].*)$//so and $residue = $1;
      }
      $residue .= jis_euc( \$str );
      $_[1] = $residue if $chk;
      return Encode::decode( 'euc-jp', $str, FB_PERLQQ );
  }
  
  #
  # encode is different
  #
  
  sub encode($$;$) {
      require Encode::JP::H2Z;
      my ( $obj, $utf8, $chk ) = @_;
  
      # empty the input string in the stack so perlio is ok
      $_[1] = '' if $chk;
      my ( $h2z, $jis0212 ) = @$obj{qw(h2z jis0212)};
      my $octet = Encode::encode( 'euc-jp', $utf8, $chk );
      $h2z and &Encode::JP::H2Z::h2z( \$octet );
      euc_jis( \$octet, $jis0212 );
      return $octet;
  }
  
  #
  # cat_decode
  #
  my $re_scan_jis_g = qr{
     \G ( ($RE{JIS_0212}) |  $RE{JIS_0208}  |
          ($RE{ISO_ASC})  | ($RE{JIS_KANA}) | )
        ([^\e]*)
  }x;
  
  sub cat_decode {    # ($obj, $dst, $src, $pos, $trm, $chk)
      my ( $obj, undef, undef, $pos, $trm ) = @_;    # currently ignores $chk
      my ( $rdst, $rsrc, $rpos ) = \@_[ 1, 2, 3 ];
      local ${^ENCODING};
      use bytes;
      my $opos = pos($$rsrc);
      pos($$rsrc) = $pos;
      while ( $$rsrc =~ /$re_scan_jis_g/gc ) {
          my ( $esc, $esc_0212, $esc_asc, $esc_kana, $chunk ) =
            ( $1, $2, $3, $4, $5 );
  
          unless ($chunk) { $esc or last; next; }
  
          if ( $esc && !$esc_asc ) {
              $chunk =~ tr/\x21-\x7e/\xa1-\xfe/;
              if ($esc_kana) {
                  $chunk =~ s/([\xa1-\xdf])/\x8e$1/og;
              }
              elsif ($esc_0212) {
                  $chunk =~ s/([\xa1-\xfe][\xa1-\xfe])/\x8f$1/og;
              }
              $chunk = Encode::decode( 'euc-jp', $chunk, 0 );
          }
          elsif ( ( my $npos = index( $chunk, $trm ) ) >= 0 ) {
              $$rdst .= substr( $chunk, 0, $npos + length($trm) );
              $$rpos += length($esc) + $npos + length($trm);
              pos($$rsrc) = $opos;
              return 1;
          }
          $$rdst .= $chunk;
          $$rpos = pos($$rsrc);
      }
      $$rpos = pos($$rsrc);
      pos($$rsrc) = $opos;
      return '';
  }
  
  # JIS<->EUC
  my $re_scan_jis = qr{
     (?:($RE{JIS_0212})|$RE{JIS_0208}|($RE{ISO_ASC})|($RE{JIS_KANA}))([^\e]*)
  }x;
  
  sub jis_euc {
      local ${^ENCODING};
      my $r_str = shift;
      $$r_str =~ s($re_scan_jis)
      {
      my ($esc_0212, $esc_asc, $esc_kana, $chunk) =
         ($1, $2, $3, $4);
      if (!$esc_asc) {
          $chunk =~ tr/\x21-\x7e/\xa1-\xfe/;
          if ($esc_kana) {
          $chunk =~ s/([\xa1-\xdf])/\x8e$1/og;
          }
          elsif ($esc_0212) {
          $chunk =~ s/([\xa1-\xfe][\xa1-\xfe])/\x8f$1/og;
          }
      }
      $chunk;
      }geox;
      my ($residue) = ( $$r_str =~ s/(\e.*)$//so );
      return $residue;
  }
  
  sub euc_jis {
      no warnings qw(uninitialized);
      local ${^ENCODING};
      my $r_str   = shift;
      my $jis0212 = shift;
      $$r_str =~ s{
      ((?:$RE{EUC_C})+|(?:$RE{EUC_KANA})+|(?:$RE{EUC_0212})+)
      }{
          my $chunk = $1;
          my $esc =
          ( $chunk =~ tr/\x8E//d ) ? $ESC{KANA} :
              ( $chunk =~ tr/\x8F//d ) ? $ESC{JIS_0212} :
              $ESC{JIS_0208};
          if ($esc eq $ESC{JIS_0212} && !$jis0212){
          # fallback to '?'
          $chunk =~ tr/\xA1-\xFE/\x3F/;
          }else{
          $chunk =~ tr/\xA1-\xFE/\x21-\x7E/;
          }
          $esc . $chunk . $ESC{ASC};
      }geox;
      $$r_str =~ s/\Q$ESC{ASC}\E
          (\Q$ESC{KANA}\E|\Q$ESC{JIS_0212}\E|\Q$ESC{JIS_0208}\E)/$1/gox;
      $$r_str;
  }
  
  1;
  __END__
  
  
  =head1 NAME
  
  Encode::JP::JIS7 -- internally used by Encode::JP
  
  =cut
I686-LINUX-GNU-THREAD-MULTI-64INT_ENCODE_JP_JIS7

$fatpacked{"i686-linux-gnu-thread-multi-64int/Encode/KR.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'I686-LINUX-GNU-THREAD-MULTI-64INT_ENCODE_KR';
  package Encode::KR;
  BEGIN {
      if ( ord("A") == 193 ) {
          die "Encode::KR not supported on EBCDIC\n";
      }
  }
  use strict;
  use warnings;
  use Encode;
  our $VERSION = do { my @r = ( q$Revision: 2.3 $ =~ /\d+/g ); sprintf "%d." . "%02d" x $#r, @r };
  use XSLoader;
  XSLoader::load( __PACKAGE__, $VERSION );
  
  use Encode::KR::2022_KR;
  
  1;
  __END__
  
  =head1 NAME
  
  Encode::KR - Korean Encodings
  
  =head1 SYNOPSIS
  
      use Encode qw/encode decode/; 
      $euc_kr = encode("euc-kr", $utf8);   # loads Encode::KR implicitly
      $utf8   = decode("euc-kr", $euc_kr); # ditto
  
  =head1 DESCRIPTION
  
  This module implements Korean charset encodings.  Encodings supported
  are as follows.
  
  
    Canonical   Alias		Description
    --------------------------------------------------------------------
    euc-kr      /\beuc.*kr$/i	EUC (Extended Unix Character)
            /\bkr.*euc$/i
    ksc5601-raw			Korean standard code set (as is)
    cp949	      /(?:x-)?uhc$/i
                /(?:x-)?windows-949$/i
                /\bks_c_5601-1987$/i
                                  Code Page 949 (EUC-KR + 8,822 
                                  (additional Hangul syllables)
    MacKorean			EUC-KR + Apple Vendor Mappings
    johab       JOHAB             A supplementary encoding defined in 
                                               Annex 3 of KS X 1001:1998
    iso-2022-kr                   iso-2022-kr                  [RFC1557]
    --------------------------------------------------------------------
  
  To find how to use this module in detail, see L<Encode>.
  
  =head1 BUGS
  
  When you see C<charset=ks_c_5601-1987> on mails and web pages, they really
  mean "cp949" encodings.  To fix that, the following aliases are set;
  
    qr/(?:x-)?uhc$/i         => '"cp949"'
    qr/(?:x-)?windows-949$/i => '"cp949"'
    qr/ks_c_5601-1987$/i     => '"cp949"'
  
  The ASCII region (0x00-0x7f) is preserved for all encodings, even
  though this conflicts with mappings by the Unicode Consortium.
  
  =head1 SEE ALSO
  
  L<Encode>
  
  =cut
I686-LINUX-GNU-THREAD-MULTI-64INT_ENCODE_KR

$fatpacked{"i686-linux-gnu-thread-multi-64int/Encode/KR/2022_KR.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'I686-LINUX-GNU-THREAD-MULTI-64INT_ENCODE_KR_2022_KR';
  package Encode::KR::2022_KR;
  use strict;
  use warnings;
  our $VERSION = do { my @r = ( q$Revision: 2.3 $ =~ /\d+/g ); sprintf "%d." . "%02d" x $#r, @r };
  
  use Encode qw(:fallbacks);
  
  use parent qw(Encode::Encoding);
  __PACKAGE__->Define('iso-2022-kr');
  
  sub needs_lines { 1 }
  
  sub perlio_ok {
      return 0;    # for the time being
  }
  
  sub decode {
      my ( $obj, $str, $chk ) = @_;
      my $res     = $str;
      my $residue = iso_euc( \$res );
  
      # This is for PerlIO
      $_[1] = $residue if $chk;
      return Encode::decode( 'euc-kr', $res, FB_PERLQQ );
  }
  
  sub encode {
      my ( $obj, $utf8, $chk ) = @_;
  
      # empty the input string in the stack so perlio is ok
      $_[1] = '' if $chk;
      my $octet = Encode::encode( 'euc-kr', $utf8, FB_PERLQQ );
      euc_iso( \$octet );
      return $octet;
  }
  
  use Encode::CJKConstants qw(:all);
  
  # ISO<->EUC
  
  sub iso_euc {
      my $r_str = shift;
      $$r_str =~ s/$RE{'2022_KR'}//gox;    # remove the designator
      $$r_str =~ s{                      # replace characters in GL
       \x0e                              # between SO(\x0e) and SI(\x0f)
       ([^\x0f]*)                        # with characters in GR
       \x0f
          }
      {
                          my $out= $1;
        $out =~ tr/\x21-\x7e/\xa1-\xfe/;
        $out;
      }geox;
      my ($residue) = ( $$r_str =~ s/(\e.*)$//so );
      return $residue;
  }
  
  sub euc_iso {
      no warnings qw(uninitialized);
      my $r_str = shift;
      substr( $$r_str, 0, 0 ) =
        $ESC{'2022_KR'};    # put the designator at the beg.
      $$r_str =~
        s{                         # move KS X 1001 characters in GR to GL
          ($RE{EUC_C}+)                     # and enclose them with SO and SI
          }{
              my $str = $1;
              $str =~ tr/\xA1-\xFE/\x21-\x7E/;
              "\x0e" . $str . "\x0f";
          }geox;
      $$r_str;
  }
  
  1;
  __END__
  
  =head1 NAME
  
  Encode::KR::2022_KR -- internally used by Encode::KR
  
  =cut
I686-LINUX-GNU-THREAD-MULTI-64INT_ENCODE_KR_2022_KR

$fatpacked{"i686-linux-gnu-thread-multi-64int/Encode/MIME/Header.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'I686-LINUX-GNU-THREAD-MULTI-64INT_ENCODE_MIME_HEADER';
  package Encode::MIME::Header;
  use strict;
  use warnings;
  
  our $VERSION = do { my @r = ( q$Revision: 2.24 $ =~ /\d+/g ); sprintf "%d." . "%02d" x $#r, @r };
  
  use Carp ();
  use Encode ();
  use MIME::Base64 ();
  
  my %seed = (
      decode_b => 1,       # decodes 'B' encoding ?
      decode_q => 1,       # decodes 'Q' encoding ?
      encode   => 'B',     # encode with 'B' or 'Q' ?
      charset  => 'UTF-8', # encode charset
      bpl      => 75,      # bytes per line
  );
  
  $Encode::Encoding{'MIME-Header'} = bless {
      %seed,
      Name     => 'MIME-Header',
  } => __PACKAGE__;
  
  $Encode::Encoding{'MIME-B'} = bless {
      %seed,
      decode_q => 0,
      Name     => 'MIME-B',
  } => __PACKAGE__;
  
  $Encode::Encoding{'MIME-Q'} = bless {
      %seed,
      decode_b => 0,
      encode   => 'Q',
      Name     => 'MIME-Q',
  } => __PACKAGE__;
  
  use parent qw(Encode::Encoding);
  
  sub needs_lines { 1 }
  sub perlio_ok   { 0 }
  
  # RFC 2047 and RFC 2231 grammar
  my $re_charset = qr/[!"#\$%&'+\-0-9A-Z\\\^_`a-z\{\|\}~]+/;
  my $re_language = qr/[A-Za-z]{1,8}(?:-[0-9A-Za-z]{1,8})*/;
  my $re_encoding = qr/[QqBb]/;
  my $re_encoded_text = qr/[^\?]*/;
  my $re_encoded_word = qr/=\?$re_charset(?:\*$re_language)?\?$re_encoding\?$re_encoded_text\?=/;
  my $re_capture_encoded_word = qr/=\?($re_charset)((?:\*$re_language)?)\?($re_encoding\?$re_encoded_text)\?=/;
  my $re_capture_encoded_word_split = qr/=\?($re_charset)((?:\*$re_language)?)\?($re_encoding)\?($re_encoded_text)\?=/;
  
  # in strict mode check also for valid base64 characters and also for valid quoted printable codes
  my $re_encoding_strict_b = qr/[Bb]/;
  my $re_encoding_strict_q = qr/[Qq]/;
  my $re_encoded_text_strict_b = qr/[0-9A-Za-z\+\/]*={0,2}/;
  my $re_encoded_text_strict_q = qr/(?:[^\?\s=]|=[0-9A-Fa-f]{2})*/;
  my $re_encoded_word_strict = qr/=\?$re_charset(?:\*$re_language)?\?(?:$re_encoding_strict_b\?$re_encoded_text_strict_b|$re_encoding_strict_q\?$re_encoded_text_strict_q)\?=/;
  my $re_capture_encoded_word_strict = qr/=\?($re_charset)((?:\*$re_language)?)\?($re_encoding_strict_b\?$re_encoded_text_strict_b|$re_encoding_strict_q\?$re_encoded_text_strict_q)\?=/;
  
  my $re_newline = qr/(?:\r\n|[\r\n])/;
  
  # in strict mode encoded words must be always separated by spaces or tabs (or folded newline)
  # except in comments when separator between words and comment round brackets can be omitted
  my $re_word_begin_strict = qr/(?:(?:[ \t]|\A)\(?|(?:[^\\]|\A)\)\()/;
  my $re_word_sep_strict = qr/(?:$re_newline?[ \t])+/;
  my $re_word_end_strict = qr/(?:\)\(|\)?(?:$re_newline?[ \t]|\z))/;
  
  my $re_match = qr/()((?:$re_encoded_word\s*)*$re_encoded_word)()/;
  my $re_match_strict = qr/($re_word_begin_strict)((?:$re_encoded_word_strict$re_word_sep_strict)*$re_encoded_word_strict)(?=$re_word_end_strict)/;
  
  my $re_capture = qr/$re_capture_encoded_word(?:\s*)?/;
  my $re_capture_strict = qr/$re_capture_encoded_word_strict$re_word_sep_strict?/;
  
  our $STRICT_DECODE = 0;
  
  sub decode($$;$) {
      my ($obj, $str, $chk) = @_;
  
      my $re_match_decode = $STRICT_DECODE ? $re_match_strict : $re_match;
      my $re_capture_decode = $STRICT_DECODE ? $re_capture_strict : $re_capture;
  
      my $stop = 0;
      my $output = substr($str, 0, 0); # to propagate taintedness
  
      # decode each line separately, match whole continuous folded line at one call
      1 while not $stop and $str =~ s{^((?:[^\r\n]*(?:$re_newline[ \t])?)*)($re_newline)?}{
  
          my $line = $1;
          my $sep = defined $2 ? $2 : '';
  
          $stop = 1 unless length($line) or length($sep);
  
          # NOTE: this code partially could break $chk support
          # in non strict mode concat consecutive encoded mime words with same charset, language and encoding
          # fixes breaking inside multi-byte characters
          1 while not $STRICT_DECODE and $line =~ s/$re_capture_encoded_word_split\s*=\?\1\2\?\3\?($re_encoded_text)\?=/=\?$1$2\?$3\?$4$5\?=/so;
  
          # process sequence of encoded MIME words at once
          1 while not $stop and $line =~ s{^(.*?)$re_match_decode}{
  
              my $begin = $1 . $2;
              my $words = $3;
  
              $begin =~ tr/\r\n//d;
              $output .= $begin;
  
              # decode one MIME word
              1 while not $stop and $words =~ s{^(.*?)($re_capture_decode)}{
  
                  $output .= $1;
                  my $orig = $2;
                  my $charset = $3;
                  my ($mime_enc, $text) = split /\?/, $5;
  
                  $text =~ tr/\r\n//d;
  
                  my $enc = Encode::find_mime_encoding($charset);
  
                  # in non strict mode allow also perl encoding aliases
                  if ( not defined $enc and not $STRICT_DECODE ) {
                      # make sure that decoded string will be always strict UTF-8
                      $charset = 'UTF-8' if lc($charset) eq 'utf8';
                      $enc = Encode::find_encoding($charset);
                  }
  
                  if ( not defined $enc ) {
                      Carp::croak qq(Unknown charset "$charset") if not ref $chk and $chk & Encode::DIE_ON_ERR;
                      Carp::carp qq(Unknown charset "$charset") if not ref $chk and $chk & Encode::WARN_ON_ERR;
                      $stop = 1 if not ref $chk and $chk & Encode::RETURN_ON_ERR;
                      $output .= ($output =~ /(?:\A|[ \t])$/ ? '' : ' ') . $orig unless $stop; # $orig mime word is separated by whitespace
                      $stop ? $orig : '';
                  } else {
                      if ( uc($mime_enc) eq 'B' and $obj->{decode_b} ) {
                          my $decoded = _decode_b($enc, $text, $chk);
                          $stop = 1 if not defined $decoded and not ref $chk and $chk & Encode::RETURN_ON_ERR;
                          $output .= (defined $decoded ? $decoded : $text) unless $stop;
                          $stop ? $orig : '';
                      } elsif ( uc($mime_enc) eq 'Q' and $obj->{decode_q} ) {
                          my $decoded = _decode_q($enc, $text, $chk);
                          $stop = 1 if not defined $decoded and not ref $chk and $chk & Encode::RETURN_ON_ERR;
                          $output .= (defined $decoded ? $decoded : $text) unless $stop;
                          $stop ? $orig : '';
                      } else {
                          Carp::croak qq(MIME "$mime_enc" unsupported) if not ref $chk and $chk & Encode::DIE_ON_ERR;
                          Carp::carp qq(MIME "$mime_enc" unsupported) if not ref $chk and $chk & Encode::WARN_ON_ERR;
                          $stop = 1 if not ref $chk and $chk & Encode::RETURN_ON_ERR;
                          $output .= ($output =~ /(?:\A|[ \t])$/ ? '' : ' ') . $orig unless $stop; # $orig mime word is separated by whitespace
                          $stop ? $orig : '';
                      }
                  }
  
              }se;
  
              if ( not $stop ) {
                  $output .= $words;
                  $words = '';
              }
  
              $words;
  
          }se;
  
          if ( not $stop ) {
              $line =~ tr/\r\n//d;
              $output .= $line . $sep;
              $line = '';
              $sep = '';
          }
  
          $line . $sep;
  
      }se;
  
      $_[1] = $str if not ref $chk and $chk and !($chk & Encode::LEAVE_SRC);
      return $output;
  }
  
  sub _decode_b {
      my ($enc, $text, $chk) = @_;
      # MIME::Base64::decode ignores everything after a '=' padding character
      # in non strict mode split string after each sequence of padding characters and decode each substring
      my $octets = $STRICT_DECODE ?
          MIME::Base64::decode($text) :
          join('', map { MIME::Base64::decode($_) } split /(?<==)(?=[^=])/, $text);
      return _decode_octets($enc, $octets, $chk);
  }
  
  sub _decode_q {
      my ($enc, $text, $chk) = @_;
      $text =~ s/_/ /go;
      $text =~ s/=([0-9A-Fa-f]{2})/pack('C', hex($1))/ego;
      return _decode_octets($enc, $text, $chk);
  }
  
  sub _decode_octets {
      my ($enc, $octets, $chk) = @_;
      $chk &= ~Encode::LEAVE_SRC if not ref $chk and $chk;
      local $Carp::CarpLevel = $Carp::CarpLevel + 1; # propagate Carp messages back to caller
      my $output = $enc->decode($octets, $chk);
      return undef if not ref $chk and $chk and $octets ne '';
      return $output;
  }
  
  sub encode($$;$) {
      my ($obj, $str, $chk) = @_;
      my $output = $obj->_fold_line($obj->_encode_string($str, $chk));
      $_[1] = $str if not ref $chk and $chk and !($chk & Encode::LEAVE_SRC);
      return $output . substr($str, 0, 0); # to propagate taintedness
  }
  
  sub _fold_line {
      my ($obj, $line) = @_;
      my $bpl = $obj->{bpl};
      my $output = '';
  
      while ( length($line) ) {
          if ( $line =~ s/^(.{0,$bpl})(\s|\z)// ) {
              $output .= $1;
              $output .= "\r\n" . $2 if length($line);
          } elsif ( $line =~ s/(\s)(.*)$// ) {
              $output .= $line;
              $line = $2;
              $output .= "\r\n" . $1 if length($line);
          } else {
              $output .= $line;
              last;
          }
      }
  
      return $output;
  }
  
  sub _encode_string {
      my ($obj, $str, $chk) = @_;
      my $wordlen = $obj->{bpl} > 76 ? 76 : $obj->{bpl};
      my $enc = Encode::find_mime_encoding($obj->{charset});
      my $enc_chk = (not ref $chk and $chk) ? ($chk | Encode::LEAVE_SRC) : $chk;
      my @result = ();
      my $octets = '';
      while ( length( my $chr = substr($str, 0, 1, '') ) ) {
          my $seq;
          {
              local $Carp::CarpLevel = $Carp::CarpLevel + 1; # propagate Carp messages back to caller
              $seq = $enc->encode($chr, $enc_chk);
          }
          if ( not length($seq) ) {
              substr($str, 0, 0, $chr);
              last;
          }
          if ( $obj->_encoded_word_len($octets . $seq) > $wordlen ) {
              push @result, $obj->_encode_word($octets);
              $octets = '';
          }
          $octets .= $seq;
      }
      length($octets) and push @result, $obj->_encode_word($octets);
      $_[1] = $str if not ref $chk and $chk and !($chk & Encode::LEAVE_SRC);
      return join(' ', @result);
  }
  
  sub _encode_word {
      my ($obj, $octets) = @_;
      my $charset = $obj->{charset};
      my $encode = $obj->{encode};
      my $text = $encode eq 'B' ? _encode_b($octets) : _encode_q($octets);
      return "=?$charset?$encode?$text?=";
  }
  
  sub _encoded_word_len {
      my ($obj, $octets) = @_;
      my $charset = $obj->{charset};
      my $encode = $obj->{encode};
      my $text_len = $encode eq 'B' ? _encoded_b_len($octets) : _encoded_q_len($octets);
      return length("=?$charset?$encode??=") + $text_len;
  }
  
  sub _encode_b {
      my ($octets) = @_;
      return MIME::Base64::encode($octets, '');
  }
  
  sub _encoded_b_len {
      my ($octets) = @_;
      return ( length($octets) + 2 ) / 3 * 4;
  }
  
  my $re_invalid_q_char = qr/[^0-9A-Za-z !*+\-\/]/;
  
  sub _encode_q {
      my ($octets) = @_;
      $octets =~ s{($re_invalid_q_char)}{
          join('', map { sprintf('=%02X', $_) } unpack('C*', $1))
      }egox;
      $octets =~ s/ /_/go;
      return $octets;
  }
  
  sub _encoded_q_len {
      my ($octets) = @_;
      my $invalid_count = () = $octets =~ /$re_invalid_q_char/sgo;
      return ( $invalid_count * 3 ) + ( length($octets) - $invalid_count );
  }
  
  1;
  __END__
  
  =head1 NAME
  
  Encode::MIME::Header -- MIME encoding for an unstructured email header
  
  =head1 SYNOPSIS
  
      use Encode qw(encode decode);
  
      my $mime_str = encode("MIME-Header", "Sample:Text \N{U+263A}");
      # $mime_str is "=?UTF-8?B?U2FtcGxlOlRleHQg4pi6?="
  
      my $mime_q_str = encode("MIME-Q", "Sample:Text \N{U+263A}");
      # $mime_q_str is "=?UTF-8?Q?Sample=3AText_=E2=98=BA?="
  
      my $str = decode("MIME-Header",
          "=?ISO-8859-1?B?SWYgeW91IGNhbiByZWFkIHRoaXMgeW8=?=\r\n " .
          "=?ISO-8859-2?B?dSB1bmRlcnN0YW5kIHRoZSBleGFtcGxlLg==?="
      );
      # $str is "If you can read this you understand the example."
  
      use Encode qw(decode :fallbacks);
      use Encode::MIME::Header;
      local $Encode::MIME::Header::STRICT_DECODE = 1;
      my $strict_string = decode("MIME-Header", $mime_string, FB_CROAK);
      # use strict decoding and croak on errors
  
  =head1 ABSTRACT
  
  This module implements L<RFC 2047|https://tools.ietf.org/html/rfc2047> MIME
  encoding for an unstructured field body of the email header.  It can also be
  used for L<RFC 822|https://tools.ietf.org/html/rfc822> 'text' token.  However,
  it cannot be used directly for the whole header with the field name or for the
  structured header fields like From, To, Cc, Message-Id, etc...  There are 3
  encoding names supported by this module: C<MIME-Header>, C<MIME-B> and
  C<MIME-Q>.
  
  =head1 DESCRIPTION
  
  Decode method takes an unstructured field body of the email header (or
  L<RFC 822|https://tools.ietf.org/html/rfc822> 'text' token) as its input and
  decodes each MIME encoded-word from input string to a sequence of bytes
  according to L<RFC 2047|https://tools.ietf.org/html/rfc2047> and
  L<RFC 2231|https://tools.ietf.org/html/rfc2231>.  Subsequently, each sequence
  of bytes with the corresponding MIME charset is decoded with
  L<the Encode module|Encode> and finally, one output string is returned.  Text
  parts of the input string which do not contain MIME encoded-word stay
  unmodified in the output string.  Folded newlines between two consecutive MIME
  encoded-words are discarded, others are preserved in the output string.
  C<MIME-B> can decode Base64 variant, C<MIME-Q> can decode Quoted-Printable
  variant and C<MIME-Header> can decode both of them.  If L<Encode module|Encode>
  does not support particular MIME charset or chosen variant then an action based
  on L<CHECK flags|Encode/Handling Malformed Data> is performed (by default, the
  MIME encoded-word is not decoded).
  
  Encode method takes a scalar string as its input and uses
  L<strict UTF-8|Encode/UTF-8 vs. utf8 vs. UTF8> encoder for encoding it to UTF-8
  bytes.  Then a sequence of UTF-8 bytes is encoded into MIME encoded-words
  (C<MIME-Header> and C<MIME-B> use a Base64 variant while C<MIME-Q> uses a
  Quoted-Printable variant) where each MIME encoded-word is limited to 75
  characters.  MIME encoded-words are separated by C<CRLF SPACE> and joined to
  one output string.  Output string is suitable for unstructured field body of
  the email header.
  
  Both encode and decode methods propagate
  L<CHECK flags|Encode/Handling Malformed Data> when encoding and decoding the
  MIME charset.
  
  =head1 BUGS
  
  Versions prior to 2.22 (part of Encode 2.83) have a malfunctioning decoder
  and encoder.  The MIME encoder infamously inserted additional spaces or
  discarded white spaces between consecutive MIME encoded-words, which led to
  invalid MIME headers produced by this module.  The MIME decoder had a tendency
  to discard white spaces, incorrectly interpret data or attempt to decode Base64
  MIME encoded-words as Quoted-Printable.  These problems were fixed in version
  2.22.  It is highly recommended not to use any version prior 2.22!
  
  Versions prior to 2.24 (part of Encode 2.87) ignored
  L<CHECK flags|Encode/Handling Malformed Data>.  The MIME encoder used
  L<not strict utf8|Encode/UTF-8 vs. utf8 vs. UTF8> encoder for input Unicode
  strings which could lead to invalid UTF-8 sequences.  MIME decoder used also
  L<not strict utf8|Encode/UTF-8 vs. utf8 vs. UTF8> decoder and additionally
  called the decode method with a C<Encode::FB_PERLQQ> flag (thus user-specified
  L<CHECK flags|Encode/Handling Malformed Data> were ignored).  Moreover, it
  automatically croaked when a MIME encoded-word contained unknown encoding.
  Since version 2.24, this module uses
  L<strict UTF-8|Encode/UTF-8 vs. utf8 vs. UTF8> encoder and decoder.  And
  L<CHECK flags|Encode/Handling Malformed Data> are correctly propagated.
  
  Since version 2.22 (part of Encode 2.83), the MIME encoder should be fully
  compliant to L<RFC 2047|https://tools.ietf.org/html/rfc2047> and
  L<RFC 2231|https://tools.ietf.org/html/rfc2231>.  Due to the aforementioned
  bugs in previous versions of the MIME encoder, there is a I<less strict>
  compatible mode for the MIME decoder which is used by default.  It should be
  able to decode MIME encoded-words encoded by pre 2.22 versions of this module.
  However, note that this is not correct according to
  L<RFC 2047|https://tools.ietf.org/html/rfc2047>.
  
  In default I<not strict> mode the MIME decoder attempts to decode every substring
  which looks like a MIME encoded-word.  Therefore, the MIME encoded-words do not
  need to be separated by white space.  To enforce a correct I<strict> mode, set
  variable C<$Encode::MIME::Header::STRICT_DECODE> to 1 e.g. by localizing:
  
    use Encode::MIME::Header;
    local $Encode::MIME::Header::STRICT_DECODE = 1;
  
  =head1 AUTHORS
  
  Pali E<lt>pali@cpan.orgE<gt>
  
  =head1 SEE ALSO
  
  L<Encode>,
  L<RFC 822|https://tools.ietf.org/html/rfc822>,
  L<RFC 2047|https://tools.ietf.org/html/rfc2047>,
  L<RFC 2231|https://tools.ietf.org/html/rfc2231>
  
  =cut
I686-LINUX-GNU-THREAD-MULTI-64INT_ENCODE_MIME_HEADER

$fatpacked{"i686-linux-gnu-thread-multi-64int/Encode/MIME/Header/ISO_2022_JP.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'I686-LINUX-GNU-THREAD-MULTI-64INT_ENCODE_MIME_HEADER_ISO_2022_JP';
  package Encode::MIME::Header::ISO_2022_JP;
  
  use strict;
  use warnings;
  
  use parent qw(Encode::MIME::Header);
  
  $Encode::Encoding{'MIME-Header-ISO_2022_JP'} =
    bless { decode_b => '1', decode_q => '1', encode => 'B', bpl => 76, Name => 'MIME-Header-ISO_2022_JP' } =>
    __PACKAGE__;
  
  use constant HEAD => '=?ISO-2022-JP?B?';
  use constant TAIL => '?=';
  
  use Encode::CJKConstants qw(%RE);
  
  our $VERSION = do { my @r = ( q$Revision: 1.7 $ =~ /\d+/g ); sprintf "%d." . "%02d" x $#r, @r };
  
  # I owe the below codes totally to
  #   Jcode by Dan Kogai & http://www.din.or.jp/~ohzaki/perl.htm#JP_Base64
  
  sub encode {
      my $self = shift;
      my $str  = shift;
  
      utf8::encode($str) if ( Encode::is_utf8($str) );
      Encode::from_to( $str, 'utf8', 'euc-jp' );
  
      my ($trailing_crlf) = ( $str =~ /(\n|\r|\x0d\x0a)$/o );
  
      $str = _mime_unstructured_header( $str, $self->{bpl} );
  
      not $trailing_crlf and $str =~ s/(\n|\r|\x0d\x0a)$//o;
  
      return $str;
  }
  
  sub _mime_unstructured_header {
      my ( $oldheader, $bpl ) = @_;
      my $crlf = $oldheader =~ /\n$/;
      my ( $header, @words, @wordstmp, $i ) = ('');
  
      $oldheader =~ s/\s+$//;
  
      @wordstmp = split /\s+/, $oldheader;
  
      for ( $i = 0 ; $i < $#wordstmp ; $i++ ) {
          if (    $wordstmp[$i] !~ /^[\x21-\x7E]+$/
              and $wordstmp[ $i + 1 ] !~ /^[\x21-\x7E]+$/ )
          {
              $wordstmp[ $i + 1 ] = "$wordstmp[$i] $wordstmp[$i + 1]";
          }
          else {
              push( @words, $wordstmp[$i] );
          }
      }
  
      push( @words, $wordstmp[-1] );
  
      for my $word (@words) {
          if ( $word =~ /^[\x21-\x7E]+$/ ) {
              $header =~ /(?:.*\n)*(.*)/;
              if ( length($1) + length($word) > $bpl ) {
                  $header .= "\n $word";
              }
              else {
                  $header .= $word;
              }
          }
          else {
              $header = _add_encoded_word( $word, $header, $bpl );
          }
  
          $header =~ /(?:.*\n)*(.*)/;
  
          if ( length($1) == $bpl ) {
              $header .= "\n ";
          }
          else {
              $header .= ' ';
          }
      }
  
      $header =~ s/\n? $//mg;
  
      $crlf ? "$header\n" : $header;
  }
  
  sub _add_encoded_word {
      my ( $str, $line, $bpl ) = @_;
      my $result = '';
  
      while ( length($str) ) {
          my $target = $str;
          $str = '';
  
          if (
              length($line) + 22 +
              ( $target =~ /^(?:$RE{EUC_0212}|$RE{EUC_C})/o ) * 8 > $bpl )
          {
              $line =~ s/[ \t\n\r]*$/\n/;
              $result .= $line;
              $line = ' ';
          }
  
          while (1) {
              my $iso_2022_jp = $target;
              Encode::from_to( $iso_2022_jp, 'euc-jp', 'iso-2022-jp' );
  
              my $encoded =
                HEAD . MIME::Base64::encode_base64( $iso_2022_jp, '' ) . TAIL;
  
              if ( length($encoded) + length($line) > $bpl ) {
                  $target =~
                    s/($RE{EUC_0212}|$RE{EUC_KANA}|$RE{EUC_C}|$RE{ASCII})$//o;
                  $str = $1 . $str;
              }
              else {
                  $line .= $encoded;
                  last;
              }
          }
  
      }
  
      $result . $line;
  }
  
  1;
  __END__
  
I686-LINUX-GNU-THREAD-MULTI-64INT_ENCODE_MIME_HEADER_ISO_2022_JP

$fatpacked{"i686-linux-gnu-thread-multi-64int/Encode/MIME/Name.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'I686-LINUX-GNU-THREAD-MULTI-64INT_ENCODE_MIME_NAME';
  package Encode::MIME::Name;
  use strict;
  use warnings;
  our $VERSION = do { my @r = ( q$Revision: 1.2 $ =~ /\d+/g ); sprintf "%d." . "%02d" x $#r, @r };
  
  # NOTE: This table must be 1:1 mapping
  our %MIME_NAME_OF = (
      'AdobeStandardEncoding' => 'Adobe-Standard-Encoding',
      'AdobeSymbol'           => 'Adobe-Symbol-Encoding',
      'ascii'                 => 'US-ASCII',
      'big5-hkscs'            => 'Big5-HKSCS',
      'cp1026'                => 'IBM1026',
      'cp1047'                => 'IBM1047',
      'cp1250'                => 'windows-1250',
      'cp1251'                => 'windows-1251',
      'cp1252'                => 'windows-1252',
      'cp1253'                => 'windows-1253',
      'cp1254'                => 'windows-1254',
      'cp1255'                => 'windows-1255',
      'cp1256'                => 'windows-1256',
      'cp1257'                => 'windows-1257',
      'cp1258'                => 'windows-1258',
      'cp37'                  => 'IBM037',
      'cp424'                 => 'IBM424',
      'cp437'                 => 'IBM437',
      'cp500'                 => 'IBM500',
      'cp775'                 => 'IBM775',
      'cp850'                 => 'IBM850',
      'cp852'                 => 'IBM852',
      'cp855'                 => 'IBM855',
      'cp857'                 => 'IBM857',
      'cp860'                 => 'IBM860',
      'cp861'                 => 'IBM861',
      'cp862'                 => 'IBM862',
      'cp863'                 => 'IBM863',
      'cp864'                 => 'IBM864',
      'cp865'                 => 'IBM865',
      'cp866'                 => 'IBM866',
      'cp869'                 => 'IBM869',
      'cp936'                 => 'GBK',
      'euc-jp'                => 'EUC-JP',
      'euc-kr'                => 'EUC-KR',
      #'gb2312-raw'            => 'GB2312', # no, you're wrong, I18N::Charset
      'hp-roman8'             => 'hp-roman8',
      'hz'                    => 'HZ-GB-2312',
      'iso-2022-jp'           => 'ISO-2022-JP',
      'iso-2022-jp-1'         => 'ISO-2022-JP-1',
      'iso-2022-kr'           => 'ISO-2022-KR',
      'iso-8859-1'            => 'ISO-8859-1',
      'iso-8859-10'           => 'ISO-8859-10',
      'iso-8859-13'           => 'ISO-8859-13',
      'iso-8859-14'           => 'ISO-8859-14',
      'iso-8859-15'           => 'ISO-8859-15',
      'iso-8859-16'           => 'ISO-8859-16',
      'iso-8859-2'            => 'ISO-8859-2',
      'iso-8859-3'            => 'ISO-8859-3',
      'iso-8859-4'            => 'ISO-8859-4',
      'iso-8859-5'            => 'ISO-8859-5',
      'iso-8859-6'            => 'ISO-8859-6',
      'iso-8859-7'            => 'ISO-8859-7',
      'iso-8859-8'            => 'ISO-8859-8',
      'iso-8859-9'            => 'ISO-8859-9',
      #'jis0201-raw'           => 'JIS_X0201',
      #'jis0208-raw'           => 'JIS_C6226-1983',
      #'jis0212-raw'           => 'JIS_X0212-1990',
      'koi8-r'                => 'KOI8-R',
      'koi8-u'                => 'KOI8-U',
      #'ksc5601-raw'           => 'KS_C_5601-1987',
      'shiftjis'              => 'Shift_JIS',
      'UTF-16'                => 'UTF-16',
      'UTF-16BE'              => 'UTF-16BE',
      'UTF-16LE'              => 'UTF-16LE',
      'UTF-32'                => 'UTF-32',
      'UTF-32BE'              => 'UTF-32BE',
      'UTF-32LE'              => 'UTF-32LE',
      'UTF-7'                 => 'UTF-7',
      'utf-8-strict'          => 'UTF-8',
      'viscii'                => 'VISCII',
  );
  
  # NOTE: %MIME_NAME_OF is still 1:1 mapping
  our %ENCODE_NAME_OF = map { uc $MIME_NAME_OF{$_} => $_ } keys %MIME_NAME_OF;
  
  # Add additional 1:N mapping
  $MIME_NAME_OF{'utf8'} = 'UTF-8';
  
  sub get_mime_name($) { $MIME_NAME_OF{$_[0]} };
  
  sub get_encode_name($) { $ENCODE_NAME_OF{uc $_[0]} };
  
  1;
  __END__
  
  =head1 NAME
  
  Encode::MIME::NAME -- internally used by Encode
  
  =head1 SEE ALSO
  
  L<I18N::Charset>
  
  =cut
I686-LINUX-GNU-THREAD-MULTI-64INT_ENCODE_MIME_NAME

$fatpacked{"i686-linux-gnu-thread-multi-64int/Encode/Symbol.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'I686-LINUX-GNU-THREAD-MULTI-64INT_ENCODE_SYMBOL';
  package Encode::Symbol;
  use strict;
  use warnings;
  use Encode;
  our $VERSION = do { my @r = ( q$Revision: 2.2 $ =~ /\d+/g ); sprintf "%d." . "%02d" x $#r, @r };
  
  use XSLoader;
  XSLoader::load( __PACKAGE__, $VERSION );
  
  1;
  __END__
  
  =head1 NAME
  
  Encode::Symbol - Symbol Encodings
  
  =head1 SYNOPSIS
  
      use Encode qw/encode decode/; 
      $symbol  = encode("symbol", $utf8); # loads Encode::Symbol implicitly
      $utf8 = decode("", $symbol);        # ditto
  
  =head1 ABSTRACT
  
  This module implements symbol and dingbats encodings.  Encodings
  supported are as follows.   
  
    Canonical   Alias		Description
    --------------------------------------------------------------------
    symbol
    dingbats
    AdobeZDingbat
    AdobeSymbol
    MacDingbats
  
  =head1 DESCRIPTION
  
  To find out how to use this module in detail, see L<Encode>.
  
  =head1 SEE ALSO
  
  L<Encode>
  
  =cut
I686-LINUX-GNU-THREAD-MULTI-64INT_ENCODE_SYMBOL

$fatpacked{"i686-linux-gnu-thread-multi-64int/Encode/TW.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'I686-LINUX-GNU-THREAD-MULTI-64INT_ENCODE_TW';
  package Encode::TW;
  BEGIN {
      if ( ord("A") == 193 ) {
          die "Encode::TW not supported on EBCDIC\n";
      }
  }
  use strict;
  use warnings;
  use Encode;
  our $VERSION = do { my @r = ( q$Revision: 2.3 $ =~ /\d+/g ); sprintf "%d." . "%02d" x $#r, @r };
  use XSLoader;
  XSLoader::load( __PACKAGE__, $VERSION );
  
  1;
  __END__
  
  =head1 NAME
  
  Encode::TW - Taiwan-based Chinese Encodings
  
  =head1 SYNOPSIS
  
      use Encode qw/encode decode/; 
      $big5 = encode("big5", $utf8); # loads Encode::TW implicitly
      $utf8 = decode("big5", $big5); # ditto
  
  =head1 DESCRIPTION
  
  This module implements tradition Chinese charset encodings as used
  in Taiwan and Hong Kong.
  Encodings supported are as follows.
  
    Canonical   Alias		Description
    --------------------------------------------------------------------
    big5-eten   /\bbig-?5$/i	Big5 encoding (with ETen extensions)
            /\bbig5-?et(en)?$/i
            /\btca-?big5$/i
    big5-hkscs  /\bbig5-?hk(scs)?$/i
                /\bhk(scs)?-?big5$/i
                                  Big5 + Cantonese characters in Hong Kong
    MacChineseTrad		Big5 + Apple Vendor Mappings
    cp950		                Code Page 950 
                                  = Big5 + Microsoft vendor mappings
    --------------------------------------------------------------------
  
  To find out how to use this module in detail, see L<Encode>.
  
  =head1 NOTES
  
  Due to size concerns, C<EUC-TW> (Extended Unix Character), C<CCCII>
  (Chinese Character Code for Information Interchange), C<BIG5PLUS>
  (CMEX's Big5+) and C<BIG5EXT> (CMEX's Big5e) are distributed separately
  on CPAN, under the name L<Encode::HanExtra>. That module also contains
  extra China-based encodings.
  
  =head1 BUGS
  
  Since the original C<big5> encoding (1984) is not supported anywhere
  (glibc and DOS-based systems uses C<big5> to mean C<big5-eten>; Microsoft
  uses C<big5> to mean C<cp950>), a conscious decision was made to alias
  C<big5> to C<big5-eten>, which is the de facto superset of the original
  big5.
  
  The C<CNS11643> encoding files are not complete. For common C<CNS11643>
  manipulation, please use C<EUC-TW> in L<Encode::HanExtra>, which contains
  planes 1-7.
  
  The ASCII region (0x00-0x7f) is preserved for all encodings, even
  though this conflicts with mappings by the Unicode Consortium.
  
  =head1 SEE ALSO
  
  L<Encode>
  
  =cut
I686-LINUX-GNU-THREAD-MULTI-64INT_ENCODE_TW

$fatpacked{"i686-linux-gnu-thread-multi-64int/Encode/Unicode.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'I686-LINUX-GNU-THREAD-MULTI-64INT_ENCODE_UNICODE';
  package Encode::Unicode;
  
  use strict;
  use warnings;
  no warnings 'redefine';
  
  our $VERSION = do { my @r = ( q$Revision: 2.15 $ =~ /\d+/g ); sprintf "%d." . "%02d" x $#r, @r };
  
  use XSLoader;
  XSLoader::load( __PACKAGE__, $VERSION );
  
  #
  # Object Generator 8 transcoders all at once!
  #
  
  require Encode;
  
  our %BOM_Unknown = map { $_ => 1 } qw(UTF-16 UTF-32);
  
  for my $name (
      qw(UTF-16 UTF-16BE UTF-16LE
      UTF-32 UTF-32BE UTF-32LE
      UCS-2BE  UCS-2LE)
    )
  {
      my ( $size, $endian, $ucs2, $mask );
      $name =~ /^(\w+)-(\d+)(\w*)$/o;
      if ( $ucs2 = ( $1 eq 'UCS' ) ) {
          $size = 2;
      }
      else {
          $size = $2 / 8;
      }
      $endian = ( $3 eq 'BE' ) ? 'n' : ( $3 eq 'LE' ) ? 'v' : '';
      $size == 4 and $endian = uc($endian);
  
      $Encode::Encoding{$name} = bless {
          Name   => $name,
          size   => $size,
          endian => $endian,
          ucs2   => $ucs2,
      } => __PACKAGE__;
  }
  
  use parent qw(Encode::Encoding);
  
  sub renew {
      my $self = shift;
      $BOM_Unknown{ $self->name } or return $self;
      my $clone = bless {%$self} => ref($self);
      $clone->{renewed}++;    # so the caller knows it is renewed.
      return $clone;
  }
  
  # There used to be a perl implementation of (en|de)code but with
  # XS version is ripe, perl version is zapped for optimal speed
  
  *decode = \&decode_xs;
  *encode = \&encode_xs;
  
  1;
  __END__
  
  =head1 NAME
  
  Encode::Unicode -- Various Unicode Transformation Formats
  
  =cut
  
  =head1 SYNOPSIS
  
      use Encode qw/encode decode/;
      $ucs2 = encode("UCS-2BE", $utf8);
      $utf8 = decode("UCS-2BE", $ucs2);
  
  =head1 ABSTRACT
  
  This module implements all Character Encoding Schemes of Unicode that
  are officially documented by Unicode Consortium (except, of course,
  for UTF-8, which is a native format in perl).
  
  =over 4
  
  =item L<http://www.unicode.org/glossary/> says:
  
  I<Character Encoding Scheme> A character encoding form plus byte
  serialization. There are Seven character encoding schemes in Unicode:
  UTF-8, UTF-16, UTF-16BE, UTF-16LE, UTF-32 (UCS-4), UTF-32BE (UCS-4BE) and
  UTF-32LE (UCS-4LE), and UTF-7.
  
  Since UTF-7 is a 7-bit (re)encoded version of UTF-16BE, It is not part of
  Unicode's Character Encoding Scheme.  It is separately implemented in
  Encode::Unicode::UTF7.  For details see L<Encode::Unicode::UTF7>.
  
  =item Quick Reference
  
                  Decodes from ord(N)           Encodes chr(N) to...
         octet/char BOM S.P d800-dfff  ord > 0xffff     \x{1abcd} ==
    ---------------+-----------------+------------------------------
    UCS-2BE       2   N   N  is bogus                  Not Available
    UCS-2LE       2   N   N     bogus                  Not Available
    UTF-16      2/4   Y   Y  is   S.P           S.P            BE/LE
    UTF-16BE    2/4   N   Y       S.P           S.P    0xd82a,0xdfcd
    UTF-16LE    2/4   N   Y       S.P           S.P    0x2ad8,0xcddf
    UTF-32        4   Y   -  is bogus         As is            BE/LE
    UTF-32BE      4   N   -     bogus         As is       0x0001abcd
    UTF-32LE      4   N   -     bogus         As is       0xcdab0100
    UTF-8       1-4   -   -     bogus   >= 4 octets   \xf0\x9a\af\8d
    ---------------+-----------------+------------------------------
  
  =back
  
  =head1 Size, Endianness, and BOM
  
  You can categorize these CES by 3 criteria:  size of each character,
  endianness, and Byte Order Mark.
  
  =head2 by size
  
  UCS-2 is a fixed-length encoding with each character taking 16 bits.
  It B<does not> support I<surrogate pairs>.  When a surrogate pair
  is encountered during decode(), its place is filled with \x{FFFD}
  if I<CHECK> is 0, or the routine croaks if I<CHECK> is 1.  When a
  character whose ord value is larger than 0xFFFF is encountered,
  its place is filled with \x{FFFD} if I<CHECK> is 0, or the routine
  croaks if I<CHECK> is 1.
  
  UTF-16 is almost the same as UCS-2 but it supports I<surrogate pairs>.
  When it encounters a high surrogate (0xD800-0xDBFF), it fetches the
  following low surrogate (0xDC00-0xDFFF) and C<desurrogate>s them to
  form a character.  Bogus surrogates result in death.  When \x{10000}
  or above is encountered during encode(), it C<ensurrogate>s them and
  pushes the surrogate pair to the output stream.
  
  UTF-32 (UCS-4) is a fixed-length encoding with each character taking 32 bits.
  Since it is 32-bit, there is no need for I<surrogate pairs>.
  
  =head2 by endianness
  
  The first (and now failed) goal of Unicode was to map all character
  repertoires into a fixed-length integer so that programmers are happy.
  Since each character is either a I<short> or I<long> in C, you have to
  pay attention to the endianness of each platform when you pass data
  to one another.
  
  Anything marked as BE is Big Endian (or network byte order) and LE is
  Little Endian (aka VAX byte order).  For anything not marked either
  BE or LE, a character called Byte Order Mark (BOM) indicating the
  endianness is prepended to the string.
  
  CAVEAT: Though BOM in utf8 (\xEF\xBB\xBF) is valid, it is meaningless
  and as of this writing Encode suite just leave it as is (\x{FeFF}).
  
  =over 4
  
  =item BOM as integer when fetched in network byte order
  
                16         32 bits/char
    -------------------------
    BE      0xFeFF 0x0000FeFF
    LE      0xFFFe 0xFFFe0000
    -------------------------
  
  =back
  
  This modules handles the BOM as follows.
  
  =over 4
  
  =item *
  
  When BE or LE is explicitly stated as the name of encoding, BOM is
  simply treated as a normal character (ZERO WIDTH NO-BREAK SPACE).
  
  =item *
  
  When BE or LE is omitted during decode(), it checks if BOM is at the
  beginning of the string; if one is found, the endianness is set to
  what the BOM says.  
  
  =item *
  
  Default Byte Order
  
  When no BOM is found, Encode 2.76 and blow croaked.  Since Encode
  2.77, it falls back to BE accordingly to RFC2781 and the Unicode
  Standard version 8.0
  
  =item *
  
  When BE or LE is omitted during encode(), it returns a BE-encoded
  string with BOM prepended.  So when you want to encode a whole text
  file, make sure you encode() the whole text at once, not line by line
  or each line, not file, will have a BOM prepended.
  
  =item *
  
  C<UCS-2> is an exception.  Unlike others, this is an alias of UCS-2BE.
  UCS-2 is already registered by IANA and others that way.
  
  =back
  
  =head1 Surrogate Pairs
  
  To say the least, surrogate pairs were the biggest mistake of the
  Unicode Consortium.  But according to the late Douglas Adams in I<The
  Hitchhiker's Guide to the Galaxy> Trilogy, C<In the beginning the
  Universe was created. This has made a lot of people very angry and
  been widely regarded as a bad move>.  Their mistake was not of this
  magnitude so let's forgive them.
  
  (I don't dare make any comparison with Unicode Consortium and the
  Vogons here ;)  Or, comparing Encode to Babel Fish is completely
  appropriate -- if you can only stick this into your ear :)
  
  Surrogate pairs were born when the Unicode Consortium finally
  admitted that 16 bits were not big enough to hold all the world's
  character repertoires.  But they already made UCS-2 16-bit.  What
  do we do?
  
  Back then, the range 0xD800-0xDFFF was not allocated.  Let's split
  that range in half and use the first half to represent the C<upper
  half of a character> and the second half to represent the C<lower
  half of a character>.  That way, you can represent 1024 * 1024 =
  1048576 more characters.  Now we can store character ranges up to
  \x{10ffff} even with 16-bit encodings.  This pair of half-character is
  now called a I<surrogate pair> and UTF-16 is the name of the encoding
  that embraces them.
  
  Here is a formula to ensurrogate a Unicode character \x{10000} and
  above;
  
    $hi = ($uni - 0x10000) / 0x400 + 0xD800;
    $lo = ($uni - 0x10000) % 0x400 + 0xDC00;
  
  And to desurrogate;
  
   $uni = 0x10000 + ($hi - 0xD800) * 0x400 + ($lo - 0xDC00);
  
  Note this move has made \x{D800}-\x{DFFF} into a forbidden zone but
  perl does not prohibit the use of characters within this range.  To perl,
  every one of \x{0000_0000} up to \x{ffff_ffff} (*) is I<a character>.
  
    (*) or \x{ffff_ffff_ffff_ffff} if your perl is compiled with 64-bit
    integer support!
  
  =head1 Error Checking
  
  Unlike most encodings which accept various ways to handle errors,
  Unicode encodings simply croaks.
  
    % perl -MEncode -e'$_ = "\xfe\xff\xd8\xd9\xda\xdb\0\n"' \
           -e'Encode::from_to($_, "utf16","shift_jis", 0); print'
    UTF-16:Malformed LO surrogate d8d9 at /path/to/Encode.pm line 184.
    % perl -MEncode -e'$a = "BOM missing"' \
           -e' Encode::from_to($a, "utf16", "shift_jis", 0); print'
    UTF-16:Unrecognised BOM 424f at /path/to/Encode.pm line 184.
  
  Unlike other encodings where mappings are not one-to-one against
  Unicode, UTFs are supposed to map 100% against one another.  So Encode
  is more strict on UTFs.
  
  Consider that "division by zero" of Encode :)
  
  =head1 SEE ALSO
  
  L<Encode>, L<Encode::Unicode::UTF7>, L<http://www.unicode.org/glossary/>,
  L<http://www.unicode.org/unicode/faq/utf_bom.html>,
  
  RFC 2781 L<http://www.ietf.org/rfc/rfc2781.txt>,
  
  The whole Unicode standard L<http://www.unicode.org/unicode/uni2book/u2.html>
  
  Ch. 15, pp. 403 of C<Programming Perl (3rd Edition)>
  by Larry Wall, Tom Christiansen, Jon Orwant;
  O'Reilly & Associates; ISBN 0-596-00027-8
  
  =cut
I686-LINUX-GNU-THREAD-MULTI-64INT_ENCODE_UNICODE

$fatpacked{"i686-linux-gnu-thread-multi-64int/Encode/Unicode/UTF7.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'I686-LINUX-GNU-THREAD-MULTI-64INT_ENCODE_UNICODE_UTF7';
  #
  # $Id: UTF7.pm,v 2.8 2013/09/14 07:51:59 dankogai Exp $
  #
  package Encode::Unicode::UTF7;
  use strict;
  use warnings;
  no warnings 'redefine';
  use parent qw(Encode::Encoding);
  __PACKAGE__->Define('UTF-7');
  our $VERSION = do { my @r = ( q$Revision: 2.8 $ =~ /\d+/g ); sprintf "%d." . "%02d" x $#r, @r };
  use MIME::Base64;
  use Encode;
  
  #
  # Algorithms taken from Unicode::String by Gisle Aas
  #
  
  our $OPTIONAL_DIRECT_CHARS = 1;
  my $specials = quotemeta "\'(),-./:?";
  $OPTIONAL_DIRECT_CHARS
    and $specials .= quotemeta "!\"#$%&*;<=>@[]^_`{|}";
  
  # \s will not work because it matches U+3000 DEOGRAPHIC SPACE
  # We use qr/[\n\r\t\ ] instead
  my $re_asis    = qr/(?:[\n\r\t\ A-Za-z0-9$specials])/;
  my $re_encoded = qr/(?:[^\n\r\t\ A-Za-z0-9$specials])/;
  my $e_utf16    = find_encoding("UTF-16BE");
  
  sub needs_lines { 1 }
  
  sub encode($$;$) {
      my ( $obj, $str, $chk ) = @_;
      my $len = length($str);
      pos($str) = 0;
      my $bytes = substr($str, 0, 0); # to propagate taintedness
      while ( pos($str) < $len ) {
          if ( $str =~ /\G($re_asis+)/ogc ) {
  	    my $octets = $1;
  	    utf8::downgrade($octets);
  	    $bytes .= $octets;
          }
          elsif ( $str =~ /\G($re_encoded+)/ogsc ) {
              if ( $1 eq "+" ) {
                  $bytes .= "+-";
              }
              else {
                  my $s = $1;
                  my $base64 = encode_base64( $e_utf16->encode($s), '' );
                  $base64 =~ s/=+$//;
                  $bytes .= "+$base64-";
              }
          }
          else {
              die "This should not happen! (pos=" . pos($str) . ")";
          }
      }
      $_[1] = '' if $chk;
      return $bytes;
  }
  
  sub decode($$;$) {
      use re 'taint';
      my ( $obj, $bytes, $chk ) = @_;
      my $len = length($bytes);
      my $str = substr($bytes, 0, 0); # to propagate taintedness;
      pos($bytes) = 0;
      no warnings 'uninitialized';
      while ( pos($bytes) < $len ) {
          if ( $bytes =~ /\G([^+]+)/ogc ) {
              $str .= $1;
          }
          elsif ( $bytes =~ /\G\+-/ogc ) {
              $str .= "+";
          }
          elsif ( $bytes =~ /\G\+([A-Za-z0-9+\/]+)-?/ogsc ) {
              my $base64 = $1;
              my $pad    = length($base64) % 4;
              $base64 .= "=" x ( 4 - $pad ) if $pad;
              $str .= $e_utf16->decode( decode_base64($base64) );
          }
          elsif ( $bytes =~ /\G\+/ogc ) {
              $^W and warn "Bad UTF7 data escape";
              $str .= "+";
          }
          else {
              die "This should not happen " . pos($bytes);
          }
      }
      $_[1] = '' if $chk;
      return $str;
  }
  1;
  __END__
  
  =head1 NAME
  
  Encode::Unicode::UTF7 -- UTF-7 encoding
  
  =head1 SYNOPSIS
  
      use Encode qw/encode decode/; 
      $utf7 = encode("UTF-7", $utf8);
      $utf8 = decode("UTF-7", $ucs2);
  
  =head1 ABSTRACT
  
  This module implements UTF-7 encoding documented in RFC 2152.  UTF-7,
  as its name suggests, is a 7-bit re-encoded version of UTF-16BE.  It
  is designed to be MTA-safe and expected to be a standard way to
  exchange Unicoded mails via mails.  But with the advent of UTF-8 and
  8-bit compliant MTAs, UTF-7 is hardly ever used.
  
  UTF-7 was not supported by Encode until version 1.95 because of that.
  But Unicode::String, a module by Gisle Aas which adds Unicode supports
  to non-utf8-savvy perl did support UTF-7, the UTF-7 support was added
  so Encode can supersede Unicode::String 100%.
  
  =head1 In Practice
  
  When you want to encode Unicode for mails and web pages, however, do
  not use UTF-7 unless you are sure your recipients and readers can
  handle it.  Very few MUAs and WWW Browsers support these days (only
  Mozilla seems to support one).  For general cases, use UTF-8 for
  message body and MIME-Header for header instead.
  
  =head1 SEE ALSO
  
  L<Encode>, L<Encode::Unicode>, L<Unicode::String>
  
  RFC 2781 L<http://www.ietf.org/rfc/rfc2152.txt>
  
  =cut
I686-LINUX-GNU-THREAD-MULTI-64INT_ENCODE_UNICODE_UTF7

$fatpacked{"i686-linux-gnu-thread-multi-64int/File/Spec.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'I686-LINUX-GNU-THREAD-MULTI-64INT_FILE_SPEC';
  package File::Spec;
  
  use strict;
  use vars qw(@ISA $VERSION);
  
  $VERSION = '3.62';
  $VERSION =~ tr/_//d;
  
  my %module = (MacOS   => 'Mac',
  	      MSWin32 => 'Win32',
  	      os2     => 'OS2',
  	      VMS     => 'VMS',
  	      epoc    => 'Epoc',
  	      NetWare => 'Win32', # Yes, File::Spec::Win32 works on NetWare.
  	      symbian => 'Win32', # Yes, File::Spec::Win32 works on symbian.
  	      dos     => 'OS2',   # Yes, File::Spec::OS2 works on DJGPP.
  	      cygwin  => 'Cygwin',
  	      amigaos => 'AmigaOS');
  
  
  my $module = $module{$^O} || 'Unix';
  
  require "File/Spec/$module.pm";
  @ISA = ("File::Spec::$module");
  
  1;
  
  __END__
  
  =head1 NAME
  
  File::Spec - portably perform operations on file names
  
  =head1 SYNOPSIS
  
  	use File::Spec;
  
  	$x=File::Spec->catfile('a', 'b', 'c');
  
  which returns 'a/b/c' under Unix. Or:
  
  	use File::Spec::Functions;
  
  	$x = catfile('a', 'b', 'c');
  
  =head1 DESCRIPTION
  
  This module is designed to support operations commonly performed on file
  specifications (usually called "file names", but not to be confused with the
  contents of a file, or Perl's file handles), such as concatenating several
  directory and file names into a single path, or determining whether a path
  is rooted. It is based on code directly taken from MakeMaker 5.17, code
  written by Andreas KE<ouml>nig, Andy Dougherty, Charles Bailey, Ilya
  Zakharevich, Paul Schinder, and others.
  
  Since these functions are different for most operating systems, each set of
  OS specific routines is available in a separate module, including:
  
  	File::Spec::Unix
  	File::Spec::Mac
  	File::Spec::OS2
  	File::Spec::Win32
  	File::Spec::VMS
  
  The module appropriate for the current OS is automatically loaded by
  File::Spec. Since some modules (like VMS) make use of facilities available
  only under that OS, it may not be possible to load all modules under all
  operating systems.
  
  Since File::Spec is object oriented, subroutines should not be called directly,
  as in:
  
  	File::Spec::catfile('a','b');
  
  but rather as class methods:
  
  	File::Spec->catfile('a','b');
  
  For simple uses, L<File::Spec::Functions> provides convenient functional
  forms of these methods.
  
  =head1 METHODS
  
  =over 2
  
  =item canonpath
  X<canonpath>
  
  No physical check on the filesystem, but a logical cleanup of a
  path.
  
      $cpath = File::Spec->canonpath( $path ) ;
  
  Note that this does *not* collapse F<x/../y> sections into F<y>.  This
  is by design.  If F</foo> on your system is a symlink to F</bar/baz>,
  then F</foo/../quux> is actually F</bar/quux>, not F</quux> as a naive
  F<../>-removal would give you.  If you want to do this kind of
  processing, you probably want C<Cwd>'s C<realpath()> function to
  actually traverse the filesystem cleaning up paths like this.
  
  =item catdir
  X<catdir>
  
  Concatenate two or more directory names to form a complete path ending
  with a directory. But remove the trailing slash from the resulting
  string, because it doesn't look good, isn't necessary and confuses
  OS/2. Of course, if this is the root directory, don't cut off the
  trailing slash :-)
  
      $path = File::Spec->catdir( @directories );
  
  =item catfile
  X<catfile>
  
  Concatenate one or more directory names and a filename to form a
  complete path ending with a filename
  
      $path = File::Spec->catfile( @directories, $filename );
  
  =item curdir
  X<curdir>
  
  Returns a string representation of the current directory.
  
      $curdir = File::Spec->curdir();
  
  =item devnull
  X<devnull>
  
  Returns a string representation of the null device.
  
      $devnull = File::Spec->devnull();
  
  =item rootdir
  X<rootdir>
  
  Returns a string representation of the root directory.
  
      $rootdir = File::Spec->rootdir();
  
  =item tmpdir
  X<tmpdir>
  
  Returns a string representation of the first writable directory from a
  list of possible temporary directories.  Returns the current directory
  if no writable temporary directories are found.  The list of directories
  checked depends on the platform; e.g. File::Spec::Unix checks C<$ENV{TMPDIR}>
  (unless taint is on) and F</tmp>.
  
      $tmpdir = File::Spec->tmpdir();
  
  =item updir
  X<updir>
  
  Returns a string representation of the parent directory.
  
      $updir = File::Spec->updir();
  
  =item no_upwards
  
  Given a list of file names, strip out those that refer to a parent
  directory. (Does not strip symlinks, only '.', '..', and equivalents.)
  
      @paths = File::Spec->no_upwards( @paths );
  
  =item case_tolerant
  
  Returns a true or false value indicating, respectively, that alphabetic
  case is not or is significant when comparing file specifications.
  Cygwin and Win32 accept an optional drive argument.
  
      $is_case_tolerant = File::Spec->case_tolerant();
  
  =item file_name_is_absolute
  
  Takes as its argument a path, and returns true if it is an absolute path.
  
      $is_absolute = File::Spec->file_name_is_absolute( $path );
  
  This does not consult the local filesystem on Unix, Win32, OS/2, or
  Mac OS (Classic).  It does consult the working environment for VMS
  (see L<File::Spec::VMS/file_name_is_absolute>).
  
  =item path
  X<path>
  
  Takes no argument.  Returns the environment variable C<PATH> (or the local
  platform's equivalent) as a list.
  
      @PATH = File::Spec->path();
  
  =item join
  X<join, path>
  
  join is the same as catfile.
  
  =item splitpath
  X<splitpath> X<split, path>
  
  Splits a path in to volume, directory, and filename portions. On systems
  with no concept of volume, returns '' for volume. 
  
      ($volume,$directories,$file) =
                         File::Spec->splitpath( $path );
      ($volume,$directories,$file) =
                         File::Spec->splitpath( $path, $no_file );
  
  For systems with no syntax differentiating filenames from directories, 
  assumes that the last file is a path unless C<$no_file> is true or a
  trailing separator or F</.> or F</..> is present. On Unix, this means that C<$no_file>
  true makes this return ( '', $path, '' ).
  
  The directory portion may or may not be returned with a trailing '/'.
  
  The results can be passed to L</catpath()> to get back a path equivalent to
  (usually identical to) the original path.
  
  =item splitdir
  X<splitdir> X<split, dir>
  
  The opposite of L</catdir>.
  
      @dirs = File::Spec->splitdir( $directories );
  
  C<$directories> must be only the directory portion of the path on systems 
  that have the concept of a volume or that have path syntax that differentiates
  files from directories.
  
  Unlike just splitting the directories on the separator, empty
  directory names (C<''>) can be returned, because these are significant
  on some OSes.
  
  =item catpath()
  
  Takes volume, directory and file portions and returns an entire path. Under
  Unix, C<$volume> is ignored, and directory and file are concatenated.  A '/' is
  inserted if need be.  On other OSes, C<$volume> is significant.
  
      $full_path = File::Spec->catpath( $volume, $directory, $file );
  
  =item abs2rel
  X<abs2rel> X<absolute, path> X<relative, path>
  
  Takes a destination path and an optional base path returns a relative path
  from the base path to the destination path:
  
      $rel_path = File::Spec->abs2rel( $path ) ;
      $rel_path = File::Spec->abs2rel( $path, $base ) ;
  
  If C<$base> is not present or '', then L<Cwd::cwd()|Cwd> is used. If C<$base> is
  relative, then it is converted to absolute form using
  L</rel2abs()>. This means that it is taken to be relative to
  L<Cwd::cwd()|Cwd>.
  
  On systems with the concept of volume, if C<$path> and C<$base> appear to be
  on two different volumes, we will not attempt to resolve the two
  paths, and we will instead simply return C<$path>.  Note that previous
  versions of this module ignored the volume of C<$base>, which resulted in
  garbage results part of the time.
  
  On systems that have a grammar that indicates filenames, this ignores the 
  C<$base> filename as well. Otherwise all path components are assumed to be
  directories.
  
  If C<$path> is relative, it is converted to absolute form using L</rel2abs()>.
  This means that it is taken to be relative to L<Cwd::cwd()|Cwd>.
  
  No checks against the filesystem are made.  On VMS, there is
  interaction with the working environment, as logicals and
  macros are expanded.
  
  Based on code written by Shigio Yamaguchi.
  
  =item rel2abs()
  X<rel2abs> X<absolute, path> X<relative, path>
  
  Converts a relative path to an absolute path. 
  
      $abs_path = File::Spec->rel2abs( $path ) ;
      $abs_path = File::Spec->rel2abs( $path, $base ) ;
  
  If C<$base> is not present or '', then L<Cwd::cwd()|Cwd> is used. If C<$base> is relative,
  then it is converted to absolute form using L</rel2abs()>. This means that it
  is taken to be relative to L<Cwd::cwd()|Cwd>.
  
  On systems with the concept of volume, if C<$path> and C<$base> appear to be
  on two different volumes, we will not attempt to resolve the two
  paths, and we will instead simply return C<$path>.  Note that previous
  versions of this module ignored the volume of C<$base>, which resulted in
  garbage results part of the time.
  
  On systems that have a grammar that indicates filenames, this ignores the 
  C<$base> filename as well. Otherwise all path components are assumed to be
  directories.
  
  If C<$path> is absolute, it is cleaned up and returned using L</canonpath>.
  
  No checks against the filesystem are made.  On VMS, there is
  interaction with the working environment, as logicals and
  macros are expanded.
  
  Based on code written by Shigio Yamaguchi.
  
  =back
  
  For further information, please see L<File::Spec::Unix>,
  L<File::Spec::Mac>, L<File::Spec::OS2>, L<File::Spec::Win32>, or
  L<File::Spec::VMS>.
  
  =head1 SEE ALSO
  
  L<File::Spec::Unix>, L<File::Spec::Mac>, L<File::Spec::OS2>,
  L<File::Spec::Win32>, L<File::Spec::VMS>, L<File::Spec::Functions>,
  L<ExtUtils::MakeMaker>
  
  =head1 AUTHOR
  
  Currently maintained by Ken Williams C<< <KWILLIAMS@cpan.org> >>.
  
  The vast majority of the code was written by
  Kenneth Albanowski C<< <kjahds@kjahds.com> >>,
  Andy Dougherty C<< <doughera@lafayette.edu> >>,
  Andreas KE<ouml>nig C<< <A.Koenig@franz.ww.TU-Berlin.DE> >>,
  Tim Bunce C<< <Tim.Bunce@ig.co.uk> >>.
  VMS support by Charles Bailey C<< <bailey@newman.upenn.edu> >>.
  OS/2 support by Ilya Zakharevich C<< <ilya@math.ohio-state.edu> >>.
  Mac support by Paul Schinder C<< <schinder@pobox.com> >>, and
  Thomas Wegner C<< <wegner_thomas@yahoo.com> >>.
  abs2rel() and rel2abs() written by Shigio Yamaguchi C<< <shigio@tamacom.com> >>,
  modified by Barrie Slaymaker C<< <barries@slaysys.com> >>.
  splitpath(), splitdir(), catpath() and catdir() by Barrie Slaymaker.
  
  =head1 COPYRIGHT
  
  Copyright (c) 2004-2013 by the Perl 5 Porters.  All rights reserved.
  
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =cut
I686-LINUX-GNU-THREAD-MULTI-64INT_FILE_SPEC

$fatpacked{"i686-linux-gnu-thread-multi-64int/File/Spec/AmigaOS.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'I686-LINUX-GNU-THREAD-MULTI-64INT_FILE_SPEC_AMIGAOS';
  package File::Spec::AmigaOS;
  
  use strict;
  use vars qw(@ISA $VERSION);
  require File::Spec::Unix;
  
  $VERSION = '3.62';
  $VERSION =~ tr/_//d;
  
  @ISA = qw(File::Spec::Unix);
  
  =head1 NAME
  
  File::Spec::AmigaOS - File::Spec for AmigaOS
  
  =head1 SYNOPSIS
  
   require File::Spec::AmigaOS; # Done automatically by File::Spec if needed
  
  =head1 DESCRIPTION
  
  Methods for manipulating file specifications.
  
  =head1 METHODS
  
  =over 2
  
  =item tmpdir
  
  Returns $ENV{TMPDIR} or if that is unset, "/t".
  
  =cut
  
  my $tmpdir;
  sub tmpdir {
    return $tmpdir if defined $tmpdir;
    $tmpdir = $_[0]->_tmpdir( $ENV{TMPDIR}, "/t" );
  }
  
  =item file_name_is_absolute
  
  Returns true if there's a colon in the file name,
  or if it begins with a slash.
  
  =cut
  
  sub file_name_is_absolute {
    my ($self, $file) = @_;
  
    # Not 100% robust as a "/" must not preceded a ":"
    # but this cannot happen in a well formed path.
    return $file =~ m{^/|:}s;
  }
  
  =back
  
  All the other methods are from L<File::Spec::Unix>.
  
  =cut
  
  1;
I686-LINUX-GNU-THREAD-MULTI-64INT_FILE_SPEC_AMIGAOS

$fatpacked{"i686-linux-gnu-thread-multi-64int/File/Spec/Cygwin.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'I686-LINUX-GNU-THREAD-MULTI-64INT_FILE_SPEC_CYGWIN';
  package File::Spec::Cygwin;
  
  use strict;
  use vars qw(@ISA $VERSION);
  require File::Spec::Unix;
  
  $VERSION = '3.62';
  $VERSION =~ tr/_//d;
  
  @ISA = qw(File::Spec::Unix);
  
  =head1 NAME
  
  File::Spec::Cygwin - methods for Cygwin file specs
  
  =head1 SYNOPSIS
  
   require File::Spec::Cygwin; # Done internally by File::Spec if needed
  
  =head1 DESCRIPTION
  
  See L<File::Spec> and L<File::Spec::Unix>.  This package overrides the
  implementation of these methods, not the semantics.
  
  This module is still in beta.  Cygwin-knowledgeable folks are invited
  to offer patches and suggestions.
  
  =cut
  
  =pod
  
  =over 4
  
  =item canonpath
  
  Any C<\> (backslashes) are converted to C</> (forward slashes),
  and then File::Spec::Unix canonpath() is called on the result.
  
  =cut
  
  sub canonpath {
      my($self,$path) = @_;
      return unless defined $path;
  
      $path =~ s|\\|/|g;
  
      # Handle network path names beginning with double slash
      my $node = '';
      if ( $path =~ s@^(//[^/]+)(?:/|\z)@/@s ) {
          $node = $1;
      }
      return $node . $self->SUPER::canonpath($path);
  }
  
  sub catdir {
      my $self = shift;
      return unless @_;
  
      # Don't create something that looks like a //network/path
      if ($_[0] and ($_[0] eq '/' or $_[0] eq '\\')) {
          shift;
          return $self->SUPER::catdir('', @_);
      }
  
      $self->SUPER::catdir(@_);
  }
  
  =pod
  
  =item file_name_is_absolute
  
  True is returned if the file name begins with C<drive_letter:>,
  and if not, File::Spec::Unix file_name_is_absolute() is called.
  
  =cut
  
  
  sub file_name_is_absolute {
      my ($self,$file) = @_;
      return 1 if $file =~ m{^([a-z]:)?[\\/]}is; # C:/test
      return $self->SUPER::file_name_is_absolute($file);
  }
  
  =item tmpdir (override)
  
  Returns a string representation of the first existing directory
  from the following list:
  
      $ENV{TMPDIR}
      /tmp
      $ENV{'TMP'}
      $ENV{'TEMP'}
      C:/temp
  
  If running under taint mode, and if the environment
  variables are tainted, they are not used.
  
  =cut
  
  sub tmpdir {
      my $cached = $_[0]->_cached_tmpdir(qw 'TMPDIR TMP TEMP');
      return $cached if defined $cached;
      $_[0]->_cache_tmpdir(
          $_[0]->_tmpdir(
              $ENV{TMPDIR}, "/tmp", $ENV{'TMP'}, $ENV{'TEMP'}, 'C:/temp'
          ),
          qw 'TMPDIR TMP TEMP'
      );
  }
  
  =item case_tolerant
  
  Override Unix. Cygwin case-tolerance depends on managed mount settings and
  as with MsWin32 on GetVolumeInformation() $ouFsFlags == FS_CASE_SENSITIVE,
  indicating the case significance when comparing file specifications.
  Default: 1
  
  =cut
  
  sub case_tolerant {
    return 1 unless $^O eq 'cygwin'
      and defined &Cygwin::mount_flags;
  
    my $drive = shift;
    if (! $drive) {
        my @flags = split(/,/, Cygwin::mount_flags('/cygwin'));
        my $prefix = pop(@flags);
        if (! $prefix || $prefix eq 'cygdrive') {
            $drive = '/cygdrive/c';
        } elsif ($prefix eq '/') {
            $drive = '/c';
        } else {
            $drive = "$prefix/c";
        }
    }
    my $mntopts = Cygwin::mount_flags($drive);
    if ($mntopts and ($mntopts =~ /,managed/)) {
      return 0;
    }
    eval { require Win32API::File; } or return 1;
    my $osFsType = "\0"x256;
    my $osVolName = "\0"x256;
    my $ouFsFlags = 0;
    Win32API::File::GetVolumeInformation($drive, $osVolName, 256, [], [], $ouFsFlags, $osFsType, 256 );
    if ($ouFsFlags & Win32API::File::FS_CASE_SENSITIVE()) { return 0; }
    else { return 1; }
  }
  
  =back
  
  =head1 COPYRIGHT
  
  Copyright (c) 2004,2007 by the Perl 5 Porters.  All rights reserved.
  
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =cut
  
  1;
I686-LINUX-GNU-THREAD-MULTI-64INT_FILE_SPEC_CYGWIN

$fatpacked{"i686-linux-gnu-thread-multi-64int/File/Spec/Epoc.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'I686-LINUX-GNU-THREAD-MULTI-64INT_FILE_SPEC_EPOC';
  package File::Spec::Epoc;
  
  use strict;
  use vars qw($VERSION @ISA);
  
  $VERSION = '3.62';
  $VERSION =~ tr/_//d;
  
  require File::Spec::Unix;
  @ISA = qw(File::Spec::Unix);
  
  =head1 NAME
  
  File::Spec::Epoc - methods for Epoc file specs
  
  =head1 SYNOPSIS
  
   require File::Spec::Epoc; # Done internally by File::Spec if needed
  
  =head1 DESCRIPTION
  
  See File::Spec::Unix for a documentation of the methods provided
  there.  This package overrides the implementation of these methods, not
  the semantics.
  
  This package is still a work in progress. ;-)
  
  =cut
  
  sub case_tolerant {
      return 1;
  }
  
  =pod
  
  =over 4
  
  =item canonpath()
  
  No physical check on the filesystem, but a logical cleanup of a
  path.  On UNIX eliminated successive slashes and successive "/.".
  
  =back
  
  =cut
  
  sub canonpath {
      my ($self,$path) = @_;
      return unless defined $path;
  
      $path =~ s|/+|/|g;                             # xx////xx  -> xx/xx
      $path =~ s|(/\.)+/|/|g;                        # xx/././xx -> xx/xx
      $path =~ s|^(\./)+||s unless $path eq "./";    # ./xx      -> xx
      $path =~ s|^/(\.\./)+|/|s;                     # /../../xx -> xx
      $path =~  s|/\Z(?!\n)|| unless $path eq "/";          # xx/       -> xx
      return $path;
  }
  
  =pod
  
  =head1 AUTHOR
  
  o.flebbe@gmx.de
  
  =head1 COPYRIGHT
  
  Copyright (c) 2004 by the Perl 5 Porters.  All rights reserved.
  
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =head1 SEE ALSO
  
  See L<File::Spec> and L<File::Spec::Unix>.  This package overrides the
  implementation of these methods, not the semantics.
  
  =cut
  
  1;
I686-LINUX-GNU-THREAD-MULTI-64INT_FILE_SPEC_EPOC

$fatpacked{"i686-linux-gnu-thread-multi-64int/File/Spec/Functions.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'I686-LINUX-GNU-THREAD-MULTI-64INT_FILE_SPEC_FUNCTIONS';
  package File::Spec::Functions;
  
  use File::Spec;
  use strict;
  
  use vars qw(@ISA @EXPORT @EXPORT_OK %EXPORT_TAGS $VERSION);
  
  $VERSION = '3.62';
  $VERSION =~ tr/_//d;
  
  require Exporter;
  
  @ISA = qw(Exporter);
  
  @EXPORT = qw(
  	canonpath
  	catdir
  	catfile
  	curdir
  	rootdir
  	updir
  	no_upwards
  	file_name_is_absolute
  	path
  );
  
  @EXPORT_OK = qw(
  	devnull
  	tmpdir
  	splitpath
  	splitdir
  	catpath
  	abs2rel
  	rel2abs
  	case_tolerant
  );
  
  %EXPORT_TAGS = ( ALL => [ @EXPORT_OK, @EXPORT ] );
  
  require File::Spec::Unix;
  my %udeps = (
      canonpath => [],
      catdir => [qw(canonpath)],
      catfile => [qw(canonpath catdir)],
      case_tolerant => [],
      curdir => [],
      devnull => [],
      rootdir => [],
      updir => [],
  );
  
  foreach my $meth (@EXPORT, @EXPORT_OK) {
      my $sub = File::Spec->can($meth);
      no strict 'refs';
      if (exists($udeps{$meth}) && $sub == File::Spec::Unix->can($meth) &&
  	    !(grep {
  		File::Spec->can($_) != File::Spec::Unix->can($_)
  	    } @{$udeps{$meth}}) &&
  	    defined(&{"File::Spec::Unix::_fn_$meth"})) {
  	*{$meth} = \&{"File::Spec::Unix::_fn_$meth"};
      } else {
  	*{$meth} = sub {&$sub('File::Spec', @_)};
      }
  }
  
  
  1;
  __END__
  
  =head1 NAME
  
  File::Spec::Functions - portably perform operations on file names
  
  =head1 SYNOPSIS
  
  	use File::Spec::Functions;
  	$x = catfile('a','b');
  
  =head1 DESCRIPTION
  
  This module exports convenience functions for all of the class methods
  provided by File::Spec.
  
  For a reference of available functions, please consult L<File::Spec::Unix>,
  which contains the entire set, and which is inherited by the modules for
  other platforms. For further information, please see L<File::Spec::Mac>,
  L<File::Spec::OS2>, L<File::Spec::Win32>, or L<File::Spec::VMS>.
  
  =head2 Exports
  
  The following functions are exported by default.
  
  	canonpath
  	catdir
  	catfile
  	curdir
  	rootdir
  	updir
  	no_upwards
  	file_name_is_absolute
  	path
  
  
  The following functions are exported only by request.
  
  	devnull
  	tmpdir
  	splitpath
  	splitdir
  	catpath
  	abs2rel
  	rel2abs
  	case_tolerant
  
  All the functions may be imported using the C<:ALL> tag.
  
  =head1 COPYRIGHT
  
  Copyright (c) 2004 by the Perl 5 Porters.  All rights reserved.
  
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =head1 SEE ALSO
  
  File::Spec, File::Spec::Unix, File::Spec::Mac, File::Spec::OS2,
  File::Spec::Win32, File::Spec::VMS, ExtUtils::MakeMaker
  
  =cut
  
I686-LINUX-GNU-THREAD-MULTI-64INT_FILE_SPEC_FUNCTIONS

$fatpacked{"i686-linux-gnu-thread-multi-64int/File/Spec/Mac.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'I686-LINUX-GNU-THREAD-MULTI-64INT_FILE_SPEC_MAC';
  package File::Spec::Mac;
  
  use strict;
  use vars qw(@ISA $VERSION);
  require File::Spec::Unix;
  
  $VERSION = '3.62';
  $VERSION =~ tr/_//d;
  
  @ISA = qw(File::Spec::Unix);
  
  my $macfiles;
  if ($^O eq 'MacOS') {
  	$macfiles = eval { require Mac::Files };
  }
  
  sub case_tolerant { 1 }
  
  
  =head1 NAME
  
  File::Spec::Mac - File::Spec for Mac OS (Classic)
  
  =head1 SYNOPSIS
  
   require File::Spec::Mac; # Done internally by File::Spec if needed
  
  =head1 DESCRIPTION
  
  Methods for manipulating file specifications.
  
  =head1 METHODS
  
  =over 2
  
  =item canonpath
  
  On Mac OS, there's nothing to be done. Returns what it's given.
  
  =cut
  
  sub canonpath {
      my ($self,$path) = @_;
      return $path;
  }
  
  =item catdir()
  
  Concatenate two or more directory names to form a path separated by colons
  (":") ending with a directory. Resulting paths are B<relative> by default,
  but can be forced to be absolute (but avoid this, see below). Automatically
  puts a trailing ":" on the end of the complete path, because that's what's
  done in MacPerl's environment and helps to distinguish a file path from a
  directory path.
  
  B<IMPORTANT NOTE:> Beginning with version 1.3 of this module, the resulting
  path is relative by default and I<not> absolute. This decision was made due
  to portability reasons. Since C<File::Spec-E<gt>catdir()> returns relative paths
  on all other operating systems, it will now also follow this convention on Mac
  OS. Note that this may break some existing scripts.
  
  The intended purpose of this routine is to concatenate I<directory names>.
  But because of the nature of Macintosh paths, some additional possibilities
  are allowed to make using this routine give reasonable results for some
  common situations. In other words, you are also allowed to concatenate
  I<paths> instead of directory names (strictly speaking, a string like ":a"
  is a path, but not a name, since it contains a punctuation character ":").
  
  So, beside calls like
  
      catdir("a") = ":a:"
      catdir("a","b") = ":a:b:"
      catdir() = ""                    (special case)
  
  calls like the following
  
      catdir(":a:") = ":a:"
      catdir(":a","b") = ":a:b:"
      catdir(":a:","b") = ":a:b:"
      catdir(":a:",":b:") = ":a:b:"
      catdir(":") = ":"
  
  are allowed.
  
  Here are the rules that are used in C<catdir()>; note that we try to be as
  compatible as possible to Unix:
  
  =over 2
  
  =item 1.
  
  The resulting path is relative by default, i.e. the resulting path will have a
  leading colon.
  
  =item 2.
  
  A trailing colon is added automatically to the resulting path, to denote a
  directory.
  
  =item 3.
  
  Generally, each argument has one leading ":" and one trailing ":"
  removed (if any). They are then joined together by a ":". Special
  treatment applies for arguments denoting updir paths like "::lib:",
  see (4), or arguments consisting solely of colons ("colon paths"),
  see (5).
  
  =item 4.
  
  When an updir path like ":::lib::" is passed as argument, the number
  of directories to climb up is handled correctly, not removing leading
  or trailing colons when necessary. E.g.
  
      catdir(":::a","::b","c")    = ":::a::b:c:"
      catdir(":::a::","::b","c")  = ":::a:::b:c:"
  
  =item 5.
  
  Adding a colon ":" or empty string "" to a path at I<any> position
  doesn't alter the path, i.e. these arguments are ignored. (When a ""
  is passed as the first argument, it has a special meaning, see
  (6)). This way, a colon ":" is handled like a "." (curdir) on Unix,
  while an empty string "" is generally ignored (see
  C<Unix-E<gt>canonpath()> ). Likewise, a "::" is handled like a ".."
  (updir), and a ":::" is handled like a "../.." etc.  E.g.
  
      catdir("a",":",":","b")   = ":a:b:"
      catdir("a",":","::",":b") = ":a::b:"
  
  =item 6.
  
  If the first argument is an empty string "" or is a volume name, i.e. matches
  the pattern /^[^:]+:/, the resulting path is B<absolute>.
  
  =item 7.
  
  Passing an empty string "" as the first argument to C<catdir()> is
  like passingC<File::Spec-E<gt>rootdir()> as the first argument, i.e.
  
      catdir("","a","b")          is the same as
  
      catdir(rootdir(),"a","b").
  
  This is true on Unix, where C<catdir("","a","b")> yields "/a/b" and
  C<rootdir()> is "/". Note that C<rootdir()> on Mac OS is the startup
  volume, which is the closest in concept to Unix' "/". This should help
  to run existing scripts originally written for Unix.
  
  =item 8.
  
  For absolute paths, some cleanup is done, to ensure that the volume
  name isn't immediately followed by updirs. This is invalid, because
  this would go beyond "root". Generally, these cases are handled like
  their Unix counterparts:
  
   Unix:
      Unix->catdir("","")                 =  "/"
      Unix->catdir("",".")                =  "/"
      Unix->catdir("","..")               =  "/"        # can't go
                                                        # beyond root
      Unix->catdir("",".","..","..","a")  =  "/a"
   Mac:
      Mac->catdir("","")                  =  rootdir()  # (e.g. "HD:")
      Mac->catdir("",":")                 =  rootdir()
      Mac->catdir("","::")                =  rootdir()  # can't go
                                                        # beyond root
      Mac->catdir("",":","::","::","a")   =  rootdir() . "a:"
                                                      # (e.g. "HD:a:")
  
  However, this approach is limited to the first arguments following
  "root" (again, see C<Unix-E<gt>canonpath()> ). If there are more
  arguments that move up the directory tree, an invalid path going
  beyond root can be created.
  
  =back
  
  As you've seen, you can force C<catdir()> to create an absolute path
  by passing either an empty string or a path that begins with a volume
  name as the first argument. However, you are strongly encouraged not
  to do so, since this is done only for backward compatibility. Newer
  versions of File::Spec come with a method called C<catpath()> (see
  below), that is designed to offer a portable solution for the creation
  of absolute paths.  It takes volume, directory and file portions and
  returns an entire path. While C<catdir()> is still suitable for the
  concatenation of I<directory names>, you are encouraged to use
  C<catpath()> to concatenate I<volume names> and I<directory
  paths>. E.g.
  
      $dir      = File::Spec->catdir("tmp","sources");
      $abs_path = File::Spec->catpath("MacintoshHD:", $dir,"");
  
  yields
  
      "MacintoshHD:tmp:sources:" .
  
  =cut
  
  sub catdir {
  	my $self = shift;
  	return '' unless @_;
  	my @args = @_;
  	my $first_arg;
  	my $relative;
  
  	# take care of the first argument
  
  	if ($args[0] eq '')  { # absolute path, rootdir
  		shift @args;
  		$relative = 0;
  		$first_arg = $self->rootdir;
  
  	} elsif ($args[0] =~ /^[^:]+:/) { # absolute path, volume name
  		$relative = 0;
  		$first_arg = shift @args;
  		# add a trailing ':' if need be (may be it's a path like HD:dir)
  		$first_arg = "$first_arg:" unless ($first_arg =~ /:\Z(?!\n)/);
  
  	} else { # relative path
  		$relative = 1;
  		if ( $args[0] =~ /^::+\Z(?!\n)/ ) {
  			# updir colon path ('::', ':::' etc.), don't shift
  			$first_arg = ':';
  		} elsif ($args[0] eq ':') {
  			$first_arg = shift @args;
  		} else {
  			# add a trailing ':' if need be
  			$first_arg = shift @args;
  			$first_arg = "$first_arg:" unless ($first_arg =~ /:\Z(?!\n)/);
  		}
  	}
  
  	# For all other arguments,
  	# (a) ignore arguments that equal ':' or '',
  	# (b) handle updir paths specially:
  	#     '::' 			-> concatenate '::'
  	#     '::' . '::' 	-> concatenate ':::' etc.
  	# (c) add a trailing ':' if need be
  
  	my $result = $first_arg;
  	while (@args) {
  		my $arg = shift @args;
  		unless (($arg eq '') || ($arg eq ':')) {
  			if ($arg =~ /^::+\Z(?!\n)/ ) { # updir colon path like ':::'
  				my $updir_count = length($arg) - 1;
  				while ((@args) && ($args[0] =~ /^::+\Z(?!\n)/) ) { # while updir colon path
  					$arg = shift @args;
  					$updir_count += (length($arg) - 1);
  				}
  				$arg = (':' x $updir_count);
  			} else {
  				$arg =~ s/^://s; # remove a leading ':' if any
  				$arg = "$arg:" unless ($arg =~ /:\Z(?!\n)/); # ensure trailing ':'
  			}
  			$result .= $arg;
  		}#unless
  	}
  
  	if ( ($relative) && ($result !~ /^:/) ) {
  		# add a leading colon if need be
  		$result = ":$result";
  	}
  
  	unless ($relative) {
  		# remove updirs immediately following the volume name
  		$result =~ s/([^:]+:)(:*)(.*)\Z(?!\n)/$1$3/;
  	}
  
  	return $result;
  }
  
  =item catfile
  
  Concatenate one or more directory names and a filename to form a
  complete path ending with a filename. Resulting paths are B<relative>
  by default, but can be forced to be absolute (but avoid this).
  
  B<IMPORTANT NOTE:> Beginning with version 1.3 of this module, the
  resulting path is relative by default and I<not> absolute. This
  decision was made due to portability reasons. Since
  C<File::Spec-E<gt>catfile()> returns relative paths on all other
  operating systems, it will now also follow this convention on Mac OS.
  Note that this may break some existing scripts.
  
  The last argument is always considered to be the file portion. Since
  C<catfile()> uses C<catdir()> (see above) for the concatenation of the
  directory portions (if any), the following with regard to relative and
  absolute paths is true:
  
      catfile("")     = ""
      catfile("file") = "file"
  
  but
  
      catfile("","")        = rootdir()         # (e.g. "HD:")
      catfile("","file")    = rootdir() . file  # (e.g. "HD:file")
      catfile("HD:","file") = "HD:file"
  
  This means that C<catdir()> is called only when there are two or more
  arguments, as one might expect.
  
  Note that the leading ":" is removed from the filename, so that
  
      catfile("a","b","file")  = ":a:b:file"    and
  
      catfile("a","b",":file") = ":a:b:file"
  
  give the same answer.
  
  To concatenate I<volume names>, I<directory paths> and I<filenames>,
  you are encouraged to use C<catpath()> (see below).
  
  =cut
  
  sub catfile {
      my $self = shift;
      return '' unless @_;
      my $file = pop @_;
      return $file unless @_;
      my $dir = $self->catdir(@_);
      $file =~ s/^://s;
      return $dir.$file;
  }
  
  =item curdir
  
  Returns a string representing the current directory. On Mac OS, this is ":".
  
  =cut
  
  sub curdir {
      return ":";
  }
  
  =item devnull
  
  Returns a string representing the null device. On Mac OS, this is "Dev:Null".
  
  =cut
  
  sub devnull {
      return "Dev:Null";
  }
  
  =item rootdir
  
  Returns a string representing the root directory.  Under MacPerl,
  returns the name of the startup volume, since that's the closest in
  concept, although other volumes aren't rooted there. The name has a
  trailing ":", because that's the correct specification for a volume
  name on Mac OS.
  
  If Mac::Files could not be loaded, the empty string is returned.
  
  =cut
  
  sub rootdir {
  #
  #  There's no real root directory on Mac OS. The name of the startup
  #  volume is returned, since that's the closest in concept.
  #
      return '' unless $macfiles;
      my $system = Mac::Files::FindFolder(&Mac::Files::kOnSystemDisk,
  	&Mac::Files::kSystemFolderType);
      $system =~ s/:.*\Z(?!\n)/:/s;
      return $system;
  }
  
  =item tmpdir
  
  Returns the contents of $ENV{TMPDIR}, if that directory exits or the
  current working directory otherwise. Under MacPerl, $ENV{TMPDIR} will
  contain a path like "MacintoshHD:Temporary Items:", which is a hidden
  directory on your startup volume.
  
  =cut
  
  sub tmpdir {
      my $cached = $_[0]->_cached_tmpdir('TMPDIR');
      return $cached if defined $cached;
      $_[0]->_cache_tmpdir($_[0]->_tmpdir( $ENV{TMPDIR} ), 'TMPDIR');
  }
  
  =item updir
  
  Returns a string representing the parent directory. On Mac OS, this is "::".
  
  =cut
  
  sub updir {
      return "::";
  }
  
  =item file_name_is_absolute
  
  Takes as argument a path and returns true, if it is an absolute path.
  If the path has a leading ":", it's a relative path. Otherwise, it's an
  absolute path, unless the path doesn't contain any colons, i.e. it's a name
  like "a". In this particular case, the path is considered to be relative
  (i.e. it is considered to be a filename). Use ":" in the appropriate place
  in the path if you want to distinguish unambiguously. As a special case,
  the filename '' is always considered to be absolute. Note that with version
  1.2 of File::Spec::Mac, this does no longer consult the local filesystem.
  
  E.g.
  
      File::Spec->file_name_is_absolute("a");         # false (relative)
      File::Spec->file_name_is_absolute(":a:b:");     # false (relative)
      File::Spec->file_name_is_absolute("MacintoshHD:");
                                                      # true (absolute)
      File::Spec->file_name_is_absolute("");          # true (absolute)
  
  
  =cut
  
  sub file_name_is_absolute {
      my ($self,$file) = @_;
      if ($file =~ /:/) {
  	return (! ($file =~ m/^:/s) );
      } elsif ( $file eq '' ) {
          return 1 ;
      } else {
  	return 0; # i.e. a file like "a"
      }
  }
  
  =item path
  
  Returns the null list for the MacPerl application, since the concept is
  usually meaningless under Mac OS. But if you're using the MacPerl tool under
  MPW, it gives back $ENV{Commands} suitably split, as is done in
  :lib:ExtUtils:MM_Mac.pm.
  
  =cut
  
  sub path {
  #
  #  The concept is meaningless under the MacPerl application.
  #  Under MPW, it has a meaning.
  #
      return unless exists $ENV{Commands};
      return split(/,/, $ENV{Commands});
  }
  
  =item splitpath
  
      ($volume,$directories,$file) = File::Spec->splitpath( $path );
      ($volume,$directories,$file) = File::Spec->splitpath( $path,
                                                            $no_file );
  
  Splits a path into volume, directory, and filename portions.
  
  On Mac OS, assumes that the last part of the path is a filename unless
  $no_file is true or a trailing separator ":" is present.
  
  The volume portion is always returned with a trailing ":". The directory portion
  is always returned with a leading (to denote a relative path) and a trailing ":"
  (to denote a directory). The file portion is always returned I<without> a leading ":".
  Empty portions are returned as empty string ''.
  
  The results can be passed to C<catpath()> to get back a path equivalent to
  (usually identical to) the original path.
  
  
  =cut
  
  sub splitpath {
      my ($self,$path, $nofile) = @_;
      my ($volume,$directory,$file);
  
      if ( $nofile ) {
          ( $volume, $directory ) = $path =~ m|^((?:[^:]+:)?)(.*)|s;
      }
      else {
          $path =~
              m|^( (?: [^:]+: )? )
                 ( (?: .*: )? )
                 ( .* )
               |xs;
          $volume    = $1;
          $directory = $2;
          $file      = $3;
      }
  
      $volume = '' unless defined($volume);
  	$directory = ":$directory" if ( $volume && $directory ); # take care of "HD::dir"
      if ($directory) {
          # Make sure non-empty directories begin and end in ':'
          $directory .= ':' unless (substr($directory,-1) eq ':');
          $directory = ":$directory" unless (substr($directory,0,1) eq ':');
      } else {
  	$directory = '';
      }
      $file = '' unless defined($file);
  
      return ($volume,$directory,$file);
  }
  
  
  =item splitdir
  
  The opposite of C<catdir()>.
  
      @dirs = File::Spec->splitdir( $directories );
  
  $directories should be only the directory portion of the path on systems
  that have the concept of a volume or that have path syntax that differentiates
  files from directories. Consider using C<splitpath()> otherwise.
  
  Unlike just splitting the directories on the separator, empty directory names
  (C<"">) can be returned. Since C<catdir()> on Mac OS always appends a trailing
  colon to distinguish a directory path from a file path, a single trailing colon
  will be ignored, i.e. there's no empty directory name after it.
  
  Hence, on Mac OS, both
  
      File::Spec->splitdir( ":a:b::c:" );    and
      File::Spec->splitdir( ":a:b::c" );
  
  yield:
  
      ( "a", "b", "::", "c")
  
  while
  
      File::Spec->splitdir( ":a:b::c::" );
  
  yields:
  
      ( "a", "b", "::", "c", "::")
  
  
  =cut
  
  sub splitdir {
  	my ($self, $path) = @_;
  	my @result = ();
  	my ($head, $sep, $tail, $volume, $directories);
  
  	return @result if ( (!defined($path)) || ($path eq '') );
  	return (':') if ($path eq ':');
  
  	( $volume, $sep, $directories ) = $path =~ m|^((?:[^:]+:)?)(:*)(.*)|s;
  
  	# deprecated, but handle it correctly
  	if ($volume) {
  		push (@result, $volume);
  		$sep .= ':';
  	}
  
  	while ($sep || $directories) {
  		if (length($sep) > 1) {
  			my $updir_count = length($sep) - 1;
  			for (my $i=0; $i<$updir_count; $i++) {
  				# push '::' updir_count times;
  				# simulate Unix '..' updirs
  				push (@result, '::');
  			}
  		}
  		$sep = '';
  		if ($directories) {
  			( $head, $sep, $tail ) = $directories =~ m|^((?:[^:]+)?)(:*)(.*)|s;
  			push (@result, $head);
  			$directories = $tail;
  		}
  	}
  	return @result;
  }
  
  
  =item catpath
  
      $path = File::Spec->catpath($volume,$directory,$file);
  
  Takes volume, directory and file portions and returns an entire path. On Mac OS,
  $volume, $directory and $file are concatenated.  A ':' is inserted if need be. You
  may pass an empty string for each portion. If all portions are empty, the empty
  string is returned. If $volume is empty, the result will be a relative path,
  beginning with a ':'. If $volume and $directory are empty, a leading ":" (if any)
  is removed form $file and the remainder is returned. If $file is empty, the
  resulting path will have a trailing ':'.
  
  
  =cut
  
  sub catpath {
      my ($self,$volume,$directory,$file) = @_;
  
      if ( (! $volume) && (! $directory) ) {
  	$file =~ s/^:// if $file;
  	return $file ;
      }
  
      # We look for a volume in $volume, then in $directory, but not both
  
      my ($dir_volume, $dir_dirs) = $self->splitpath($directory, 1);
  
      $volume = $dir_volume unless length $volume;
      my $path = $volume; # may be ''
      $path .= ':' unless (substr($path, -1) eq ':'); # ensure trailing ':'
  
      if ($directory) {
  	$directory = $dir_dirs if $volume;
  	$directory =~ s/^://; # remove leading ':' if any
  	$path .= $directory;
  	$path .= ':' unless (substr($path, -1) eq ':'); # ensure trailing ':'
      }
  
      if ($file) {
  	$file =~ s/^://; # remove leading ':' if any
  	$path .= $file;
      }
  
      return $path;
  }
  
  =item abs2rel
  
  Takes a destination path and an optional base path and returns a relative path
  from the base path to the destination path:
  
      $rel_path = File::Spec->abs2rel( $path ) ;
      $rel_path = File::Spec->abs2rel( $path, $base ) ;
  
  Note that both paths are assumed to have a notation that distinguishes a
  directory path (with trailing ':') from a file path (without trailing ':').
  
  If $base is not present or '', then the current working directory is used.
  If $base is relative, then it is converted to absolute form using C<rel2abs()>.
  This means that it is taken to be relative to the current working directory.
  
  If $path and $base appear to be on two different volumes, we will not
  attempt to resolve the two paths, and we will instead simply return
  $path.  Note that previous versions of this module ignored the volume
  of $base, which resulted in garbage results part of the time.
  
  If $base doesn't have a trailing colon, the last element of $base is
  assumed to be a filename.  This filename is ignored.  Otherwise all path
  components are assumed to be directories.
  
  If $path is relative, it is converted to absolute form using C<rel2abs()>.
  This means that it is taken to be relative to the current working directory.
  
  Based on code written by Shigio Yamaguchi.
  
  
  =cut
  
  # maybe this should be done in canonpath() ?
  sub _resolve_updirs {
  	my $path = shift @_;
  	my $proceed;
  
  	# resolve any updirs, e.g. "HD:tmp::file" -> "HD:file"
  	do {
  		$proceed = ($path =~ s/^(.*):[^:]+::(.*?)\z/$1:$2/);
  	} while ($proceed);
  
  	return $path;
  }
  
  
  sub abs2rel {
      my($self,$path,$base) = @_;
  
      # Clean up $path
      if ( ! $self->file_name_is_absolute( $path ) ) {
          $path = $self->rel2abs( $path ) ;
      }
  
      # Figure out the effective $base and clean it up.
      if ( !defined( $base ) || $base eq '' ) {
  	$base = $self->_cwd();
      }
      elsif ( ! $self->file_name_is_absolute( $base ) ) {
          $base = $self->rel2abs( $base ) ;
  	$base = _resolve_updirs( $base ); # resolve updirs in $base
      }
      else {
  	$base = _resolve_updirs( $base );
      }
  
      # Split up paths - ignore $base's file
      my ( $path_vol, $path_dirs, $path_file ) =  $self->splitpath( $path );
      my ( $base_vol, $base_dirs )             =  $self->splitpath( $base );
  
      return $path unless lc( $path_vol ) eq lc( $base_vol );
  
      # Now, remove all leading components that are the same
      my @pathchunks = $self->splitdir( $path_dirs );
      my @basechunks = $self->splitdir( $base_dirs );
  	
      while ( @pathchunks &&
  	    @basechunks &&
  	    lc( $pathchunks[0] ) eq lc( $basechunks[0] ) ) {
          shift @pathchunks ;
          shift @basechunks ;
      }
  
      # @pathchunks now has the directories to descend in to.
      # ensure relative path, even if @pathchunks is empty
      $path_dirs = $self->catdir( ':', @pathchunks );
  
      # @basechunks now contains the number of directories to climb out of.
      $base_dirs = (':' x @basechunks) . ':' ;
  
      return $self->catpath( '', $self->catdir( $base_dirs, $path_dirs ), $path_file ) ;
  }
  
  =item rel2abs
  
  Converts a relative path to an absolute path:
  
      $abs_path = File::Spec->rel2abs( $path ) ;
      $abs_path = File::Spec->rel2abs( $path, $base ) ;
  
  Note that both paths are assumed to have a notation that distinguishes a
  directory path (with trailing ':') from a file path (without trailing ':').
  
  If $base is not present or '', then $base is set to the current working
  directory. If $base is relative, then it is converted to absolute form
  using C<rel2abs()>. This means that it is taken to be relative to the
  current working directory.
  
  If $base doesn't have a trailing colon, the last element of $base is
  assumed to be a filename.  This filename is ignored.  Otherwise all path
  components are assumed to be directories.
  
  If $path is already absolute, it is returned and $base is ignored.
  
  Based on code written by Shigio Yamaguchi.
  
  =cut
  
  sub rel2abs {
      my ($self,$path,$base) = @_;
  
      if ( ! $self->file_name_is_absolute($path) ) {
          # Figure out the effective $base and clean it up.
          if ( !defined( $base ) || $base eq '' ) {
  	    $base = $self->_cwd();
          }
          elsif ( ! $self->file_name_is_absolute($base) ) {
              $base = $self->rel2abs($base) ;
          }
  
  	# Split up paths
  
  	# ignore $path's volume
          my ( $path_dirs, $path_file ) = ($self->splitpath($path))[1,2] ;
  
          # ignore $base's file part
  	my ( $base_vol, $base_dirs ) = $self->splitpath($base) ;
  
  	# Glom them together
  	$path_dirs = ':' if ($path_dirs eq '');
  	$base_dirs =~ s/:$//; # remove trailing ':', if any
  	$base_dirs = $base_dirs . $path_dirs;
  
          $path = $self->catpath( $base_vol, $base_dirs, $path_file );
      }
      return $path;
  }
  
  
  =back
  
  =head1 AUTHORS
  
  See the authors list in I<File::Spec>. Mac OS support by Paul Schinder
  <schinder@pobox.com> and Thomas Wegner <wegner_thomas@yahoo.com>.
  
  =head1 COPYRIGHT
  
  Copyright (c) 2004 by the Perl 5 Porters.  All rights reserved.
  
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =head1 SEE ALSO
  
  See L<File::Spec> and L<File::Spec::Unix>.  This package overrides the
  implementation of these methods, not the semantics.
  
  =cut
  
  1;
I686-LINUX-GNU-THREAD-MULTI-64INT_FILE_SPEC_MAC

$fatpacked{"i686-linux-gnu-thread-multi-64int/File/Spec/OS2.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'I686-LINUX-GNU-THREAD-MULTI-64INT_FILE_SPEC_OS2';
  package File::Spec::OS2;
  
  use strict;
  use vars qw(@ISA $VERSION);
  require File::Spec::Unix;
  
  $VERSION = '3.62';
  $VERSION =~ tr/_//d;
  
  @ISA = qw(File::Spec::Unix);
  
  sub devnull {
      return "/dev/nul";
  }
  
  sub case_tolerant {
      return 1;
  }
  
  sub file_name_is_absolute {
      my ($self,$file) = @_;
      return scalar($file =~ m{^([a-z]:)?[\\/]}is);
  }
  
  sub path {
      my $path = $ENV{PATH};
      $path =~ s:\\:/:g;
      my @path = split(';',$path);
      foreach (@path) { $_ = '.' if $_ eq '' }
      return @path;
  }
  
  sub _cwd {
      # In OS/2 the "require Cwd" is unnecessary bloat.
      return Cwd::sys_cwd();
  }
  
  sub tmpdir {
      my $cached = $_[0]->_cached_tmpdir(qw 'TMPDIR TEMP TMP');
      return $cached if defined $cached;
      my @d = @ENV{qw(TMPDIR TEMP TMP)};	# function call could autovivivy
      $_[0]->_cache_tmpdir(
  	$_[0]->_tmpdir( @d, '/tmp', '/' ), qw 'TMPDIR TEMP TMP'
      );
  }
  
  sub catdir {
      my $self = shift;
      my @args = @_;
      foreach (@args) {
  	tr[\\][/];
          # append a backslash to each argument unless it has one there
          $_ .= "/" unless m{/$};
      }
      return $self->canonpath(join('', @args));
  }
  
  sub canonpath {
      my ($self,$path) = @_;
      return unless defined $path;
  
      $path =~ s/^([a-z]:)/\l$1/s;
      $path =~ s|\\|/|g;
      $path =~ s|([^/])/+|$1/|g;                  # xx////xx  -> xx/xx
      $path =~ s|(/\.)+/|/|g;                     # xx/././xx -> xx/xx
      $path =~ s|^(\./)+(?=[^/])||s;		# ./xx      -> xx
      $path =~ s|/\Z(?!\n)||
               unless $path =~ m#^([a-z]:)?/\Z(?!\n)#si;# xx/       -> xx
      $path =~ s{^/\.\.$}{/};                     # /..    -> /
      1 while $path =~ s{^/\.\.}{};               # /../xx -> /xx
      return $path;
  }
  
  
  sub splitpath {
      my ($self,$path, $nofile) = @_;
      my ($volume,$directory,$file) = ('','','');
      if ( $nofile ) {
          $path =~ 
              m{^( (?:[a-zA-Z]:|(?:\\\\|//)[^\\/]+[\\/][^\\/]+)? ) 
                   (.*)
               }xs;
          $volume    = $1;
          $directory = $2;
      }
      else {
          $path =~ 
              m{^ ( (?: [a-zA-Z]: |
                        (?:\\\\|//)[^\\/]+[\\/][^\\/]+
                    )?
                  )
                  ( (?:.*[\\\\/](?:\.\.?\Z(?!\n))?)? )
                  (.*)
               }xs;
          $volume    = $1;
          $directory = $2;
          $file      = $3;
      }
  
      return ($volume,$directory,$file);
  }
  
  
  sub splitdir {
      my ($self,$directories) = @_ ;
      split m|[\\/]|, $directories, -1;
  }
  
  
  sub catpath {
      my ($self,$volume,$directory,$file) = @_;
  
      # If it's UNC, make sure the glue separator is there, reusing
      # whatever separator is first in the $volume
      $volume .= $1
          if ( $volume =~ m@^([\\/])[\\/][^\\/]+[\\/][^\\/]+\Z(?!\n)@s &&
               $directory =~ m@^[^\\/]@s
             ) ;
  
      $volume .= $directory ;
  
      # If the volume is not just A:, make sure the glue separator is 
      # there, reusing whatever separator is first in the $volume if possible.
      if ( $volume !~ m@^[a-zA-Z]:\Z(?!\n)@s &&
           $volume =~ m@[^\\/]\Z(?!\n)@      &&
           $file   =~ m@[^\\/]@
         ) {
          $volume =~ m@([\\/])@ ;
          my $sep = $1 ? $1 : '/' ;
          $volume .= $sep ;
      }
  
      $volume .= $file ;
  
      return $volume ;
  }
  
  
  sub abs2rel {
      my($self,$path,$base) = @_;
  
      # Clean up $path
      if ( ! $self->file_name_is_absolute( $path ) ) {
          $path = $self->rel2abs( $path ) ;
      } else {
          $path = $self->canonpath( $path ) ;
      }
  
      # Figure out the effective $base and clean it up.
      if ( !defined( $base ) || $base eq '' ) {
  	$base = $self->_cwd();
      } elsif ( ! $self->file_name_is_absolute( $base ) ) {
          $base = $self->rel2abs( $base ) ;
      } else {
          $base = $self->canonpath( $base ) ;
      }
  
      # Split up paths
      my ( $path_volume, $path_directories, $path_file ) = $self->splitpath( $path, 1 ) ;
      my ( $base_volume, $base_directories ) = $self->splitpath( $base, 1 ) ;
      return $path unless $path_volume eq $base_volume;
  
      # Now, remove all leading components that are the same
      my @pathchunks = $self->splitdir( $path_directories );
      my @basechunks = $self->splitdir( $base_directories );
  
      while ( @pathchunks && 
              @basechunks && 
              lc( $pathchunks[0] ) eq lc( $basechunks[0] ) 
            ) {
          shift @pathchunks ;
          shift @basechunks ;
      }
  
      # No need to catdir, we know these are well formed.
      $path_directories = CORE::join( '/', @pathchunks );
      $base_directories = CORE::join( '/', @basechunks );
  
      # $base_directories now contains the directories the resulting relative
      # path must ascend out of before it can descend to $path_directory.  So, 
      # replace all names with $parentDir
  
      #FA Need to replace between backslashes...
      $base_directories =~ s|[^\\/]+|..|g ;
  
      # Glue the two together, using a separator if necessary, and preventing an
      # empty result.
  
      #FA Must check that new directories are not empty.
      if ( $path_directories ne '' && $base_directories ne '' ) {
          $path_directories = "$base_directories/$path_directories" ;
      } else {
          $path_directories = "$base_directories$path_directories" ;
      }
  
      return $self->canonpath( 
          $self->catpath( "", $path_directories, $path_file ) 
      ) ;
  }
  
  
  sub rel2abs {
      my ($self,$path,$base ) = @_;
  
      if ( ! $self->file_name_is_absolute( $path ) ) {
  
          if ( !defined( $base ) || $base eq '' ) {
  	    $base = $self->_cwd();
          }
          elsif ( ! $self->file_name_is_absolute( $base ) ) {
              $base = $self->rel2abs( $base ) ;
          }
          else {
              $base = $self->canonpath( $base ) ;
          }
  
          my ( $path_directories, $path_file ) =
              ($self->splitpath( $path, 1 ))[1,2] ;
  
          my ( $base_volume, $base_directories ) =
              $self->splitpath( $base, 1 ) ;
  
          $path = $self->catpath( 
              $base_volume, 
              $self->catdir( $base_directories, $path_directories ), 
              $path_file
          ) ;
      }
  
      return $self->canonpath( $path ) ;
  }
  
  1;
  __END__
  
  =head1 NAME
  
  File::Spec::OS2 - methods for OS/2 file specs
  
  =head1 SYNOPSIS
  
   require File::Spec::OS2; # Done internally by File::Spec if needed
  
  =head1 DESCRIPTION
  
  See L<File::Spec> and L<File::Spec::Unix>.  This package overrides the
  implementation of these methods, not the semantics.
  
  Amongst the changes made for OS/2 are...
  
  =over 4
  
  =item tmpdir
  
  Modifies the list of places temp directory information is looked for.
  
      $ENV{TMPDIR}
      $ENV{TEMP}
      $ENV{TMP}
      /tmp
      /
  
  =item splitpath
  
  Volumes can be drive letters or UNC sharenames (\\server\share).
  
  =back
  
  =head1 COPYRIGHT
  
  Copyright (c) 2004 by the Perl 5 Porters.  All rights reserved.
  
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =cut
I686-LINUX-GNU-THREAD-MULTI-64INT_FILE_SPEC_OS2

$fatpacked{"i686-linux-gnu-thread-multi-64int/File/Spec/Unix.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'I686-LINUX-GNU-THREAD-MULTI-64INT_FILE_SPEC_UNIX';
  package File::Spec::Unix;
  
  use strict;
  use vars qw($VERSION);
  
  $VERSION = '3.62';
  my $xs_version = $VERSION;
  $VERSION =~ tr/_//d;
  
  #dont try to load XSLoader and DynaLoader only to ultimately fail on miniperl
  if(!defined &canonpath && defined &DynaLoader::boot_DynaLoader) {
    eval {#eval is questionable since we are handling potential errors like
          #"Cwd object version 3.48 does not match bootstrap parameter 3.50
          #at lib/DynaLoader.pm line 216." by having this eval
      if ( $] >= 5.006 ) {
  	require XSLoader;
  	XSLoader::load("Cwd", $xs_version);
      } else {
  	require Cwd;
      }
    };
  }
  
  =head1 NAME
  
  File::Spec::Unix - File::Spec for Unix, base for other File::Spec modules
  
  =head1 SYNOPSIS
  
   require File::Spec::Unix; # Done automatically by File::Spec
  
  =head1 DESCRIPTION
  
  Methods for manipulating file specifications.  Other File::Spec
  modules, such as File::Spec::Mac, inherit from File::Spec::Unix and
  override specific methods.
  
  =head1 METHODS
  
  =over 2
  
  =item canonpath()
  
  No physical check on the filesystem, but a logical cleanup of a
  path. On UNIX eliminates successive slashes and successive "/.".
  
      $cpath = File::Spec->canonpath( $path ) ;
  
  Note that this does *not* collapse F<x/../y> sections into F<y>.  This
  is by design.  If F</foo> on your system is a symlink to F</bar/baz>,
  then F</foo/../quux> is actually F</bar/quux>, not F</quux> as a naive
  F<../>-removal would give you.  If you want to do this kind of
  processing, you probably want C<Cwd>'s C<realpath()> function to
  actually traverse the filesystem cleaning up paths like this.
  
  =cut
  
  sub _pp_canonpath {
      my ($self,$path) = @_;
      return unless defined $path;
      
      # Handle POSIX-style node names beginning with double slash (qnx, nto)
      # (POSIX says: "a pathname that begins with two successive slashes
      # may be interpreted in an implementation-defined manner, although
      # more than two leading slashes shall be treated as a single slash.")
      my $node = '';
      my $double_slashes_special = $^O eq 'qnx' || $^O eq 'nto';
  
  
      if ( $double_slashes_special
           && ( $path =~ s{^(//[^/]+)/?\z}{}s || $path =~ s{^(//[^/]+)/}{/}s ) ) {
        $node = $1;
      }
      # This used to be
      # $path =~ s|/+|/|g unless ($^O eq 'cygwin');
      # but that made tests 29, 30, 35, 46, and 213 (as of #13272) to fail
      # (Mainly because trailing "" directories didn't get stripped).
      # Why would cygwin avoid collapsing multiple slashes into one? --jhi
      $path =~ s|/{2,}|/|g;                            # xx////xx  -> xx/xx
      $path =~ s{(?:/\.)+(?:/|\z)}{/}g;                # xx/././xx -> xx/xx
      $path =~ s|^(?:\./)+||s unless $path eq "./";    # ./xx      -> xx
      $path =~ s|^/(?:\.\./)+|/|;                      # /../../xx -> xx
      $path =~ s|^/\.\.$|/|;                         # /..       -> /
      $path =~ s|/\z|| unless $path eq "/";          # xx/       -> xx
      return "$node$path";
  }
  *canonpath = \&_pp_canonpath unless defined &canonpath;
  
  =item catdir()
  
  Concatenate two or more directory names to form a complete path ending
  with a directory. But remove the trailing slash from the resulting
  string, because it doesn't look good, isn't necessary and confuses
  OS2. Of course, if this is the root directory, don't cut off the
  trailing slash :-)
  
  =cut
  
  sub _pp_catdir {
      my $self = shift;
  
      $self->canonpath(join('/', @_, '')); # '' because need a trailing '/'
  }
  *catdir = \&_pp_catdir unless defined &catdir;
  
  =item catfile
  
  Concatenate one or more directory names and a filename to form a
  complete path ending with a filename
  
  =cut
  
  sub _pp_catfile {
      my $self = shift;
      my $file = $self->canonpath(pop @_);
      return $file unless @_;
      my $dir = $self->catdir(@_);
      $dir .= "/" unless substr($dir,-1) eq "/";
      return $dir.$file;
  }
  *catfile = \&_pp_catfile unless defined &catfile;
  
  =item curdir
  
  Returns a string representation of the current directory.  "." on UNIX.
  
  =cut
  
  sub curdir { '.' }
  use constant _fn_curdir => ".";
  
  =item devnull
  
  Returns a string representation of the null device. "/dev/null" on UNIX.
  
  =cut
  
  sub devnull { '/dev/null' }
  use constant _fn_devnull => "/dev/null";
  
  =item rootdir
  
  Returns a string representation of the root directory.  "/" on UNIX.
  
  =cut
  
  sub rootdir { '/' }
  use constant _fn_rootdir => "/";
  
  =item tmpdir
  
  Returns a string representation of the first writable directory from
  the following list or the current directory if none from the list are
  writable:
  
      $ENV{TMPDIR}
      /tmp
  
  If running under taint mode, and if $ENV{TMPDIR}
  is tainted, it is not used.
  
  =cut
  
  my ($tmpdir, %tmpenv);
  # Cache and return the calculated tmpdir, recording which env vars
  # determined it.
  sub _cache_tmpdir {
      @tmpenv{@_[2..$#_]} = @ENV{@_[2..$#_]};
      return $tmpdir = $_[1];
  }
  # Retrieve the cached tmpdir, checking first whether relevant env vars have
  # changed and invalidated the cache.
  sub _cached_tmpdir {
      shift;
      local $^W;
      return if grep $ENV{$_} ne $tmpenv{$_}, @_;
      return $tmpdir;
  }
  sub _tmpdir {
      my $self = shift;
      my @dirlist = @_;
      my $taint = do { no strict 'refs'; ${"\cTAINT"} };
      if ($taint) { # Check for taint mode on perl >= 5.8.0
  	require Scalar::Util;
  	@dirlist = grep { ! Scalar::Util::tainted($_) } @dirlist;
      }
      elsif ($] < 5.007) { # No ${^TAINT} before 5.8
  	@dirlist = grep { eval { eval('1'.substr $_,0,0) } } @dirlist;
      }
      
      foreach (@dirlist) {
  	next unless defined && -d && -w _;
  	$tmpdir = $_;
  	last;
      }
      $tmpdir = $self->curdir unless defined $tmpdir;
      $tmpdir = defined $tmpdir && $self->canonpath($tmpdir);
      if ( !$self->file_name_is_absolute($tmpdir) ) {
          # See [perl #120593] for the full details
          # If possible, return a full path, rather than '.' or 'lib', but
          # jump through some hoops to avoid returning a tainted value.
          ($tmpdir) = grep {
              $taint     ? ! Scalar::Util::tainted($_) :
              $] < 5.007 ? eval { eval('1'.substr $_,0,0) } : 1
          } $self->rel2abs($tmpdir), $tmpdir;
      }
      return $tmpdir;
  }
  
  sub tmpdir {
      my $cached = $_[0]->_cached_tmpdir('TMPDIR');
      return $cached if defined $cached;
      $_[0]->_cache_tmpdir($_[0]->_tmpdir( $ENV{TMPDIR}, "/tmp" ), 'TMPDIR');
  }
  
  =item updir
  
  Returns a string representation of the parent directory.  ".." on UNIX.
  
  =cut
  
  sub updir { '..' }
  use constant _fn_updir => "..";
  
  =item no_upwards
  
  Given a list of file names, strip out those that refer to a parent
  directory. (Does not strip symlinks, only '.', '..', and equivalents.)
  
  =cut
  
  sub no_upwards {
      my $self = shift;
      return grep(!/^\.{1,2}\z/s, @_);
  }
  
  =item case_tolerant
  
  Returns a true or false value indicating, respectively, that alphabetic
  is not or is significant when comparing file specifications.
  
  =cut
  
  sub case_tolerant { 0 }
  use constant _fn_case_tolerant => 0;
  
  =item file_name_is_absolute
  
  Takes as argument a path and returns true if it is an absolute path.
  
  This does not consult the local filesystem on Unix, Win32, OS/2 or Mac 
  OS (Classic).  It does consult the working environment for VMS (see
  L<File::Spec::VMS/file_name_is_absolute>).
  
  =cut
  
  sub file_name_is_absolute {
      my ($self,$file) = @_;
      return scalar($file =~ m:^/:s);
  }
  
  =item path
  
  Takes no argument, returns the environment variable PATH as an array.
  
  =cut
  
  sub path {
      return () unless exists $ENV{PATH};
      my @path = split(':', $ENV{PATH});
      foreach (@path) { $_ = '.' if $_ eq '' }
      return @path;
  }
  
  =item join
  
  join is the same as catfile.
  
  =cut
  
  sub join {
      my $self = shift;
      return $self->catfile(@_);
  }
  
  =item splitpath
  
      ($volume,$directories,$file) = File::Spec->splitpath( $path );
      ($volume,$directories,$file) = File::Spec->splitpath( $path,
                                                            $no_file );
  
  Splits a path into volume, directory, and filename portions. On systems
  with no concept of volume, returns '' for volume. 
  
  For systems with no syntax differentiating filenames from directories, 
  assumes that the last file is a path unless $no_file is true or a 
  trailing separator or /. or /.. is present. On Unix this means that $no_file
  true makes this return ( '', $path, '' ).
  
  The directory portion may or may not be returned with a trailing '/'.
  
  The results can be passed to L</catpath()> to get back a path equivalent to
  (usually identical to) the original path.
  
  =cut
  
  sub splitpath {
      my ($self,$path, $nofile) = @_;
  
      my ($volume,$directory,$file) = ('','','');
  
      if ( $nofile ) {
          $directory = $path;
      }
      else {
          $path =~ m|^ ( (?: .* / (?: \.\.?\z )? )? ) ([^/]*) |xs;
          $directory = $1;
          $file      = $2;
      }
  
      return ($volume,$directory,$file);
  }
  
  
  =item splitdir
  
  The opposite of L</catdir()>.
  
      @dirs = File::Spec->splitdir( $directories );
  
  $directories must be only the directory portion of the path on systems 
  that have the concept of a volume or that have path syntax that differentiates
  files from directories.
  
  Unlike just splitting the directories on the separator, empty
  directory names (C<''>) can be returned, because these are significant
  on some OSs.
  
  On Unix,
  
      File::Spec->splitdir( "/a/b//c/" );
  
  Yields:
  
      ( '', 'a', 'b', '', 'c', '' )
  
  =cut
  
  sub splitdir {
      return split m|/|, $_[1], -1;  # Preserve trailing fields
  }
  
  
  =item catpath()
  
  Takes volume, directory and file portions and returns an entire path. Under
  Unix, $volume is ignored, and directory and file are concatenated.  A '/' is
  inserted if needed (though if the directory portion doesn't start with
  '/' it is not added).  On other OSs, $volume is significant.
  
  =cut
  
  sub catpath {
      my ($self,$volume,$directory,$file) = @_;
  
      if ( $directory ne ''                && 
           $file ne ''                     && 
           substr( $directory, -1 ) ne '/' && 
           substr( $file, 0, 1 ) ne '/' 
      ) {
          $directory .= "/$file" ;
      }
      else {
          $directory .= $file ;
      }
  
      return $directory ;
  }
  
  =item abs2rel
  
  Takes a destination path and an optional base path returns a relative path
  from the base path to the destination path:
  
      $rel_path = File::Spec->abs2rel( $path ) ;
      $rel_path = File::Spec->abs2rel( $path, $base ) ;
  
  If $base is not present or '', then L<cwd()|Cwd> is used. If $base is
  relative, then it is converted to absolute form using
  L</rel2abs()>. This means that it is taken to be relative to
  L<cwd()|Cwd>.
  
  On systems that have a grammar that indicates filenames, this ignores the 
  $base filename. Otherwise all path components are assumed to be
  directories.
  
  If $path is relative, it is converted to absolute form using L</rel2abs()>.
  This means that it is taken to be relative to L<cwd()|Cwd>.
  
  No checks against the filesystem are made, so the result may not be correct if
  C<$base> contains symbolic links.  (Apply
  L<Cwd::abs_path()|Cwd/abs_path> beforehand if that
  is a concern.)  On VMS, there is interaction with the working environment, as
  logicals and macros are expanded.
  
  Based on code written by Shigio Yamaguchi.
  
  =cut
  
  sub abs2rel {
      my($self,$path,$base) = @_;
      $base = $self->_cwd() unless defined $base and length $base;
  
      ($path, $base) = map $self->canonpath($_), $path, $base;
  
      my $path_directories;
      my $base_directories;
  
      if (grep $self->file_name_is_absolute($_), $path, $base) {
  	($path, $base) = map $self->rel2abs($_), $path, $base;
  
  	my ($path_volume) = $self->splitpath($path, 1);
  	my ($base_volume) = $self->splitpath($base, 1);
  
  	# Can't relativize across volumes
  	return $path unless $path_volume eq $base_volume;
  
  	$path_directories = ($self->splitpath($path, 1))[1];
  	$base_directories = ($self->splitpath($base, 1))[1];
  
  	# For UNC paths, the user might give a volume like //foo/bar that
  	# strictly speaking has no directory portion.  Treat it as if it
  	# had the root directory for that volume.
  	if (!length($base_directories) and $self->file_name_is_absolute($base)) {
  	    $base_directories = $self->rootdir;
  	}
      }
      else {
  	my $wd= ($self->splitpath($self->_cwd(), 1))[1];
  	$path_directories = $self->catdir($wd, $path);
  	$base_directories = $self->catdir($wd, $base);
      }
  
      # Now, remove all leading components that are the same
      my @pathchunks = $self->splitdir( $path_directories );
      my @basechunks = $self->splitdir( $base_directories );
  
      if ($base_directories eq $self->rootdir) {
        return $self->curdir if $path_directories eq $self->rootdir;
        shift @pathchunks;
        return $self->canonpath( $self->catpath('', $self->catdir( @pathchunks ), '') );
      }
  
      my @common;
      while (@pathchunks && @basechunks && $self->_same($pathchunks[0], $basechunks[0])) {
          push @common, shift @pathchunks ;
          shift @basechunks ;
      }
      return $self->curdir unless @pathchunks || @basechunks;
  
      # @basechunks now contains the directories the resulting relative path 
      # must ascend out of before it can descend to $path_directory.  If there
      # are updir components, we must descend into the corresponding directories
      # (this only works if they are no symlinks).
      my @reverse_base;
      while( defined(my $dir= shift @basechunks) ) {
  	if( $dir ne $self->updir ) {
  	    unshift @reverse_base, $self->updir;
  	    push @common, $dir;
  	}
  	elsif( @common ) {
  	    if( @reverse_base && $reverse_base[0] eq $self->updir ) {
  		shift @reverse_base;
  		pop @common;
  	    }
  	    else {
  		unshift @reverse_base, pop @common;
  	    }
  	}
      }
      my $result_dirs = $self->catdir( @reverse_base, @pathchunks );
      return $self->canonpath( $self->catpath('', $result_dirs, '') );
  }
  
  sub _same {
    $_[1] eq $_[2];
  }
  
  =item rel2abs()
  
  Converts a relative path to an absolute path. 
  
      $abs_path = File::Spec->rel2abs( $path ) ;
      $abs_path = File::Spec->rel2abs( $path, $base ) ;
  
  If $base is not present or '', then L<cwd()|Cwd> is used. If $base is
  relative, then it is converted to absolute form using
  L</rel2abs()>. This means that it is taken to be relative to
  L<cwd()|Cwd>.
  
  On systems that have a grammar that indicates filenames, this ignores
  the $base filename. Otherwise all path components are assumed to be
  directories.
  
  If $path is absolute, it is cleaned up and returned using L</canonpath()>.
  
  No checks against the filesystem are made.  On VMS, there is
  interaction with the working environment, as logicals and
  macros are expanded.
  
  Based on code written by Shigio Yamaguchi.
  
  =cut
  
  sub rel2abs {
      my ($self,$path,$base ) = @_;
  
      # Clean up $path
      if ( ! $self->file_name_is_absolute( $path ) ) {
          # Figure out the effective $base and clean it up.
          if ( !defined( $base ) || $base eq '' ) {
  	    $base = $self->_cwd();
          }
          elsif ( ! $self->file_name_is_absolute( $base ) ) {
              $base = $self->rel2abs( $base ) ;
          }
          else {
              $base = $self->canonpath( $base ) ;
          }
  
          # Glom them together
          $path = $self->catdir( $base, $path ) ;
      }
  
      return $self->canonpath( $path ) ;
  }
  
  =back
  
  =head1 COPYRIGHT
  
  Copyright (c) 2004 by the Perl 5 Porters.  All rights reserved.
  
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  Please submit bug reports and patches to perlbug@perl.org.
  
  =head1 SEE ALSO
  
  L<File::Spec>
  
  =cut
  
  # Internal routine to File::Spec, no point in making this public since
  # it is the standard Cwd interface.  Most of the platform-specific
  # File::Spec subclasses use this.
  sub _cwd {
      require Cwd;
      Cwd::getcwd();
  }
  
  
  # Internal method to reduce xx\..\yy -> yy
  sub _collapse {
      my($fs, $path) = @_;
  
      my $updir  = $fs->updir;
      my $curdir = $fs->curdir;
  
      my($vol, $dirs, $file) = $fs->splitpath($path);
      my @dirs = $fs->splitdir($dirs);
      pop @dirs if @dirs && $dirs[-1] eq '';
  
      my @collapsed;
      foreach my $dir (@dirs) {
          if( $dir eq $updir              and   # if we have an updir
              @collapsed                  and   # and something to collapse
              length $collapsed[-1]       and   # and its not the rootdir
              $collapsed[-1] ne $updir    and   # nor another updir
              $collapsed[-1] ne $curdir         # nor the curdir
            ) 
          {                                     # then
              pop @collapsed;                   # collapse
          }
          else {                                # else
              push @collapsed, $dir;            # just hang onto it
          }
      }
  
      return $fs->catpath($vol,
                          $fs->catdir(@collapsed),
                          $file
                         );
  }
  
  
  1;
I686-LINUX-GNU-THREAD-MULTI-64INT_FILE_SPEC_UNIX

$fatpacked{"i686-linux-gnu-thread-multi-64int/File/Spec/VMS.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'I686-LINUX-GNU-THREAD-MULTI-64INT_FILE_SPEC_VMS';
  package File::Spec::VMS;
  
  use strict;
  use vars qw(@ISA $VERSION);
  require File::Spec::Unix;
  
  $VERSION = '3.62';
  $VERSION =~ tr/_//d;
  
  @ISA = qw(File::Spec::Unix);
  
  use File::Basename;
  use VMS::Filespec;
  
  =head1 NAME
  
  File::Spec::VMS - methods for VMS file specs
  
  =head1 SYNOPSIS
  
   require File::Spec::VMS; # Done internally by File::Spec if needed
  
  =head1 DESCRIPTION
  
  See File::Spec::Unix for a documentation of the methods provided
  there. This package overrides the implementation of these methods, not
  the semantics.
  
  The default behavior is to allow either VMS or Unix syntax on input and to 
  return VMS syntax on output unless Unix syntax has been explicitly requested
  via the C<DECC$FILENAME_UNIX_REPORT> CRTL feature.
  
  =over 4
  
  =cut
  
  # Need to look up the feature settings.  The preferred way is to use the
  # VMS::Feature module, but that may not be available to dual life modules.
  
  my $use_feature;
  BEGIN {
      if (eval { local $SIG{__DIE__}; require VMS::Feature; }) {
          $use_feature = 1;
      }
  }
  
  # Need to look up the UNIX report mode.  This may become a dynamic mode
  # in the future.
  sub _unix_rpt {
      my $unix_rpt;
      if ($use_feature) {
          $unix_rpt = VMS::Feature::current("filename_unix_report");
      } else {
          my $env_unix_rpt = $ENV{'DECC$FILENAME_UNIX_REPORT'} || '';
          $unix_rpt = $env_unix_rpt =~ /^[ET1]/i; 
      }
      return $unix_rpt;
  }
  
  =item canonpath (override)
  
  Removes redundant portions of file specifications and returns results
  in native syntax unless Unix filename reporting has been enabled.
  
  =cut
  
  
  sub canonpath {
      my($self,$path) = @_;
  
      return undef unless defined $path;
  
      my $unix_rpt = $self->_unix_rpt;
  
      if ($path =~ m|/|) {
        my $pathify = $path =~ m|/\Z(?!\n)|;
        $path = $self->SUPER::canonpath($path);
  
        return $path if $unix_rpt;
        $path = $pathify ? vmspath($path) : vmsify($path);
      }
  
      $path =~ s/(?<!\^)</[/;			# < and >       ==> [ and ]
      $path =~ s/(?<!\^)>/]/;
      $path =~ s/(?<!\^)\]\[\./\.\]\[/g;		# ][.		==> .][
      $path =~ s/(?<!\^)\[000000\.\]\[/\[/g;	# [000000.][	==> [
      $path =~ s/(?<!\^)\[000000\./\[/g;		# [000000.	==> [
      $path =~ s/(?<!\^)\.\]\[000000\]/\]/g;	# .][000000]	==> ]
      $path =~ s/(?<!\^)\.\]\[/\./g;		# foo.][bar     ==> foo.bar
      1 while ($path =~ s/(?<!\^)([\[\.])(-+)\.(-+)([\.\]])/$1$2$3$4/);
  						# That loop does the following
  						# with any amount of dashes:
  						# .-.-.		==> .--.
  						# [-.-.		==> [--.
  						# .-.-]		==> .--]
  						# [-.-]		==> [--]
      1 while ($path =~ s/(?<!\^)([\[\.])[^\]\.]+\.-(-+)([\]\.])/$1$2$3/);
  						# That loop does the following
  						# with any amount (minimum 2)
  						# of dashes:
  						# .foo.--.	==> .-.
  						# .foo.--]	==> .-]
  						# [foo.--.	==> [-.
  						# [foo.--]	==> [-]
  						#
  						# And then, the remaining cases
      $path =~ s/(?<!\^)\[\.-/[-/;		# [.-		==> [-
      $path =~ s/(?<!\^)\.[^\]\.]+\.-\./\./g;	# .foo.-.	==> .
      $path =~ s/(?<!\^)\[[^\]\.]+\.-\./\[/g;	# [foo.-.	==> [
      $path =~ s/(?<!\^)\.[^\]\.]+\.-\]/\]/g;	# .foo.-]	==> ]
  						# [foo.-]       ==> [000000]
      $path =~ s/(?<!\^)\[[^\]\.]+\.-\]/\[000000\]/g;
  						# []		==>
      $path =~ s/(?<!\^)\[\]// unless $path eq '[]';
      return $unix_rpt ? unixify($path) : $path;
  }
  
  =item catdir (override)
  
  Concatenates a list of file specifications, and returns the result as a
  native directory specification unless the Unix filename reporting feature
  has been enabled.  No check is made for "impossible" cases (e.g. elements
  other than the first being absolute filespecs).
  
  =cut
  
  sub catdir {
      my $self = shift;
      my $dir = pop;
  
      my $unix_rpt = $self->_unix_rpt;
  
      my @dirs = grep {defined() && length()} @_;
  
      my $rslt;
      if (@dirs) {
  	my $path = (@dirs == 1 ? $dirs[0] : $self->catdir(@dirs));
  	my ($spath,$sdir) = ($path,$dir);
  	$spath =~ s/\.dir\Z(?!\n)//i; $sdir =~ s/\.dir\Z(?!\n)//i; 
  
  	if ($unix_rpt) {
  	    $spath = unixify($spath) unless $spath =~ m#/#;
  	    $sdir= unixify($sdir) unless $sdir =~ m#/#;
              return $self->SUPER::catdir($spath, $sdir)
  	}
  
  	$rslt = vmspath( unixify($spath) . '/' . unixify($sdir));
  
  	# Special case for VMS absolute directory specs: these will have
  	# had device prepended during trip through Unix syntax in
  	# eliminate_macros(), since Unix syntax has no way to express
  	# "absolute from the top of this device's directory tree".
  	if ($spath =~ /^[\[<][^.\-]/s) { $rslt =~ s/^[^\[<]+//s; }
  
      } else {
  	# Single directory. Return an empty string on null input; otherwise
  	# just return a canonical path.
  
  	if    (not defined $dir or not length $dir) {
  	    $rslt = '';
  	} else {
  	    $rslt = $unix_rpt ? $dir : vmspath($dir);
  	}
      }
      return $self->canonpath($rslt);
  }
  
  =item catfile (override)
  
  Concatenates a list of directory specifications with a filename specification
  to build a path.
  
  =cut
  
  sub catfile {
      my $self = shift;
      my $tfile = pop();
      my $file = $self->canonpath($tfile);
      my @files = grep {defined() && length()} @_;
  
      my $unix_rpt = $self->_unix_rpt;
  
      my $rslt;
      if (@files) {
  	my $path = (@files == 1 ? $files[0] : $self->catdir(@files));
  	my $spath = $path;
  
          # Something building a VMS path in pieces may try to pass a
          # directory name in filename format, so normalize it.
  	$spath =~ s/\.dir\Z(?!\n)//i;
  
          # If the spath ends with a directory delimiter and the file is bare,
          # then just concatenate them.
  	if ($spath =~ /^(?<!\^)[^\)\]\/:>]+\)\Z(?!\n)/s && basename($file) eq $file) {
  	    $rslt = "$spath$file";
  	} else {
             $rslt = unixify($spath);
             $rslt .= (defined($rslt) && length($rslt) ? '/' : '') . unixify($file);
             $rslt = vmsify($rslt) unless $unix_rpt;
  	}
      }
      else {
          # Only passed a single file?
          my $xfile = (defined($file) && length($file)) ? $file : '';
  
          $rslt = $unix_rpt ? $xfile : vmsify($xfile);
      }
      return $self->canonpath($rslt) unless $unix_rpt;
  
      # In Unix report mode, do not strip off redundant path information.
      return $rslt;
  }
  
  
  =item curdir (override)
  
  Returns a string representation of the current directory: '[]' or '.'
  
  =cut
  
  sub curdir {
      my $self = shift @_;
      return '.' if ($self->_unix_rpt);
      return '[]';
  }
  
  =item devnull (override)
  
  Returns a string representation of the null device: '_NLA0:' or '/dev/null'
  
  =cut
  
  sub devnull {
      my $self = shift @_;
      return '/dev/null' if ($self->_unix_rpt);
      return "_NLA0:";
  }
  
  =item rootdir (override)
  
  Returns a string representation of the root directory: 'SYS$DISK:[000000]'
  or '/'
  
  =cut
  
  sub rootdir {
      my $self = shift @_;
      if ($self->_unix_rpt) {
         # Root may exist, try it first.
         my $try = '/';
         my ($dev1, $ino1) = stat('/');
         my ($dev2, $ino2) = stat('.');
  
         # Perl falls back to '.' if it can not determine '/'
         if (($dev1 != $dev2) || ($ino1 != $ino2)) {
             return $try;
         }
         # Fall back to UNIX format sys$disk.
         return '/sys$disk/';
      }
      return 'SYS$DISK:[000000]';
  }
  
  =item tmpdir (override)
  
  Returns a string representation of the first writable directory
  from the following list or '' if none are writable:
  
      /tmp if C<DECC$FILENAME_UNIX_REPORT> is enabled.
      sys$scratch:
      $ENV{TMPDIR}
  
  If running under taint mode, and if $ENV{TMPDIR}
  is tainted, it is not used.
  
  =cut
  
  sub tmpdir {
      my $self = shift @_;
      my $tmpdir = $self->_cached_tmpdir('TMPDIR');
      return $tmpdir if defined $tmpdir;
      if ($self->_unix_rpt) {
          $tmpdir = $self->_tmpdir('/tmp', '/sys$scratch', $ENV{TMPDIR});
      }
      else {
          $tmpdir = $self->_tmpdir( 'sys$scratch:', $ENV{TMPDIR} );
      }
      $self->_cache_tmpdir($tmpdir, 'TMPDIR');
  }
  
  =item updir (override)
  
  Returns a string representation of the parent directory: '[-]' or '..'
  
  =cut
  
  sub updir {
      my $self = shift @_;
      return '..' if ($self->_unix_rpt);
      return '[-]';
  }
  
  =item case_tolerant (override)
  
  VMS file specification syntax is case-tolerant.
  
  =cut
  
  sub case_tolerant {
      return 1;
  }
  
  =item path (override)
  
  Translate logical name DCL$PATH as a searchlist, rather than trying
  to C<split> string value of C<$ENV{'PATH'}>.
  
  =cut
  
  sub path {
      my (@dirs,$dir,$i);
      while ($dir = $ENV{'DCL$PATH;' . $i++}) { push(@dirs,$dir); }
      return @dirs;
  }
  
  =item file_name_is_absolute (override)
  
  Checks for VMS directory spec as well as Unix separators.
  
  =cut
  
  sub file_name_is_absolute {
      my ($self,$file) = @_;
      # If it's a logical name, expand it.
      $file = $ENV{$file} while $file =~ /^[\w\$\-]+\Z(?!\n)/s && $ENV{$file};
      return scalar($file =~ m!^/!s             ||
  		  $file =~ m![<\[][^.\-\]>]!  ||
  		  $file =~ /^[A-Za-z0-9_\$\-\~]+(?<!\^):/);
  }
  
  =item splitpath (override)
  
     ($volume,$directories,$file) = File::Spec->splitpath( $path );
     ($volume,$directories,$file) = File::Spec->splitpath( $path,
                                                           $no_file );
  
  Passing a true value for C<$no_file> indicates that the path being
  split only contains directory components, even on systems where you
  can usually (when not supporting a foreign syntax) tell the difference
  between directories and files at a glance.
  
  =cut
  
  sub splitpath {
      my($self,$path, $nofile) = @_;
      my($dev,$dir,$file)      = ('','','');
      my $vmsify_path = vmsify($path);
  
      if ( $nofile ) {
          #vmsify('d1/d2/d3') returns '[.d1.d2]d3'
          #vmsify('/d1/d2/d3') returns 'd1:[d2]d3'
          if( $vmsify_path =~ /(.*)\](.+)/ ){
              $vmsify_path = $1.'.'.$2.']';
          }
          $vmsify_path =~ /(.+:)?(.*)/s;
          $dir = defined $2 ? $2 : ''; # dir can be '0'
          return ($1 || '',$dir,$file);
      }
      else {
          $vmsify_path =~ /(.+:)?([\[<].*[\]>])?(.*)/s;
          return ($1 || '',$2 || '',$3);
      }
  }
  
  =item splitdir (override)
  
  Split a directory specification into the components.
  
  =cut
  
  sub splitdir {
      my($self,$dirspec) = @_;
      my @dirs = ();
      return @dirs if ( (!defined $dirspec) || ('' eq $dirspec) );
  
      $dirspec =~ s/(?<!\^)</[/;                  # < and >	==> [ and ]
      $dirspec =~ s/(?<!\^)>/]/;
      $dirspec =~ s/(?<!\^)\]\[\./\.\]\[/g;	# ][.		==> .][
      $dirspec =~ s/(?<!\^)\[000000\.\]\[/\[/g;	# [000000.][	==> [
      $dirspec =~ s/(?<!\^)\[000000\./\[/g;	# [000000.	==> [
      $dirspec =~ s/(?<!\^)\.\]\[000000\]/\]/g;	# .][000000]	==> ]
      $dirspec =~ s/(?<!\^)\.\]\[/\./g;		# foo.][bar	==> foo.bar
      while ($dirspec =~ s/(^|[\[\<\.])\-(\-+)($|[\]\>\.])/$1-.$2$3/g) {}
  						# That loop does the following
  						# with any amount of dashes:
  						# .--.		==> .-.-.
  						# [--.		==> [-.-.
  						# .--]		==> .-.-]
  						# [--]		==> [-.-]
      $dirspec = "[$dirspec]" unless $dirspec =~ /(?<!\^)[\[<]/; # make legal
      $dirspec =~ s/^(\[|<)\./$1/;
      @dirs = split /(?<!\^)\./, vmspath($dirspec);
      $dirs[0] =~ s/^[\[<]//s;  $dirs[-1] =~ s/[\]>]\Z(?!\n)//s;
      @dirs;
  }
  
  
  =item catpath (override)
  
  Construct a complete filespec.
  
  =cut
  
  sub catpath {
      my($self,$dev,$dir,$file) = @_;
      
      # We look for a volume in $dev, then in $dir, but not both
      my ($dir_volume, $dir_dir, $dir_file) = $self->splitpath($dir);
      $dev = $dir_volume unless length $dev;
      $dir = length $dir_file ? $self->catfile($dir_dir, $dir_file) : $dir_dir;
      
      if ($dev =~ m|^(?<!\^)/+([^/]+)|) { $dev = "$1:"; }
      else { $dev .= ':' unless $dev eq '' or $dev =~ /:\Z(?!\n)/; }
      if (length($dev) or length($dir)) {
          $dir = "[$dir]" unless $dir =~ /(?<!\^)[\[<\/]/;
          $dir = vmspath($dir);
      }
      $dir = '' if length($dev) && ($dir eq '[]' || $dir eq '<>');
      "$dev$dir$file";
  }
  
  =item abs2rel (override)
  
  Attempt to convert an absolute file specification to a relative specification.
  
  =cut
  
  sub abs2rel {
      my $self = shift;
      return vmspath(File::Spec::Unix::abs2rel( $self, @_ ))
          if ((grep m{/}, @_) && !(grep m{(?<!\^)[\[<:]}, @_));
  
      my($path,$base) = @_;
      $base = $self->_cwd() unless defined $base and length $base;
  
      # If there is no device or directory syntax on $base, make sure it
      # is treated as a directory.
      $base = VMS::Filespec::vmspath($base) unless $base =~ m{(?<!\^)[\[<:]};
  
      for ($path, $base) { $_ = $self->rel2abs($_) }
  
      # Are we even starting $path on the same (node::)device as $base?  Note that
      # logical paths or nodename differences may be on the "same device" 
      # but the comparison that ignores device differences so as to concatenate 
      # [---] up directory specs is not even a good idea in cases where there is 
      # a logical path difference between $path and $base nodename and/or device.
      # Hence we fall back to returning the absolute $path spec
      # if there is a case blind device (or node) difference of any sort
      # and we do not even try to call $parse() or consult %ENV for $trnlnm()
      # (this module needs to run on non VMS platforms after all).
      
      my ($path_volume, $path_directories, $path_file) = $self->splitpath($path);
      my ($base_volume, $base_directories, $base_file) = $self->splitpath($base);
      return $path unless lc($path_volume) eq lc($base_volume);
  
      # Now, remove all leading components that are the same
      my @pathchunks = $self->splitdir( $path_directories );
      my $pathchunks = @pathchunks;
      unshift(@pathchunks,'000000') unless $pathchunks[0] eq '000000';
      my @basechunks = $self->splitdir( $base_directories );
      my $basechunks = @basechunks;
      unshift(@basechunks,'000000') unless $basechunks[0] eq '000000';
  
      while ( @pathchunks && 
              @basechunks && 
              lc( $pathchunks[0] ) eq lc( $basechunks[0] ) 
            ) {
          shift @pathchunks ;
          shift @basechunks ;
      }
  
      # @basechunks now contains the directories to climb out of,
      # @pathchunks now has the directories to descend in to.
      if ((@basechunks > 0) || ($basechunks != $pathchunks)) {
        $path_directories = join '.', ('-' x @basechunks, @pathchunks) ;
      }
      else {
        $path_directories = join '.', @pathchunks;
      }
      $path_directories = '['.$path_directories.']';
      return $self->canonpath( $self->catpath( '', $path_directories, $path_file ) ) ;
  }
  
  
  =item rel2abs (override)
  
  Return an absolute file specification from a relative one.
  
  =cut
  
  sub rel2abs {
      my $self = shift ;
      my ($path,$base ) = @_;
      return undef unless defined $path;
      if ($path =~ m/\//) {
         $path = ( -d $path || $path =~ m/\/\z/  # educated guessing about
                    ? vmspath($path)             # whether it's a directory
                    : vmsify($path) );
      }
      $base = vmspath($base) if defined $base && $base =~ m/\//;
  
      # Clean up and split up $path
      if ( ! $self->file_name_is_absolute( $path ) ) {
          # Figure out the effective $base and clean it up.
          if ( !defined( $base ) || $base eq '' ) {
              $base = $self->_cwd;
          }
          elsif ( ! $self->file_name_is_absolute( $base ) ) {
              $base = $self->rel2abs( $base ) ;
          }
          else {
              $base = $self->canonpath( $base ) ;
          }
  
          # Split up paths
          my ( $path_directories, $path_file ) =
              ($self->splitpath( $path ))[1,2] ;
  
          my ( $base_volume, $base_directories ) =
              $self->splitpath( $base ) ;
  
          $path_directories = '' if $path_directories eq '[]' ||
                                    $path_directories eq '<>';
          my $sep = '' ;
          $sep = '.'
              if ( $base_directories =~ m{[^.\]>]\Z(?!\n)} &&
                   $path_directories =~ m{^[^.\[<]}s
              ) ;
          $base_directories = "$base_directories$sep$path_directories";
          $base_directories =~ s{\.?[\]>][\[<]\.?}{.};
  
          $path = $self->catpath( $base_volume, $base_directories, $path_file );
     }
  
      return $self->canonpath( $path ) ;
  }
  
  
  =back
  
  =head1 COPYRIGHT
  
  Copyright (c) 2004-14 by the Perl 5 Porters.  All rights reserved.
  
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =head1 SEE ALSO
  
  See L<File::Spec> and L<File::Spec::Unix>.  This package overrides the
  implementation of these methods, not the semantics.
  
  An explanation of VMS file specs can be found at
  L<http://h71000.www7.hp.com/doc/731FINAL/4506/4506pro_014.html#apps_locating_naming_files>.
  
  =cut
  
  1;
I686-LINUX-GNU-THREAD-MULTI-64INT_FILE_SPEC_VMS

$fatpacked{"i686-linux-gnu-thread-multi-64int/File/Spec/Win32.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'I686-LINUX-GNU-THREAD-MULTI-64INT_FILE_SPEC_WIN32';
  package File::Spec::Win32;
  
  use strict;
  
  use vars qw(@ISA $VERSION);
  require File::Spec::Unix;
  
  $VERSION = '3.62';
  $VERSION =~ tr/_//d;
  
  @ISA = qw(File::Spec::Unix);
  
  # Some regexes we use for path splitting
  my $DRIVE_RX = '[a-zA-Z]:';
  my $UNC_RX = '(?:\\\\\\\\|//)[^\\\\/]+[\\\\/][^\\\\/]+';
  my $VOL_RX = "(?:$DRIVE_RX|$UNC_RX)";
  
  
  =head1 NAME
  
  File::Spec::Win32 - methods for Win32 file specs
  
  =head1 SYNOPSIS
  
   require File::Spec::Win32; # Done internally by File::Spec if needed
  
  =head1 DESCRIPTION
  
  See File::Spec::Unix for a documentation of the methods provided
  there. This package overrides the implementation of these methods, not
  the semantics.
  
  =over 4
  
  =item devnull
  
  Returns a string representation of the null device.
  
  =cut
  
  sub devnull {
      return "nul";
  }
  
  sub rootdir { '\\' }
  
  
  =item tmpdir
  
  Returns a string representation of the first existing directory
  from the following list:
  
      $ENV{TMPDIR}
      $ENV{TEMP}
      $ENV{TMP}
      SYS:/temp
      C:\system\temp
      C:/temp
      /tmp
      /
  
  The SYS:/temp is preferred in Novell NetWare and the C:\system\temp
  for Symbian (the File::Spec::Win32 is used also for those platforms).
  
  If running under taint mode, and if the environment
  variables are tainted, they are not used.
  
  =cut
  
  sub tmpdir {
      my $tmpdir = $_[0]->_cached_tmpdir(qw(TMPDIR TEMP TMP));
      return $tmpdir if defined $tmpdir;
      $tmpdir = $_[0]->_tmpdir( map( $ENV{$_}, qw(TMPDIR TEMP TMP) ),
  			      'SYS:/temp',
  			      'C:\system\temp',
  			      'C:/temp',
  			      '/tmp',
  			      '/'  );
      $_[0]->_cache_tmpdir($tmpdir, qw(TMPDIR TEMP TMP));
  }
  
  =item case_tolerant
  
  MSWin32 case-tolerance depends on GetVolumeInformation() $ouFsFlags == FS_CASE_SENSITIVE,
  indicating the case significance when comparing file specifications.
  Since XP FS_CASE_SENSITIVE is effectively disabled for the NT subsubsystem.
  See http://cygwin.com/ml/cygwin/2007-07/msg00891.html
  Default: 1
  
  =cut
  
  sub case_tolerant {
    eval { require Win32API::File; } or return 1;
    my $drive = shift || "C:";
    my $osFsType = "\0"x256;
    my $osVolName = "\0"x256;
    my $ouFsFlags = 0;
    Win32API::File::GetVolumeInformation($drive, $osVolName, 256, [], [], $ouFsFlags, $osFsType, 256 );
    if ($ouFsFlags & Win32API::File::FS_CASE_SENSITIVE()) { return 0; }
    else { return 1; }
  }
  
  =item file_name_is_absolute
  
  As of right now, this returns 2 if the path is absolute with a
  volume, 1 if it's absolute with no volume, 0 otherwise.
  
  =cut
  
  sub file_name_is_absolute {
  
      my ($self,$file) = @_;
  
      if ($file =~ m{^($VOL_RX)}o) {
        my $vol = $1;
        return ($vol =~ m{^$UNC_RX}o ? 2
  	      : $file =~ m{^$DRIVE_RX[\\/]}o ? 2
  	      : 0);
      }
      return $file =~  m{^[\\/]} ? 1 : 0;
  }
  
  =item catfile
  
  Concatenate one or more directory names and a filename to form a
  complete path ending with a filename
  
  =cut
  
  sub catfile {
      shift;
  
      # Legacy / compatibility support
      #
      shift, return _canon_cat( "/", @_ )
  	if $_[0] eq "";
  
      # Compatibility with File::Spec <= 3.26:
      #     catfile('A:', 'foo') should return 'A:\foo'.
      return _canon_cat( ($_[0].'\\'), @_[1..$#_] )
          if $_[0] =~ m{^$DRIVE_RX\z}o;
  
      return _canon_cat( @_ );
  }
  
  sub catdir {
      shift;
  
      # Legacy / compatibility support
      #
      return ""
      	unless @_;
      shift, return _canon_cat( "/", @_ )
  	if $_[0] eq "";
  
      # Compatibility with File::Spec <= 3.26:
      #     catdir('A:', 'foo') should return 'A:\foo'.
      return _canon_cat( ($_[0].'\\'), @_[1..$#_] )
          if $_[0] =~ m{^$DRIVE_RX\z}o;
  
      return _canon_cat( @_ );
  }
  
  sub path {
      my @path = split(';', $ENV{PATH});
      s/"//g for @path;
      @path = grep length, @path;
      unshift(@path, ".");
      return @path;
  }
  
  =item canonpath
  
  No physical check on the filesystem, but a logical cleanup of a
  path. On UNIX eliminated successive slashes and successive "/.".
  On Win32 makes 
  
  	dir1\dir2\dir3\..\..\dir4 -> \dir\dir4 and even
  	dir1\dir2\dir3\...\dir4   -> \dir\dir4
  
  =cut
  
  sub canonpath {
      # Legacy / compatibility support
      #
      return $_[1] if !defined($_[1]) or $_[1] eq '';
      return _canon_cat( $_[1] );
  }
  
  =item splitpath
  
     ($volume,$directories,$file) = File::Spec->splitpath( $path );
     ($volume,$directories,$file) = File::Spec->splitpath( $path,
                                                           $no_file );
  
  Splits a path into volume, directory, and filename portions. Assumes that 
  the last file is a path unless the path ends in '\\', '\\.', '\\..'
  or $no_file is true.  On Win32 this means that $no_file true makes this return 
  ( $volume, $path, '' ).
  
  Separators accepted are \ and /.
  
  Volumes can be drive letters or UNC sharenames (\\server\share).
  
  The results can be passed to L</catpath> to get back a path equivalent to
  (usually identical to) the original path.
  
  =cut
  
  sub splitpath {
      my ($self,$path, $nofile) = @_;
      my ($volume,$directory,$file) = ('','','');
      if ( $nofile ) {
          $path =~ 
              m{^ ( $VOL_RX ? ) (.*) }sox;
          $volume    = $1;
          $directory = $2;
      }
      else {
          $path =~ 
              m{^ ( $VOL_RX ? )
                  ( (?:.*[\\/](?:\.\.?\Z(?!\n))?)? )
                  (.*)
               }sox;
          $volume    = $1;
          $directory = $2;
          $file      = $3;
      }
  
      return ($volume,$directory,$file);
  }
  
  
  =item splitdir
  
  The opposite of L<catdir()|File::Spec/catdir>.
  
      @dirs = File::Spec->splitdir( $directories );
  
  $directories must be only the directory portion of the path on systems 
  that have the concept of a volume or that have path syntax that differentiates
  files from directories.
  
  Unlike just splitting the directories on the separator, leading empty and 
  trailing directory entries can be returned, because these are significant
  on some OSs. So,
  
      File::Spec->splitdir( "/a/b/c" );
  
  Yields:
  
      ( '', 'a', 'b', '', 'c', '' )
  
  =cut
  
  sub splitdir {
      my ($self,$directories) = @_ ;
      #
      # split() likes to forget about trailing null fields, so here we
      # check to be sure that there will not be any before handling the
      # simple case.
      #
      if ( $directories !~ m|[\\/]\Z(?!\n)| ) {
          return split( m|[\\/]|, $directories );
      }
      else {
          #
          # since there was a trailing separator, add a file name to the end, 
          # then do the split, then replace it with ''.
          #
          my( @directories )= split( m|[\\/]|, "${directories}dummy" ) ;
          $directories[ $#directories ]= '' ;
          return @directories ;
      }
  }
  
  
  =item catpath
  
  Takes volume, directory and file portions and returns an entire path. Under
  Unix, $volume is ignored, and this is just like catfile(). On other OSs,
  the $volume become significant.
  
  =cut
  
  sub catpath {
      my ($self,$volume,$directory,$file) = @_;
  
      # If it's UNC, make sure the glue separator is there, reusing
      # whatever separator is first in the $volume
      my $v;
      $volume .= $v
          if ( (($v) = $volume =~ m@^([\\/])[\\/][^\\/]+[\\/][^\\/]+\Z(?!\n)@s) &&
               $directory =~ m@^[^\\/]@s
             ) ;
  
      $volume .= $directory ;
  
      # If the volume is not just A:, make sure the glue separator is 
      # there, reusing whatever separator is first in the $volume if possible.
      if ( $volume !~ m@^[a-zA-Z]:\Z(?!\n)@s &&
           $volume =~ m@[^\\/]\Z(?!\n)@      &&
           $file   =~ m@[^\\/]@
         ) {
          $volume =~ m@([\\/])@ ;
          my $sep = $1 ? $1 : '\\' ;
          $volume .= $sep ;
      }
  
      $volume .= $file ;
  
      return $volume ;
  }
  
  sub _same {
    lc($_[1]) eq lc($_[2]);
  }
  
  sub rel2abs {
      my ($self,$path,$base ) = @_;
  
      my $is_abs = $self->file_name_is_absolute($path);
  
      # Check for volume (should probably document the '2' thing...)
      return $self->canonpath( $path ) if $is_abs == 2;
  
      if ($is_abs) {
        # It's missing a volume, add one
        my $vol = ($self->splitpath( $self->_cwd() ))[0];
        return $self->canonpath( $vol . $path );
      }
  
      if ( !defined( $base ) || $base eq '' ) {
        require Cwd ;
        $base = Cwd::getdcwd( ($self->splitpath( $path ))[0] ) if defined &Cwd::getdcwd ;
        $base = $self->_cwd() unless defined $base ;
      }
      elsif ( ! $self->file_name_is_absolute( $base ) ) {
        $base = $self->rel2abs( $base ) ;
      }
      else {
        $base = $self->canonpath( $base ) ;
      }
  
      my ( $path_directories, $path_file ) =
        ($self->splitpath( $path, 1 ))[1,2] ;
  
      my ( $base_volume, $base_directories ) =
        $self->splitpath( $base, 1 ) ;
  
      $path = $self->catpath( 
  			   $base_volume, 
  			   $self->catdir( $base_directories, $path_directories ), 
  			   $path_file
  			  ) ;
  
      return $self->canonpath( $path ) ;
  }
  
  =back
  
  =head2 Note For File::Spec::Win32 Maintainers
  
  Novell NetWare inherits its File::Spec behaviour from File::Spec::Win32.
  
  =head1 COPYRIGHT
  
  Copyright (c) 2004,2007 by the Perl 5 Porters.  All rights reserved.
  
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =head1 SEE ALSO
  
  See L<File::Spec> and L<File::Spec::Unix>.  This package overrides the
  implementation of these methods, not the semantics.
  
  =cut
  
  
  sub _canon_cat				# @path -> path
  {
      my ($first, @rest) = @_;
  
      my $volume = $first =~ s{ \A ([A-Za-z]:) ([\\/]?) }{}x	# drive letter
      	       ? ucfirst( $1 ).( $2 ? "\\" : "" )
  	       : $first =~ s{ \A (?:\\\\|//) ([^\\/]+)
  				 (?: [\\/] ([^\\/]+) )?
  	       			 [\\/]? }{}xs			# UNC volume
  	       ? "\\\\$1".( defined $2 ? "\\$2" : "" )."\\"
  	       : $first =~ s{ \A [\\/] }{}x			# root dir
  	       ? "\\"
  	       : "";
      my $path   = join "\\", $first, @rest;
  
      $path =~ tr#\\/#\\\\#s;		# xx/yy --> xx\yy & xx\\yy --> xx\yy
  
      					# xx/././yy --> xx/yy
      $path =~ s{(?:
  		(?:\A|\\)		# at begin or after a slash
  		\.
  		(?:\\\.)*		# and more
  		(?:\\|\z) 		# at end or followed by slash
  	       )+			# performance boost -- I do not know why
  	     }{\\}gx;
  
      # XXX I do not know whether more dots are supported by the OS supporting
      #     this ... annotation (NetWare or symbian but not MSWin32).
      #     Then .... could easily become ../../.. etc:
      # Replace \.\.\. by (\.\.\.+)  and substitute with
      # { $1 . ".." . "\\.." x (length($2)-2) }gex
  	     				# ... --> ../..
      $path =~ s{ (\A|\\)			# at begin or after a slash
      		\.\.\.
  		(?=\\|\z) 		# at end or followed by slash
  	     }{$1..\\..}gx;
      					# xx\yy\..\zz --> xx\zz
      while ( $path =~ s{(?:
  		(?:\A|\\)		# at begin or after a slash
  		[^\\]+			# rip this 'yy' off
  		\\\.\.
  		(?<!\A\.\.\\\.\.)	# do *not* replace ^..\..
  		(?<!\\\.\.\\\.\.)	# do *not* replace \..\..
  		(?:\\|\z) 		# at end or followed by slash
  	       )+			# performance boost -- I do not know why
  	     }{\\}sx ) {}
  
      $path =~ s#\A\\##;			# \xx --> xx  NOTE: this is *not* root
      $path =~ s#\\\z##;			# xx\ --> xx
  
      if ( $volume =~ m#\\\z# )
      {					# <vol>\.. --> <vol>\
  	$path =~ s{ \A			# at begin
  		    \.\.
  		    (?:\\\.\.)*		# and more
  		    (?:\\|\z) 		# at end or followed by slash
  		 }{}x;
  
  	return $1			# \\HOST\SHARE\ --> \\HOST\SHARE
  	    if    $path eq ""
  	      and $volume =~ m#\A(\\\\.*)\\\z#s;
      }
      return $path ne "" || $volume ? $volume.$path : ".";
  }
  
  1;
I686-LINUX-GNU-THREAD-MULTI-64INT_FILE_SPEC_WIN32

$fatpacked{"i686-linux-gnu-thread-multi-64int/List/Util.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'I686-LINUX-GNU-THREAD-MULTI-64INT_LIST_UTIL';
  # Copyright (c) 1997-2009 Graham Barr <gbarr@pobox.com>. All rights reserved.
  # This program is free software; you can redistribute it and/or
  # modify it under the same terms as Perl itself.
  #
  # Maintained since 2013 by Paul Evans <leonerd@leonerd.org.uk>
  
  package List::Util;
  
  use strict;
  use warnings;
  require Exporter;
  
  our @ISA        = qw(Exporter);
  our @EXPORT_OK  = qw(
    all any first min max minstr maxstr none notall product reduce sum sum0 shuffle uniq uniqnum uniqstr
    pairs unpairs pairkeys pairvalues pairmap pairgrep pairfirst
  );
  our $VERSION    = "1.47";
  our $XS_VERSION = $VERSION;
  $VERSION    = eval $VERSION;
  
  require XSLoader;
  XSLoader::load('List::Util', $XS_VERSION);
  
  sub import
  {
    my $pkg = caller;
  
    # (RT88848) Touch the caller's $a and $b, to avoid the warning of
    #   Name "main::a" used only once: possible typo" warning
    no strict 'refs';
    ${"${pkg}::a"} = ${"${pkg}::a"};
    ${"${pkg}::b"} = ${"${pkg}::b"};
  
    goto &Exporter::import;
  }
  
  # For objects returned by pairs()
  sub List::Util::_Pair::key   { shift->[0] }
  sub List::Util::_Pair::value { shift->[1] }
  
  =head1 NAME
  
  List::Util - A selection of general-utility list subroutines
  
  =head1 SYNOPSIS
  
      use List::Util qw(
        reduce any all none notall first
  
        max maxstr min minstr product sum sum0
  
        pairs unpairs pairkeys pairvalues pairfirst pairgrep pairmap
  
        shuffle uniq uniqnum uniqstr
      );
  
  =head1 DESCRIPTION
  
  C<List::Util> contains a selection of subroutines that people have expressed
  would be nice to have in the perl core, but the usage would not really be high
  enough to warrant the use of a keyword, and the size so small such that being
  individual extensions would be wasteful.
  
  By default C<List::Util> does not export any subroutines.
  
  =cut
  
  =head1 LIST-REDUCTION FUNCTIONS
  
  The following set of functions all reduce a list down to a single value.
  
  =cut
  
  =head2 reduce
  
      $result = reduce { BLOCK } @list
  
  Reduces C<@list> by calling C<BLOCK> in a scalar context multiple times,
  setting C<$a> and C<$b> each time. The first call will be with C<$a> and C<$b>
  set to the first two elements of the list, subsequent calls will be done by
  setting C<$a> to the result of the previous call and C<$b> to the next element
  in the list.
  
  Returns the result of the last call to the C<BLOCK>. If C<@list> is empty then
  C<undef> is returned. If C<@list> only contains one element then that element
  is returned and C<BLOCK> is not executed.
  
  The following examples all demonstrate how C<reduce> could be used to implement
  the other list-reduction functions in this module. (They are not in fact
  implemented like this, but instead in a more efficient manner in individual C
  functions).
  
      $foo = reduce { defined($a)            ? $a :
                      $code->(local $_ = $b) ? $b :
                                               undef } undef, @list # first
  
      $foo = reduce { $a > $b ? $a : $b } 1..10       # max
      $foo = reduce { $a gt $b ? $a : $b } 'A'..'Z'   # maxstr
      $foo = reduce { $a < $b ? $a : $b } 1..10       # min
      $foo = reduce { $a lt $b ? $a : $b } 'aa'..'zz' # minstr
      $foo = reduce { $a + $b } 1 .. 10               # sum
      $foo = reduce { $a . $b } @bar                  # concat
  
      $foo = reduce { $a || $code->(local $_ = $b) } 0, @bar   # any
      $foo = reduce { $a && $code->(local $_ = $b) } 1, @bar   # all
      $foo = reduce { $a && !$code->(local $_ = $b) } 1, @bar  # none
      $foo = reduce { $a || !$code->(local $_ = $b) } 0, @bar  # notall
         # Note that these implementations do not fully short-circuit
  
  If your algorithm requires that C<reduce> produce an identity value, then make
  sure that you always pass that identity value as the first argument to prevent
  C<undef> being returned
  
    $foo = reduce { $a + $b } 0, @values;             # sum with 0 identity value
  
  The above example code blocks also suggest how to use C<reduce> to build a
  more efficient combined version of one of these basic functions and a C<map>
  block. For example, to find the total length of the all the strings in a list,
  we could use
  
      $total = sum map { length } @strings;
  
  However, this produces a list of temporary integer values as long as the
  original list of strings, only to reduce it down to a single value again. We
  can compute the same result more efficiently by using C<reduce> with a code
  block that accumulates lengths by writing this instead as:
  
      $total = reduce { $a + length $b } 0, @strings
  
  The remaining list-reduction functions are all specialisations of this generic
  idea.
  
  =head2 any
  
      my $bool = any { BLOCK } @list;
  
  I<Since version 1.33.>
  
  Similar to C<grep> in that it evaluates C<BLOCK> setting C<$_> to each element
  of C<@list> in turn. C<any> returns true if any element makes the C<BLOCK>
  return a true value. If C<BLOCK> never returns true or C<@list> was empty then
  it returns false.
  
  Many cases of using C<grep> in a conditional can be written using C<any>
  instead, as it can short-circuit after the first true result.
  
      if( any { length > 10 } @strings ) {
          # at least one string has more than 10 characters
      }
  
  =head2 all
  
      my $bool = all { BLOCK } @list;
  
  I<Since version 1.33.>
  
  Similar to L</any>, except that it requires all elements of the C<@list> to
  make the C<BLOCK> return true. If any element returns false, then it returns
  false. If the C<BLOCK> never returns false or the C<@list> was empty then it
  returns true.
  
  =head2 none
  
  =head2 notall
  
      my $bool = none { BLOCK } @list;
  
      my $bool = notall { BLOCK } @list;
  
  I<Since version 1.33.>
  
  Similar to L</any> and L</all>, but with the return sense inverted. C<none>
  returns true only if no value in the C<@list> causes the C<BLOCK> to return
  true, and C<notall> returns true only if not all of the values do.
  
  =head2 first
  
      my $val = first { BLOCK } @list;
  
  Similar to C<grep> in that it evaluates C<BLOCK> setting C<$_> to each element
  of C<@list> in turn. C<first> returns the first element where the result from
  C<BLOCK> is a true value. If C<BLOCK> never returns true or C<@list> was empty
  then C<undef> is returned.
  
      $foo = first { defined($_) } @list    # first defined value in @list
      $foo = first { $_ > $value } @list    # first value in @list which
                                            # is greater than $value
  
  =head2 max
  
      my $num = max @list;
  
  Returns the entry in the list with the highest numerical value. If the list is
  empty then C<undef> is returned.
  
      $foo = max 1..10                # 10
      $foo = max 3,9,12               # 12
      $foo = max @bar, @baz           # whatever
  
  =head2 maxstr
  
      my $str = maxstr @list;
  
  Similar to L</max>, but treats all the entries in the list as strings and
  returns the highest string as defined by the C<gt> operator. If the list is
  empty then C<undef> is returned.
  
      $foo = maxstr 'A'..'Z'          # 'Z'
      $foo = maxstr "hello","world"   # "world"
      $foo = maxstr @bar, @baz        # whatever
  
  =head2 min
  
      my $num = min @list;
  
  Similar to L</max> but returns the entry in the list with the lowest numerical
  value. If the list is empty then C<undef> is returned.
  
      $foo = min 1..10                # 1
      $foo = min 3,9,12               # 3
      $foo = min @bar, @baz           # whatever
  
  =head2 minstr
  
      my $str = minstr @list;
  
  Similar to L</min>, but treats all the entries in the list as strings and
  returns the lowest string as defined by the C<lt> operator. If the list is
  empty then C<undef> is returned.
  
      $foo = minstr 'A'..'Z'          # 'A'
      $foo = minstr "hello","world"   # "hello"
      $foo = minstr @bar, @baz        # whatever
  
  =head2 product
  
      my $num = product @list;
  
  I<Since version 1.35.>
  
  Returns the numerical product of all the elements in C<@list>. If C<@list> is
  empty then C<1> is returned.
  
      $foo = product 1..10            # 3628800
      $foo = product 3,9,12           # 324
  
  =head2 sum
  
      my $num_or_undef = sum @list;
  
  Returns the numerical sum of all the elements in C<@list>. For backwards
  compatibility, if C<@list> is empty then C<undef> is returned.
  
      $foo = sum 1..10                # 55
      $foo = sum 3,9,12               # 24
      $foo = sum @bar, @baz           # whatever
  
  =head2 sum0
  
      my $num = sum0 @list;
  
  I<Since version 1.26.>
  
  Similar to L</sum>, except this returns 0 when given an empty list, rather
  than C<undef>.
  
  =cut
  
  =head1 KEY/VALUE PAIR LIST FUNCTIONS
  
  The following set of functions, all inspired by L<List::Pairwise>, consume an
  even-sized list of pairs. The pairs may be key/value associations from a hash,
  or just a list of values. The functions will all preserve the original ordering
  of the pairs, and will not be confused by multiple pairs having the same "key"
  value - nor even do they require that the first of each pair be a plain string.
  
  B<NOTE>: At the time of writing, the following C<pair*> functions that take a
  block do not modify the value of C<$_> within the block, and instead operate
  using the C<$a> and C<$b> globals instead. This has turned out to be a poor
  design, as it precludes the ability to provide a C<pairsort> function. Better
  would be to pass pair-like objects as 2-element array references in C<$_>, in
  a style similar to the return value of the C<pairs> function. At some future
  version this behaviour may be added.
  
  Until then, users are alerted B<NOT> to rely on the value of C<$_> remaining
  unmodified between the outside and the inside of the control block. In
  particular, the following example is B<UNSAFE>:
  
   my @kvlist = ...
  
   foreach (qw( some keys here )) {
      my @items = pairgrep { $a eq $_ } @kvlist;
      ...
   }
  
  Instead, write this using a lexical variable:
  
   foreach my $key (qw( some keys here )) {
      my @items = pairgrep { $a eq $key } @kvlist;
      ...
   }
  
  =cut
  
  =head2 pairs
  
      my @pairs = pairs @kvlist;
  
  I<Since version 1.29.>
  
  A convenient shortcut to operating on even-sized lists of pairs, this function
  returns a list of C<ARRAY> references, each containing two items from the
  given list. It is a more efficient version of
  
      @pairs = pairmap { [ $a, $b ] } @kvlist
  
  It is most convenient to use in a C<foreach> loop, for example:
  
      foreach my $pair ( pairs @kvlist ) {
         my ( $key, $value ) = @$pair;
         ...
      }
  
  Since version C<1.39> these C<ARRAY> references are blessed objects,
  recognising the two methods C<key> and C<value>. The following code is
  equivalent:
  
      foreach my $pair ( pairs @kvlist ) {
         my $key   = $pair->key;
         my $value = $pair->value;
         ...
      }
  
  =head2 unpairs
  
      my @kvlist = unpairs @pairs
  
  I<Since version 1.42.>
  
  The inverse function to C<pairs>; this function takes a list of C<ARRAY>
  references containing two elements each, and returns a flattened list of the
  two values from each of the pairs, in order. This is notionally equivalent to
  
      my @kvlist = map { @{$_}[0,1] } @pairs
  
  except that it is implemented more efficiently internally. Specifically, for
  any input item it will extract exactly two values for the output list; using
  C<undef> if the input array references are short.
  
  Between C<pairs> and C<unpairs>, a higher-order list function can be used to
  operate on the pairs as single scalars; such as the following near-equivalents
  of the other C<pair*> higher-order functions:
  
      @kvlist = unpairs grep { FUNC } pairs @kvlist
      # Like pairgrep, but takes $_ instead of $a and $b
  
      @kvlist = unpairs map { FUNC } pairs @kvlist
      # Like pairmap, but takes $_ instead of $a and $b
  
  Note however that these versions will not behave as nicely in scalar context.
  
  Finally, this technique can be used to implement a sort on a keyvalue pair
  list; e.g.:
  
      @kvlist = unpairs sort { $a->key cmp $b->key } pairs @kvlist
  
  =head2 pairkeys
  
      my @keys = pairkeys @kvlist;
  
  I<Since version 1.29.>
  
  A convenient shortcut to operating on even-sized lists of pairs, this function
  returns a list of the the first values of each of the pairs in the given list.
  It is a more efficient version of
  
      @keys = pairmap { $a } @kvlist
  
  =head2 pairvalues
  
      my @values = pairvalues @kvlist;
  
  I<Since version 1.29.>
  
  A convenient shortcut to operating on even-sized lists of pairs, this function
  returns a list of the the second values of each of the pairs in the given list.
  It is a more efficient version of
  
      @values = pairmap { $b } @kvlist
  
  =head2 pairgrep
  
      my @kvlist = pairgrep { BLOCK } @kvlist;
  
      my $count = pairgrep { BLOCK } @kvlist;
  
  I<Since version 1.29.>
  
  Similar to perl's C<grep> keyword, but interprets the given list as an
  even-sized list of pairs. It invokes the C<BLOCK> multiple times, in scalar
  context, with C<$a> and C<$b> set to successive pairs of values from the
  C<@kvlist>.
  
  Returns an even-sized list of those pairs for which the C<BLOCK> returned true
  in list context, or the count of the B<number of pairs> in scalar context.
  (Note, therefore, in scalar context that it returns a number half the size of
  the count of items it would have returned in list context).
  
      @subset = pairgrep { $a =~ m/^[[:upper:]]+$/ } @kvlist
  
  As with C<grep> aliasing C<$_> to list elements, C<pairgrep> aliases C<$a> and
  C<$b> to elements of the given list. Any modifications of it by the code block
  will be visible to the caller.
  
  =head2 pairfirst
  
      my ( $key, $val ) = pairfirst { BLOCK } @kvlist;
  
      my $found = pairfirst { BLOCK } @kvlist;
  
  I<Since version 1.30.>
  
  Similar to the L</first> function, but interprets the given list as an
  even-sized list of pairs. It invokes the C<BLOCK> multiple times, in scalar
  context, with C<$a> and C<$b> set to successive pairs of values from the
  C<@kvlist>.
  
  Returns the first pair of values from the list for which the C<BLOCK> returned
  true in list context, or an empty list of no such pair was found. In scalar
  context it returns a simple boolean value, rather than either the key or the
  value found.
  
      ( $key, $value ) = pairfirst { $a =~ m/^[[:upper:]]+$/ } @kvlist
  
  As with C<grep> aliasing C<$_> to list elements, C<pairfirst> aliases C<$a> and
  C<$b> to elements of the given list. Any modifications of it by the code block
  will be visible to the caller.
  
  =head2 pairmap
  
      my @list = pairmap { BLOCK } @kvlist;
  
      my $count = pairmap { BLOCK } @kvlist;
  
  I<Since version 1.29.>
  
  Similar to perl's C<map> keyword, but interprets the given list as an
  even-sized list of pairs. It invokes the C<BLOCK> multiple times, in list
  context, with C<$a> and C<$b> set to successive pairs of values from the
  C<@kvlist>.
  
  Returns the concatenation of all the values returned by the C<BLOCK> in list
  context, or the count of the number of items that would have been returned in
  scalar context.
  
      @result = pairmap { "The key $a has value $b" } @kvlist
  
  As with C<map> aliasing C<$_> to list elements, C<pairmap> aliases C<$a> and
  C<$b> to elements of the given list. Any modifications of it by the code block
  will be visible to the caller.
  
  See L</KNOWN BUGS> for a known-bug with C<pairmap>, and a workaround.
  
  =cut
  
  =head1 OTHER FUNCTIONS
  
  =cut
  
  =head2 shuffle
  
      my @values = shuffle @values;
  
  Returns the values of the input in a random order
  
      @cards = shuffle 0..51      # 0..51 in a random order
  
  =head2 uniq
  
      my @subset = uniq @values
  
  I<Since version 1.45.>
  
  Filters a list of values to remove subsequent duplicates, as judged by a
  DWIM-ish string equality or C<undef> test. Preserves the order of unique
  elements, and retains the first value of any duplicate set.
  
      my $count = uniq @values
  
  In scalar context, returns the number of elements that would have been
  returned as a list.
  
  The C<undef> value is treated by this function as distinct from the empty
  string, and no warning will be produced. It is left as-is in the returned
  list. Subsequent C<undef> values are still considered identical to the first,
  and will be removed.
  
  =head2 uniqnum
  
      my @subset = uniqnum @values
  
  I<Since version 1.44.>
  
  Filters a list of values to remove subsequent duplicates, as judged by a
  numerical equality test. Preserves the order of unique elements, and retains
  the first value of any duplicate set.
  
      my $count = uniqnum @values
  
  In scalar context, returns the number of elements that would have been
  returned as a list.
  
  Note that C<undef> is treated much as other numerical operations treat it; it
  compares equal to zero but additionally produces a warning if such warnings
  are enabled (C<use warnings 'uninitialized';>). In addition, an C<undef> in
  the returned list is coerced into a numerical zero, so that the entire list of
  values returned by C<uniqnum> are well-behaved as numbers.
  
  Note also that multiple IEEE C<NaN> values are treated as duplicates of
  each other, regardless of any differences in their payloads, and despite
  the fact that C<< 0+'NaN' == 0+'NaN' >> yields false.
  
  =head2 uniqstr
  
      my @subset = uniqstr @values
  
  I<Since version 1.45.>
  
  Filters a list of values to remove subsequent duplicates, as judged by a
  string equality test. Preserves the order of unique elements, and retains the
  first value of any duplicate set.
  
      my $count = uniqstr @values
  
  In scalar context, returns the number of elements that would have been
  returned as a list.
  
  Note that C<undef> is treated much as other string operations treat it; it
  compares equal to the empty string but additionally produces a warning if such
  warnings are enabled (C<use warnings 'uninitialized';>). In addition, an
  C<undef> in the returned list is coerced into an empty string, so that the
  entire list of values returned by C<uniqstr> are well-behaved as strings.
  
  =cut
  
  =head1 KNOWN BUGS
  
  =head2 RT #95409
  
  L<https://rt.cpan.org/Ticket/Display.html?id=95409>
  
  If the block of code given to L</pairmap> contains lexical variables that are
  captured by a returned closure, and the closure is executed after the block
  has been re-used for the next iteration, these lexicals will not see the
  correct values. For example:
  
   my @subs = pairmap {
      my $var = "$a is $b";
      sub { print "$var\n" };
   } one => 1, two => 2, three => 3;
  
   $_->() for @subs;
  
  Will incorrectly print
  
   three is 3
   three is 3
   three is 3
  
  This is due to the performance optimisation of using C<MULTICALL> for the code
  block, which means that fresh SVs do not get allocated for each call to the
  block. Instead, the same SV is re-assigned for each iteration, and all the
  closures will share the value seen on the final iteration.
  
  To work around this bug, surround the code with a second set of braces. This
  creates an inner block that defeats the C<MULTICALL> logic, and does get fresh
  SVs allocated each time:
  
   my @subs = pairmap {
      {
         my $var = "$a is $b";
         sub { print "$var\n"; }
      }
   } one => 1, two => 2, three => 3;
  
  This bug only affects closures that are generated by the block but used
  afterwards. Lexical variables that are only used during the lifetime of the
  block's execution will take their individual values for each invocation, as
  normal.
  
  =head2 uniqnum() on oversized bignums
  
  Due to the way that C<uniqnum()> compares numbers, it cannot distinguish
  differences between bignums (especially bigints) that are too large to fit in
  the native platform types. For example,
  
   my $x = Math::BigInt->new( "1" x 100 );
   my $y = $x + 1;
  
   say for uniqnum( $x, $y );
  
  Will print just the value of C<$x>, believing that C<$y> is a numerically-
  equivalent value. This bug does not affect C<uniqstr()>, which will correctly
  observe that the two values stringify to different strings.
  
  =head1 SUGGESTED ADDITIONS
  
  The following are additions that have been requested, but I have been reluctant
  to add due to them being very simple to implement in perl
  
    # How many elements are true
  
    sub true { scalar grep { $_ } @_ }
  
    # How many elements are false
  
    sub false { scalar grep { !$_ } @_ }
  
  =head1 SEE ALSO
  
  L<Scalar::Util>, L<List::MoreUtils>
  
  =head1 COPYRIGHT
  
  Copyright (c) 1997-2007 Graham Barr <gbarr@pobox.com>. All rights reserved.
  This program is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  Recent additions and current maintenance by
  Paul Evans, <leonerd@leonerd.org.uk>.
  
  =cut
  
  1;
I686-LINUX-GNU-THREAD-MULTI-64INT_LIST_UTIL

$fatpacked{"i686-linux-gnu-thread-multi-64int/List/Util/XS.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'I686-LINUX-GNU-THREAD-MULTI-64INT_LIST_UTIL_XS';
  package List::Util::XS;
  use strict;
  use warnings;
  use List::Util;
  
  our $VERSION = "1.47";       # FIXUP
  $VERSION = eval $VERSION;    # FIXUP
  
  1;
  __END__
  
  =head1 NAME
  
  List::Util::XS - Indicate if List::Util was compiled with a C compiler
  
  =head1 SYNOPSIS
  
      use List::Util::XS 1.20;
  
  =head1 DESCRIPTION
  
  C<List::Util::XS> can be used as a dependency to ensure List::Util was
  installed using a C compiler and that the XS version is installed.
  
  During installation C<$List::Util::XS::VERSION> will be set to
  C<undef> if the XS was not compiled.
  
  Starting with release 1.23_03, Scalar-List-Util is B<always> using
  the XS implementation, but for backwards compatibility, we still
  ship the C<List::Util::XS> module which just loads C<List::Util>.
  
  =head1 SEE ALSO
  
  L<Scalar::Util>, L<List::Util>, L<List::MoreUtils>
  
  =head1 COPYRIGHT
  
  Copyright (c) 2008 Graham Barr <gbarr@pobox.com>. All rights reserved.
  This program is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  =cut
I686-LINUX-GNU-THREAD-MULTI-64INT_LIST_UTIL_XS

$fatpacked{"i686-linux-gnu-thread-multi-64int/Scalar/Util.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'I686-LINUX-GNU-THREAD-MULTI-64INT_SCALAR_UTIL';
  # Copyright (c) 1997-2007 Graham Barr <gbarr@pobox.com>. All rights reserved.
  # This program is free software; you can redistribute it and/or
  # modify it under the same terms as Perl itself.
  #
  # Maintained since 2013 by Paul Evans <leonerd@leonerd.org.uk>
  
  package Scalar::Util;
  
  use strict;
  use warnings;
  require Exporter;
  
  our @ISA       = qw(Exporter);
  our @EXPORT_OK = qw(
    blessed refaddr reftype weaken unweaken isweak
  
    dualvar isdual isvstring looks_like_number openhandle readonly set_prototype
    tainted
  );
  our $VERSION    = "1.47";
  $VERSION   = eval $VERSION;
  
  require List::Util; # List::Util loads the XS
  List::Util->VERSION( $VERSION ); # Ensure we got the right XS version (RT#100863)
  
  our @EXPORT_FAIL;
  
  unless (defined &weaken) {
    push @EXPORT_FAIL, qw(weaken);
  }
  unless (defined &isweak) {
    push @EXPORT_FAIL, qw(isweak isvstring);
  }
  unless (defined &isvstring) {
    push @EXPORT_FAIL, qw(isvstring);
  }
  
  sub export_fail {
    if (grep { /^(?:weaken|isweak)$/ } @_ ) {
      require Carp;
      Carp::croak("Weak references are not implemented in the version of perl");
    }
  
    if (grep { /^isvstring$/ } @_ ) {
      require Carp;
      Carp::croak("Vstrings are not implemented in the version of perl");
    }
  
    @_;
  }
  
  # set_prototype has been moved to Sub::Util with a different interface
  sub set_prototype(&$)
  {
    my ( $code, $proto ) = @_;
    return Sub::Util::set_prototype( $proto, $code );
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Scalar::Util - A selection of general-utility scalar subroutines
  
  =head1 SYNOPSIS
  
      use Scalar::Util qw(blessed dualvar isdual readonly refaddr reftype
                          tainted weaken isweak isvstring looks_like_number
                          set_prototype);
                          # and other useful utils appearing below
  
  =head1 DESCRIPTION
  
  C<Scalar::Util> contains a selection of subroutines that people have expressed
  would be nice to have in the perl core, but the usage would not really be high
  enough to warrant the use of a keyword, and the size would be so small that 
  being individual extensions would be wasteful.
  
  By default C<Scalar::Util> does not export any subroutines.
  
  =cut
  
  =head1 FUNCTIONS FOR REFERENCES
  
  The following functions all perform some useful activity on reference values.
  
  =head2 blessed
  
      my $pkg = blessed( $ref );
  
  If C<$ref> is a blessed reference, the name of the package that it is blessed
  into is returned. Otherwise C<undef> is returned.
  
      $scalar = "foo";
      $class  = blessed $scalar;           # undef
  
      $ref    = [];
      $class  = blessed $ref;              # undef
  
      $obj    = bless [], "Foo";
      $class  = blessed $obj;              # "Foo"
  
  Take care when using this function simply as a truth test (such as in
  C<if(blessed $ref)...>) because the package name C<"0"> is defined yet false.
  
  =head2 refaddr
  
      my $addr = refaddr( $ref );
  
  If C<$ref> is reference, the internal memory address of the referenced value is
  returned as a plain integer. Otherwise C<undef> is returned.
  
      $addr = refaddr "string";           # undef
      $addr = refaddr \$var;              # eg 12345678
      $addr = refaddr [];                 # eg 23456784
  
      $obj  = bless {}, "Foo";
      $addr = refaddr $obj;               # eg 88123488
  
  =head2 reftype
  
      my $type = reftype( $ref );
  
  If C<$ref> is a reference, the basic Perl type of the variable referenced is
  returned as a plain string (such as C<ARRAY> or C<HASH>). Otherwise C<undef>
  is returned.
  
      $type = reftype "string";           # undef
      $type = reftype \$var;              # SCALAR
      $type = reftype [];                 # ARRAY
  
      $obj  = bless {}, "Foo";
      $type = reftype $obj;               # HASH
  
  =head2 weaken
  
      weaken( $ref );
  
  The lvalue C<$ref> will be turned into a weak reference. This means that it
  will not hold a reference count on the object it references. Also, when the
  reference count on that object reaches zero, the reference will be set to
  undef. This function mutates the lvalue passed as its argument and returns no
  value.
  
  This is useful for keeping copies of references, but you don't want to prevent
  the object being DESTROY-ed at its usual time.
  
      {
        my $var;
        $ref = \$var;
        weaken($ref);                     # Make $ref a weak reference
      }
      # $ref is now undef
  
  Note that if you take a copy of a scalar with a weakened reference, the copy
  will be a strong reference.
  
      my $var;
      my $foo = \$var;
      weaken($foo);                       # Make $foo a weak reference
      my $bar = $foo;                     # $bar is now a strong reference
  
  This may be less obvious in other situations, such as C<grep()>, for instance
  when grepping through a list of weakened references to objects that may have
  been destroyed already:
  
      @object = grep { defined } @object;
  
  This will indeed remove all references to destroyed objects, but the remaining
  references to objects will be strong, causing the remaining objects to never be
  destroyed because there is now always a strong reference to them in the @object
  array.
  
  =head2 unweaken
  
      unweaken( $ref );
  
  I<Since version 1.36.>
  
  The lvalue C<REF> will be turned from a weak reference back into a normal
  (strong) reference again. This function mutates the lvalue passed as its
  argument and returns no value. This undoes the action performed by
  L</weaken>.
  
  This function is slightly neater and more convenient than the
  otherwise-equivalent code
  
      my $tmp = $REF;
      undef $REF;
      $REF = $tmp;
  
  (because in particular, simply assigning a weak reference back to itself does
  not work to unweaken it; C<$REF = $REF> does not work).
  
  =head2 isweak
  
      my $weak = isweak( $ref );
  
  Returns true if C<$ref> is a weak reference.
  
      $ref  = \$foo;
      $weak = isweak($ref);               # false
      weaken($ref);
      $weak = isweak($ref);               # true
  
  B<NOTE>: Copying a weak reference creates a normal, strong, reference.
  
      $copy = $ref;
      $weak = isweak($copy);              # false
  
  =head1 OTHER FUNCTIONS
  
  =head2 dualvar
  
      my $var = dualvar( $num, $string );
  
  Returns a scalar that has the value C<$num> in a numeric context and the value
  C<$string> in a string context.
  
      $foo = dualvar 10, "Hello";
      $num = $foo + 2;                    # 12
      $str = $foo . " world";             # Hello world
  
  =head2 isdual
  
      my $dual = isdual( $var );
  
  I<Since version 1.26.>
  
  If C<$var> is a scalar that has both numeric and string values, the result is
  true.
  
      $foo = dualvar 86, "Nix";
      $dual = isdual($foo);               # true
  
  Note that a scalar can be made to have both string and numeric content through
  numeric operations:
  
      $foo = "10";
      $dual = isdual($foo);               # false
      $bar = $foo + 0;
      $dual = isdual($foo);               # true
  
  Note that although C<$!> appears to be a dual-valued variable, it is
  actually implemented as a magical variable inside the interpreter:
  
      $! = 1;
      print("$!\n");                      # "Operation not permitted"
      $dual = isdual($!);                 # false
  
  You can capture its numeric and string content using:
  
      $err = dualvar $!, $!;
      $dual = isdual($err);               # true
  
  =head2 isvstring
  
      my $vstring = isvstring( $var );
  
  If C<$var> is a scalar which was coded as a vstring, the result is true.
  
      $vs   = v49.46.48;
      $fmt  = isvstring($vs) ? "%vd" : "%s"; #true
      printf($fmt,$vs);
  
  =head2 looks_like_number
  
      my $isnum = looks_like_number( $var );
  
  Returns true if perl thinks C<$var> is a number. See
  L<perlapi/looks_like_number>.
  
  =head2 openhandle
  
      my $fh = openhandle( $fh );
  
  Returns C<$fh> itself if C<$fh> may be used as a filehandle and is open, or is
  is a tied handle. Otherwise C<undef> is returned.
  
      $fh = openhandle(*STDIN);           # \*STDIN
      $fh = openhandle(\*STDIN);          # \*STDIN
      $fh = openhandle(*NOTOPEN);         # undef
      $fh = openhandle("scalar");         # undef
  
  =head2 readonly
  
      my $ro = readonly( $var );
  
  Returns true if C<$var> is readonly.
  
      sub foo { readonly($_[0]) }
  
      $readonly = foo($bar);              # false
      $readonly = foo(0);                 # true
  
  =head2 set_prototype
  
      my $code = set_prototype( $code, $prototype );
  
  Sets the prototype of the function given by the C<$code> reference, or deletes
  it if C<$prototype> is C<undef>. Returns the C<$code> reference itself.
  
      set_prototype \&foo, '$$';
  
  =head2 tainted
  
      my $t = tainted( $var );
  
  Return true if C<$var> is tainted.
  
      $taint = tainted("constant");       # false
      $taint = tainted($ENV{PWD});        # true if running under -T
  
  =head1 DIAGNOSTICS
  
  Module use may give one of the following errors during import.
  
  =over
  
  =item Weak references are not implemented in the version of perl
  
  The version of perl that you are using does not implement weak references, to
  use L</isweak> or L</weaken> you will need to use a newer release of perl.
  
  =item Vstrings are not implemented in the version of perl
  
  The version of perl that you are using does not implement Vstrings, to use
  L</isvstring> you will need to use a newer release of perl.
  
  =back
  
  =head1 KNOWN BUGS
  
  There is a bug in perl5.6.0 with UV's that are >= 1<<31. This will
  show up as tests 8 and 9 of dualvar.t failing
  
  =head1 SEE ALSO
  
  L<List::Util>
  
  =head1 COPYRIGHT
  
  Copyright (c) 1997-2007 Graham Barr <gbarr@pobox.com>. All rights reserved.
  This program is free software; you can redistribute it and/or modify it
  under the same terms as Perl itself.
  
  Additionally L</weaken> and L</isweak> which are
  
  Copyright (c) 1999 Tuomas J. Lukka <lukka@iki.fi>. All rights reserved.
  This program is free software; you can redistribute it and/or modify it
  under the same terms as perl itself.
  
  Copyright (C) 2004, 2008  Matthijs van Duin.  All rights reserved.
  Copyright (C) 2014 cPanel Inc.  All rights reserved.
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =cut
I686-LINUX-GNU-THREAD-MULTI-64INT_SCALAR_UTIL

$fatpacked{"i686-linux-gnu-thread-multi-64int/Sub/Util.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'I686-LINUX-GNU-THREAD-MULTI-64INT_SUB_UTIL';
  # Copyright (c) 2014 Paul Evans <leonerd@leonerd.org.uk>. All rights reserved.
  # This program is free software; you can redistribute it and/or
  # modify it under the same terms as Perl itself.
  
  package Sub::Util;
  
  use strict;
  use warnings;
  
  require Exporter;
  
  our @ISA = qw( Exporter );
  our @EXPORT_OK = qw(
    prototype set_prototype
    subname set_subname
  );
  
  our $VERSION    = "1.47";
  $VERSION   = eval $VERSION;
  
  require List::Util; # as it has the XS
  List::Util->VERSION( $VERSION ); # Ensure we got the right XS version (RT#100863)
  
  =head1 NAME
  
  Sub::Util - A selection of utility subroutines for subs and CODE references
  
  =head1 SYNOPSIS
  
      use Sub::Util qw( prototype set_prototype subname set_subname );
  
  =head1 DESCRIPTION
  
  C<Sub::Util> contains a selection of utility subroutines that are useful for
  operating on subs and CODE references.
  
  The rationale for inclusion in this module is that the function performs some
  work for which an XS implementation is essential because it cannot be
  implemented in Pure Perl, and which is sufficiently-widely used across CPAN
  that its popularity warrants inclusion in a core module, which this is.
  
  =cut
  
  =head1 FUNCTIONS
  
  =cut
  
  =head2 prototype
  
      my $proto = prototype( $code )
  
  I<Since version 1.40.>
  
  Returns the prototype of the given C<$code> reference, if it has one, as a
  string. This is the same as the C<CORE::prototype> operator; it is included
  here simply for symmetry and completeness with the other functions.
  
  =cut
  
  sub prototype
  {
    my ( $code ) = @_;
    return CORE::prototype( $code );
  }
  
  =head2 set_prototype
  
      my $code = set_prototype $prototype, $code;
  
  I<Since version 1.40.>
  
  Sets the prototype of the function given by the C<$code> reference, or deletes
  it if C<$prototype> is C<undef>. Returns the C<$code> reference itself.
  
  I<Caution>: This function takes arguments in a different order to the previous
  copy of the code from C<Scalar::Util>. This is to match the order of
  C<set_subname>, and other potential additions in this file. This order has
  been chosen as it allows a neat and simple chaining of other
  C<Sub::Util::set_*> functions as might become available, such as:
  
   my $code =
      set_subname   name_here =>
      set_prototype '&@'      =>
      set_attribute ':lvalue' =>
         sub { ...... };
  
  =cut
  
  =head2 subname
  
      my $name = subname( $code )
  
  I<Since version 1.40.>
  
  Returns the name of the given C<$code> reference, if it has one. Normal named
  subs will give a fully-qualified name consisting of the package and the
  localname separated by C<::>. Anonymous code references will give C<__ANON__>
  as the localname. If a name has been set using L</set_subname>, this name will
  be returned instead.
  
  This function was inspired by C<sub_fullname> from L<Sub::Identify>. The
  remaining functions that C<Sub::Identify> implements can easily be emulated
  using regexp operations, such as
  
   sub get_code_info { return (subname $_[0]) =~ m/^(.+)::(.+?)$/ }
   sub sub_name      { return (get_code_info $_[0])[0] }
   sub stash_name    { return (get_code_info $_[0])[1] }
  
  I<Users of Sub::Name beware>: This function is B<not> the same as
  C<Sub::Name::subname>; it returns the existing name of the sub rather than
  changing it. To set or change a name, see instead L</set_subname>.
  
  =cut
  
  =head2 set_subname
  
      my $code = set_subname $name, $code;
  
  I<Since version 1.40.>
  
  Sets the name of the function given by the C<$code> reference. Returns the
  C<$code> reference itself. If the C<$name> is unqualified, the package of the
  caller is used to qualify it.
  
  This is useful for applying names to anonymous CODE references so that stack
  traces and similar situations, to give a useful name rather than having the
  default of C<__ANON__>. Note that this name is only used for this situation;
  the C<set_subname> will not install it into the symbol table; you will have to
  do that yourself if required.
  
  However, since the name is not used by perl except as the return value of
  C<caller>, for stack traces or similar, there is no actual requirement that
  the name be syntactically valid as a perl function name. This could be used to
  attach extra information that could be useful in debugging stack traces.
  
  This function was copied from C<Sub::Name::subname> and renamed to the naming
  convention of this module.
  
  =cut
  
  =head1 AUTHOR
  
  The general structure of this module was written by Paul Evans
  <leonerd@leonerd.org.uk>.
  
  The XS implementation of L</set_subname> was copied from L<Sub::Name> by
  Matthijs van Duin <xmath@cpan.org>
  
  =cut
  
  1;
I686-LINUX-GNU-THREAD-MULTI-64INT_SUB_UTIL

$fatpacked{"i686-linux-gnu-thread-multi-64int/Time/HiRes.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'I686-LINUX-GNU-THREAD-MULTI-64INT_TIME_HIRES';
  package Time::HiRes;
  
  { use 5.006; }
  use strict;
  
  require Exporter;
  require DynaLoader;
  
  our @ISA = qw(Exporter DynaLoader);
  
  our @EXPORT = qw( );
  our @EXPORT_OK = qw (usleep sleep ualarm alarm gettimeofday time tv_interval
  		 getitimer setitimer nanosleep clock_gettime clock_getres
  		 clock clock_nanosleep
  		 CLOCK_BOOTTIME CLOCK_HIGHRES
  		 CLOCK_MONOTONIC CLOCK_MONOTONIC_COARSE
  		 CLOCK_MONOTONIC_PRECISE CLOCK_MONOTONIC_RAW
  		 CLOCK_PROCESS_CPUTIME_ID
  		 CLOCK_REALTIME CLOCK_REALTIME_COARSE
  		 CLOCK_REALTIME_FAST CLOCK_REALTIME_PRECISE
  		 CLOCK_SECOND CLOCK_SOFTTIME CLOCK_THREAD_CPUTIME_ID
  		 CLOCK_TIMEOFDAY CLOCKS_PER_SEC
  		 ITIMER_REAL ITIMER_VIRTUAL ITIMER_PROF ITIMER_REALPROF
  		 TIMER_ABSTIME
  		 d_usleep d_ualarm d_gettimeofday d_getitimer d_setitimer
  		 d_nanosleep d_clock_gettime d_clock_getres d_hires_utime
  		 d_clock d_clock_nanosleep
  		 stat lstat utime
  		);
  
  our $VERSION = '1.9741';
  our $XS_VERSION = $VERSION;
  $VERSION = eval $VERSION;
  
  our $AUTOLOAD;
  sub AUTOLOAD {
      my $constname;
      ($constname = $AUTOLOAD) =~ s/.*:://;
      # print "AUTOLOAD: constname = $constname ($AUTOLOAD)\n";
      die "&Time::HiRes::constant not defined" if $constname eq 'constant';
      my ($error, $val) = constant($constname);
      # print "AUTOLOAD: error = $error, val = $val\n";
      if ($error) {
          my (undef,$file,$line) = caller;
          die "$error at $file line $line.\n";
      }
      {
  	no strict 'refs';
  	*$AUTOLOAD = sub { $val };
      }
      goto &$AUTOLOAD;
  }
  
  sub import {
      my $this = shift;
      for my $i (@_) {
  	if (($i eq 'clock_getres'    && !&d_clock_getres)    ||
  	    ($i eq 'clock_gettime'   && !&d_clock_gettime)   ||
  	    ($i eq 'clock_nanosleep' && !&d_clock_nanosleep) ||
  	    ($i eq 'clock'           && !&d_clock)           ||
  	    ($i eq 'nanosleep'       && !&d_nanosleep)       ||
  	    ($i eq 'usleep'          && !&d_usleep)          ||
  	    ($i eq 'utime'           && !&d_hires_utime)     ||
  	    ($i eq 'ualarm'          && !&d_ualarm)) {
  	    require Carp;
  	    Carp::croak("Time::HiRes::$i(): unimplemented in this platform");
  	}
      }
      Time::HiRes->export_to_level(1, $this, @_);
  }
  
  bootstrap Time::HiRes;
  
  # Preloaded methods go here.
  
  sub tv_interval {
      # probably could have been done in C
      my ($a, $b) = @_;
      $b = [gettimeofday()] unless defined($b);
      (${$b}[0] - ${$a}[0]) + ((${$b}[1] - ${$a}[1]) / 1_000_000);
  }
  
  # Autoload methods go after =cut, and are processed by the autosplit program.
  
  1;
  __END__
  
  =head1 NAME
  
  Time::HiRes - High resolution alarm, sleep, gettimeofday, interval timers
  
  =head1 SYNOPSIS
  
    use Time::HiRes qw( usleep ualarm gettimeofday tv_interval nanosleep
  		      clock_gettime clock_getres clock_nanosleep clock
                        stat lstat utime);
  
    usleep ($microseconds);
    nanosleep ($nanoseconds);
  
    ualarm ($microseconds);
    ualarm ($microseconds, $interval_microseconds);
  
    $t0 = [gettimeofday];
    ($seconds, $microseconds) = gettimeofday;
  
    $elapsed = tv_interval ( $t0, [$seconds, $microseconds]);
    $elapsed = tv_interval ( $t0, [gettimeofday]);
    $elapsed = tv_interval ( $t0 );
  
    use Time::HiRes qw ( time alarm sleep );
  
    $now_fractions = time;
    sleep ($floating_seconds);
    alarm ($floating_seconds);
    alarm ($floating_seconds, $floating_interval);
  
    use Time::HiRes qw( setitimer getitimer );
  
    setitimer ($which, $floating_seconds, $floating_interval );
    getitimer ($which);
  
    use Time::HiRes qw( clock_gettime clock_getres clock_nanosleep
  		      ITIMER_REAL ITIMER_VIRTUAL ITIMER_PROF
                        ITIMER_REALPROF );
  
    $realtime   = clock_gettime(CLOCK_REALTIME);
    $resolution = clock_getres(CLOCK_REALTIME);
  
    clock_nanosleep(CLOCK_REALTIME, 1.5e9);
    clock_nanosleep(CLOCK_REALTIME, time()*1e9 + 10e9, TIMER_ABSTIME);
  
    my $ticktock = clock();
  
    use Time::HiRes qw( stat lstat );
  
    my @stat = stat("file");
    my @stat = stat(FH);
    my @stat = lstat("file");
  
    use Time::HiRes qw( utime );
    utime $floating_seconds, $floating_seconds, file...;
  
  =head1 DESCRIPTION
  
  The C<Time::HiRes> module implements a Perl interface to the
  C<usleep>, C<nanosleep>, C<ualarm>, C<gettimeofday>, and
  C<setitimer>/C<getitimer> system calls, in other words, high
  resolution time and timers. See the L</EXAMPLES> section below and the
  test scripts for usage; see your system documentation for the
  description of the underlying C<nanosleep> or C<usleep>, C<ualarm>,
  C<gettimeofday>, and C<setitimer>/C<getitimer> calls.
  
  If your system lacks C<gettimeofday()> or an emulation of it you don't
  get C<gettimeofday()> or the one-argument form of C<tv_interval()>.
  If your system lacks all of C<nanosleep()>, C<usleep()>,
  C<select()>, and C<poll>, you don't get C<Time::HiRes::usleep()>,
  C<Time::HiRes::nanosleep()>, or C<Time::HiRes::sleep()>.
  If your system lacks both C<ualarm()> and C<setitimer()> you don't get
  C<Time::HiRes::ualarm()> or C<Time::HiRes::alarm()>.
  
  If you try to import an unimplemented function in the C<use> statement
  it will fail at compile time.
  
  If your subsecond sleeping is implemented with C<nanosleep()> instead
  of C<usleep()>, you can mix subsecond sleeping with signals since
  C<nanosleep()> does not use signals.  This, however, is not portable,
  and you should first check for the truth value of
  C<&Time::HiRes::d_nanosleep> to see whether you have nanosleep, and
  then carefully read your C<nanosleep()> C API documentation for any
  peculiarities.
  
  If you are using C<nanosleep> for something else than mixing sleeping
  with signals, give some thought to whether Perl is the tool you should
  be using for work requiring nanosecond accuracies.
  
  Remember that unless you are working on a I<hard realtime> system,
  any clocks and timers will be imprecise, especially so if you are working
  in a pre-emptive multiuser system.  Understand the difference between
  I<wallclock time> and process time (in UNIX-like systems the sum of
  I<user> and I<system> times).  Any attempt to sleep for X seconds will
  most probably end up sleeping B<more> than that, but don't be surprised
  if you end up sleeping slightly B<less>.
  
  The following functions can be imported from this module.
  No functions are exported by default.
  
  =over 4
  
  =item gettimeofday ()
  
  In array context returns a two-element array with the seconds and
  microseconds since the epoch.  In scalar context returns floating
  seconds like C<Time::HiRes::time()> (see below).
  
  =item usleep ( $useconds )
  
  Sleeps for the number of microseconds (millionths of a second)
  specified.  Returns the number of microseconds actually slept.
  Can sleep for more than one second, unlike the C<usleep> system call.
  Can also sleep for zero seconds, which often works like a I<thread yield>.
  See also C<Time::HiRes::usleep()>, C<Time::HiRes::sleep()>, and
  C<Time::HiRes::clock_nanosleep()>.
  
  Do not expect usleep() to be exact down to one microsecond.
  
  =item nanosleep ( $nanoseconds )
  
  Sleeps for the number of nanoseconds (1e9ths of a second) specified.
  Returns the number of nanoseconds actually slept (accurate only to
  microseconds, the nearest thousand of them).  Can sleep for more than
  one second.  Can also sleep for zero seconds, which often works like
  a I<thread yield>.  See also C<Time::HiRes::sleep()>,
  C<Time::HiRes::usleep()>, and C<Time::HiRes::clock_nanosleep()>.
  
  Do not expect nanosleep() to be exact down to one nanosecond.
  Getting even accuracy of one thousand nanoseconds is good.
  
  =item ualarm ( $useconds [, $interval_useconds ] )
  
  Issues a C<ualarm> call; the C<$interval_useconds> is optional and
  will be zero if unspecified, resulting in C<alarm>-like behaviour.
  
  Returns the remaining time in the alarm in microseconds, or C<undef>
  if an error occurred.
  
  ualarm(0) will cancel an outstanding ualarm().
  
  Note that the interaction between alarms and sleeps is unspecified.
  
  =item tv_interval 
  
  tv_interval ( $ref_to_gettimeofday [, $ref_to_later_gettimeofday] )
  
  Returns the floating seconds between the two times, which should have
  been returned by C<gettimeofday()>. If the second argument is omitted,
  then the current time is used.
  
  =item time ()
  
  Returns a floating seconds since the epoch. This function can be
  imported, resulting in a nice drop-in replacement for the C<time>
  provided with core Perl; see the L</EXAMPLES> below.
  
  B<NOTE 1>: This higher resolution timer can return values either less
  or more than the core C<time()>, depending on whether your platform
  rounds the higher resolution timer values up, down, or to the nearest second
  to get the core C<time()>, but naturally the difference should be never
  more than half a second.  See also L</clock_getres>, if available
  in your system.
  
  B<NOTE 2>: Since Sunday, September 9th, 2001 at 01:46:40 AM GMT, when
  the C<time()> seconds since epoch rolled over to 1_000_000_000, the
  default floating point format of Perl and the seconds since epoch have
  conspired to produce an apparent bug: if you print the value of
  C<Time::HiRes::time()> you seem to be getting only five decimals, not
  six as promised (microseconds).  Not to worry, the microseconds are
  there (assuming your platform supports such granularity in the first
  place).  What is going on is that the default floating point format of
  Perl only outputs 15 digits.  In this case that means ten digits
  before the decimal separator and five after.  To see the microseconds
  you can use either C<printf>/C<sprintf> with C<"%.6f">, or the
  C<gettimeofday()> function in list context, which will give you the
  seconds and microseconds as two separate values.
  
  =item sleep ( $floating_seconds )
  
  Sleeps for the specified amount of seconds.  Returns the number of
  seconds actually slept (a floating point value).  This function can
  be imported, resulting in a nice drop-in replacement for the C<sleep>
  provided with perl, see the L</EXAMPLES> below.
  
  Note that the interaction between alarms and sleeps is unspecified.
  
  =item alarm ( $floating_seconds [, $interval_floating_seconds ] )
  
  The C<SIGALRM> signal is sent after the specified number of seconds.
  Implemented using C<setitimer()> if available, C<ualarm()> if not.
  The C<$interval_floating_seconds> argument is optional and will be
  zero if unspecified, resulting in C<alarm()>-like behaviour.  This
  function can be imported, resulting in a nice drop-in replacement for
  the C<alarm> provided with perl, see the L</EXAMPLES> below.
  
  Returns the remaining time in the alarm in seconds, or C<undef>
  if an error occurred.
  
  B<NOTE 1>: With some combinations of operating systems and Perl
  releases C<SIGALRM> restarts C<select()>, instead of interrupting it.
  This means that an C<alarm()> followed by a C<select()> may together
  take the sum of the times specified for the C<alarm()> and the
  C<select()>, not just the time of the C<alarm()>.
  
  Note that the interaction between alarms and sleeps is unspecified.
  
  =item setitimer ( $which, $floating_seconds [, $interval_floating_seconds ] )
  
  Start up an interval timer: after a certain time, a signal ($which) arrives,
  and more signals may keep arriving at certain intervals.  To disable
  an "itimer", use C<$floating_seconds> of zero.  If the
  C<$interval_floating_seconds> is set to zero (or unspecified), the
  timer is disabled B<after> the next delivered signal.
  
  Use of interval timers may interfere with C<alarm()>, C<sleep()>,
  and C<usleep()>.  In standard-speak the "interaction is unspecified",
  which means that I<anything> may happen: it may work, it may not.
  
  In scalar context, the remaining time in the timer is returned.
  
  In list context, both the remaining time and the interval are returned.
  
  There are usually three or four interval timers (signals) available: the
  C<$which> can be C<ITIMER_REAL>, C<ITIMER_VIRTUAL>, C<ITIMER_PROF>, or
  C<ITIMER_REALPROF>.  Note that which ones are available depends: true
  UNIX platforms usually have the first three, but only Solaris seems to
  have C<ITIMER_REALPROF> (which is used to profile multithreaded programs).
  Win32 unfortunately does not have interval timers.
  
  C<ITIMER_REAL> results in C<alarm()>-like behaviour.  Time is counted in
  I<real time>; that is, wallclock time.  C<SIGALRM> is delivered when
  the timer expires.
  
  C<ITIMER_VIRTUAL> counts time in (process) I<virtual time>; that is,
  only when the process is running.  In multiprocessor/user/CPU systems
  this may be more or less than real or wallclock time.  (This time is
  also known as the I<user time>.)  C<SIGVTALRM> is delivered when the
  timer expires.
  
  C<ITIMER_PROF> counts time when either the process virtual time or when
  the operating system is running on behalf of the process (such as I/O).
  (This time is also known as the I<system time>.)  (The sum of user
  time and system time is known as the I<CPU time>.)  C<SIGPROF> is
  delivered when the timer expires.  C<SIGPROF> can interrupt system calls.
  
  The semantics of interval timers for multithreaded programs are
  system-specific, and some systems may support additional interval
  timers.  For example, it is unspecified which thread gets the signals.
  See your C<setitimer()> documentation.
  
  =item getitimer ( $which )
  
  Return the remaining time in the interval timer specified by C<$which>.
  
  In scalar context, the remaining time is returned.
  
  In list context, both the remaining time and the interval are returned.
  The interval is always what you put in using C<setitimer()>.
  
  =item clock_gettime ( $which )
  
  Return as seconds the current value of the POSIX high resolution timer
  specified by C<$which>.  All implementations that support POSIX high
  resolution timers are supposed to support at least the C<$which> value
  of C<CLOCK_REALTIME>, which is supposed to return results close to the
  results of C<gettimeofday>, or the number of seconds since 00:00:00:00
  January 1, 1970 Greenwich Mean Time (GMT).  Do not assume that
  CLOCK_REALTIME is zero, it might be one, or something else.
  Another potentially useful (but not available everywhere) value is
  C<CLOCK_MONOTONIC>, which guarantees a monotonically increasing time
  value (unlike time() or gettimeofday(), which can be adjusted).
  See your system documentation for other possibly supported values.
  
  =item clock_getres ( $which )
  
  Return as seconds the resolution of the POSIX high resolution timer
  specified by C<$which>.  All implementations that support POSIX high
  resolution timers are supposed to support at least the C<$which> value
  of C<CLOCK_REALTIME>, see L</clock_gettime>.
  
  B<NOTE>: the resolution returned may be highly optimistic.  Even if
  the resolution is high (a small number), all it means is that you'll
  be able to specify the arguments to clock_gettime() and clock_nanosleep()
  with that resolution.  The system might not actually be able to measure
  events at that resolution, and the various overheads and the overall system
  load are certain to affect any timings.
  
  =item clock_nanosleep ( $which, $nanoseconds, $flags = 0)
  
  Sleeps for the number of nanoseconds (1e9ths of a second) specified.
  Returns the number of nanoseconds actually slept.  The $which is the
  "clock id", as with clock_gettime() and clock_getres().  The flags
  default to zero but C<TIMER_ABSTIME> can specified (must be exported
  explicitly) which means that C<$nanoseconds> is not a time interval
  (as is the default) but instead an absolute time.  Can sleep for more
  than one second.  Can also sleep for zero seconds, which often works
  like a I<thread yield>.  See also C<Time::HiRes::sleep()>,
  C<Time::HiRes::usleep()>, and C<Time::HiRes::nanosleep()>.
  
  Do not expect clock_nanosleep() to be exact down to one nanosecond.
  Getting even accuracy of one thousand nanoseconds is good.
  
  =item clock()
  
  Return as seconds the I<process time> (user + system time) spent by
  the process since the first call to clock() (the definition is B<not>
  "since the start of the process", though if you are lucky these times
  may be quite close to each other, depending on the system).  What this
  means is that you probably need to store the result of your first call
  to clock(), and subtract that value from the following results of clock().
  
  The time returned also includes the process times of the terminated
  child processes for which wait() has been executed.  This value is
  somewhat like the second value returned by the times() of core Perl,
  but not necessarily identical.  Note that due to backward
  compatibility limitations the returned value may wrap around at about
  2147 seconds or at about 36 minutes.
  
  =item stat
  
  =item stat FH
  
  =item stat EXPR
  
  =item lstat
  
  =item lstat FH
  
  =item lstat EXPR
  
  As L<perlfunc/stat> or L<perlfunc/lstat>
  but with the access/modify/change file timestamps
  in subsecond resolution, if the operating system and the filesystem
  both support such timestamps.  To override the standard stat():
  
      use Time::HiRes qw(stat);
  
  Test for the value of &Time::HiRes::d_hires_stat to find out whether
  the operating system supports subsecond file timestamps: a value
  larger than zero means yes. There are unfortunately no easy
  ways to find out whether the filesystem supports such timestamps.
  UNIX filesystems often do; NTFS does; FAT doesn't (FAT timestamp
  granularity is B<two> seconds).
  
  A zero return value of &Time::HiRes::d_hires_stat means that
  Time::HiRes::stat is a no-op passthrough for CORE::stat()
  (and likewise for lstat),
  and therefore the timestamps will stay integers.  The same
  thing will happen if the filesystem does not do subsecond timestamps,
  even if the &Time::HiRes::d_hires_stat is non-zero.
  
  In any case do not expect nanosecond resolution, or even a microsecond
  resolution.  Also note that the modify/access timestamps might have
  different resolutions, and that they need not be synchronized, e.g.
  if the operations are
  
      write
      stat # t1
      read
      stat # t2
  
  the access time stamp from t2 need not be greater-than the modify
  time stamp from t1: it may be equal or I<less>.
  
  =item utime LIST
  
  As L<perlfunc/utime>
  but with the ability to set the access/modify file timestamps
  in subsecond resolution, if the operating system and the filesystem
  both support such timestamps.  To override the standard utime():
  
      use Time::HiRes qw(utime);
  
  Test for the value of &Time::HiRes::d_hires_utime to find out whether
  the operating system supports setting subsecond file timestamps.
  
  As with CORE::utime(), passing undef as both the atime and mtime will
  call the syscall with a NULL argument.
  
  The actual achievable subsecond resolution depends on the combination
  of the operating system and the filesystem.
  
  Returns the number of files successfully changed.
  
  =back
  
  =head1 EXAMPLES
  
    use Time::HiRes qw(usleep ualarm gettimeofday tv_interval);
  
    $microseconds = 750_000;
    usleep($microseconds);
  
    # signal alarm in 2.5s & every .1s thereafter
    ualarm(2_500_000, 100_000);
    # cancel that ualarm
    ualarm(0);
  
    # get seconds and microseconds since the epoch
    ($s, $usec) = gettimeofday();
  
    # measure elapsed time 
    # (could also do by subtracting 2 gettimeofday return values)
    $t0 = [gettimeofday];
    # do bunch of stuff here
    $t1 = [gettimeofday];
    # do more stuff here
    $t0_t1 = tv_interval $t0, $t1;
  
    $elapsed = tv_interval ($t0, [gettimeofday]);
    $elapsed = tv_interval ($t0);	# equivalent code
  
    #
    # replacements for time, alarm and sleep that know about
    # floating seconds
    #
    use Time::HiRes;
    $now_fractions = Time::HiRes::time;
    Time::HiRes::sleep (2.5);
    Time::HiRes::alarm (10.6666666);
  
    use Time::HiRes qw ( time alarm sleep );
    $now_fractions = time;
    sleep (2.5);
    alarm (10.6666666);
  
    # Arm an interval timer to go off first at 10 seconds and
    # after that every 2.5 seconds, in process virtual time
  
    use Time::HiRes qw ( setitimer ITIMER_VIRTUAL time );
  
    $SIG{VTALRM} = sub { print time, "\n" };
    setitimer(ITIMER_VIRTUAL, 10, 2.5);
  
    use Time::HiRes qw( clock_gettime clock_getres CLOCK_REALTIME );
    # Read the POSIX high resolution timer.
    my $high = clock_gettime(CLOCK_REALTIME);
    # But how accurate we can be, really?
    my $reso = clock_getres(CLOCK_REALTIME);
  
    use Time::HiRes qw( clock_nanosleep TIMER_ABSTIME );
    clock_nanosleep(CLOCK_REALTIME, 1e6);
    clock_nanosleep(CLOCK_REALTIME, 2e9, TIMER_ABSTIME);
  
    use Time::HiRes qw( clock );
    my $clock0 = clock();
    ... # Do something.
    my $clock1 = clock();
    my $clockd = $clock1 - $clock0;
  
    use Time::HiRes qw( stat );
    my ($atime, $mtime, $ctime) = (stat("istics"))[8, 9, 10];
  
  =head1 C API
  
  In addition to the perl API described above, a C API is available for
  extension writers.  The following C functions are available in the
  modglobal hash:
  
    name             C prototype
    ---------------  ----------------------
    Time::NVtime     NV (*)()
    Time::U2time     void (*)(pTHX_ UV ret[2])
  
  Both functions return equivalent information (like C<gettimeofday>)
  but with different representations.  The names C<NVtime> and C<U2time>
  were selected mainly because they are operating system independent.
  (C<gettimeofday> is Unix-centric, though some platforms like Win32 and
  VMS have emulations for it.)
  
  Here is an example of using C<NVtime> from C:
  
    NV (*myNVtime)(); /* Returns -1 on failure. */
    SV **svp = hv_fetchs(PL_modglobal, "Time::NVtime", 0);
    if (!svp)         croak("Time::HiRes is required");
    if (!SvIOK(*svp)) croak("Time::NVtime isn't a function pointer");
    myNVtime = INT2PTR(NV(*)(), SvIV(*svp));
    printf("The current time is: %" NVff "\n", (*myNVtime)());
  
  =head1 DIAGNOSTICS
  
  =head2 useconds or interval more than ...
  
  In ualarm() you tried to use number of microseconds or interval (also
  in microseconds) more than 1_000_000 and setitimer() is not available
  in your system to emulate that case.
  
  =head2 negative time not invented yet
  
  You tried to use a negative time argument.
  
  =head2 internal error: useconds < 0 (unsigned ... signed ...)
  
  Something went horribly wrong-- the number of microseconds that cannot
  become negative just became negative.  Maybe your compiler is broken?
  
  =head2 useconds or uinterval equal to or more than 1000000
  
  In some platforms it is not possible to get an alarm with subsecond
  resolution and later than one second.
  
  =head2 unimplemented in this platform
  
  Some calls simply aren't available, real or emulated, on every platform.
  
  =head1 CAVEATS
  
  Notice that the core C<time()> maybe rounding rather than truncating.
  What this means is that the core C<time()> may be reporting the time
  as one second later than C<gettimeofday()> and C<Time::HiRes::time()>.
  
  Adjusting the system clock (either manually or by services like ntp)
  may cause problems, especially for long running programs that assume
  a monotonously increasing time (note that all platforms do not adjust
  time as gracefully as UNIX ntp does).  For example in Win32 (and derived
  platforms like Cygwin and MinGW) the Time::HiRes::time() may temporarily
  drift off from the system clock (and the original time())  by up to 0.5
  seconds. Time::HiRes will notice this eventually and recalibrate.
  Note that since Time::HiRes 1.77 the clock_gettime(CLOCK_MONOTONIC)
  might help in this (in case your system supports CLOCK_MONOTONIC).
  
  Some systems have APIs but not implementations: for example QNX and Haiku
  have the interval timer APIs but not the functionality.
  
  In pre-Sierra macOS (pre-10.12, OS X) clock_getres(), clock_gettime()
  and clock_nanosleep() are emulated using the Mach timers; as a side
  effect of being emulated the CLOCK_REALTIME and CLOCK_MONOTONIC are
  the same timer.
  
  gnukfreebsd seems to have non-functional futimens() and utimensat()
  (at least as of 10.1): therefore the hires utime() does not work.
  
  =head1 SEE ALSO
  
  Perl modules L<BSD::Resource>, L<Time::TAI64>.
  
  Your system documentation for C<clock>, C<clock_gettime>,
  C<clock_getres>, C<clock_nanosleep>, C<clock_settime>, C<getitimer>,
  C<gettimeofday>, C<setitimer>, C<sleep>, C<stat>, C<ualarm>.
  
  =head1 AUTHORS
  
  D. Wegscheid <wegscd@whirlpool.com>
  R. Schertler <roderick@argon.org>
  J. Hietaniemi <jhi@iki.fi>
  G. Aas <gisle@aas.no>
  
  =head1 COPYRIGHT AND LICENSE
  
  Copyright (c) 1996-2002 Douglas E. Wegscheid.  All rights reserved.
  
  Copyright (c) 2002, 2003, 2004, 2005, 2006, 2007, 2008 Jarkko Hietaniemi.
  All rights reserved.
  
  Copyright (C) 2011, 2012, 2013 Andrew Main (Zefram) <zefram@fysh.org>
  
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =cut
I686-LINUX-GNU-THREAD-MULTI-64INT_TIME_HIRES

$fatpacked{"i686-linux-gnu-thread-multi-64int/encoding.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'I686-LINUX-GNU-THREAD-MULTI-64INT_ENCODING';
  # $Id: encoding.pm,v 2.19 2016/11/01 13:30:38 dankogai Exp $
  package encoding;
  our $VERSION = sprintf "%d.%02d", q$Revision: 2.19 $ =~ /(\d+)/g;
  
  use Encode;
  use strict;
  use warnings;
  
  use constant {
      DEBUG => !!$ENV{PERL_ENCODE_DEBUG},
      HAS_PERLIO => eval { require PerlIO::encoding; PerlIO::encoding->VERSION(0.02) },
      PERL_5_21_7 => $^V && $^V ge v5.21.7,
  };
  
  sub _exception {
      my $name = shift;
      $] > 5.008 and return 0;    # 5.8.1 or higher then no
      my %utfs = map { $_ => 1 }
        qw(utf8 UCS-2BE UCS-2LE UTF-16 UTF-16BE UTF-16LE
        UTF-32 UTF-32BE UTF-32LE);
      $utfs{$name} or return 0;    # UTFs or no
      require Config;
      Config->import();
      our %Config;
      return $Config{perl_patchlevel} ? 0 : 1    # maintperl then no
  }
  
  sub in_locale { $^H & ( $locale::hint_bits || 0 ) }
  
  sub _get_locale_encoding {
      my $locale_encoding;
  
      if ($^O eq 'MSWin32') {
          my @tries = (
              # First try to get the OutputCP. This will work only if we
              # are attached to a console
              'Win32.pm' => 'Win32::GetConsoleOutputCP',
              'Win32/Console.pm' => 'Win32::Console::OutputCP',
              # If above failed, this means that we are a GUI app
              # Let's assume that the ANSI codepage is what matters
              'Win32.pm' => 'Win32::GetACP',
          );
          while (@tries) {
              my $cp = eval {
                  require $tries[0];
                  no strict 'refs';
                  &{$tries[1]}()
              };
              if ($cp) {
                  if ($cp == 65001) { # Code page for UTF-8
                      $locale_encoding = 'UTF-8';
                  } else {
                      $locale_encoding = 'cp' . $cp;
                  }
                  return $locale_encoding;
              }
              splice(@tries, 0, 2)
          }
      }
  
      # I18N::Langinfo isn't available everywhere
      $locale_encoding = eval {
          require I18N::Langinfo;
          find_encoding(
              I18N::Langinfo::langinfo( I18N::Langinfo::CODESET() )
          )->name
      };
      return $locale_encoding if defined $locale_encoding;
  
      eval {
          require POSIX;
          # Get the current locale
          # Remember that MSVCRT impl is quite different from Unixes
          my $locale = POSIX::setlocale(POSIX::LC_CTYPE());
          if ( $locale =~ /^([^.]+)\.([^.@]+)(?:@.*)?$/ ) {
              my $country_language;
              ( $country_language, $locale_encoding ) = ( $1, $2 );
  
              # Could do more heuristics based on the country and language
              # since we have Locale::Country and Locale::Language available.
              # TODO: get a database of Language -> Encoding mappings
              # (the Estonian database at http://www.eki.ee/letter/
              # would be excellent!) --jhi
              if (lc($locale_encoding) eq 'euc') {
                  if ( $country_language =~ /^ja_JP|japan(?:ese)?$/i ) {
                      $locale_encoding = 'euc-jp';
                  }
                  elsif ( $country_language =~ /^ko_KR|korean?$/i ) {
                      $locale_encoding = 'euc-kr';
                  }
                  elsif ( $country_language =~ /^zh_CN|chin(?:a|ese)$/i ) {
                      $locale_encoding = 'euc-cn';
                  }
                  elsif ( $country_language =~ /^zh_TW|taiwan(?:ese)?$/i ) {
                      $locale_encoding = 'euc-tw';
                  }
                  else {
                      require Carp;
                      Carp::croak(
                          "encoding: Locale encoding '$locale_encoding' too ambiguous"
                      );
                  }
              }
          }
      };
  
      return $locale_encoding;
  }
  
  sub import {
  
      if ( ord("A") == 193 ) {
          require Carp;
          Carp::croak("encoding: pragma does not support EBCDIC platforms");
      }
  
      my $deprecate =
          $] >= 5.017 ? "Use of the encoding pragma is deprecated" : 0;
  
      my $class = shift;
      my $name  = shift;
      if (!$name){
  	require Carp;
          Carp::croak("encoding: no encoding specified.");
      }
      if ( $name eq ':_get_locale_encoding' ) {    # used by lib/open.pm
          my $caller = caller();
          {
              no strict 'refs';
              *{"${caller}::_get_locale_encoding"} = \&_get_locale_encoding;
          }
          return;
      }
      $name = _get_locale_encoding() if $name eq ':locale';
      my %arg = @_;
      $name = $ENV{PERL_ENCODING} unless defined $name;
      my $enc = find_encoding($name);
      unless ( defined $enc ) {
          require Carp;
          Carp::croak("encoding: Unknown encoding '$name'");
      }
      $name = $enc->name;    # canonize
      unless ( $arg{Filter} ) {
          if ($] >= 5.025003) {
              require Carp;
              Carp::croak("The encoding pragma is no longer supported");
          }
          warnings::warnif("deprecated",$deprecate) if $deprecate;
  
          DEBUG and warn "_exception($name) = ", _exception($name);
          if (! _exception($name)) {
              if (!PERL_5_21_7) {
                  ${^ENCODING} = $enc;
              }
              else {
                  # Starting with 5.21.7, this pragma uses a shadow variable
                  # designed explicitly for it, ${^E_NCODING}, to enforce
                  # lexical scope; instead of ${^ENCODING}.
                  $^H{'encoding'} = 1;
                  ${^E_NCODING} = $enc;
              }
          }
          if (! HAS_PERLIO ) {
              return 1;
          }
      }
      else {
          warnings::warnif("deprecated",$deprecate) if $deprecate;
  
          defined( ${^ENCODING} ) and undef ${^ENCODING};
          undef ${^E_NCODING} if PERL_5_21_7;
  
          # implicitly 'use utf8'
          require utf8;      # to fetch $utf8::hint_bits;
          $^H |= $utf8::hint_bits;
          eval {
              require Filter::Util::Call;
              Filter::Util::Call->import;
              filter_add(
                  sub {
                      my $status = filter_read();
                      if ( $status > 0 ) {
                          $_ = $enc->decode( $_, 1 );
                          DEBUG and warn $_;
                      }
                      $status;
                  }
              );
          };
          $@ eq '' and DEBUG and warn "Filter installed";
      }
      defined ${^UNICODE} and ${^UNICODE} != 0 and return 1;
      for my $h (qw(STDIN STDOUT)) {
          if ( $arg{$h} ) {
              unless ( defined find_encoding( $arg{$h} ) ) {
                  require Carp;
                  Carp::croak(
                      "encoding: Unknown encoding for $h, '$arg{$h}'");
              }
              eval { binmode( $h, ":raw :encoding($arg{$h})" ) };
          }
          else {
              unless ( exists $arg{$h} ) {
                  eval {
                      no warnings 'uninitialized';
                      binmode( $h, ":raw :encoding($name)" );
                  };
              }
          }
          if ($@) {
              require Carp;
              Carp::croak($@);
          }
      }
      return 1;    # I doubt if we need it, though
  }
  
  sub unimport {
      no warnings;
      undef ${^ENCODING};
      undef ${^E_NCODING} if PERL_5_21_7;
      if (HAS_PERLIO) {
          binmode( STDIN,  ":raw" );
          binmode( STDOUT, ":raw" );
      }
      else {
          binmode(STDIN);
          binmode(STDOUT);
      }
      if ( $INC{"Filter/Util/Call.pm"} ) {
          eval { filter_del() };
      }
  }
  
  1;
  __END__
  
  =pod
  
  =head1 NAME
  
  encoding - allows you to write your script in non-ASCII and non-UTF-8
  
  =head1 WARNING
  
  This module has been deprecated since perl v5.18.  See L</DESCRIPTION> and
  L</BUGS>.
  
  =head1 SYNOPSIS
  
    use encoding "greek";  # Perl like Greek to you?
    use encoding "euc-jp"; # Jperl!
  
    # or you can even do this if your shell supports your native encoding
  
    perl -Mencoding=latin2 -e'...' # Feeling centrally European?
    perl -Mencoding=euc-kr -e'...' # Or Korean?
  
    # more control
  
    # A simple euc-cn => utf-8 converter
    use encoding "euc-cn", STDOUT => "utf8";  while(<>){print};
  
    # "no encoding;" supported
    no encoding;
  
    # an alternate way, Filter
    use encoding "euc-jp", Filter=>1;
    # now you can use kanji identifiers -- in euc-jp!
  
    # encode based on the current locale - specialized purposes only;
    # fraught with danger!!
    use encoding ':locale';
  
  =head1 DESCRIPTION
  
  This pragma is used to enable a Perl script to be written in encodings that
  aren't strictly ASCII nor UTF-8.  It translates all or portions of the Perl
  program script from a given encoding into UTF-8, and changes the PerlIO layers
  of C<STDIN> and C<STDOUT> to the encoding specified.
  
  This pragma dates from the days when UTF-8-enabled editors were uncommon.  But
  that was long ago, and the need for it is greatly diminished.  That, coupled
  with the fact that it doesn't work with threads, along with other problems,
  (see L</BUGS>) have led to its being deprecated.  It is planned to remove this
  pragma in a future Perl version.  New code should be written in UTF-8, and the
  C<use utf8> pragma used instead (see L<perluniintro> and L<utf8> for details).
  Old code should be converted to UTF-8, via something like the recipe in the
  L</SYNOPSIS> (though this simple approach may require manual adjustments
  afterwards).
  
  If UTF-8 is not an option, it is recommended that one use a simple source
  filter, such as that provided by L<Filter::Encoding> on CPAN or this
  pragma's own C<Filter> option (see below).
  
  The only legitimate use of this pragma is almost certainly just one per file,
  near the top, with file scope, as the file is likely going to only be written
  in one encoding.  Further restrictions apply in Perls before v5.22 (see
  L</Prior to Perl v5.22>).
  
  There are two basic modes of operation (plus turning if off):
  
  =over 4
  
  =item C<use encoding ['I<ENCNAME>'] ;>
  
  Please note: This mode of operation is no longer supported as of Perl
  v5.26.
  
  This is the normal operation.  It translates various literals encountered in
  the Perl source file from the encoding I<ENCNAME> into UTF-8, and similarly
  converts character code points.  This is used when the script is a combination
  of ASCII (for the variable names and punctuation, I<etc>), but the literal
  data is in the specified encoding.
  
  I<ENCNAME> is optional.  If omitted, the encoding specified in the environment
  variable L<C<PERL_ENCODING>|perlrun/PERL_ENCODING> is used.  If this isn't
  set, or the resolved-to encoding is not known to C<L<Encode>>, the error
  C<Unknown encoding 'I<ENCNAME>'> will be thrown.
  
  Starting in Perl v5.8.6 (C<Encode> version 2.0.1), I<ENCNAME> may be the
  name C<:locale>.  This is for very specialized applications, and is documented
  in L</The C<:locale> sub-pragma> below.
  
  The literals that are converted are C<q//, qq//, qr//, qw///, qx//>, and
  starting in v5.8.1, C<tr///>.  Operations that do conversions include C<chr>,
  C<ord>, C<utf8::upgrade> (but not C<utf8::downgrade>), and C<chomp>.
  
  Also starting in v5.8.1, the C<DATA> pseudo-filehandle is translated from the
  encoding into UTF-8.
  
  For example, you can write code in EUC-JP as follows:
  
    my $Rakuda = "\xF1\xD1\xF1\xCC"; # Camel in Kanji
                 #<-char-><-char->   # 4 octets
    s/\bCamel\b/$Rakuda/;
  
  And with C<use encoding "euc-jp"> in effect, it is the same thing as
  that code in UTF-8:
  
    my $Rakuda = "\x{99F1}\x{99DD}"; # two Unicode Characters
    s/\bCamel\b/$Rakuda/;
  
  See L</EXAMPLE> below for a more complete example.
  
  Unless C<${^UNICODE}> (available starting in v5.8.2) exists and is non-zero, the
  PerlIO layers of C<STDIN> and C<STDOUT> are set to "C<:encoding(I<ENCNAME>)>".
  Therefore,
  
    use encoding "euc-jp";
    my $message = "Camel is the symbol of perl.\n";
    my $Rakuda = "\xF1\xD1\xF1\xCC"; # Camel in Kanji
    $message =~ s/\bCamel\b/$Rakuda/;
    print $message;
  
  will print
  
   "\xF1\xD1\xF1\xCC is the symbol of perl.\n"
  
  not
  
   "\x{99F1}\x{99DD} is the symbol of perl.\n"
  
  You can override this by giving extra arguments; see below.
  
  Note that C<STDERR> WILL NOT be changed, regardless.
  
  Also note that non-STD file handles remain unaffected.  Use C<use
  open> or C<binmode> to change the layers of those.
  
  =item C<use encoding I<ENCNAME> Filter=E<gt>1;>
  
  This operates as above, but the C<Filter> argument with a non-zero
  value causes the entire script, and not just literals, to be translated from
  the encoding into UTF-8.  This allows identifiers in the source to be in that
  encoding as well.  (Problems may occur if the encoding is not a superset of
  ASCII; imagine all your semi-colons being translated into something
  different.)  One can use this form to make
  
   ${"\x{4eba}"}++
  
  work.  (This is equivalent to C<$I<human>++>, where I<human> is a single Han
  ideograph).
  
  This effectively means that your source code behaves as if it were written in
  UTF-8 with C<'use utf8>' in effect.  So even if your editor only supports
  Shift_JIS, for example, you can still try examples in Chapter 15 of
  C<Programming Perl, 3rd Ed.>.
  
  This option is significantly slower than the other one.
  
  =item C<no encoding;>
  
  Unsets the script encoding. The layers of C<STDIN>, C<STDOUT> are
  reset to "C<:raw>" (the default unprocessed raw stream of bytes).
  
  =back
  
  =head1 OPTIONS
  
  =head2 Setting C<STDIN> and/or C<STDOUT> individually
  
  The encodings of C<STDIN> and C<STDOUT> are individually settable by parameters to
  the pragma:
  
   use encoding 'euc-tw', STDIN => 'greek'  ...;
  
  In this case, you cannot omit the first I<ENCNAME>.  C<< STDIN => undef >>
  turns the I/O transcoding completely off for that filehandle.
  
  When C<${^UNICODE}> (available starting in v5.8.2) exists and is non-zero,
  these options will be completely ignored.  See L<perlvar/C<${^UNICODE}>> and
  L<"C<-C>" in perlrun|perlrun/-C [numberE<sol>list]> for details.
  
  =head2 The C<:locale> sub-pragma
  
  Starting in v5.8.6, the encoding name may be C<:locale>.  This means that the
  encoding is taken from the current locale, and not hard-coded by the pragma.
  Since a script really can only be encoded in exactly one encoding, this option
  is dangerous.  It makes sense only if the script itself is written in ASCII,
  and all the possible locales that will be in use when the script is executed
  are supersets of ASCII.  That means that the script itself doesn't get
  changed, but the I/O handles have the specified encoding added, and the
  operations like C<chr> and C<ord> use that encoding.
  
  The logic of finding which locale C<:locale> uses is as follows:
  
  =over 4
  
  =item 1.
  
  If the platform supports the C<langinfo(CODESET)> interface, the codeset
  returned is used as the default encoding for the open pragma.
  
  =item 2.
  
  If 1. didn't work but we are under the locale pragma, the environment
  variables C<LC_ALL> and C<LANG> (in that order) are matched for encodings
  (the part after "C<.>", if any), and if any found, that is used
  as the default encoding for the open pragma.
  
  =item 3.
  
  If 1. and 2. didn't work, the environment variables C<LC_ALL> and C<LANG>
  (in that order) are matched for anything looking like UTF-8, and if
  any found, C<:utf8> is used as the default encoding for the open
  pragma.
  
  =back
  
  If your locale environment variables (C<LC_ALL>, C<LC_CTYPE>, C<LANG>)
  contain the strings 'UTF-8' or 'UTF8' (case-insensitive matching),
  the default encoding of your C<STDIN>, C<STDOUT>, and C<STDERR>, and of
  B<any subsequent file open>, is UTF-8.
  
  =head1 CAVEATS
  
  =head2 SIDE EFFECTS
  
  =over
  
  =item *
  
  If the C<encoding> pragma is in scope then the lengths returned are
  calculated from the length of C<$/> in Unicode characters, which is not
  always the same as the length of C<$/> in the native encoding.
  
  =item *
  
  Without this pragma, if strings operating under byte semantics and strings
  with Unicode character data are concatenated, the new string will
  be created by decoding the byte strings as I<ISO 8859-1 (Latin-1)>.
  
  The B<encoding> pragma changes this to use the specified encoding
  instead.  For example:
  
      use encoding 'utf8';
      my $string = chr(20000); # a Unicode string
      utf8::encode($string);   # now it's a UTF-8 encoded byte string
      # concatenate with another Unicode string
      print length($string . chr(20000));
  
  Will print C<2>, because C<$string> is upgraded as UTF-8.  Without
  C<use encoding 'utf8';>, it will print C<4> instead, since C<$string>
  is three octets when interpreted as Latin-1.
  
  =back
  
  =head2 DO NOT MIX MULTIPLE ENCODINGS
  
  Notice that only literals (string or regular expression) having only
  legacy code points are affected: if you mix data like this
  
      \x{100}\xDF
      \xDF\x{100}
  
  the data is assumed to be in (Latin 1 and) Unicode, not in your native
  encoding.  In other words, this will match in "greek":
  
      "\xDF" =~ /\x{3af}/
  
  but this will not
  
      "\xDF\x{100}" =~ /\x{3af}\x{100}/
  
  since the C<\xDF> (ISO 8859-7 GREEK SMALL LETTER IOTA WITH TONOS) on
  the left will B<not> be upgraded to C<\x{3af}> (Unicode GREEK SMALL
  LETTER IOTA WITH TONOS) because of the C<\x{100}> on the left.  You
  should not be mixing your legacy data and Unicode in the same string.
  
  This pragma also affects encoding of the 0x80..0xFF code point range:
  normally characters in that range are left as eight-bit bytes (unless
  they are combined with characters with code points 0x100 or larger,
  in which case all characters need to become UTF-8 encoded), but if
  the C<encoding> pragma is present, even the 0x80..0xFF range always
  gets UTF-8 encoded.
  
  After all, the best thing about this pragma is that you don't have to
  resort to \x{....} just to spell your name in a native encoding.
  So feel free to put your strings in your encoding in quotes and
  regexes.
  
  =head2 Prior to Perl v5.22
  
  The pragma was a per script, not a per block lexical.  Only the last
  C<use encoding> or C<no encoding> mattered, and it affected
  B<the whole script>.  However, the C<no encoding> pragma was supported and
  C<use encoding> could appear as many times as you want in a given script
  (though only the last was effective).
  
  Since the scope wasn't lexical, other modules' use of C<chr>, C<ord>, I<etc.>
  were affected.  This leads to spooky, incorrect action at a distance that is
  hard to debug.
  
  This means you would have to be very careful of the load order:
  
    # called module
    package Module_IN_BAR;
    use encoding "bar";
    # stuff in "bar" encoding here
    1;
  
    # caller script
    use encoding "foo"
    use Module_IN_BAR;
    # surprise! use encoding "bar" is in effect.
  
  The best way to avoid this oddity is to use this pragma RIGHT AFTER
  other modules are loaded.  i.e.
  
    use Module_IN_BAR;
    use encoding "foo";
  
  =head2 Prior to Encode version 1.87
  
  =over
  
  =item *
  
  C<STDIN> and C<STDOUT> were not set under the filter option.
  And C<< STDIN=>I<ENCODING> >> and C<< STDOUT=>I<ENCODING> >> didn't work like
  non-filter version.
  
  =item *
  
  C<use utf8> wasn't implicitly declared so you have to C<use utf8> to do
  
   ${"\x{4eba}"}++
  
  =back
  
  =head2 Prior to Perl v5.8.1
  
  =over
  
  =item "NON-EUC" doublebyte encodings
  
  Because perl needs to parse the script before applying this pragma, such
  encodings as Shift_JIS and Big-5 that may contain C<'\'> (BACKSLASH;
  C<\x5c>) in the second byte fail because the second byte may
  accidentally escape the quoting character that follows.
  
  =item C<tr///>
  
  The B<encoding> pragma works by decoding string literals in
  C<q//,qq//,qr//,qw///, qx//> and so forth.  In perl v5.8.0, this
  does not apply to C<tr///>.  Therefore,
  
    use encoding 'euc-jp';
    #....
    $kana =~ tr/\xA4\xA1-\xA4\xF3/\xA5\xA1-\xA5\xF3/;
    #           -------- -------- -------- --------
  
  Does not work as
  
    $kana =~ tr/\x{3041}-\x{3093}/\x{30a1}-\x{30f3}/;
  
  =over
  
  =item Legend of characters above
  
    utf8     euc-jp   charnames::viacode()
    -----------------------------------------
    \x{3041} \xA4\xA1 HIRAGANA LETTER SMALL A
    \x{3093} \xA4\xF3 HIRAGANA LETTER N
    \x{30a1} \xA5\xA1 KATAKANA LETTER SMALL A
    \x{30f3} \xA5\xF3 KATAKANA LETTER N
  
  =back
  
  This counterintuitive behavior has been fixed in perl v5.8.1.
  
  In perl v5.8.0, you can work around this as follows;
  
    use encoding 'euc-jp';
    #  ....
    eval qq{ \$kana =~ tr/\xA4\xA1-\xA4\xF3/\xA5\xA1-\xA5\xF3/ };
  
  Note the C<tr//> expression is surrounded by C<qq{}>.  The idea behind
  this is the same as the classic idiom that makes C<tr///> 'interpolate':
  
     tr/$from/$to/;            # wrong!
     eval qq{ tr/$from/$to/ }; # workaround.
  
  =back
  
  =head1 EXAMPLE - Greekperl
  
      use encoding "iso 8859-7";
  
      # \xDF in ISO 8859-7 (Greek) is \x{3af} in Unicode.
  
      $a = "\xDF";
      $b = "\x{100}";
  
      printf "%#x\n", ord($a); # will print 0x3af, not 0xdf
  
      $c = $a . $b;
  
      # $c will be "\x{3af}\x{100}", not "\x{df}\x{100}".
  
      # chr() is affected, and ...
  
      print "mega\n"  if ord(chr(0xdf)) == 0x3af;
  
      # ... ord() is affected by the encoding pragma ...
  
      print "tera\n" if ord(pack("C", 0xdf)) == 0x3af;
  
      # ... as are eq and cmp ...
  
      print "peta\n" if "\x{3af}" eq  pack("C", 0xdf);
      print "exa\n"  if "\x{3af}" cmp pack("C", 0xdf) == 0;
  
      # ... but pack/unpack C are not affected, in case you still
      # want to go back to your native encoding
  
      print "zetta\n" if unpack("C", (pack("C", 0xdf))) == 0xdf;
  
  =head1 BUGS
  
  =over
  
  =item Thread safety
  
  C<use encoding ...> is not thread-safe (i.e., do not use in threaded
  applications).
  
  =item Can't be used by more than one module in a single program.
  
  Only one encoding is allowed.  If you combine modules in a program that have
  different encodings, only one will be actually used.
  
  =item Other modules using C<STDIN> and C<STDOUT> get the encoded stream
  
  They may be expecting something completely different.
  
  =item literals in regex that are longer than 127 bytes
  
  For native multibyte encodings (either fixed or variable length),
  the current implementation of the regular expressions may introduce
  recoding errors for regular expression literals longer than 127 bytes.
  
  =item EBCDIC
  
  The encoding pragma is not supported on EBCDIC platforms.
  
  =item C<format>
  
  This pragma doesn't work well with C<format> because PerlIO does not
  get along very well with it.  When C<format> contains non-ASCII
  characters it prints funny or gets "wide character warnings".
  To understand it, try the code below.
  
    # Save this one in utf8
    # replace *non-ascii* with a non-ascii string
    my $camel;
    format STDOUT =
    *non-ascii*@>>>>>>>
    $camel
    .
    $camel = "*non-ascii*";
    binmode(STDOUT=>':encoding(utf8)'); # bang!
    write;              # funny
    print $camel, "\n"; # fine
  
  Without binmode this happens to work but without binmode, print()
  fails instead of write().
  
  At any rate, the very use of C<format> is questionable when it comes to
  unicode characters since you have to consider such things as character
  width (i.e. double-width for ideographs) and directions (i.e. BIDI for
  Arabic and Hebrew).
  
  =item See also L</CAVEATS>
  
  =back
  
  =head1 HISTORY
  
  This pragma first appeared in Perl v5.8.0.  It has been enhanced in later
  releases as specified above.
  
  =head1 SEE ALSO
  
  L<perlunicode>, L<Encode>, L<open>, L<Filter::Util::Call>,
  
  Ch. 15 of C<Programming Perl (3rd Edition)>
  by Larry Wall, Tom Christiansen, Jon Orwant;
  O'Reilly & Associates; ISBN 0-596-00027-8
  
  =cut
I686-LINUX-GNU-THREAD-MULTI-64INT_ENCODING

$fatpacked{"ojo.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'OJO';
  package ojo;
  use Mojo::Base -strict;
  
  use Benchmark qw(timeit timestr :hireswallclock);
  use Mojo::ByteStream 'b';
  use Mojo::Collection 'c';
  use Mojo::DOM;
  use Mojo::File 'path';
  use Mojo::JSON 'j';
  use Mojo::Util qw(dumper monkey_patch);
  
  # Silent one-liners
  $ENV{MOJO_LOG_LEVEL} ||= 'fatal';
  
  sub import {
  
    # Mojolicious::Lite
    my $caller = caller;
    eval "package $caller; use Mojolicious::Lite; 1" or die $@;
    my $ua = $caller->app->ua;
    $ua->server->app->hook(around_action => sub { local $_ = $_[1]; $_[0]() });
  
    $ua->max_redirects(10) unless defined $ENV{MOJO_MAX_REDIRECTS};
    $ua->proxy->detect unless defined $ENV{MOJO_PROXY};
  
    # The ojo DSL
    monkey_patch $caller,
      a => sub { $caller->can('any')->(@_) and return $ua->server->app },
      b => \&b,
      c => \&c,
      d => sub { $ua->delete(@_)->result },
      f => \&path,
      g => sub { $ua->get(@_)->result },
      h => sub { $ua->head(@_)->result },
      j => \&j,
      n => sub (&@) { say STDERR timestr timeit($_[1] // 1, $_[0]) },
      o => sub      { $ua->options(@_)->result },
      p => sub      { $ua->post(@_)->result },
      r => \&dumper,
      t => sub { $ua->patch(@_)->result },
      u => sub { $ua->put(@_)->result },
      x => sub { Mojo::DOM->new(@_) };
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  ojo - Fun one-liners with Mojo
  
  =head1 SYNOPSIS
  
    $ perl -Mojo -E 'say g("mojolicious.org")->dom->at("title")->text'
  
  =head1 DESCRIPTION
  
  A collection of automatically exported functions for fun Perl one-liners. Ten
  redirects will be followed by default, you can change this behavior with the
  C<MOJO_MAX_REDIRECTS> environment variable.
  
    $ MOJO_MAX_REDIRECTS=0 perl -Mojo -E 'say g("example.com")->code'
  
  Proxy detection is enabled by default, but you can disable it with the
  C<MOJO_PROXY> environment variable.
  
    $ MOJO_PROXY=0 perl -Mojo -E 'say g("example.com")->body'
  
  Every L<ojo> one-liner is also a L<Mojolicious::Lite> application.
  
    $ perl -Mojo -E 'get "/" => {inline => "%= time"}; app->start' get /
  
  If it is not already defined, the C<MOJO_LOG_LEVEL> environment variable will
  be set to C<fatal>.
  
  =head1 FUNCTIONS
  
  L<ojo> implements the following functions, which are automatically exported.
  
  =head2 a
  
    my $app = a('/hello' => sub { $_->render(json => {hello => 'world'}) });
  
  Create a route with L<Mojolicious::Lite/"any"> and return the current
  L<Mojolicious::Lite> object. The current controller object is also available to
  actions as C<$_>. See also L<Mojolicious::Guides::Tutorial> for more argument
  variations.
  
    $ perl -Mojo -E 'a("/hello" => {text => "Hello Mojo!"})->start' daemon
  
  =head2 b
  
    my $stream = b('lalala');
  
  Turn string into a L<Mojo::ByteStream> object.
  
    $ perl -Mojo -E 'b(g("mojolicious.org")->body)->html_unescape->say'
  
  =head2 c
  
    my $collection = c(1, 2, 3);
  
  Turn list into a L<Mojo::Collection> object.
  
  =head2 d
  
    my $res = d('example.com');
    my $res = d('http://example.com' => {Accept => '*/*'} => 'Hi!');
    my $res = d('http://example.com' => {Accept => '*/*'} => form => {a => 'b'});
    my $res = d('http://example.com' => {Accept => '*/*'} => json => {a => 'b'});
  
  Perform C<DELETE> request with L<Mojo::UserAgent/"delete"> and return resulting
  L<Mojo::Message::Response> object.
  
  =head2 f
  
    my $path = f('/home/sri/foo.txt');
  
  Turn string into a L<Mojo::File> object.
  
    $ perl -Mojo -E 'say r j f("hello.json")->slurp'
  
  =head2 g
  
    my $res = g('example.com');
    my $res = g('http://example.com' => {Accept => '*/*'} => 'Hi!');
    my $res = g('http://example.com' => {Accept => '*/*'} => form => {a => 'b'});
    my $res = g('http://example.com' => {Accept => '*/*'} => json => {a => 'b'});
  
  Perform C<GET> request with L<Mojo::UserAgent/"get"> and return resulting
  L<Mojo::Message::Response> object.
  
    $ perl -Mojo -E 'say g("mojolicious.org")->dom("h1")->map("text")->join("\n")'
  
  =head2 h
  
    my $res = h('example.com');
    my $res = h('http://example.com' => {Accept => '*/*'} => 'Hi!');
    my $res = h('http://example.com' => {Accept => '*/*'} => form => {a => 'b'});
    my $res = h('http://example.com' => {Accept => '*/*'} => json => {a => 'b'});
  
  Perform C<HEAD> request with L<Mojo::UserAgent/"head"> and return resulting
  L<Mojo::Message::Response> object.
  
  =head2 j
  
    my $bytes = j([1, 2, 3]);
    my $bytes = j({foo => 'bar'});
    my $value = j($bytes);
  
  Encode Perl data structure or decode JSON with L<Mojo::JSON/"j">.
  
    $ perl -Mojo -E 'f("hello.json")->spurt(j {hello => "world!"})'
  
  =head2 n
  
    n {...};
    n {...} 100;
  
  Benchmark block and print the results to C<STDERR>, with an optional number of
  iterations, which defaults to C<1>.
  
    $ perl -Mojo -E 'n { say g("mojolicious.org")->code }'
  
  =head2 o
  
    my $res = o('example.com');
    my $res = o('http://example.com' => {Accept => '*/*'} => 'Hi!');
    my $res = o('http://example.com' => {Accept => '*/*'} => form => {a => 'b'});
    my $res = o('http://example.com' => {Accept => '*/*'} => json => {a => 'b'});
  
  Perform C<OPTIONS> request with L<Mojo::UserAgent/"options"> and return
  resulting L<Mojo::Message::Response> object.
  
  =head2 p
  
    my $res = p('example.com');
    my $res = p('http://example.com' => {Accept => '*/*'} => 'Hi!');
    my $res = p('http://example.com' => {Accept => '*/*'} => form => {a => 'b'});
    my $res = p('http://example.com' => {Accept => '*/*'} => json => {a => 'b'});
  
  Perform C<POST> request with L<Mojo::UserAgent/"post"> and return resulting
  L<Mojo::Message::Response> object.
  
  =head2 r
  
    my $perl = r({data => 'structure'});
  
  Dump a Perl data structure with L<Mojo::Util/"dumper">.
  
    perl -Mojo -E 'say r g("example.com")->headers->to_hash'
  
  =head2 t
  
    my $res = t('example.com');
    my $res = t('http://example.com' => {Accept => '*/*'} => 'Hi!');
    my $res = t('http://example.com' => {Accept => '*/*'} => form => {a => 'b'});
    my $res = t('http://example.com' => {Accept => '*/*'} => json => {a => 'b'});
  
  Perform C<PATCH> request with L<Mojo::UserAgent/"patch"> and return resulting
  L<Mojo::Message::Response> object.
  
  =head2 u
  
    my $res = u('example.com');
    my $res = u('http://example.com' => {Accept => '*/*'} => 'Hi!');
    my $res = u('http://example.com' => {Accept => '*/*'} => form => {a => 'b'});
    my $res = u('http://example.com' => {Accept => '*/*'} => json => {a => 'b'});
  
  Perform C<PUT> request with L<Mojo::UserAgent/"put"> and return resulting
  L<Mojo::Message::Response> object.
  
  =head2 x
  
    my $dom = x('<div>Hello!</div>');
  
  Turn HTML/XML input into L<Mojo::DOM> object.
  
    $ perl -Mojo -E 'say x(f("test.html")->slurp)->at("title")->text'
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<http://mojolicious.org>.
  
  =cut
OJO

$fatpacked{"parent.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PARENT';
  package parent;
  use strict;
  use vars qw($VERSION);
  $VERSION = '0.236';
  
  sub import {
      my $class = shift;
  
      my $inheritor = caller(0);
  
      if ( @_ and $_[0] eq '-norequire' ) {
          shift @_;
      } else {
          for ( my @filename = @_ ) {
              s{::|'}{/}g;
              require "$_.pm"; # dies if the file is not found
          }
      }
  
      {
          no strict 'refs';
          push @{"$inheritor\::ISA"}, @_; # dies if a loop is detected
      };
  };
  
  1;
  
  __END__
  
  =encoding utf8
  
  =head1 NAME
  
  parent - Establish an ISA relationship with base classes at compile time
  
  =head1 SYNOPSIS
  
      package Baz;
      use parent qw(Foo Bar);
  
  =head1 DESCRIPTION
  
  Allows you to both load one or more modules, while setting up inheritance from
  those modules at the same time.  Mostly similar in effect to
  
      package Baz;
      BEGIN {
          require Foo;
          require Bar;
          push @ISA, qw(Foo Bar);
      }
  
  By default, every base class needs to live in a file of its own.
  If you want to have a subclass and its parent class in the same file, you
  can tell C<parent> not to load any modules by using the C<-norequire> switch:
  
    package Foo;
    sub exclaim { "I CAN HAS PERL" }
  
    package DoesNotLoadFooBar;
    use parent -norequire, 'Foo', 'Bar';
    # will not go looking for Foo.pm or Bar.pm
  
  This is equivalent to the following code:
  
    package Foo;
    sub exclaim { "I CAN HAS PERL" }
  
    package DoesNotLoadFooBar;
    push @DoesNotLoadFooBar::ISA, 'Foo', 'Bar';
  
  This is also helpful for the case where a package lives within
  a differently named file:
  
    package MyHash;
    use Tie::Hash;
    use parent -norequire, 'Tie::StdHash';
  
  This is equivalent to the following code:
  
    package MyHash;
    require Tie::Hash;
    push @ISA, 'Tie::StdHash';
  
  If you want to load a subclass from a file that C<require> would
  not consider an eligible filename (that is, it does not end in
  either C<.pm> or C<.pmc>), use the following code:
  
    package MySecondPlugin;
    require './plugins/custom.plugin'; # contains Plugin::Custom
    use parent -norequire, 'Plugin::Custom';
  
  =head1 HISTORY
  
  This module was forked from L<base> to remove the cruft
  that had accumulated in it.
  
  =head1 CAVEATS
  
  =head1 SEE ALSO
  
  L<base>
  
  =head1 AUTHORS AND CONTRIBUTORS
  
  Rafal Garcia-Suarez, Bart Lateur, Max Maischein, Anno Siegel, Michael Schwern
  
  =head1 MAINTAINER
  
  Max Maischein C< corion@cpan.org >
  
  Copyright (c) 2007-10 Max Maischein C<< <corion@cpan.org> >>
  Based on the idea of C<base.pm>, which was introduced with Perl 5.004_04.
  
  =head1 LICENSE
  
  This module is released under the same terms as Perl itself.
  
  =cut
PARENT

s/^  //mg for values %fatpacked;

my $class = 'FatPacked::'.(0+\%fatpacked);
no strict 'refs';
*{"${class}::files"} = sub { keys %{$_[0]} };

if ($] < 5.008) {
  *{"${class}::INC"} = sub {
    if (my $fat = $_[0]{$_[1]}) {
      my $pos = 0;
      my $last = length $fat;
      return (sub {
        return 0 if $pos == $last;
        my $next = (1 + index $fat, "\n", $pos) || $last;
        $_ .= substr $fat, $pos, $next - $pos;
        $pos = $next;
        return 1;
      });
    }
  };
}

else {
  *{"${class}::INC"} = sub {
    if (my $fat = $_[0]{$_[1]}) {
      open my $fh, '<', \$fat
        or die "FatPacker error loading $_[1] (could be a perl installation issue?)";
      return $fh;
    }
    return;
  };
}

unshift @INC, bless \%fatpacked, $class;
  } # END OF FATPACK CODE


# Check if user connected through tor layer network (for torsocks user)
use warnings;
use LWP::Simple 'get';
use Mojo::DOM;
use v5.10;

my $dom = Mojo::DOM->new(get "https://check.torproject.org");

say $dom->at('title')->text;

say "Your IP is: " . $dom->at('strong')->text;
